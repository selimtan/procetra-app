// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../@realmocean/core

import { Ajax } from '@realmocean/core';
import { NumberFormatOptions, DateFormatOptions } from '@realmocean/core';

/**
  * Data modules
  */
import './exports';

/**
    * DataManager is used to manage and manipulate relational data.
    */
export class DataManager {
        /** @hidden */
        adaptor: AdaptorOptions;
        /** @hidden */
        defaultQuery: Query;
        /** @hidden */
        dataSource: DataOptions;
        /** @hidden */
        dateParse: boolean;
        /** @hidden */
        timeZoneHandling: boolean;
        /** @hidden */
        ready: Promise<Ajax>;
        /**
            * Constructor for DataManager class
            * @param  {DataOptions|JSON[]} dataSource?
            * @param  {Query} query?
            * @param  {AdaptorOptions|string} adaptor?
            * @hidden
            */
        constructor(dataSource?: DataOptions | JSON[] | Object[], query?: Query, adaptor?: AdaptorOptions | string);
        /**
            * Overrides DataManager's default query with given query.
            * @param  {Query} query - Defines the new default query.
            */
        setDefaultQuery(query: Query): DataManager;
        /**
            * Executes the given query with local data source.
            * @param  {Query} query - Defines the query to retrieve data.
            */
        executeLocal(query?: Query): Object[];
        /**
            * Executes the given query with either local or remote data source.
            * It will be executed as asynchronously and returns Promise object which will be resolved or rejected after action completed.
            * @param  {Query|Function} query - Defines the query to retrieve data.
            * @param  {Function} done - Defines the callback function and triggers when the Promise is resolved.
            * @param  {Function} fail - Defines the callback function and triggers when the Promise is rejected.
            * @param  {Function} always - Defines the callback function and triggers when the Promise is resolved or rejected.
            */
        executeQuery(query: Query | Function, done?: Function, fail?: Function, always?: Function): Promise<Ajax>;
        /**
            * Save bulk changes to the given table name.
            * User can add a new record, edit an existing record, and delete a record at the same time.
            * If the datasource from remote, then updated in a single post.
            * @param  {Object} changes - Defines the CrudOptions.
            * @param  {string} key - Defines the column field.
            * @param  {string|Query} tableName - Defines the table name.
            * @param  {Query} query - Sets default query for the DataManager.
            */
        saveChanges(changes: Object, key?: string, tableName?: string | Query, query?: Query, original?: Object): Promise<Object> | Object;
        /**
            * Inserts new record in the given table.
            * @param  {Object} data - Defines the data to insert.
            * @param  {string|Query} tableName - Defines the table name.
            * @param  {Query} query - Sets default query for the DataManager.
            */
        insert(data: Object, tableName?: string | Query, query?: Query, position?: number): Object | Promise<Object>;
        /**
            * Removes data from the table with the given key.
            * @param  {string} keyField - Defines the column field.
            * @param  {Object} value - Defines the value to find the data in the specified column.
            * @param  {string|Query} tableName - Defines the table name
            * @param  {Query} query - Sets default query for the DataManager.
            */
        remove(keyField: string, value: Object, tableName?: string | Query, query?: Query): Object | Promise<Object>;
        /**
            * Updates existing record in the given table.
            * @param  {string} keyField - Defines the column field.
            * @param  {Object} value - Defines the value to find the data in the specified column.
            * @param  {string|Query} tableName - Defines the table name
            * @param  {Query} query - Sets default query for the DataManager.
            */
        update(keyField: string, value: Object, tableName?: string | Query, query?: Query, original?: Object): Object | Promise<Object>;
}
/**
    * Deferred is used to handle asynchronous operation.
    */
export class Deferred {
        /**
            * Resolve a Deferred object and call doneCallbacks with the given args.
            */
        resolve: Function;
        /**
            * Reject a Deferred object and call failCallbacks with the given args.
            */
        reject: Function;
        /**
            * Promise is an object that represents a value that may not be available yet, but will be resolved at some point in the future.
            */
        promise: Promise<Object>;
        /**
            * Defines the callback function triggers when the Deferred object is resolved.
            */
        then: Function;
        /**
            * Defines the callback function triggers when the Deferred object is rejected.
            */
        catch: Function;
}
/**
    * @hidden
    */
export interface DataOptions {
        url?: string;
        adaptor?: AdaptorOptions;
        insertUrl?: string;
        removeUrl?: string;
        updateUrl?: string;
        crudUrl?: string;
        batchUrl?: string;
        json?: Object[];
        headers?: Object[];
        accept?: boolean;
        data?: JSON;
        timeTillExpiration?: number;
        cachingPageSize?: number;
        enableCaching?: boolean;
        requestType?: string;
        key?: string;
        crossDomain?: boolean;
        jsonp?: string;
        dataType?: string;
        offline?: boolean;
        requiresFormat?: boolean;
        timeZoneHandling?: boolean;
}
/**
    * @hidden
    */
export interface ReturnOption {
        result?: ReturnOption;
        count?: number;
        url?: string;
        aggregates?: Aggregates;
}
/**
    * @hidden
    */
export interface AjaxOption {
        onSuccess?: Function;
        onFailure?: Function;
        data?: string;
}
/**
    * @hidden
    */
export interface RequestOptions {
        xhr?: XMLHttpRequest;
        count?: number;
        result?: ReturnOption;
        request?: Ajax;
        aggregates?: Aggregates;
        actual?: Object;
        virtualSelectRecords?: Object;
        error?: string;
}
/**
    * @hidden
    */
export interface AdaptorOptions {
        processQuery?: Function;
        processResponse?: Function;
        beforeSend?: Function;
        batchRequest?: Function;
        insert?: Function;
        remove?: Function;
        update?: Function;
        key?: string;
}

/**
    * Query class is used to build query which is used by the DataManager to communicate with datasource.
    */
export class Query {
        /** @hidden */
        queries: QueryOptions[];
        /** @hidden */
        key: string;
        /** @hidden */
        fKey: string;
        /** @hidden */
        fromTable: string;
        /** @hidden */
        lookups: string[];
        /** @hidden */
        expands: Object[];
        /** @hidden */
        sortedColumns: Object[];
        /** @hidden */
        groupedColumns: Object[];
        /** @hidden */
        subQuerySelector: Function;
        /** @hidden */
        subQuery: Query;
        /** @hidden */
        isChild: boolean;
        /** @hidden */
        params: ParamOption[];
        /** @hidden */
        lazyLoad: {
                key: string;
                value: object | boolean;
        }[];
        /** @hidden */
        isCountRequired: boolean;
        /** @hidden */
        dataManager: DataManager;
        /** @hidden */
        distincts: string[];
        /**
            * Constructor for Query class.
            * @param  {string|string[]} from?
            * @hidden
            */
        constructor(from?: string | string[]);
        /**
            * Sets the primary key.
            * @param  {string} field - Defines the column field.
            */
        setKey(field: string): Query;
        /**
            * Sets default DataManager to execute query.
            * @param  {DataManager} dataManager - Defines the DataManager.
            */
        using(dataManager: DataManager): Query;
        /**
            * Executes query with the given DataManager.
            * @param  {DataManager} dataManager - Defines the DataManager.
            * @param  {Function} done - Defines the success callback.
            * @param  {Function} fail - Defines the failure callback.
            * @param  {Function} always - Defines the callback which will be invoked on either success or failure.
            *
            * <pre>
            * let dataManager: DataManager = new DataManager([{ ID: '10' }, { ID: '2' }, { ID: '1' }, { ID: '20' }]);
            * let query: Query = new Query();
            * query.sortBy('ID', (x: string, y: string): number => { return parseInt(x, 10) - parseInt(y, 10) });
            * let promise: Promise< Object > = query.execute(dataManager);
            * promise.then((e: { result: Object }) => { });
            * </pre>
            */
        execute(dataManager?: DataManager, done?: Function, fail?: Function, always?: Function): Promise<Object>;
        /**
            * Executes query with the local datasource.
            * @param  {DataManager} dataManager - Defines the DataManager.
            */
        executeLocal(dataManager?: DataManager): Object[];
        /**
            * Creates deep copy of the Query object.
            */
        clone(): Query;
        /**
            * Specifies the name of table to retrieve data in query execution.
            * @param  {string} tableName - Defines the table name.
            */
        from(tableName: string): Query;
        /**
            * Adds additional parameter which will be sent along with the request which will be generated while DataManager execute.
            * @param  {string} key - Defines the key of additional parameter.
            * @param  {Function|string} value - Defines the value for the key.
            */
        addParams(key: string, value: Function | string | null): Query;
        /**
            * @hidden
            */
        distinct(fields: string | string[]): Query;
        /**
            * Expands the related table.
            * @param  {string|Object[]} tables
            */
        expand(tables: string | Object[]): Query;
        /**
            * Filter data with given filter criteria.
            * @param  {string|Predicate} fieldName - Defines the column field or Predicate.
            * @param  {string} operator - Defines the operator how to filter data.
            * @param  {string|number|boolean} value - Defines the values to match with data.
            * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else
            * filter data with case insensitive.
            */
        where(fieldName: string | Predicate | Predicate[], operator?: string, value?: string | Date | number | boolean | null, ignoreCase?: boolean, ignoreAccent?: boolean): Query;
        /**
            * Search data with given search criteria.
            * @param  {string|number|boolean} searchKey - Defines the search key.
            * @param  {string|string[]} fieldNames - Defines the collection of column fields.
            * @param  {string} operator - Defines the operator how to search data.
            * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else
            * filter data with case insensitive.
            */
        search(searchKey: string | number | boolean, fieldNames?: string | string[], operator?: string, ignoreCase?: boolean, ignoreAccent?: boolean): Query;
        /**
            * Sort the data with given sort criteria.
            * By default, sort direction is ascending.
            * @param  {string|string[]} fieldName - Defines the single or collection of column fields.
            * @param  {string|Function} comparer - Defines the sort direction or custom sort comparer function.
            */
        sortBy(fieldName: string | string[], comparer?: string | Function, isFromGroup?: boolean): Query;
        /**
            * Sort the data with given sort criteria.
            * By default, sort direction is ascending.
            * @param  {string|string[]} fieldName - Defines the single or collection of column fields.
            * @param  {string|Function} comparer - Defines the sort direction or custom sort comparer function.
            * @param  {string} direction - Defines the sort direction .
            */
        sortByForeignKey(fieldName: string | string[], comparer?: string | Function, isFromGroup?: boolean, direction?: string): Query;
        /**
            * Sorts data in descending order.
            * @param  {string} fieldName - Defines the column field.
            */
        sortByDesc(fieldName: string): Query;
        /**
            * Groups data with the given field name.
            * @param  {string} fieldName - Defines the column field.
            */
        group(fieldName: string, fn?: Function, format?: string | NumberFormatOptions | DateFormatOptions): Query;
        /**
            * Gets data based on the given page index and size.
            * @param  {number} pageIndex - Defines the current page index.
            * @param  {number} pageSize - Defines the no of records per page.
            */
        page(pageIndex: number, pageSize: number): Query;
        /**
            * Gets data based on the given start and end index.
            * @param  {number} start - Defines the start index of the datasource.
            * @param  {number} end - Defines the end index of the datasource.
            */
        range(start: number, end: number): Query;
        /**
            * Gets data from the top of the data source based on given number of records count.
            * @param  {number} nos - Defines the no of records to retrieve from datasource.
            */
        take(nos: number): Query;
        /**
            * Skips data with given number of records count from the top of the data source.
            * @param  {number} nos - Defines the no of records skip in the datasource.
            */
        skip(nos: number): Query;
        /**
            * Selects specified columns from the data source.
            * @param  {string|string[]} fieldNames - Defines the collection of column fields.
            */
        select(fieldNames: string | string[]): Query;
        /**
            * Gets the records in hierarchical relationship from two tables. It requires the foreign key to relate two tables.
            * @param  {Query} query - Defines the query to relate two tables.
            * @param  {Function} selectorFn - Defines the custom function to select records.
            */
        hierarchy(query: Query, selectorFn: Function): Query;
        /**
            * Sets the foreign key which is used to get data from the related table.
            * @param  {string} key - Defines the foreign key.
            */
        foreignKey(key: string): Query;
        /**
            * It is used to get total number of records in the DataManager execution result.
            */
        requiresCount(): Query;
        /**
            * Aggregate the data with given type and field name.
            * @param  {string} type - Defines the aggregate type.
            * @param  {string} field - Defines the column field to aggregate.
            */
        aggregate(type: string, field: string): Query;
        /**
            * Pass array of filterColumn query for performing filter operation.
            * @param  {QueryOptions[]} queries
            * @param  {string} name
            * @hidden
            */
        static filterQueries(queries: QueryOptions[], name: string): QueryOptions[];
        /**
            * To get the list of queries which is already filtered in current data source.
            * @param  {Object[]} queries
            * @param  {string[]} singles
            * @hidden
            */
        static filterQueryLists(queries: Object[], singles: string[]): Object;
}
/**
    * Predicate class is used to generate complex filter criteria.
    * This will be used by DataManager to perform multiple filtering operation.
    */
export class Predicate {
        /** @hidden */
        field: string;
        /** @hidden */
        operator: string;
        /** @hidden */
        value: string | number | Date | boolean | Predicate | Predicate[] | null;
        /** @hidden */
        condition: string;
        /** @hidden */
        ignoreCase: boolean;
        /** @hidden */
        ignoreAccent: boolean;
        /** @hidden */
        isComplex: boolean;
        /** @hidden */
        predicates: Predicate[];
        /** @hidden */
        comparer: Function;
        [x: string]: string | number | Date | boolean | Predicate | Predicate[] | Function | null;
        /**
            * Constructor for Predicate class.
            * @param  {string|Predicate} field
            * @param  {string} operator
            * @param  {string|number|boolean|Predicate|Predicate[]} value
            * @param  {boolean=false} ignoreCase
            * @hidden
            */
        constructor(field: string | Predicate, operator: string, value: string | number | Date | boolean | Predicate | Predicate[] | null, ignoreCase?: boolean, ignoreAccent?: boolean);
        /**
            * Adds n-number of new predicates on existing predicate with “and” condition.
            * @param  {Object[]} args - Defines the collection of predicates.
            */
        static and(...args: Object[]): Predicate;
        /**
            * Adds new predicate on existing predicate with “and” condition.
            * @param  {string} field - Defines the column field.
            * @param  {string} operator - Defines the operator how to filter data.
            * @param  {string} value - Defines the values to match with data.
            * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else
            * filter data with case insensitive.
            */
        and(field: string | Predicate, operator?: string, value?: string | number | Date | null, ignoreCase?: boolean, ignoreAccent?: boolean): Predicate;
        /**
            * Adds n-number of new predicates on existing predicate with “or” condition.
            * @param  {Object[]} args - Defines the collection of predicates.
            */
        static or(...args: Object[]): Predicate;
        /**
            * Adds new predicate on existing predicate with “or” condition.
            * @param  {string} field - Defines the column field.
            * @param  {string} operator - Defines the operator how to filter data.
            * @param  {string} value - Defines the values to match with data.
            * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else
            * filter data with case insensitive.
            */
        or(field: string | Predicate, operator?: string, value?: string | number | Date | null, ignoreCase?: boolean, ignoreAccent?: boolean): Predicate;
        /**
            * Converts plain JavaScript object to Predicate object.
            * @param  {Predicate[]|Predicate} json - Defines single or collection of Predicate.
            */
        static fromJson(json: Predicate[] | Predicate): Predicate[];
        /**
            * Validate the record based on the predicates.
            * @param  {Object} record - Defines the datasource record.
            */
        validate(record: Object): boolean;
        /**
            * Converts predicates to plain JavaScript.
            * This method is uses Json stringify when serializing Predicate object.
            */
        toJson(): Object;
}
/**
    * @hidden
    */
export interface QueryOptions {
        fn?: string;
        e?: QueryOptions;
        fieldNames?: string | string[];
        operator?: string;
        searchKey?: string | number | boolean;
        ignoreCase?: boolean;
        ignoreAccent?: boolean;
        comparer?: string | Function;
        format?: string | NumberFormatOptions | DateFormatOptions;
        direction?: string;
        pageIndex?: number;
        pageSize?: number;
        start?: number;
        end?: number;
        nos?: number;
        field?: string;
        fieldName?: string;
        type?: Object;
        name?: string | string[];
        filter?: Object;
        key?: string;
        value?: string | number | Date | boolean | Predicate | Predicate[];
        isComplex?: boolean;
        predicates?: Predicate[];
        condition?: string;
}
/**
    * @hidden
    */
export interface QueryList {
        onSelect?: QueryOptions;
        onPage?: QueryOptions;
        onSkip?: QueryOptions;
        onTake?: QueryOptions;
        onRange?: QueryOptions;
}
/**
    * @hidden
    */
export interface ParamOption {
        key: string;
        value?: string | null;
        fn?: Function;
}

/**
    * Adaptors are specific data source type aware interfaces that are used by DataManager to communicate with DataSource.
    * This is the base adaptor class that other adaptors can extend.
    * @hidden
    */
export class Adaptor {
        /**
            * Specifies the datasource option.
            * @default null
            */
        dataSource: DataOptions;
        updateType: string;
        updateKey: string;
        /**
            * It contains the datamanager operations list like group, searches, etc.,
            * @default null
            * @hidden
            */
        pvt: PvtOptions;
        /**
            * Constructor for Adaptor class
            * @param  {DataOptions} ds?
            * @hidden
            * @returns aggregates
            */
        constructor(ds?: DataOptions);
        protected options: RemoteOptions;
        /**
            * Returns the data from the query processing.
            * @param  {Object} data
            * @param  {DataOptions} ds?
            * @param  {Query} query?
            * @param  {XMLHttpRequest} xhr?
            * @returns Object
            */
        processResponse(data: Object, ds?: DataOptions, query?: Query, xhr?: XMLHttpRequest): Object;
        /**
            * Specifies the type of adaptor.
            * @default Adaptor
            */
        type: Object;
}
/**
    * JsonAdaptor is used to process JSON data. It contains methods to process the given JSON data based on the queries.
    * @hidden
    */
export class JsonAdaptor extends Adaptor {
        /**
            * Process the JSON data based on the provided queries.
            * @param  {DataManager} dataManager
            * @param  {Query} query
            * @returns Object
            */
        processQuery(dataManager: DataManager, query: Query): Object;
        /**
            * Perform lazy load grouping in JSON array based on the given query and lazy load details.
            * @param  {LazyLoadGroupArgs} args
            */
        lazyLoadGroup(args: LazyLoadGroupArgs): {
                result: Object[];
                count: number;
        };
        /**
            * Separate the aggregate query from the given queries
            * @param  {Query} query
            */
        getAggregate(query: Query): Object[];
        /**
            * Performs batch update in the JSON array which add, remove and update records.
            * @param  {DataManager} dm
            * @param  {CrudOptions} changes
            * @param  {RemoteArgs} e
            */
        batchRequest(dm: DataManager, changes: CrudOptions, e: RemoteArgs): CrudOptions;
        /**
            * Performs filter operation with the given data and where query.
            * @param  {Object[]} ds
            * @param  {{validate:Function}} e
            */
        onWhere(ds: Object[], e: {
                validate: Function;
        }): Object[];
        /**
            * Returns aggregate function based on the aggregate type.
            * @param  {Object[]} ds
            * @param  {{field:string} e
            * @param  {string}} type
            */
        onAggregates(ds: Object[], e: {
                field: string;
                type: string;
        }): Function;
        /**
            * Performs search operation based on the given query.
            * @param  {Object[]} ds
            * @param  {QueryOptions} e
            */
        onSearch(ds: Object[], e: QueryOptions): Object[];
        /**
            * Sort the data with given direction and field.
            * @param  {Object[]} ds
            * @param  {{comparer:(a:Object} e
            * @param  {Object} b
            */
        onSortBy(ds: Object[], e: {
                comparer: (a: Object, b: Object) => number;
                fieldName: string;
        }, query: Query): Object[];
        /**
            * Group the data based on the given query.
            * @param  {Object[]} ds
            * @param  {QueryOptions} e
            * @param  {Query} query
            */
        onGroup(ds: Object[], e: QueryOptions, query: Query): Object[];
        /**
            * Retrieves records based on the given page index and size.
            * @param  {Object[]} ds
            * @param  {{pageSize:number} e
            * @param  {number}} pageIndex
            * @param  {Query} query
            */
        onPage(ds: Object[], e: {
                pageSize: number;
                pageIndex: number;
        }, query: Query): Object[];
        /**
            * Retrieves records based on the given start and end index from query.
            * @param  {Object[]} ds
            * @param  {{start:number} e
            * @param  {number}} end
            */
        onRange(ds: Object[], e: {
                start: number;
                end: number;
        }): Object[];
        /**
            * Picks the given count of records from the top of the datasource.
            * @param  {Object[]} ds
            * @param  {{nos:number}} e
            */
        onTake(ds: Object[], e: {
                nos: number;
        }): Object[];
        /**
            * Skips the given count of records from the data source.
            * @param  {Object[]} ds
            * @param  {{nos:number}} e
            */
        onSkip(ds: Object[], e: {
                nos: number;
        }): Object[];
        /**
            * Selects specified columns from the data source.
            * @param  {Object[]} ds
            * @param  {{fieldNames:string}} e
            */
        onSelect(ds: Object[], e: {
                fieldNames: string[] | Function;
        }): Object[];
        /**
            * Inserts new record in the table.
            * @param  {DataManager} dm
            * @param  {Object} data
            * @param  {number} position
            */
        insert(dm: DataManager, data: Object, tableName?: string, query?: Query, position?: number): Object;
        /**
            * Remove the data from the dataSource based on the key field value.
            * @param  {DataManager} dm
            * @param  {string} keyField
            * @param  {Object} value
            * @param  {string} tableName?
            * @returns null
            */
        remove(dm: DataManager, keyField: string, value: Object, tableName?: string): Object;
        /**
            * Updates existing record and saves the changes to the table.
            * @param  {DataManager} dm
            * @param  {string} keyField
            * @param  {Object} value
            * @param  {string} tableName?
            * @returns null
            */
        update(dm: DataManager, keyField: string, value: Object, tableName?: string): void;
}
/**
    * URL Adaptor of DataManager can be used when you are required to use remote service to retrieve data.
    * It interacts with server-side for all DataManager Queries and CRUD operations.
    * @hidden
    */
export class UrlAdaptor extends Adaptor {
        /**
            * Process the query to generate request body.
            * @param  {DataManager} dm
            * @param  {Query} query
            * @param  {Object[]} hierarchyFilters?
            * @returns p
            */
        processQuery(dm: DataManager, query: Query, hierarchyFilters?: Object[]): Object;
        /**
            * Convert the object from processQuery to string which can be added query string.
            * @param  {Object} req
            * @param  {Query} query
            * @param  {DataManager} dm
            */
        convertToQueryString(request: Object, query: Query, dm: DataManager): string;
        /**
            * Return the data from the data manager processing.
            * @param  {DataResult} data
            * @param  {DataOptions} ds?
            * @param  {Query} query?
            * @param  {XMLHttpRequest} xhr?
            * @param  {Object} request?
            * @param  {CrudOptions} changes?
            */
        processResponse(data: DataResult, ds?: DataOptions, query?: Query, xhr?: XMLHttpRequest, request?: Object, changes?: CrudOptions): DataResult;
        protected formRemoteGroupedData(data: Group[], level: number, childLevel: number): Group[];
        /**
            * Add the group query to the adaptor`s option.
            * @param  {Object[]} e
            * @returns void
            */
        onGroup(e: QueryOptions[]): QueryOptions[];
        /**
            * Add the aggregate query to the adaptor`s option.
            * @param  {Aggregates[]} e
            * @returns void
            */
        onAggregates(e: Aggregates[]): void;
        /**
            * Prepare the request body based on the newly added, removed and updated records.
            * The result is used by the batch request.
            * @param  {DataManager} dm
            * @param  {CrudOptions} changes
            * @param  {Object} e
            */
        batchRequest(dm: DataManager, changes: CrudOptions, e: Object, query: Query, original?: Object): Object;
        /**
            * Method will trigger before send the request to server side.
            * Used to set the custom header or modify the request options.
            * @param  {DataManager} dm
            * @param  {XMLHttpRequest} request
            * @returns void
            */
        beforeSend(dm: DataManager, request: XMLHttpRequest): void;
        /**
            * Prepare and returns request body which is used to insert a new record in the table.
            * @param  {DataManager} dm
            * @param  {Object} data
            * @param  {string} tableName
            */
        insert(dm: DataManager, data: Object, tableName: string, query: Query): Object;
        /**
            * Prepare and return request body which is used to remove record from the table.
            * @param  {DataManager} dm
            * @param  {string} keyField
            * @param  {number|string} value
            * @param  {string} tableName
            */
        remove(dm: DataManager, keyField: string, value: number | string, tableName: string, query: Query): Object;
        /**
            * Prepare and return request body which is used to update record.
            * @param  {DataManager} dm
            * @param  {string} keyField
            * @param  {Object} value
            * @param  {string} tableName
            */
        update(dm: DataManager, keyField: string, value: Object, tableName: string, query: Query): Object;
        /**
            * To generate the predicate based on the filtered query.
            * @param  {Object[]|string[]|number[]} data
            * @param  {Query} query
            * @hidden
            */
        getFiltersFrom(data: Object[] | string[] | number[], query: Query): Predicate;
        protected getAggregateResult(pvt: PvtOptions, data: DataResult, args: DataResult, groupDs?: Object[], query?: Query): DataResult;
        protected getQueryRequest(query: Query): Requests;
        addParams(options: {
                dm: DataManager;
                query: Query;
                params: ParamOption[];
                reqParams: {
                        [key: string]: Object;
                };
        }): void;
}
/**
    * OData Adaptor that is extended from URL Adaptor, is used for consuming data through OData Service.
    * @hidden
    */
export class ODataAdaptor extends UrlAdaptor {
        protected getModuleName(): string;
        /**
            * Specifies the root url of the provided odata url.
            * @hidden
            * @default null
            */
        rootUrl: string;
        /**
            * Specifies the resource name of the provided odata table.
            * @hidden
            * @default null
            */
        resourceTableName: string;
        protected options: RemoteOptions;
        constructor(props?: RemoteOptions);
        /**
            * Generate request string based on the filter criteria from query.
            * @param  {Predicate} pred
            * @param  {boolean} requiresCast?
            */
        onPredicate(predicate: Predicate, query: Query | boolean, requiresCast?: boolean): string;
        addParams(options: {
                dm: DataManager;
                query: Query;
                params: ParamOption[];
                reqParams: {
                        [key: string]: Object;
                };
        }): void;
        /**
            * Generate request string based on the multiple filter criteria from query.
            * @param  {Predicate} pred
            * @param  {boolean} requiresCast?
            */
        onComplexPredicate(predicate: Predicate, query: Query, requiresCast?: boolean): string;
        /**
            * Generate query string based on the multiple filter criteria from query.
            * @param  {Predicate} filter
            * @param  {boolean} requiresCast?
            */
        onEachWhere(filter: Predicate, query: Query, requiresCast?: boolean): string;
        /**
            * Generate query string based on the multiple filter criteria from query.
            * @param  {string[]} filters
            */
        onWhere(filters: string[]): string;
        /**
            * Generate query string based on the multiple search criteria from query.
            * @param  {{fields:string[]} e
            * @param  {string} operator
            * @param  {string} key
            * @param  {boolean}} ignoreCase
            */
        onEachSearch(e: {
                fields: string[];
                operator: string;
                key: string;
                ignoreCase: boolean;
        }): void;
        /**
            * Generate query string based on the search criteria from query.
            * @param  {Object} e
            */
        onSearch(e: Object): string;
        /**
            * Generate query string based on multiple sort criteria from query.
            * @param  {QueryOptions} e
            */
        onEachSort(e: QueryOptions): string;
        /**
            * Returns sort query string.
            * @param  {string[]} e
            */
        onSortBy(e: string[]): string;
        /**
            * Adds the group query to the adaptor option.
            * @param  {Object[]} e
            * @returns string
            */
        onGroup(e: QueryOptions[]): QueryOptions[];
        /**
            * Returns the select query string.
            * @param  {string[]} e
            */
        onSelect(e: string[]): string;
        /**
            * Add the aggregate query to the adaptor option.
            * @param  {Object[]} e
            * @returns string
            */
        onAggregates(e: Object[]): string;
        /**
            * Returns the query string which requests total count from the data source.
            * @param  {boolean} e
            * @returns string
            */
        onCount(e: boolean): string;
        /**
            * Method will trigger before send the request to server side.
            * Used to set the custom header or modify the request options.
            * @param  {DataManager} dm
            * @param  {XMLHttpRequest} request
            * @param  {Ajax} settings?
            */
        beforeSend(dm: DataManager, request: XMLHttpRequest, settings?: Ajax): void;
        /**
            * Returns the data from the query processing.
            * @param  {DataResult} data
            * @param  {DataOptions} ds?
            * @param  {Query} query?
            * @param  {XMLHttpRequest} xhr?
            * @param  {Ajax} request?
            * @param  {CrudOptions} changes?
            * @returns aggregateResult
            */
        processResponse(data: DataResult, ds?: DataOptions, query?: Query, xhr?: XMLHttpRequest, request?: Ajax, changes?: CrudOptions): Object;
        /**
            * Converts the request object to query string.
            * @param  {Object} req
            * @param  {Query} query
            * @param  {DataManager} dm
            * @returns tableName
            */
        convertToQueryString(request: Object, query: Query, dm: DataManager): string;
        /**
            * Prepare and returns request body which is used to insert a new record in the table.
            * @param  {DataManager} dm
            * @param  {Object} data
            * @param  {string} tableName?
            */
        insert(dm: DataManager, data: Object, tableName?: string): Object;
        /**
            * Prepare and return request body which is used to remove record from the table.
            * @param  {DataManager} dm
            * @param  {string} keyField
            * @param  {number} value
            * @param  {string} tableName?
            */
        remove(dm: DataManager, keyField: string, value: number, tableName?: string): Object;
        /**
            * Updates existing record and saves the changes to the table.
            * @param  {DataManager} dm
            * @param  {string} keyField
            * @param  {Object} value
            * @param  {string} tableName?
            * @returns this
            */
        update(dm: DataManager, keyField: string, value: Object, tableName?: string, query?: Query, original?: Object): Object;
        /**
            * Prepare the request body based on the newly added, removed and updated records.
            * The result is used by the batch request.
            * @param  {DataManager} dm
            * @param  {CrudOptions} changes
            * @param  {RemoteArgs} e
            * @returns {Object}
            */
        batchRequest(dm: DataManager, changes: CrudOptions, e: RemoteArgs, query: Query, original?: CrudOptions): Object;
        /**
            * Generate the string content from the removed records.
            * The result will be send during batch update.
            * @param  {Object[]} arr
            * @param  {RemoteArgs} e
            * @returns this
            */
        generateDeleteRequest(arr: Object[], e: RemoteArgs, dm: DataManager): string;
        /**
            * Generate the string content from the inserted records.
            * The result will be send during batch update.
            * @param  {Object[]} arr
            * @param  {RemoteArgs} e
            */
        generateInsertRequest(arr: Object[], e: RemoteArgs, dm: DataManager): string;
        /**
            * Generate the string content from the updated records.
            * The result will be send during batch update.
            * @param  {Object[]} arr
            * @param  {RemoteArgs} e
            */
        generateUpdateRequest(arr: Object[], e: RemoteArgs, dm: DataManager, org?: Object[]): string;
        protected static getField(prop: string): string;
        protected processBatchResponse(data: DataResult, query?: Query, xhr?: XMLHttpRequest, request?: Ajax, changes?: CrudOptions): CrudOptions | DataResult;
        compareAndRemove(data: Object, original: Object, key?: string): Object;
}
/**
    * The OData v4 is an improved version of OData protocols.
    * The DataManager uses the ODataV4Adaptor to consume OData v4 services.
    * @hidden
    */
export class ODataV4Adaptor extends ODataAdaptor {
        /**
            * @hidden
            */
        protected getModuleName(): string;
        protected options: RemoteOptions;
        constructor(props?: RemoteOptions);
        /**
            * Returns the query string which requests total count from the data source.
            * @param  {boolean} e
            * @returns string
            */
        onCount(e: boolean): string;
        /**
            * Generate request string based on the filter criteria from query.
            * @param  {Predicate} pred
            * @param  {boolean} requiresCast?
            */
        onPredicate(predicate: Predicate, query: Query | boolean, requiresCast?: boolean): string;
        /**
            *  Generate query string based on the multiple search criteria from query.
            * @param  {{fields:string[]} e
            * @param  {string} operator
            * @param  {string} key
            * @param  {boolean}} ignoreCase
            */
        onEachSearch(e: {
                fields: string[];
                operator: string;
                key: string;
                ignoreCase: boolean;
        }): void;
        /**
            *  Generate query string based on the search criteria from query.
            * @param  {Object} e
            */
        onSearch(e: Object): string;
        /**
            * Returns the expand query string.
            * @param  {string} e
            */
        onExpand(e: {
                selects: string[];
                expands: string[];
        }): string;
        /**
            * Returns the groupby query string.
            * @param  {string} e
            */
        onDistinct(distinctFields: string[]): Object;
        /**
            * Returns the select query string.
            * @param  {string[]} e
            */
        onSelect(e: string[]): string;
        /**
            * Method will trigger before send the request to server side.
            * Used to set the custom header or modify the request options.
            * @param  {DataManager} dm
            * @param  {XMLHttpRequest} request
            * @param  {Ajax} settings
            * @returns void
            */
        beforeSend(dm: DataManager, request: XMLHttpRequest, settings: Ajax): void;
        /**
            * Returns the data from the query processing.
            * @param  {DataResult} data
            * @param  {DataOptions} ds?
            * @param  {Query} query?
            * @param  {XMLHttpRequest} xhr?
            * @param  {Ajax} request?
            * @param  {CrudOptions} changes?
            * @returns aggregateResult
            */
        processResponse(data: DataResult, ds?: DataOptions, query?: Query, xhr?: XMLHttpRequest, request?: Ajax, changes?: CrudOptions): Object;
}
/**
    * The Web API is a programmatic interface to define the request and response messages system that is mostly exposed in JSON or XML.
    * The DataManager uses the WebApiAdaptor to consume Web API.
    * Since this adaptor is targeted to interact with Web API created using OData endpoint, it is extended from ODataAdaptor
    * @hidden
    */
export class WebApiAdaptor extends ODataAdaptor {
        protected getModuleName(): string;
        /**
            * Prepare and returns request body which is used to insert a new record in the table.
            * @param  {DataManager} dm
            * @param  {Object} data
            * @param  {string} tableName?
            */
        insert(dm: DataManager, data: Object, tableName?: string): Object;
        /**
            * Prepare and return request body which is used to remove record from the table.
            * @param  {DataManager} dm
            * @param  {string} keyField
            * @param  {number} value
            * @param  {string} tableName?
            */
        remove(dm: DataManager, keyField: string, value: number, tableName?: string): Object;
        /**
            * Prepare and return request body which is used to update record.
            * @param  {DataManager} dm
            * @param  {string} keyField
            * @param  {Object} value
            * @param  {string} tableName?
            */
        update(dm: DataManager, keyField: string, value: Object, tableName?: string): Object;
        batchRequest(dm: DataManager, changes: CrudOptions, e: RemoteArgs): Object;
        /**
            * Method will trigger before send the request to server side.
            * Used to set the custom header or modify the request options.
            * @param  {DataManager} dm
            * @param  {XMLHttpRequest} request
            * @param  {Ajax} settings
            * @returns void
            */
        beforeSend(dm: DataManager, request: XMLHttpRequest, settings: Ajax): void;
        /**
            * Returns the data from the query processing.
            * @param  {DataResult} data
            * @param  {DataOptions} ds?
            * @param  {Query} query?
            * @param  {XMLHttpRequest} xhr?
            * @param  {Ajax} request?
            * @param  {CrudOptions} changes?
            * @returns aggregateResult
            */
        processResponse(data: DataResult, ds?: DataOptions, query?: Query, xhr?: XMLHttpRequest, request?: Ajax, changes?: CrudOptions): Object;
}
/**
    * WebMethodAdaptor can be used by DataManager to interact with web method.
    * @hidden
    */
export class WebMethodAdaptor extends UrlAdaptor {
        /**
            * Prepare the request body based on the query.
            * The query information can be accessed at the WebMethod using variable named `value`.
            * @param  {DataManager} dm
            * @param  {Query} query
            * @param  {Object[]} hierarchyFilters?
            * @returns application
            */
        processQuery(dm: DataManager, query: Query, hierarchyFilters?: Object[]): Object;
}
/**
    * RemoteSaveAdaptor, extended from JsonAdaptor and it is used for binding local data and performs all DataManager queries in client-side.
    * It interacts with server-side only for CRUD operations.
    * @hidden
    */
export class RemoteSaveAdaptor extends JsonAdaptor {
        /**
            * @hidden
            */
        constructor();
        insert(dm: DataManager, data: Object, tableName: string, query: Query, position?: number): Object;
        remove(dm: DataManager, keyField: string, val: Object, tableName?: string, query?: Query): Object;
        update(dm: DataManager, keyField: string, val: Object, tableName: string, query?: Query): Object;
        processResponse(data: CrudOptions, ds?: DataOptions, query?: Query, xhr?: XMLHttpRequest, request?: Ajax, changes?: CrudOptions, e?: RemoteArgs): Object;
        /**
            * Prepare the request body based on the newly added, removed and updated records.
            * Also perform the changes in the locally cached data to sync with the remote data.
            * The result is used by the batch request.
            * @param  {DataManager} dm
            * @param  {CrudOptions} changes
            * @param  {RemoteArgs} e
            */
        batchRequest(dm: DataManager, changes: CrudOptions, e: RemoteArgs, query?: Query, original?: Object): Object;
        addParams(options: {
                dm: DataManager;
                query: Query;
                params: ParamOption[];
                reqParams: {
                        [key: string]: Object;
                };
        }): void;
}
/**
    * Ajax Adaptor that is extended from URL Adaptor, is used for handle data operations with user defined functions.
    * @hidden
    */
export class CustomDataAdaptor extends UrlAdaptor {
        protected getModuleName(): string;
        protected options: RemoteOptions;
        constructor(props?: RemoteOptions);
}
/**
    * The GraphqlAdaptor that is extended from URL Adaptor, is used for retrieving data from the Graphql server.
    * It interacts with the Graphql server with all the DataManager Queries and performs CRUD operations.
    * @hidden
    */
export class GraphQLAdaptor extends UrlAdaptor {
        protected getModuleName(): string;
        getVariables: Function;
        constructor(options: GraphQLAdaptorOptions);
        /**
            * Process the JSON data based on the provided queries.
            * @param  {DataManager} dm
            * @param  {Query} query?
            */
        processQuery(datamanager: DataManager, query: Query): Object;
        /**
            * Returns the data from the query processing.
            * It will also cache the data for later usage.
            * @param  {DataResult} data
            * @param  {DataManager} ds?
            * @param  {Query} query?
            * @param  {XMLHttpRequest} xhr?
            * @param  {Object} request?
            * @returns DataResult
            */
        processResponse(resData: DataResult, ds?: DataManager, query?: Query, xhr?: XMLHttpRequest, request?: Object): DataResult;
        /**
            * Prepare and returns request body which is used to insert a new record in the table.
            */
        insert(): {
                data: string;
        };
        /**
            * Prepare and returns request body which is used to update a new record in the table.
            */
        update(): {
                data: string;
        };
        /**
            * Prepare and returns request body which is used to remove a new record in the table.
            */
        remove(): {
                data: string;
        };
        /**
            * Prepare the request body based on the newly added, removed and updated records.
            * The result is used by the batch request.
            * @param  {DataManager} dm
            * @param  {CrudOptions} changes
            * @param  {Object} e
            * @param  {Query} query
            * @param  {Object} original
            */
        batchRequest(dm: DataManager, changes: CrudOptions, e: {
                key: string;
        }, query: Query, original?: Object): Object;
}
/**
    * Cache Adaptor is used to cache the data of the visited pages. It prevents new requests for the previously visited pages.
    * You can configure cache page size and duration of caching by using cachingPageSize and timeTillExpiration properties of the DataManager
    * @hidden
    */
export class CacheAdaptor extends UrlAdaptor {
        /**
            * Constructor for CacheAdaptor class.
            * @param  {CacheAdaptor} adaptor?
            * @param  {number} timeStamp?
            * @param  {number} pageSize?
            * @hidden
            */
        constructor(adaptor?: CacheAdaptor, timeStamp?: number, pageSize?: number);
        /**
            * It will generate the key based on the URL when we send a request to server.
            * @param  {string} url
            * @param  {Query} query?
            * @hidden
            */
        generateKey(url: string, query: Query): string;
        /**
            * Process the query to generate request body.
            * If the data is already cached, it will return the cached data.
            * @param  {DataManager} dm
            * @param  {Query} query?
            * @param  {Object[]} hierarchyFilters?
            */
        processQuery(dm: DataManager, query?: Query, hierarchyFilters?: Object[]): Object;
        /**
            * Returns the data from the query processing.
            * It will also cache the data for later usage.
            * @param  {DataResult} data
            * @param  {DataManager} ds?
            * @param  {Query} query?
            * @param  {XMLHttpRequest} xhr?
            * @param  {Ajax} request?
            * @param  {CrudOptions} changes?
            */
        processResponse(data: DataResult, ds?: DataManager, query?: Query, xhr?: XMLHttpRequest, request?: Ajax, changes?: CrudOptions): DataResult;
        /**
            * Method will trigger before send the request to server side. Used to set the custom header or modify the request options.
            * @param  {DataManager} dm
            * @param  {XMLHttpRequest} request
            * @param  {Ajax} settings?
            */
        beforeSend(dm: DataManager, request: XMLHttpRequest, settings?: Ajax): void;
        /**
            * Updates existing record and saves the changes to the table.
            * @param  {DataManager} dm
            * @param  {string} keyField
            * @param  {Object} value
            * @param  {string} tableName
            */
        update(dm: DataManager, keyField: string, value: Object, tableName: string): Object;
        /**
            * Prepare and returns request body which is used to insert a new record in the table.
            * @param  {DataManager} dm
            * @param  {Object} data
            * @param  {string} tableName?
            */
        insert(dm: DataManager, data: Object, tableName?: string): Object;
        /**
            * Prepare and return request body which is used to remove record from the table.
            * @param  {DataManager} dm
            * @param  {string} keyField
            * @param  {Object} value
            * @param  {string} tableName?
            */
        remove(dm: DataManager, keyField: string, value: Object, tableName?: string): Object[];
        /**
            * Prepare the request body based on the newly added, removed and updated records.
            * The result is used by the batch request.
            * @param  {DataManager} dm
            * @param  {CrudOptions} changes
            * @param  {RemoteArgs} e
            */
        batchRequest(dm: DataManager, changes: CrudOptions, e: RemoteArgs): CrudOptions;
}
/**
    * @hidden
    */
export interface CrudOptions {
        changedRecords?: Object[];
        addedRecords?: Object[];
        deletedRecords?: Object[];
        changed?: Object[];
        added?: Object[];
        deleted?: Object[];
        action?: string;
        table?: string;
        key?: string;
}
/**
    * @hidden
    */
export interface PvtOptions {
        groups?: QueryOptions[];
        aggregates?: Aggregates[];
        search?: Object | Predicate;
        changeSet?: number;
        searches?: Object[];
        position?: number;
}
/**
    * @hidden
    */
export interface DataResult {
        nodeType?: number;
        addedRecords?: Object[];
        d?: DataResult | Object[];
        Count?: number;
        count?: number;
        result?: Object;
        results?: Object[] | DataResult;
        aggregate?: DataResult;
        aggregates?: Aggregates;
        value?: Object;
        Items?: Object[] | DataResult;
        keys?: string[];
        groupDs?: Object[];
}
/**
    * @hidden
    */
export interface Requests {
        sorts: QueryOptions[];
        groups: QueryOptions[];
        filters: QueryOptions[];
        searches: QueryOptions[];
        aggregates: QueryOptions[];
}
/**
    * @hidden
    */
export interface RemoteArgs {
        guid?: string;
        url?: string;
        key?: string;
        cid?: number;
        cSet?: string;
}
/**
    * @hidden
    */
export interface RemoteOptions {
        from?: string;
        requestType?: string;
        sortBy?: string;
        select?: string;
        skip?: string;
        group?: string;
        take?: string;
        search?: string;
        count?: string;
        where?: string;
        aggregates?: string;
        expand?: string;
        accept?: string;
        multipartAccept?: string;
        batch?: string;
        changeSet?: string;
        batchPre?: string;
        contentId?: string;
        batchContent?: string;
        changeSetContent?: string;
        batchChangeSetContentType?: string;
        updateType?: string;
        localTime?: boolean;
        apply?: string;
        getData?: Function;
        updateRecord?: Function;
        addRecord?: Function;
        deleteRecord?: Function;
        batchUpdate?: Function;
}
/**
    * @hidden
    */
export interface GraphQLAdaptorOptions {
        response: {
                result: string;
                count?: string;
                aggregates?: string;
        };
        query: string;
        getQuery?: () => string;
        getVariables?: Function;
        getMutation?: (action: string) => string;
}
/**
    * @hidden
    */
export interface LazyLoad {
        isLazyLoad: boolean;
        onDemandGroupInfo: OnDemandGroupInfo;
}
/**
    * @hidden
    */
export interface OnDemandGroupInfo {
        level: number;
        skip: number;
        take: number;
        where: Predicate[];
}
/**
    * @hidden
    */
export interface LazyLoadGroupArgs {
        query: Query;
        lazyLoad: LazyLoad;
        result: Object[];
        group: Object[];
        page: {
                pageIndex: number;
                pageSize: number;
        };
}
/**
    * @hidden
    */
export type ReturnType = {
        result: Object[];
        count?: number;
        aggregates?: string;
};

/**
    * Data manager common utility methods.
    * @hidden
    */
export class DataUtil {
        /**
            * Specifies the value which will be used to adjust the date value to server timezone.
            * @default null
            */
        static serverTimezoneOffset: number;
        /**
            * Species whether are not to be parsed with serverTimezoneOffset value.
            * @hidden
            */
        static timeZoneHandling: boolean;
        /**
            * Returns the value by invoking the provided parameter function.
            * If the paramater is not of type function then it will be returned as it is.
            * @param  {Function|string|string[]|number} value
            * @param  {Object} inst?
            * @hidden
            */
        static getValue<T>(value: T | Function, inst?: Object): T;
        /**
            * Returns true if the input string ends with given string.
            * @param  {string} input
            * @param  {string} substr
            */
        static endsWith(input: string, substr: string): boolean;
        /**
            * Returns true if the input string starts with given string.
            * @param  {string} str
            * @param  {string} startstr
            */
        static startsWith(input: string, start: string): boolean;
        /**
            * To return the sorting function based on the string.
            * @param  {string} order
            * @hidden
            */
        static fnSort(order: string): Function;
        /**
            * Comparer function which is used to sort the data in ascending order.
            * @param  {string|number} x
            * @param  {string|number} y
            * @returns number
            */
        static fnAscending(x: string | number, y: string | number): number;
        /**
            * Comparer function which is used to sort the data in descending order.
            * @param  {string|number} x
            * @param  {string|number} y
            * @returns number
            */
        static fnDescending(x: string | number, y: string | number): number;
        /**
            * Select objects by given fields from jsonArray.
            * @param  {Object[]} jsonArray
            * @param  {string[]} fields
            */
        static select(jsonArray: Object[], fields: string[]): Object[];
        /**
            * Group the input data based on the field name.
            * It also performs aggregation of the grouped records based on the aggregates paramater.
            * @param  {Object[]} jsonArray
            * @param  {string} field?
            * @param  {Object[]} agg?
            * @param  {number} level?
            * @param  {Object[]} groupDs?
            */
        static group(jsonArray: Object[], field?: string, aggregates?: Object[], level?: number, groupDs?: Object[], format?: Function, isLazyLoad?: boolean): Object[];
        /**
            * It is used to categorize the multiple items based on a specific field in jsonArray.
            * The hierarchical queries are commonly required when you use foreign key binding.
            * @param  {string} fKey
            * @param  {string} from
            * @param  {Object[]} source
            * @param  {Group} lookup?
            * @param  {string} pKey?
            * @hidden
            */
        static buildHierarchy(fKey: string, from: string, source: Group, lookup?: Group, pKey?: string): void;
        /**
            * Throw error with the given string as message.
            * @param  {string} er
            */
        static throwError: Function;
        static aggregates: Aggregates;
        /**
            * The method used to get the field names which started with specified characters.
            * @param  {Object} obj
            * @param  {string[]} fields?
            * @param  {string} prefix?
            * @hidden
            */
        static getFieldList(obj: Object, fields?: string[], prefix?: string): string[];
        /**
            * Gets the value of the property in the given object.
            * The complex object can be accessed by providing the field names concatenated with dot(.).
            * @param  {string} nameSpace - The name of the property to be accessed.
            * @param  {Object} from - Defines the source object.
            */
        static getObject(nameSpace: string, from: Object): Object;
        /**
            * To set value for the nameSpace in desired object.
            * @param {string} nameSpace - String value to the get the inner object.
            * @param {Object} value - Value that you need to set.
            * @param {Object} obj - Object to get the inner object value.
            * @return { [key: string]: Object; } | Object
            * @hidden
            */
        static setValue(nameSpace: string, value: Object | null, obj: Object): {
                [key: string]: Object;
        } | Object;
        /**
            * Sort the given data based on the field and comparer.
            * @param  {Object[]} ds - Defines the input data.
            * @param  {string} field - Defines the field to be sorted.
            * @param  {Function} comparer - Defines the comparer function used to sort the records.
            */
        static sort(ds: Object[], field: string, comparer: Function): Object[];
        static ignoreDiacritics(value: string | number | boolean): string | Object;
        /**
            * Specifies the Object with filter operators.
            */
        static operatorSymbols: {
                [key: string]: string;
        };
        /**
            * Specifies the Object with filter operators which will be used for OData filter query generation.
            * * It will be used for date/number type filter query.
            */
        static odBiOperator: {
                [key: string]: string;
        };
        /**
            * Specifies the Object with filter operators which will be used for OData filter query generation.
            * It will be used for string type filter query.
            */
        static odUniOperator: {
                [key: string]: string;
        };
        /**
            * Specifies the Object with filter operators which will be used for ODataV4 filter query generation.
            * It will be used for string type filter query.
            */
        static odv4UniOperator: {
                [key: string]: string;
        };
        static diacritics: {
                [key: string]: string;
        };
        static fnOperators: Operators;
        /**
            * To perform the filter operation with specified adaptor and returns the result.
            * @param  {Object} adaptor
            * @param  {string} fnName
            * @param  {Object} param1?
            * @param  {Object} param2?
            * @hidden
            */
        static callAdaptorFunction(adaptor: Object, fnName: string, param1?: Object, param2?: Object): Object;
        static getAddParams(adp: Object, dm: DataManager, query: Query): Object;
        /**
            * To perform the parse operation on JSON data, like convert to string from JSON or convert to JSON from string.
            */
        static parse: ParseOption;
        /**
            * Checks wheather the given input is a plain object or not.
            * @param  {Object|Object[]} obj
            */
        static isPlainObject(obj: Object | Object[]): boolean;
        /**
            * Returns true when the browser cross origin request.
            */
        static isCors(): boolean;
        /**
            * Generate random GUID value which will be prefixed with the given value.
            * @param  {string} prefix
            */
        static getGuid(prefix: string): string;
        /**
            * Checks wheather the given value is null or not.
            * @param  {string|Object} val
            * @returns boolean
            */
        static isNull(val: string | Object): boolean;
        /**
            * To get the required items from collection of objects.
            * @param  {Object[]} array
            * @param  {string} field
            * @param  {Function} comparer
            * @returns Object
            * @hidden
            */
        static getItemFromComparer(array: Object[], field: string, comparer: Function): Object;
        /**
            * To get distinct values of Array or Array of Objects.
            * @param  {Object[]} json
            * @param  {string} field
            * @param  {boolean} requiresCompleteRecord
            * @returns Object[]
            * * distinct array of objects is return when requiresCompleteRecord set as true.
            * @hidden
            */
        static distinct(json: Object[], fieldName: string, requiresCompleteRecord?: boolean): Object[];
        /**
            * @hidden
            */
        static dateParse: DateParseOption;
        /**
            * Process the given records based on the datamanager string.
            * @param  {string} datamanager
            * @param  {Object[]} records
            */
        static processData(dm: GraphQLParams, records: Object[]): ReturnType;
}
/**
    * @hidden
    */
export interface GraphQLParams {
        skip?: number;
        take?: number;
        sorted?: {
                name: string;
                direction: string;
        }[];
        group?: string[];
        table?: string;
        select?: string[];
        where?: string;
        search?: string;
        requiresCounts?: boolean;
        aggregates?: Aggregates[];
        params?: string;
}
/**
    * @hidden
    */
export interface Aggregates {
        sum?: Function;
        average?: Function;
        min?: Function;
        max?: Function;
        truecount?: Function;
        falsecount?: Function;
        count?: Function;
        type?: string;
        field?: string;
}
/**
    * @hidden
    */
export interface Operators {
        equal?: Function;
        notequal?: Function;
        lessthan?: Function;
        greaterthan?: Function;
        lessthanorequal?: Function;
        greaterthanorequal?: Function;
        contains?: Function;
        notnull?: Function;
        isnull?: Function;
        startswith?: Function;
        endswith?: Function;
        processSymbols?: Function;
        processOperator?: Function;
}
/**
    * @hidden
    */
export interface Group {
        GroupGuid?: string;
        level?: number;
        childLevels?: number;
        records?: Object[];
        key?: string;
        count?: number;
        items?: Object[];
        aggregates?: Object;
        field?: string;
        result?: Object;
}
/**
    * @hidden
    */
export interface ParseOption {
        parseJson?: Function;
        iterateAndReviveArray?: Function;
        iterateAndReviveJson?: Function;
        jsonReviver?: (key: string, value: Object) => Object;
        isJson?: Function;
        isGuid?: Function;
        replacer?: Function;
        jsonReplacer?: Function;
        arrayReplacer?: Function;
        jsonDateReplacer?: (key: string, value: any) => any;
}
/**
    * @hidden
    */
export interface DateParseOption {
        addSelfOffset?: (input: Date) => Date;
        toUTC?: (input: Date) => Date;
        toTimeZone?: (input: Date, offset?: number, utc?: boolean) => Date;
        toLocalTime?: (input: Date) => string;
}

