// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../@tuval/cg
//   ../../@tuval/core

import { CGRectangle, IContext2D, CGColor, CGPoint, CGSize, CGContext2D, CGCommandContext2D } from "@tuval/cg";
import { float, Out, byte, int, TObject, IntPtr } from '@tuval/core';
import { CGRectangle } from '@tuval/cg';
import { CGPoint } from '@tuval/cg';
import { List, IDisposable, float } from '@tuval/core';
import { CGRectangle, CGPoint } from '@tuval/cg';
import { List } from "@tuval/core";
import { float } from "@tuval/core";
import { CGColor } from '@tuval/cg';
import { IDisposable } from "@tuval/core";
import { IContext2D } from '@tuval/cg';
import { float } from '@tuval/core';
import { CGFont } from '@tuval/cg';
import { int } from '@tuval/core';
import { CGImage } from "@tuval/cg";
import { CGSize, CGColor, CGRectangle } from '@tuval/cg';
import { IntPtr, Stream, int, Type } from '@tuval/core';
import { IntPtr, Out, Stream, int, IntArray } from '@tuval/core';
import { CGRectangle, CGSize } from '@tuval/cg';
import { Guid, float, Delegate } from '@tuval/core';
import { EventArgs } from "@tuval/core";
import { Delegate } from "@tuval/core";
import { CGRectangle, CGPoint, CGSize, CGAffineTransform } from '@tuval/cg';
import { float, Out } from '@tuval/core';
import { CGAffineTransform, CGRectangle, CGPoint } from "@tuval/cg";
import { IDisposable, float } from "@tuval/core";
import { CGImage } from '@tuval/cg';
import { CGContext2D } from '@tuval/cg';
import { CGRectangle, CGPoint, CGColor, CGContext2D } from "@tuval/cg";
import { CGColor } from "@tuval/cg";
import { float, Out } from "@tuval/core";
import { Ticker } from "@tuval/core";
import { ICloneable, IDisposable, float } from "@tuval/core";
import { byte } from "@tuval/core";
import { List } from '@tuval/core';
import { int, IntPtr } from '@tuval/core';
import { IDisposable, int, IntPtr } from '@tuval/core';
import { int, short, ByteArray } from '@tuval/core';
import { Guid, int } from '@tuval/core';
import { ByteArray, int, Guid } from '@tuval/core';
import { CGRectangle, CGColor } from '@tuval/cg';
import { int, byte } from "@tuval/core";
import { EventDispatcher, float } from "@tuval/core";
import { int, ICursorService } from '@tuval/core';
import { int, uint, CanvasModule, byte, ByteArray } from '@tuval/core';
import { CGColor, CGRectangle, CGSize } from '@tuval/cg';
import { CGRectangle } from "@tuval/cg";
import { TextConsole, int, LazyValue } from '@tuval/core';
import { EventDispatcher } from "@tuval/core";
import { CGContext2D, CGColor } from "@tuval/cg";
import { TVC } from "@tuval/core";
import { Guid } from '@tuval/core';
import { Screen } from '@tuval/core';

import './exports';
export const TDIModule: {
    Bitmap: (string | typeof Bitmap)[];
};

export enum AngleModes {
    Degrees = "degrees",
    Radians = "radians"
}
export enum EllipseModes {
    Radians = "radians",
    Corner = "corner",
    Corners = "corners",
    Center = "center"
}
export enum RectangleModes {
    Radians = "radians",
    Corner = "corner",
    Corners = "corners",
    Center = "center"
}
export enum ArcModes {
    Chord = "chord",
    Pie = "pie",
    Open = "open"
}
export enum CompositingMode {
    SourceOver = 0,
    SourceCopy = 1
}
export interface TextMetricsEx {
    width: number;
    fontSize: number;
    leading: number;
    ascent: number;
    descent: number;
    bounds: any;
    height: number;
}
export const PI: number;
export const DEG_TO_RAD: number;
export const RAD_TO_DEG: number;
export const TWO_PI: number;
export const HALF_PI: number;
export const QUARTER_PI: number;
export const CORNER = "corner";
export const CORNERS = "corners";
export abstract class GraphicsBase<T extends IContext2D> extends TObject {
    nativeObject: IntPtr;
    renderer: T;
    LastPen: Pen;
    LastBrush: Brush;
    protected isFlipped: boolean;
    x: number;
    y: number;
    width: number;
    height: number;
    LastBrushColor: CGColor;
    modelMatrix: Matrix;
    protected screenScale: float;
    constructor();
    get CurrentPen(): Pen;
    set CurrentPen(value: Pen);
    protected getCurrentPen(): Pen;
    protected setCurrentPen(value: Pen): void;
    get CurrentBrush(): Brush;
    set CurrentBrush(value: Brush);
    protected getCurrentBrush(): Brush;
    protected setCurrentBrush(value: Brush): void;
    setSize(width: int, height: int): void;
    abstract provideRenderer2D(): T;
    abstract init(): void;
    get CompositingMode(): CompositingMode;
    set CompositingMode(value: CompositingMode);
    Graphics(context: CanvasRenderingContext2D, flipped: boolean): void;
    Graphics(context: CGContext2D, flipped: boolean): void;
    DeltaTime: int;
    FPS: int;
    MemoryUsage: int;
    FrameCount: int;
    CreateTween(obj: any, props?: any): Tween;
    UpdateTween(event: any): void;
    RequestAnimationFrame(func: Function): void;
    protected initializeContext(context: IContext2D): void;
    dispose(disposing?: boolean): void;
    transferToImageBitmap(): ImageBitmap;
    moveTo(point: CGPoint): void;
    moveTo(x: float, y: float): void;
    lineTo(point: CGPoint): void;
    lineTo(x: float, y: float): void;
    curveTo(x1: float, y1: float, x2: float, y2: float, x3: float, y3: float): void;
    preparePen(pen: Pen): void;
    drawArc(pen: Pen, rect: CGRectangle, startAngle: float, sweepAngle: float): void;
    drawArc(pen: Pen, x: float, y: float, width: float, height: float, startAngle: float, sweepAngle: float): void;
    DrawLine(pen: Pen, pt1: CGPoint, pt2: CGPoint): void;
    DrawLine(pen: Pen, x1: float, y1: float, x2: float, y2: float): void;
    drawBezier(pen: Pen, pt1: CGPoint, pt2: CGPoint, pt3: CGPoint, pt4: CGPoint): void;
    drawBezier(pen: Pen, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float, x4: float, y4: float): void;
    drawBeziers(pen: Pen, points: CGPoint[]): void;
    drawLines(pen: Pen, points: CGPoint[]): void;
    DrawRectangle(pen: Pen, rect: CGRectangle, mode?: RectangleModes): void;
    DrawRectangle(pen: Pen, rect: CGRectangle, tl: number, tr?: number, br?: number, bl?: number, mode?: RectangleModes): void;
    DrawRectangle(pen: Pen, x1: float, y1: float, w: float, h: float, mode?: RectangleModes): void;
    DrawRectangle(pen: Pen, x1: float, y1: float, w: float, h: float, tl: number, tr?: number, br?: number, bl?: number, mode?: RectangleModes): void;
    FillRectangle(brush: Brush, rect: CGRectangle, mode?: RectangleModes): void;
    FillRectangle(brush: Brush, rect: CGRectangle, tl: number, tr?: number, br?: number, bl?: number, mode?: RectangleModes): void;
    FillRectangle(brush: Brush, x1: float, y1: float, w: float, h: float, mode?: RectangleModes): void;
    FillRectangle(brush: Brush, x1: float, y1: float, w: float, h: float, tl: number, tr?: number, br?: number, bl?: number, mode?: RectangleModes): void;
    fillRegion(brush: Brush, region: Region): void;
    drawPoint(pen: Pen, point: CGPoint): void;
    drawPoint(pen: Pen, x: number, y: number): void;
    DrawEllipse(pen: Pen, rect: CGRectangle): void;
    DrawEllipse(pen: Pen, x: float, y: float, radius: float, ellipseMode?: EllipseModes): void;
    DrawEllipse(pen: Pen, x: float, y: float, width: float, height: float, ellipseMode?: EllipseModes): void;
    FillEllipse(pen: Brush, rect: CGRectangle): void;
    FillEllipse(pen: Brush, x: float, y: float, radius: float, ellipseMode?: EllipseModes): void;
    FillEllipse(pen: Brush, x: float, y: float, width: float, height: float, ellipseMode?: EllipseModes): void;
    resetTransform(): void;
    get Transform(): Matrix;
    set Transform(value: Matrix);
    rotateTransform(angle: float): void;
    rotateTransform(angle: float, order: MatrixOrder): void;
    translateTransform(tx: float, ty: float): void;
    translateTransform(tx: float, ty: float, order: MatrixOrder): void;
    ScaleTransform(sx: float, sy: float): void;
    ScaleTransform(sx: float, sy: float, order: MatrixOrder): void;
    drawCurve(pen: Pen, points: CGPoint[]): void;
    drawCurve(pen: Pen, points: CGPoint[], tension: float): void;
    drawCurve(pen: Pen, points: CGPoint[], offset: number, numberOfSegments: number, tension: float): void;
    drawContextPath(pen: Pen): void;
    drawPath(pen: Pen, path: GraphicsPath): void;
    fillContextPath(brush: Brush): void;
    fillPath(brush: Brush, path: GraphicsPath): void;
    getNearestColor(color: CGColor): CGColor;
    get PageUnit(): GraphicsUnit;
    set PageUnit(value: GraphicsUnit);
    get PageScale(): float;
    set PageScale(value: float);
    setClip(rect: CGRectangle): void;
    setClip(graphicsPath: GraphicsPath): void;
    setClip(g: Graphics): void;
    setClip(rect: CGRectangle, combineMode: CombineMode): void;
    setClip(graphicsPath: GraphicsPath, combineMode: CombineMode): void;
    setClip(g: Graphics, combineMode: CombineMode): void;
    setClip(region: Region, combineMode: CombineMode): void;
    beginContainer(dstRect: CGRectangle, srcRect: CGRectangle, unit: GraphicsUnit): GraphicsContainer;
    endContainer(container: GraphicsContainer): void;
    get SmoothingMode(): SmoothingMode;
    set SmoothingMode(value: SmoothingMode);
    get IsClipEmpty(): boolean;
    get PixelOffsetMode(): PixelOffsetMode;
    set PixelOffsetMode(value: PixelOffsetMode);
    get Clip(): Region;
    set Clip(value: Region);
    get ClipBounds(): CGRectangle;
    set ClipBounds(value: CGRectangle);
    get VisibleClipBounds(): CGRectangle;
    set VisibleClipBounds(value: CGRectangle);
    get InterpolationMode(): InterpolationMode;
    set InterpolationMode(value: InterpolationMode);
    get RenderingOrigin(): CGPoint;
    set RenderingOrigin(value: CGPoint);
    get TextContrast(): number;
    set TextContrast(value: number);
    get DpiX(): float;
    get DpiY(): float;
    get CompositingQuality(): CompositingQuality;
    get isVisibleClipEmpty(): boolean;
    translateClip(dx: float, dy: float): void;
    resetClip(): void;
    resetNativeClip(): void;
    excludeClip(region: Region): void;
    excludeClip(rect: CGRectangle): void;
    intersectClip(region: Region): void;
    intersectClip(rect: CGRectangle): void;
    clear(color?: CGColor): void;
    restore(gstate?: GraphicsState): void;
    save(): GraphicsState;
    drawClosedCurve(pen: Pen, points: CGPoint[]): void;
    drawClosedCurve(pen: Pen, points: CGPoint[], tension: float, fillmode: FillMode): void;
    fillClosedCurve(brush: Brush, points: CGPoint[], fillmode: FillMode, tension: float): void;
    fillClosedCurve(brush: Brush, points: CGPoint[]): void;
    drawPie(pen: Pen, x: float, y: float, width: float, height: float, startAngle: float, sweepAngle: float): void;
    drawPie(pen: Pen, rect: CGRectangle, startAngle: float, sweepAngle: float): void;
    fillPie(brush: Brush, rect: CGRectangle, startAngle: float, sweepAngle: float): void;
    fillPie(brush: Brush, x: float, y: float, width: float, height: float, startAngle: float, sweepAngle: float): void;
    drawPolygon(pen: Pen, points: CGPoint[]): void;
    fillPolygon(brush: Brush, points: CGPoint[], fillMode: FillMode): void;
    fillPolygon(brush: Brush, points: CGPoint[]): void;
    drawRectangles(pen: Pen, rects: CGRectangle[]): void;
    fillRectangles(brush: Brush, rects: CGRectangle[]): void;
    flush(intention: FlushIntention): void;
    flush(): void;
    isVisible(x: float, y: float, width: float, height: float): boolean;
    isVisible(x: float, y: float): boolean;
    isVisible(rect: CGRectangle): boolean;
    isVisible(point: CGPoint): boolean;
    multiplyTransform(matrix: Matrix): void;
    multiplyTransform(matrix: Matrix, order: MatrixOrder): void;
    transformPoints(destSpace: CoordinateSpace, srcSpace: CoordinateSpace, pts: CGPoint[]): void;
    drawEllipticalArc(x: float, y: float, width: float, height: float, lambda1: float, lambda2: float, isPieSlice: boolean): void;
    drawEllipticalArc(arcRect: CGRectangle, lambda1: float, lambda2: float, isPieSlice: boolean): void;
    measureCharacterRanges(text: string, font: Font, layoutRect: CGRectangle, stringFormat: StringFormat): Region[];
    protected abstract measureStringEx(textstring: string, font: Font): TextMetricsEx;
    MeasureString(text: string, font: Font): CGSize;
    MeasureString(text: string, font: Font, width: number): CGSize;
    MeasureString(text: string, font: Font, area: CGSize): CGSize;
    MeasureString(text: string, font: Font, point: CGPoint, stringFormat: StringFormat): CGSize;
    MeasureString(text: string, font: Font, area: CGSize, stringFormat: StringFormat): CGSize;
    MeasureString(text: string, font: Font, width: number, stringFormat: StringFormat): CGSize;
    MeasureString(text: string, font: Font, area: CGSize, format: StringFormat, charactersFitted: Out<number>, linesFilled: Out<number>): CGSize;
    drawString(s: string, font: Font, brush: Brush, x: float, y: float): void;
    drawString(s: string, font: Font, brush: Brush, x: float, y: float, format: StringFormat): void;
    drawString(s: string, font: Font, brush: Brush, point: CGPoint, format: StringFormat): void;
    drawString(s: string, font: Font, brush: Brush, x: float, y: float, format: StringFormat): void;
    drawString(s: string, font: Font, brush: Brush, layoutRectangle: CGRectangle, format: StringFormat): void;
    DrawImage(image: Image, rect: CGRectangle): void;
    DrawImage(image: Image, point: CGPoint): void;
    DrawImage(image: Image, destPoints: CGPoint[]): void;
    DrawImage(image: Image, x: int, y: int): void;
    DrawImage(image: Image, destRect: CGRectangle, srcRect: CGRectangle, srcUnit: GraphicsUnit): void;
    DrawImage(image: Image, destPoints: CGPoint[], srcRect: CGRectangle, srcUnit: GraphicsUnit): void;
    DrawImage(image: Image, destPoints: CGPoint[], srcRect: CGRectangle, srcUnit: GraphicsUnit, imageAttr: ImageAttributes): void;
    DrawImage(image: Image, x: float, y: float, width: float, height: float): void;
    drawImageBitmap(image: ImageBitmap, x: float, y: float): void;
    createRectangle(x: int, y: int, width: int, height: int): CGRectangle;
    createColor(r: byte, g: byte, b: byte): CGColor;
    createSolidBrush(r: byte, g: byte, b: byte): SolidBrush;
    createPen(r: byte, g: byte, b: byte, size?: int): Pen;
}
export abstract class CanvasGraphics<T extends IContext2D> extends GraphicsBase<T> {
    constructor();
    constructor(handle: IntPtr);
    constructor(width: number, height: number);
    constructor(width: number, height: number, pixelSize: int);
    constructor(left: number, top: number, width: number, height: number);
    constructor(context: CanvasRenderingContext2D, flipped?: boolean);
    constructor(context: CGContext2D, flipped?: boolean);
    abstract provideRenderer2D(): T;
    abstract provideRenderer2D(context: CanvasRenderingContext2D): T;
    setSize(width: int, height: int): void;
    init(): void;
    getContext(): CanvasRenderingContext2D;
    getCanvas(): HTMLCanvasElement;
    measureStringEx(textstring: string, font: Font): TextMetricsEx;
    static fromCurrentContext(): Graphics;
}
export interface IDeviceContext {
    GetHdc(): IntPtr;
    ReleaseHdc(): void;
}
export class Graphics extends CanvasGraphics<CGContext2D> implements IDeviceContext {
    static FromImage(image: Image): Graphics;
    GetHdc(): IntPtr;
    static FromHwnd(handle: IntPtr): Graphics;
    ReleaseHdc(): void;
    init(): void;
    provideRenderer2D(): CGContext2D;
    provideRenderer2D(canvasContext: CanvasRenderingContext2D): CGContext2D;
    static fromCurrentContext(): Graphics;
}
export class CommandGraphics extends GraphicsBase<CGCommandContext2D> {
    constructor();
    protected measureStringEx(textstring: string, font: Font): TextMetricsEx;
    provideRenderer2D(): CGCommandContext2D;
    init(): void;
}
export class OffScreenGraphics extends GraphicsBase<CGContext2D> {
    constructor(width: int, height: int);
    protected measureStringEx(textstring: string, font: Font): TextMetricsEx;
    provideRenderer2D(): CGContext2D;
    provideRenderer2D(canvasContext: any): CGContext2D;
    init(): void;
    TrasferToImageBitmap(): ImageBitmap;
}

export enum CurveType {
    Open = 0,
    Close = 1
}
type byte = number;
export const CURVE_MIN_TERMS: number;
export const CURVE_MAX_TERMS: number;
export class GraphicsPath implements ICloneable<GraphicsPath>, IDisposable {
    points: List<CGPoint>;
    types: List<byte>;
    isReverseWindingOnFill: boolean;
    get PathPoints(): CGPoint[];
    get PathTypes(): byte[];
    get PointCount(): number;
    get PathData(): PathData;
    get FillMode(): FillMode;
    set FillMode(value: FillMode);
    get IsEmpty(): boolean;
    constructor();
    constructor(fillMode: FillMode);
    constructor(pts: CGPoint[], types: byte[], fillMode: FillMode);
    addClosedCurve(points: CGPoint[]): void;
    addClosedCurve(points: CGPoint[], tension: float): void;
    addCurve(points: CGPoint[]): void;
    addCurve(points: CGPoint[], tension: float): void;
    addCurve(points: CGPoint[], offset: number, numberOfSegments: number, tension: float): void;
    addPolygon(points: CGPoint[]): void;
    startFigure(): void;
    closeFigure(): void;
    addEllipse(rect: CGRectangle): void;
    addEllipse(x: float, y: float, width: float, height: float): void;
    addLine(pt1: CGPoint, pt2: CGPoint): void;
    addLine(x1: float, y1: float, x2: float, y2: float): void;
    addLines(points: CGPoint[]): void;
    addRectangle(rect: CGRectangle): void;
    addRectangles(rects: CGRectangle[]): void;
    addPie(x: float, y: float, width: float, height: float, startAngle: float, sweepAngle: float): void;
    addArc(rect: CGRectangle, start_angle: float, sweep_angle: float): void;
    addArc(x: float, y: float, width: float, height: float, start_angle: float, sweep_angle: float): void;
    addBezier(pt1: CGPoint, pt2: CGPoint, pt3: CGPoint, pt4: CGPoint): void;
    addBezier(x1: float, y1: float, x2: float, y2: float, x3: float, y3: float, x4: float, y4: float): void;
    addBeziers(points: CGPoint[]): void;
    addPath(addingPath: GraphicsPath, connect: boolean): void;
    closeAllFigures(): void;
    getLastPoint(): CGPoint;
    getBounds(): CGRectangle;
    getBounds(matrix: Matrix): CGRectangle;
    getBounds(matrix: Matrix, pen: Pen): CGRectangle;
    static PathHasCurve(path: GraphicsPath): boolean;
    isVisible(point: CGPoint): boolean;
    isVisible(point: CGPoint, graphics: Graphics): boolean;
    isVisible(x: float, y: float): boolean;
    isOutlineVisible(pt: CGPoint, pen: Pen, graphics: Graphics): boolean;
    flatten(): void;
    flatten(matrix: Matrix): void;
    flatten(matrix: Matrix, flatness: float): void;
    reset(): void;
    reverse(): void;
    setMarkers(): void;
    clearMarkers(): void;
    transform(matrix: Matrix): void;
    widen(pen: Pen, matrix: Matrix, flatness?: float): void;
    Dispose(): void;
    Clone(): GraphicsPath;
}
export {};

export enum RegionType {
    Rectangle = 10000,
    Infinity = 10001,
    Empty = 10002,
    Path = 10003
}
export enum RegionClipType {
    Intersection = 0,
    Union = 1,
    Difference = 2,
    Xor = 3,
    None = -1
}
class RegionEntry {
    regionType: RegionType;
    regionObject: any;
    regionPath: Paths;
    regionClipType: RegionClipType;
    constructor1(type: RegionType): void;
    constructor2(type: RegionType, obj: any): void;
    constructor3(type: RegionType, obj: any, path: Path): void;
    constructor();
    constructor(type: RegionType, obj: any, path: Path, clipType: RegionClipType);
    constructor(type: RegionType, obj: any, path: Paths, clipType: RegionClipType);
}
export class Region {
    static infinite: CGRectangle;
    regionObject: any;
    regionList: List<RegionEntry>;
    regionPath: GraphicsPath;
    regionBounds: CGRectangle;
    solution: Paths;
    constructor(region: Region);
    constructor(path: GraphicsPath);
    constructor(rect: CGRectangle);
    constructor();
    static PointFArrayToIntArray(points: CGPoint[], scale: float): Path;
    static PathToPointFArray(pg: Path, scale: float): CGPoint[];
    equals(region: Region, g: Graphics): boolean;
    clone(): Region;
    static Copy(src: Paths): Paths;
    static Copy1(src: List<RegionEntry>): List<RegionEntry>;
    static CopyRegionObject(src: CGRectangle | GraphicsPath): CGRectangle | GraphicsPath;
    getBounds(): CGRectangle;
    getBounds(g: Graphics): CGRectangle;
    makeInfinite(): void;
    makeEmpty(): void;
    transform(matrix: Matrix): void;
    translate(dx: float, dy: float): void;
    intersect(path: GraphicsPath): void;
    intersect(region: Region): void;
    intersect(rect: CGRectangle): void;
    dispose(): void;
    union(rect: CGRectangle): void;
    union(region: Region): void;
    union(path: GraphicsPath): void;
    xor(rect: CGRectangle): void;
    xor(region: Region): void;
    xor(path: GraphicsPath): void;
    exclude(rect: CGRectangle): void;
    exclude(region: Region): void;
    exclude(path: GraphicsPath): void;
    isInfinite(g: Graphics): boolean;
    isVisible(x: float, y: float): boolean;
    isVisible(point: CGPoint): boolean;
    isEmpty(g: Graphics): boolean;
    getRegionScans(matrix: Matrix): CGRectangle[];
}
export {};

export class Pen implements IDisposable, ICloneable<Pen> {
    constructor(brush: Brush);
    constructor(color: CGColor);
    constructor(brush: Brush, width: float);
    constructor(color: CGColor, width: float);
    get DashCap(): DashCap;
    set DashCap(value: DashCap);
    get Brush(): Brush;
    set Brush(value: Brush);
    get Color(): CGColor;
    set Color(value: CGColor);
    Dispose(): void;
    Dispose(disposing: boolean): void;
    Clone(): Pen;
    get Width(): float;
    set Width(value: float);
    get Transform(): Matrix;
    set Transform(value: Matrix);
    get StartCap(): LineCap;
    set StartCap(value: LineCap);
    get EndCap(): LineCap;
    set EndCap(value: LineCap);
    get DashStyle(): DashStyle;
    set DashStyle(value: DashStyle);
    get DashOffset(): number;
    set DashOffset(value: number);
    get DashPattern(): float[];
    set DashPattern(value: float[]);
    setLineCap(startCap: LineCap, endCap: LineCap, dashCap: DashCap): void;
    get LineJoin(): LineJoin;
    set LineJoin(value: LineJoin);
    get MiterLimit(): float;
    set MiterLimit(value: float);
    get Alignment(): PenAlignment;
    set Alignment(value: PenAlignment);
    get PenType(): PenTypes;
    Shadow: Shadow;
}

export class Brush implements IDisposable, ICloneable<Brush> {
    protected changed: boolean;
    Shadow: Shadow;
    Dispose(): void;
    Clone(): Brush;
    setup(graphics: Graphics, fill: boolean): void;
}

export class Font extends CGFont {
    get Height(): int;
    constructor(fontFamily: /* opentype.Font | */ FontFamily | string, size: float);
    setup(graphics: IContext2D): void;
    protected _prepContext(ctx: any): any;
    getHeight(): number;
    getTextWidth(text: string): number;
    equals(font: Font): boolean;
    GetCellAscent(): float;
    GetHeight(): float;
}

export class Icon {
    toBitmap(): CGImage;
}

export class Bitmap extends Image {
    constructor();
    constructor(ptr: IntPtr);
    constructor(ptr: IntPtr, stream: Stream);
    constructor(width: int, height: int);
    constructor(width: int, height: int, g: Graphics);
    constructor(width: int, height: int, format: PixelFormat);
    constructor(original: Image);
    constructor(stream: Stream);
    constructor(filename: string);
    constructor(original: Image, newSize: CGSize);
    constructor(stream: Stream, useIcm: boolean);
    constructor(filename: string, useIcm: boolean);
    constructor(type: Type, resource: string);
    constructor(original: Image, width: int, height: int);
    constructor1(): void;
    constructor2(ptr: IntPtr): void;
    constructor3(ptr: IntPtr, stream: Stream): void;
    constructor4(width: int, height: int): void;
    constructor5(width: int, height: int, g: Graphics): void;
    constructor6(width: int, height: int, format: PixelFormat): void;
    constructor7(original: Image): void;
    constructor8(stream: Stream): void;
    constructor9(filename: string): void;
    constructor10(original: Image, newSize: CGSize): void;
    constructor11(stream: Stream, useIcm: boolean): void;
    constructor12(filename: string, useIcm: boolean): void;
    constructor13(type: Type, resource: string): void;
    constructor14(original: Image, width: int, height: int): void;
    constructor15(width: int, height: int, stride: int, format: PixelFormat, scan0: IntPtr): void;
    GetPixel(x: int, y: int): CGColor;
    SetPixel(x: int, y: int, color: CGColor): void;
    Clone<Bitmap>(): Bitmap;
    Clone<Bitmap>(rect: CGRectangle, format: PixelFormat): Bitmap;
    static FromHicon(hicon: IntPtr): Bitmap;
    static FromResource(hinstance: IntPtr, bitmapName: string): Bitmap;
    GetHbitmap(): IntPtr;
    GetHbitmap(background: CGColor): IntPtr;
    GetHicon(): IntPtr;
    LockBits(rect: CGRectangle, flags: ImageLockMode, format: PixelFormat): BitmapData;
    LockBits(rect: CGRectangle, flags: ImageLockMode, format: PixelFormat, bitmapData: BitmapData): BitmapData;
    MakeTransparent(): void;
    MakeTransparent(transparentColor: CGColor): void;
    SetResolution(xDpi: float, yDpi: float): void;
    UnlockBits(bitmapdata: BitmapData): void;
}

export class GetThumbnailImageAbort extends Delegate<() => boolean> {
}
export abstract class Image {
    nativeObject: IntPtr;
    stream: Stream;
    static FromFile(filename: string): Image;
    static FromFile(filename: string, useEmbeddedColorManagement: boolean): Image;
    static FromHbitmap(hbitmap: IntPtr): Bitmap;
    static FromHbitmap(hbitmap: IntPtr, hpalette: IntPtr): Bitmap;
    static FromStream(stream: Stream): Image;
    static FromStream(stream: Stream, useEmbeddedColorManagement: boolean): Image;
    static FromStream(stream: Stream, useEmbeddedColorManagement: boolean, validateImageData: boolean): Image;
    static LoadFromStream(stream: Stream, keepAlive: boolean): Image;
    static CreateFromHandle(handle: IntPtr): Image;
    static GetPixelFormatSize(pixfmt: PixelFormat): int;
    static IsAlphaPixelFormat(pixfmt: PixelFormat): boolean;
    static IsCanonicalPixelFormat(pixfmt: PixelFormat): boolean;
    static IsExtendedPixelFormat(pixfmt: PixelFormat): boolean;
    static InitFromStream(stream: Stream): IntPtr;
    GetBounds(pageUnit: Out<GraphicsUnit>): CGRectangle;
    GetEncoderParameterList(encoder: Guid): EncoderParameters;
    GetFrameCount(dimension: FrameDimension): int;
    GetPropertyItem(propid: int): PropertyItem;
    GetThumbnailImage(thumbWidth: int, thumbHeight: int, callback: GetThumbnailImageAbort, callbackData: IntPtr): Image;
    RemovePropertyItem(propid: int): void;
    RotateFlip(rotateFlipType: RotateFlipType): void;
    findEncoderForFormat(format: ImageFormat): ImageCodecInfo;
    Save(filename: string): void;
    Save(filename: string, format: ImageFormat): void;
    Save(filename: string, encoder: ImageCodecInfo, encoderParams: EncoderParameters): void;
    Save(stream: Stream, format: ImageFormat): void;
    Save(stream: Stream, encoder: ImageCodecInfo, encoderParams: EncoderParameters): void;
    SaveAdd(encoderParams: EncoderParameters): void;
    SaveAdd(image: Image, encoderParams: EncoderParameters): void;
    SelectActiveFrame(dimension: FrameDimension, frameIndex: int): int;
    SetPropertyItem(propitem: PropertyItem): void;
    get Flags(): int;
    get FrameDimensionsList(): Guid[];
    get Height(): int;
    get HorizontalResolution(): float;
    get Palette(): ColorPalette;
    set Palette(value: ColorPalette);
    retrieveGDIPalette(): ColorPalette;
    storeGDIPalette(palette: ColorPalette): void;
    get PhysicalDimension(): CGSize;
    get PixelFormat(): PixelFormat;
    get PropertyIdList(): IntArray;
    get PropertyItems(): PropertyItem[];
    get RawFormat(): ImageFormat;
    get Size(): CGSize;
    Tag: any;
    get VerticalResolution(): float;
    get Width(): int;
    get NativeObject(): IntPtr;
    set NativeObject(value: IntPtr);
    Dispose(): void;
    protected dispose(disposing: boolean): void;
    Clone(): Image;
}

export class SolidBrush extends Brush {
    isModifiable: boolean;
    constructor(color: CGColor, isModifiable?: boolean);
    get Color(): CGColor;
    set Color(value: CGColor);
    Dispose(disposing?: boolean): void;
    Clone(): SolidBrush;
    setup(graphics: Graphics, fill: boolean): void;
    equals(sb: SolidBrush): boolean;
    getHashCode(): number;
}

export class Brushes {
    static Transparent: Brush;
    static AliceBlue: Brush;
    static AntiqueWhite: Brush;
    static Aqua: Brush;
    static Aquamarine: Brush;
    static Azure: Brush;
    static Beige: Brush;
    static Bisque: Brush;
    static Black: Brush;
    static BlanchedAlmond: Brush;
    static Blue: Brush;
    static BlueViolet: Brush;
    static Brown: Brush;
    static BurlyWood: Brush;
    static CadetBlue: Brush;
    static Chartreuse: Brush;
    static Chocolate: Brush;
    static Coral: Brush;
    static CornflowerBlue: Brush;
    static Cornsilk: Brush;
    static Crimson: Brush;
    static Cyan: Brush;
    static DarkBlue: Brush;
    static DarkCyan: Brush;
    static DarkGoldenrod: Brush;
    static DarkGray: Brush;
    static DarkGreen: Brush;
    static DarkKhaki: Brush;
    static DarkMagenta: Brush;
    static DarkOliveGreen: Brush;
    static DarkOrange: Brush;
    static DarkOrchid: Brush;
    static DarkRed: Brush;
    static DarkSalmon: Brush;
    static DarkSeaGreen: Brush;
    static DarkSlateBlue: Brush;
    static DarkSlateGray: Brush;
    static DarkTurquoise: Brush;
    static DarkViolet: Brush;
    static DeepPink: Brush;
    static DeepSkyBlue: Brush;
    static DimGray: Brush;
    static DodgerBlue: Brush;
    static Firebrick: Brush;
    static FloralWhite: Brush;
    static ForestGreen: Brush;
    static Fuchsia: Brush;
    static Gainsboro: Brush;
    static GhostWhite: Brush;
    static Gold: Brush;
    static Goldenrod: Brush;
    static Gray: Brush;
    static Green: Brush;
    static GreenYellow: Brush;
    static Honeydew: Brush;
    static HotPink: Brush;
    static IndianRed: Brush;
    static Indigo: Brush;
    static Ivory: Brush;
    static Khaki: Brush;
    static Lavender: Brush;
    static LavenderBlush: Brush;
    static LawnGreen: Brush;
    static LemonChiffon: Brush;
    static LightBlue: Brush;
    static LightCoral: Brush;
    static LightCyan: Brush;
    static LightGoldenrodYellow: Brush;
    static LightGreen: Brush;
    static LightGray: Brush;
    static LightPink: Brush;
    static LightSalmon: Brush;
    static LightSeaGreen: Brush;
    static LightSkyBlue: Brush;
    static LightSlateGray: Brush;
    static LightSteelBlue: Brush;
    static LightYellow: Brush;
    static Lime: Brush;
    static LimeGreen: Brush;
    static Linen: Brush;
    static Magenta: Brush;
    static Maroon: Brush;
    static MediumAquamarine: Brush;
    static MediumBlue: Brush;
    static MediumOrchid: Brush;
    static MediumPurple: Brush;
    static MediumSeaGreen: Brush;
    static MediumSlateBlue: Brush;
    static MediumSpringGreen: Brush;
    static MediumTurquoise: Brush;
    static MediumVioletRed: Brush;
    static MidnightBlue: Brush;
    static MintCream: Brush;
    static MistyRose: Brush;
    static Moccasin: Brush;
    static NavajoWhite: Brush;
    static Navy: Brush;
    static OldLace: Brush;
    static Olive: Brush;
    static OliveDrab: Brush;
    static Orange: Brush;
    static OrangeRed: Brush;
    static Orchid: Brush;
    static PaleGoldenrod: Brush;
    static PaleGreen: Brush;
    static PaleTurquoise: Brush;
    static PaleVioletRed: Brush;
    static PapayaWhip: Brush;
    static PeachPuff: Brush;
    static Peru: Brush;
    static Pink: Brush;
    static Plum: Brush;
    static PowderBlue: Brush;
    static Purple: Brush;
    static Red: Brush;
    static RosyBrown: Brush;
    static RoyalBlue: Brush;
    static SaddleBrown: Brush;
    static Salmon: Brush;
    static SandyBrown: Brush;
    static SeaGreen: Brush;
    static SeaShell: Brush;
    static Sienna: Brush;
    static Silver: Brush;
    static SkyBlue: Brush;
    static SlateBlue: Brush;
    static SlateGray: Brush;
    static Snow: Brush;
    static SpringGreen: Brush;
    static SteelBlue: Brush;
    static Tan: Brush;
    static Teal: Brush;
    static Thistle: Brush;
    static Tomato: Brush;
    static Turquoise: Brush;
    static Violet: Brush;
    static Wheat: Brush;
    static White: Brush;
    static WhiteSmoke: Brush;
    static Yellow: Brush;
    static YellowGreen: Brush;
}

export class Pens {
    static get Transparent(): Pen;
    static get AliceBlue(): Pen;
    static get AntiqueWhite(): Pen;
    static get Aqua(): Pen;
    static get Aquamarine(): Pen;
    static get Azure(): Pen;
    static get Beige(): Pen;
    static get Bisque(): Pen;
    static get Black(): Pen;
    static get BlanchedAlmond(): Pen;
    static get Blue(): Pen;
    static get BlueViolet(): Pen;
    static get Brown(): Pen;
    static get BurlyWood(): Pen;
    static get CadetBlue(): Pen;
    static get Chartreuse(): Pen;
    static get Chocolate(): Pen;
    static get Coral(): Pen;
    static get CornflowerBlue(): Pen;
    static get Cornsilk(): Pen;
    static get Crimson(): Pen;
    static get Cyan(): Pen;
    static get DarkBlue(): Pen;
    static get DarkCyan(): Pen;
    static get DarkGoldenrod(): Pen;
    static get DarkGray(): Pen;
    static get DarkGreen(): Pen;
    static get DarkKhaki(): Pen;
    static get DarkMagenta(): Pen;
    static get DarkOliveGreen(): Pen;
    static get DarkOrange(): Pen;
    static get DarkOrchid(): Pen;
    static get DarkRed(): Pen;
    static get DarkSalmon(): Pen;
    static get DarkSeaGreen(): Pen;
    static get DarkSlateBlue(): Pen;
    static get DarkSlateGray(): Pen;
    static get DarkTurquoise(): Pen;
    static get DarkViolet(): Pen;
    static get DeepPink(): Pen;
    static get DeepSkyBlue(): Pen;
    static get DimGray(): Pen;
    static get DodgerBlue(): Pen;
    static get Firebrick(): Pen;
    static get FloralWhite(): Pen;
    static get ForestGreen(): Pen;
    static get Fuchsia(): Pen;
    static get Gainsboro(): Pen;
    static get GhostWhite(): Pen;
    static get Gold(): Pen;
    static get Goldenrod(): Pen;
    static get Gray(): Pen;
    static get Green(): Pen;
    static get GreenYellow(): Pen;
    static get Honeydew(): Pen;
    static get HotPink(): Pen;
    static get IndianRed(): Pen;
    static get Indigo(): Pen;
    static get Ivory(): Pen;
    static get Khaki(): Pen;
    static get Lavender(): Pen;
    static get LavenderBlush(): Pen;
    static get LawnGreen(): Pen;
    static get LemonChiffon(): Pen;
    static get LightBlue(): Pen;
    static get LightCoral(): Pen;
    static get LightCyan(): Pen;
    static get LightGoldenrodYellow(): Pen;
    static get LightGreen(): Pen;
    static get LightGray(): Pen;
    static get LightPink(): Pen;
    static get LightSalmon(): Pen;
    static get LightSeaGreen(): Pen;
    static get LightSkyBlue(): Pen;
    static get LightSlateGray(): Pen;
    static get LightSteelBlue(): Pen;
    static get LightYellow(): Pen;
    static get Lime(): Pen;
    static get LimeGreen(): Pen;
    static get Linen(): Pen;
    static get Magenta(): Pen;
    static get Maroon(): Pen;
    static get MediumAquamarine(): Pen;
    static get MediumBlue(): Pen;
    static get MediumOrchid(): Pen;
    static get MediumPurple(): Pen;
    static get MediumSeaGreen(): Pen;
    static get MediumSlateBlue(): Pen;
    static get MediumSpringGreen(): Pen;
    static get MediumTurquoise(): Pen;
    static get MediumVioletRed(): Pen;
    static get MidnightBlue(): Pen;
    static get MintCream(): Pen;
    static get MistyRose(): Pen;
    static get Moccasin(): Pen;
    static get NavajoWhite(): Pen;
    static get Navy(): Pen;
    static get OldLace(): Pen;
    static get Olive(): Pen;
    static get OliveDrab(): Pen;
    static get Orange(): Pen;
    static get OrangeRed(): Pen;
    static get Orchid(): Pen;
    static get PaleGoldenrod(): Pen;
    static get PaleGreen(): Pen;
    static get PaleTurquoise(): Pen;
    static get PaleVioletRed(): Pen;
    static get PapayaWhip(): Pen;
    static get PeachPuff(): Pen;
    static get Peru(): Pen;
    static get Pink(): Pen;
    static get Plum(): Pen;
    static get PowderBlue(): Pen;
    static get Purple(): Pen;
    static get Red(): Pen;
    static get RosyBrown(): Pen;
    static get RoyalBlue(): Pen;
    static get SaddleBrown(): Pen;
    static get Salmon(): Pen;
    static get SandyBrown(): Pen;
    static get SeaGreen(): Pen;
    static get SeaShell(): Pen;
    static get Sienna(): Pen;
    static get Silver(): Pen;
    static get SkyBlue(): Pen;
    static get SlateBlue(): Pen;
    static get SlateGray(): Pen;
    static get Snow(): Pen;
    static get SpringGreen(): Pen;
    static get SteelBlue(): Pen;
    static get Tan(): Pen;
    static get Teal(): Pen;
    static get Thistle(): Pen;
    static get Tomato(): Pen;
    static get Turquoise(): Pen;
    static get Violet(): Pen;
    static get Wheat(): Pen;
    static get White(): Pen;
    static get WhiteSmoke(): Pen;
    static get Yellow(): Pen;
    static get YellowGreen(): Pen;
}

export enum FillMode {
    Alternate = 0,
    Winding = 1
}

export class PrintDocument {
    DocumentName: string;
    DefaultPageSettings: PageSettings;
    print(): void;
}

export class PageSettings {
    PrinterSettings: any;
}

export class PrintPageEventArgs extends EventArgs {
    MarginBounds: CGRectangle;
    Graphics: Graphics;
    PageSettings: PageSettings;
    HasMorePages: boolean;
}

export class PrintPageEventHandler extends Delegate<(sender: any, e: PrintPageEventArgs) => void> {
}

export class HitTester {
    constructor(graphicsPath: GraphicsPath);
    test(point: CGPoint): boolean;
}

export class GeomUtilities {
        static ComputeOrientationLine(rect: CGRectangle, angle: float, start: Out<CGPoint>, end: Out<CGPoint>): void;
        static ToRadians(degrees: float): float;
        static Lerp(value1: float, value2: float, amount: float): float;
        static SigmaBellShape(focus: float, scale: float): Blend;
        static Phi(x: float): float;
        static Erf(x: float): float;
        static CreateGeometricTransform(rect: CGRectangle, points: CGPoint[]): CGAffineTransform;
        static CreateRotateFlipTransform(width: Out<number>, height: Out<number>, angle: float, flipX: boolean, flipY: boolean): CGAffineTransform;
        static TransformRectangle(rectangle: Out<CGRectangle>, matrix: Matrix): void;
        static GetCurveTangents(terms: number, points: CGPoint[], count: number, tension: float, type: CurveType): CGPoint[];
        static QuadraticToCubic(start: CGPoint, controlPoint: CGPoint, end: CGPoint, controlPoint1: Out<CGPoint>, controlPoint2: Out<CGPoint>): void;
        static DotProduct(u: CGPoint, v: CGPoint): float;
        static Normal(v: CGPoint): float;
        static CrossProduct(v1: CGPoint, v2: CGPoint): float;
        static TriangleBoundingBox(points: CGPoint[]): CGRectangle;
        static PolygonBoundingBox(points: CGPoint[]): CGRectangle;
        static PolygonCentroid(points: CGPoint[]): CGPoint;
        static PolygonArea(points: CGPoint[]): float;
        static InflateRect(a: Out<CGRectangle>, w: float, h: float): void;
        static IntersectionRect(a: CGRectangle, b: CGRectangle): CGRectangle;
        static ContainsRect(a: CGRectangle, b: CGPoint): boolean;
        static ContainsRect(a: CGRectangle, b: CGRectangle): boolean;
        static IntersectsLineSegment(rect: CGRectangle, p1: CGPoint, p2: CGPoint): boolean;
        static IntersectsRect(a: CGRectangle, b: CGRectangle): boolean;
        static ComparePointWithLine(a1: CGPoint, a2: CGPoint, p: CGPoint): number;
        static IntersectingLines(a1: CGPoint, a2: CGPoint, b1: CGPoint, b2: CGPoint): boolean;
        static LineBounds(a: CGPoint, b: CGPoint): CGRectangle;
        static LineContainsPoint(a: CGPoint, b: CGPoint, fuzz: float, p: CGPoint): boolean;
        static NearestIntersectionOnLine(a: CGPoint, b: CGPoint, p: CGPoint, q: CGPoint, result: Out<CGPoint>): boolean;
        static RectFromLine(a: CGPoint, b: CGPoint, w: float): CGRectangle;
        static NearestPointOnLine(a: CGPoint, b: CGPoint, p: CGPoint, result: Out<CGPoint>): boolean;
        static GetNearestIntersectionPoint(rect: CGRectangle, p1: CGPoint, p2: CGPoint, result: Out<CGPoint>): boolean;
        static LargestSizeKeepingAspectRatio(target: CGSize, aspect: CGSize): CGSize;
        static MakeRect(x: float): CGRectangle;
        static MakeRect(p: CGPoint): CGRectangle;
        static MakeRect(s: CGSize): CGRectangle;
        static UnionRect(a: CGRectangle, b: CGRectangle): CGRectangle;
        static UnionRect(r: CGRectangle, p: CGPoint): CGRectangle;
        static BezierBounds(s: CGPoint, c1: CGPoint, c2: CGPoint, e: CGPoint, epsilon: number): CGRectangle;
        static BezierContainsPoint(s: CGPoint, c1: CGPoint, c2: CGPoint, e: CGPoint, epsilon: number, p: CGPoint): boolean;
        static BezierMidPoint(b0: CGPoint, b1: CGPoint, b2: CGPoint, b3: CGPoint, v: Out<CGPoint>, w: Out<CGPoint>): void;
        static BezierNearestIntersectionOnLine(s: CGPoint, c1: CGPoint, c2: CGPoint, e: CGPoint, p1: CGPoint, p2: CGPoint, epsilon: number, /*out*/ result: Out<CGPoint>): boolean;
        static RescalePoints(v: CGPoint[], oldr: CGRectangle, newr: CGRectangle): void;
        static ExpandPointOnEdge(p: CGPoint, rect: CGRectangle, shift: float): CGPoint;
        static TranslatePoints(v: CGPoint[], dx: number, dy: number): void;
        static GetAngle(x: number, y: number): number;
        static NearestIntersectionOnArc(rect: CGRectangle, p1: CGPoint, p2: CGPoint, result: Out<CGPoint>, startAngle: float, sweepAngle: float): boolean;
        static NearestIntersectionOnEllipse(rect: CGRectangle, p1: CGPoint, p2: CGPoint, result: Out<CGPoint>): boolean;
        /**
            * Get surrounding rectangle of  given rect with angle.
            * @param angleInDeg
            * @param rect
            */
        static GetSurroundingRectangle(angleInDeg: float, rect: CGRectangle): CGPoint[];
        static CheckLineIntersection(line1StartX: number, line1StartY: number, line1EndX: number, line1EndY: number, line2StartX: number, line2StartY: number, line2EndX: number, line2EndY: number): any;
}

export const GraphicTypes: {
    Bitmap: symbol;
    GdipEncoderParameter: symbol;
    Region: symbol;
    Image: symbol;
    ImageList: symbol;
    StringFormat: symbol;
    Font: symbol;
    Graphics: symbol;
    GraphicsBase: symbol;
    ColorMatrix: symbol;
    SolidBrush: symbol;
    Brush: symbol;
    LinearGradientBrush: symbol;
    PathGradientBrush: symbol;
    GraphicsPath: symbol;
    HatchBrush: symbol;
    Icon: symbol;
    Pen: symbol;
    TextureBrush: symbol;
    RadialGradientBrush: symbol;
    PaintEventArgs: symbol;
    Imaging: {
        ImageAttributes: symbol;
        FrameDimension: symbol;
    };
    geom: {
        Shape: symbol;
        Point2D: symbol;
        Line2D: symbol;
        Rectangle2D: symbol;
        AffineTransform: symbol;
    };
    Application: symbol;
    Tgx: {
        graphics: {
            Color: symbol;
            Pixmap: symbol;
        };
        files: {
            FileHandle: symbol;
        };
        backend: {
            preloader: {
                Preloader: symbol;
            };
        };
        utils: {
            ObjectMap: {
                Keys: symbol;
                Values: symbol;
                Entries: symbol;
                MapIterator: symbol;
                ObjectMap: symbol;
                Entry: symbol;
            };
            IntArray: symbol;
            Array: symbol;
        };
    };
};

export enum LineJoin {
    Miter = 0,
    Bevel = 1,
    Round = 2,
    MiterClipped = 3
}

export enum LineCap {
    Flat = 0,
    Square = 1,
    Round = 2,
    Triangle = 3,
    NoAnchor = 16,
    SquareAnchor = 17,
    RoundAnchor = 18,
    DiamondAnchor = 19,
    ArrowAnchor = 20,
    Custom = 255,
    AnchorMask = 240
}

export enum DashStyle {
    Solid = 0,
    Dash = 1,
    Dot = 2,
    DashDot = 3,
    DashDotDot = 4,
    Custom = 5
}

export enum MatrixOrder {
    Prepend = 0,
    Append = 1
}
export class Matrix implements IDisposable {
    transform: CGAffineTransform;
    constructor();
    constructor(transform: CGAffineTransform);
    constructor(rect: CGRectangle, plgpts: CGPoint[]);
    constructor(m11: float, m12: float, m21: float, m22: float, dx: float, dy: float);
    get Elements(): float[];
    get IsIdentity(): boolean;
    get IsInvertible(): boolean;
    get OffsetX(): float;
    get OffsetY(): float;
    get IsScaled(): boolean;
    clone(): Matrix;
    Dispose(): void;
    equals(m: Matrix): boolean;
    getHashCode(): number;
    invert(): void;
    multiply(matrix: Matrix): void;
    multiply(matrix: Matrix, order: MatrixOrder): void;
    reset(): void;
    rotate(angle: float): void;
    rotate(angle: float, order: MatrixOrder): void;
    rotateAt(angle: float, point: CGPoint): void;
    rotateAt(angle: float, point: CGPoint, order: MatrixOrder): void;
    scale(scaleX: float, scaleY: float): void;
    scale(scaleX: float, scaleY: float, order: MatrixOrder): void;
    shear(shearX: float, shearY: float): void;
    shear(shearX: float, shearY: float, order: MatrixOrder): void;
    transformPoints(pts: CGPoint[]): void;
    transformVectors(pts: CGPoint[]): void;
    translate(offsetX: float, offsetY: float): void;
    translate(offsetX: float, offsetY: float, order: MatrixOrder): void;
    vectorTransformPoints(pts: CGPoint[]): void;
}

export class ImageList extends List<CGImage> {
}

export interface ColorMatrixConfig {
    matrix00: float;
    matrix01: float;
    matrix02: float;
    matrix03: float;
    matrix04: float;
    matrix10: float;
    matrix11: float;
    matrix12: float;
    matrix13: float;
    matrix14: float;
    matrix20: float;
    matrix21: float;
    matrix22: float;
    matrix23: float;
    matrix24: float;
    matrix30: float;
    matrix31: float;
    matrix32: float;
    matrix33: float;
    matrix34: float;
    matrix40: float;
    matrix41: float;
    matrix42: float;
    matrix43: float;
    matrix44: float;
}
export class ColorMatrix {
    get Matrix00(): float;
    set Matrix00(value: float);
    get Matrix01(): float;
    set Matrix01(value: float);
    get Matrix02(): float;
    set Matrix02(value: float);
    get Matrix03(): float;
    set Matrix03(value: float);
    get Matrix04(): float;
    set Matrix04(value: float);
    get Matrix10(): float;
    set Matrix10(value: float);
    get Matrix11(): float;
    set Matrix11(value: float);
    get Matrix12(): float;
    set Matrix12(value: float);
    get Matrix13(): float;
    set Matrix13(value: float);
    get Matrix14(): float;
    set Matrix14(value: float);
    get Matrix20(): float;
    set Matrix20(value: float);
    get Matrix21(): float;
    set Matrix21(value: float);
    get Matrix22(): float;
    set Matrix22(value: float);
    get Matrix23(): float;
    set Matrix23(value: float);
    get Matrix24(): float;
    set Matrix24(value: float);
    get Matrix30(): float;
    set Matrix30(value: float);
    get Matrix31(): float;
    set Matrix31(value: float);
    get Matrix32(): float;
    set Matrix32(value: float);
    get Matrix33(): float;
    set Matrix33(value: float);
    get Matrix34(): float;
    set Matrix34(value: float);
    get Matrix40(): float;
    set Matrix40(value: float);
    get Matrix41(): float;
    set Matrix41(value: float);
    get Matrix42(): float;
    set Matrix42(value: float);
    get Matrix43(): float;
    set Matrix43(value: float);
    get Matrix44(): float;
    set Matrix44(value: float);
    constructor(newColorMatrix: float[][]);
    constructor(config?: ColorMatrixConfig);
    get(row: number, column: number): float;
    set(row: number, column: number, value: float): void;
}

export class GraphicsState {
    lastPen: Pen;
    lastBrush: Brush;
    model: Matrix;
    view: Matrix;
    renderingOrigin: CGPoint;
    pageUnit: GraphicsUnit;
    pageScale: float;
    smoothingMode: SmoothingMode;
    clipRegion: Region;
}

export enum CompositingQuality {
    Invalid = -1,
    Default = 0,
    HighSpeed = 1,
    HighQuality = 2,
    GammaCorrected = 3,
    AssumeLinear = 4
}

export enum InterpolationMode {
    Invalid = -1,
    Default = 0,
    Low = 1,
    High = 2,
    Bilinear = 3,
    Bicubic = 4,
    NearestNeighbor = 5,
    HighQualityBilinear = 6,
    HighQualityBicubic = 7
}

export enum SmoothingMode {
    Invalid = -1,
    Default = 0,
    HighSpeed = 1,
    HighQuality = 2,
    None = 3,
    AntiAlias = 4
}
export enum TextRenderingHint {
    SystemDefault = 0,
    SingleBitPerPixelGridFit = 1,
    SingleBitPerPixel = 2,
    AntiAliasGridFit = 3,
    AntiAlias = 4,
    ClearTypeGridFit = 5
}

export class PathGradientBrush extends Brush {
    get Blend(): Blend;
    set Blend(value: Blend);
    get CenterColor(): CGColor;
    set CenterColor(value: CGColor);
    get CenterPoint(): CGPoint;
    set CenterPoint(value: CGPoint);
    get FocusScales(): CGPoint;
    set FocusScales(value: CGPoint);
    get InterpolationColors(): ColorBlend;
    set InterpolationColors(value: ColorBlend);
    get Rectangle(): CGRectangle;
    get SurroundColors(): CGColor[];
    set SurroundColors(value: CGColor[]);
    get Transform(): Matrix;
    set Transform(value: Matrix);
    get WrapMode(): WrapMode;
    set WrapMode(value: WrapMode);
    constructor(points: CGPoint[], wrapMode: WrapMode);
    constructor(path: GraphicsPath);
    multiplyTransform(matrix: Matrix): void;
    multiplyTransform(matrix: Matrix, order: MatrixOrder): void;
    resetTransform(): void;
    rotateTransform(angle: float): void;
    rotateTransform(angle: float, order: MatrixOrder): void;
    scaleTransform(sx: float, sy: float): void;
    scaleTransform(sx: float, sy: float, order: MatrixOrder): void;
    translateTransform(dx: float, dy: float): void;
    translateTransform(dx: float, dy: float, order: MatrixOrder): void;
    setBlendTriangularShape(focus: float, scale?: float): void;
    setSigmaBellShape(focus: float, scale?: float): void;
    Clone(): PathGradientBrush;
    setup(graphics: Graphics, fill: boolean): void;
    equals(obj: PathGradientBrush): boolean;
}

export class HatchBrush extends Brush {
        constructor(hatchStyle: HatchStyle, foreColor: CGColor);
        constructor(hatchStyle: HatchStyle, foreColor: CGColor, backColor: CGColor);
        get BackgroundColor(): CGColor;
        get ForegroundColor(): CGColor;
        get HatchStyle(): HatchStyle;
        Clone(): HatchBrush;
        setup(graphics: Graphics, fill: boolean): void;
}

export enum HatchStyle {
    Horizontal = 0,
    Vertical = 1,
    ForwardDiagonal = 2,
    BackwardDiagonal = 3,
    Cross = 4,
    DiagonalCross = 5,
    Percent05 = 6,
    Percent10 = 7,
    Percent20 = 8,
    Percent25 = 9,
    Percent30 = 10,
    Percent40 = 11,
    Percent50 = 12,
    Percent60 = 13,
    Percent70 = 14,
    Percent75 = 15,
    Percent80 = 16,
    Percent90 = 17,
    LightDownwardDiagonal = 18,
    LightUpwardDiagonal = 19,
    DarkDownwardDiagonal = 20,
    DarkUpwardDiagonal = 21,
    WideDownwardDiagonal = 22,
    WideUpwardDiagonal = 23,
    LightVertical = 24,
    LightHorizontal = 25,
    NarrowVertical = 26,
    NarrowHorizontal = 27,
    DarkVertical = 28,
    DarkHorizontal = 29,
    DashedDownwardDiagonal = 30,
    DashedUpwardDiagonal = 31,
    DashedHorizontal = 32,
    DashedVertical = 33,
    SmallConfetti = 34,
    LargeConfetti = 35,
    ZigZag = 36,
    Wave = 37,
    DiagonalBrick = 38,
    HorizontalBrick = 39,
    Weave = 40,
    Plaid = 41,
    Divot = 42,
    DottedGrid = 43,
    DottedDiamond = 44,
    Shingle = 45,
    Trellis = 46,
    Sphere = 47,
    SmallGrid = 48,
    SmallCheckerBoard = 49,
    LargeCheckerBoard = 50,
    OutlinedDiamond = 51,
    SolidDiamond = 52,
    LargeGrid = 4,
    Min = 0,
    Max = 4
}

export class LinearGradientBrush extends Brush {
    protected interpolationColorsWasSet: boolean;
    protected wrapMode: WrapMode;
    protected gammaCorrection: boolean;
    protected gradientTransform: Matrix;
    protected startPoint: CGPoint;
    protected endPoint: CGPoint;
    protected colors: CGColor[];
    protected blend: Blend;
    protected colorBlend: ColorBlend;
    protected rectangle: CGRectangle;
    protected angle: float;
    protected angleIsScalable: boolean;
    protected mode: LinearGradientMode;
    protected modeWasSet: boolean;
    protected positions: float[];
    protected factors: float[];
    protected gamma: float;
    protected shadingColors: float[][];
    protected hasTransparencyLayer: boolean;
    get Blend(): Blend;
    set Blend(value: Blend);
    get GammaCorrection(): boolean;
    set GammaCorrection(value: boolean);
    get InterpolationColors(): ColorBlend;
    set InterpolationColors(value: ColorBlend);
    get LinearColors(): CGColor[];
    set LinearColors(value: CGColor[]);
    get Rectangle(): CGRectangle;
    get Transform(): Matrix;
    set Transform(value: Matrix);
    get WrapMode(): WrapMode;
    set WrapMode(value: WrapMode);
    constructor(rect: CGRectangle, color1: CGColor, color2: CGColor);
    constructor(rect: CGRectangle, color1: CGColor, color2: CGColor, mode: LinearGradientMode);
    constructor(rect: CGRectangle, color1: CGColor, color2: CGColor, angle: float);
    constructor(startPoint: CGPoint, endPoint: CGPoint, startColor: CGColor, endColor: CGColor);
    Clone(): LinearGradientBrush;
    multiplyTransform(matrix: Matrix): void;
    multiplyTransform(matrix: Matrix, order: MatrixOrder): void;
    resetTransform(): void;
    rotateTransform(angle: float): void;
    rotateTransform(angle: float, order: MatrixOrder): void;
    scaleTransform(sx: float, sy: float): void;
    scaleTransform(sx: float, sy: float, order: MatrixOrder): void;
    translateTransform(dx: float, dy: float): void;
    translateTransform(dx: float, dy: float, order: MatrixOrder): void;
    setBlendTriangularShape(focus: float, scale?: float): void;
    setSigmaBellShape(focus: float, scale?: float): void;
    protected drawGradient(context: CGContext2D): void;
    setup(graphics: Graphics, fill: boolean): void;
}

export enum LinearGradientMode {
    Horizontal = "Horizontal",
    Vertical = "Vertical",
    ForwardDiagonal = "ForwardDiagonal",
    BackwardDiagonal = "BackwardDiagonal"
}

export class RadialGradientBrush extends Brush {
    protected interpolationColorsWasSet: boolean;
    protected gammaCorrection: boolean;
    protected gradientTransform: Matrix;
    protected startPoint: CGPoint;
    protected endPoint: CGPoint;
    protected colors: CGColor[];
    protected blend: Blend;
    protected colorBlend: ColorBlend;
    protected rectangle: CGRectangle;
    protected positions: float[];
    protected factors: float[];
    protected gamma: float;
    protected shadingColors: float[][];
    protected hasTransparencyLayer: boolean;
    get Blend(): Blend;
    set Blend(value: Blend);
    get GammaCorrection(): boolean;
    set GammaCorrection(value: boolean);
    get InterpolationColors(): ColorBlend;
    set InterpolationColors(value: ColorBlend);
    get LinearColors(): CGColor[];
    set LinearColors(value: CGColor[]);
    get Rectangle(): CGRectangle;
    get Transform(): Matrix;
    set Transform(value: Matrix);
    constructor(x1: number, y1: number, innerRadius: number, x2: number, y2: number, outerRadius: number, startColor: CGColor, endColor: CGColor);
    constructor(rect: CGRectangle, startColor: CGColor, endColor: CGColor);
    Clone(): LinearGradientBrush;
    multiplyTransform(matrix: Matrix): void;
    multiplyTransform(matrix: Matrix, order: MatrixOrder): void;
    resetTransform(): void;
    rotateTransform(angle: float): void;
    rotateTransform(angle: float, order: MatrixOrder): void;
    scaleTransform(sx: float, sy: float): void;
    scaleTransform(sx: float, sy: float, order: MatrixOrder): void;
    translateTransform(dx: float, dy: float): void;
    translateTransform(dx: float, dy: float, order: MatrixOrder): void;
    setBlendTriangularShape(focus: float, scale?: float): void;
    setSigmaBellShape(focus: float, scale?: float): void;
    protected drawGradient(context: CGContext2D): void;
    setup(graphics: Graphics, fill: boolean): void;
}

export class ColorBlend {
    Colors: CGColor[];
    Positions: float[];
    constructor(count?: number);
}

export class Blend {
    Factors: float[];
    Positions: float[];
    constructor(count?: number);
}

export class TextureBrush extends Brush {
    get Image(): CGImage | HTMLImageElement;
    get Transform(): Matrix;
    set Transform(value: Matrix);
    get WrapMode(): WrapMode;
    set WrapMode(value: WrapMode);
    constructor(image: CGImage);
    multiplyTransform(matrix: Matrix, order?: MatrixOrder): void;
    resetTransform(): void;
    rotateTransform(angle: float): void;
    scaleTransform(sx: float, sy: float, order?: MatrixOrder): void;
    translateTransform(dx: float, dy: float, order?: MatrixOrder): void;
    setup(graphics: Graphics, fill: boolean): void;
}

/**
    * This class encapsulates the properties required to define a shadow to apply to a {@link DisplayObject}
    * via its `shadow` property.
    *
    * @memberof easeljs
    * @example
    * img.shadow = new Shadow("#000000", 5, 5, 10);
    *
    * @param {String} [color=black] The color of the shadow. This can be any valid CSS color value.
    * @param {Number} [offsetX=0] The x offset of the shadow in pixels.
    * @param {Number} [offsetY=0] The y offset of the shadow in pixels.
    * @param {Number} [blur=0] The size of the blurring effect.
    */
export class Shadow {
        /**
            * The color of the shadow. This can be any valid CSS color value.
            * @type {String}
            * @default black
            */
        color: CGColor;
        /**
            * The x offset of the shadow.
            * @type {Number}
            * @default 0
            */
        offsetX: number;
        /**
            * The y offset of the shadow.
            * @type {Number}
            * @default 0
            */
        offsetY: number;
        /**
            * The blur of the shadow.
            * @type {Number}
            * @default 0
            */
        blur: number;
        static identity: Shadow;
        constructor(color?: CGColor, offsetX?: number, offsetY?: number, blur?: number);
        /**
            * Returns a string representation of this object.
            * @return {String}
            */
        toString(): string;
        /**
            * Returns a clone of this Shadow instance.
            * @return {Shadow} A clone of the current Shadow instance.
            */
        clone(): Shadow;
}

export enum DashCap {
    Flat = 0,
    Round = 2,
    Triangle = 3
}

export enum PenAlignment {
    Center = 0,
    Inset = 1,
    Outset = 2,
    Left = 3,
    Right = 4
}

export class StringFormat {
    measurableCharacterRanges: CharacterRange[];
    get Alignment(): StringAlignment;
    set Alignment(value: StringAlignment);
    get LineAlignment(): StringAlignment;
    set LineAlignment(value: StringAlignment);
    get Trimming(): StringTrimming;
    set Trimming(value: StringTrimming);
    get FormatFlags(): StringFormatFlags;
    set FormatFlags(value: StringFormatFlags);
    get HotkeyPrefix(): HotkeyPrefix;
    set HotkeyPrefix(value: HotkeyPrefix);
    constructor();
    constructor(format: StringFormat);
    constructor(options: StringFormatFlags);
    constructor(options: StringFormatFlags, language: number);
    clone(): StringFormat;
    static get GenericDefault(): StringFormat;
    static get GenericTypographic(): StringFormat;
    setMeasurableCharacterRanges(ranges: CharacterRange[]): void;
    setTabStops(firstTabOffset: float, tabStops: float[]): void;
    getTabStops(firstTabOffset: Out<float>): float[];
    equals(f: StringFormat): boolean;
}

export enum FontStyle {
    Regular = 0,
    Bold = 1,
    Italic = 2,
    Underline = 4,
    Strikeout = 8
}

export enum StringTrimming {
    None = 0,
    Character = 1,
    Word = 2,
    EllipsisCharacter = 3,
    EllipsisWord = 4,
    EllipsisPath = 5
}

export class FontFamily {
    get Name(): string;
    getLineSpacing(style: FontStyle): number;
    getEmHeight(style: FontStyle): number;
    constructor(name: string);
    toString(): string;
}

export enum StringFormatFlags {
    DirectionRightToLeft = 1,
    DirectionVertical = 2,
    FitBlackBox = 4,
    DisplayFormatControl = 32,
    NoFontFallback = 1024,
    MeasureTrailingSpaces = 2048,
    NoWrap = 4096,
    LineLimit = 8192,
    NoClip = 16384
}

export enum StringAlignment {
    Near = 0,
    Center = 1,
    Far = 2
}

export enum GraphicsUnit {
    World = 0,
    Display = 1,
    Pixel = 2,
    Point = 3,
    Inch = 4,
    Document = 5,
    Millimeter = 6
}

export class SystemColors {
    static ActiveBorder: CGColor;
    static ActiveCaption: CGColor;
    static ActiveCaptionText: CGColor;
    static AppWorkspace: CGColor;
    static ButtonFace: CGColor;
    static ButtonHighlight: CGColor;
    static ButtonShadow: CGColor;
    static Control: CGColor;
    static ControlDark: CGColor;
    static ControlDarkDark: CGColor;
    static ControlLight: CGColor;
    static ControlLightLight: CGColor;
    static ControlText: CGColor;
    static Desktop: CGColor;
    static GradientActiveCaption: CGColor;
    static GradientInactiveCaption: CGColor;
    static GrayText: CGColor;
    static Highlight: CGColor;
    static HighlightText: CGColor;
    static HotTrack: CGColor;
    static InactiveBorder: CGColor;
    static InactiveCaption: CGColor;
    static InactiveCaptionText: CGColor;
    static Info: CGColor;
    static InfoText: CGColor;
    static Menu: CGColor;
    static MenuBar: CGColor;
    static MenuHighlight: CGColor;
    static MenuText: CGColor;
    static ScrollBar: CGColor;
    static Window: CGColor;
    static WindowFrame: CGColor;
    static WindowText: CGColor;
}

export enum KnownColor {
    ActiveBorder = 1,
    ActiveCaption = 2,
    ActiveCaptionText = 3,
    AppWorkspace = 4,
    Control = 5,
    ControlDark = 6,
    ControlDarkDark = 7,
    ControlLight = 8,
    ControlLightLight = 9,
    ControlText = 10,
    Desktop = 11,
    GrayText = 12,
    Highlight = 13,
    HighlightText = 14,
    HotTrack = 15,
    InactiveBorder = 16,
    InactiveCaption = 17,
    InactiveCaptionText = 18,
    Info = 19,
    InfoText = 20,
    Menu = 21,
    MenuText = 22,
    ScrollBar = 23,
    Window = 24,
    WindowFrame = 25,
    WindowText = 26,
    Transparent = 27,
    AliceBlue = 28,
    AntiqueWhite = 29,
    Aqua = 30,
    Aquamarine = 31,
    Azure = 32,
    Beige = 33,
    Bisque = 34,
    Black = 35,
    BlanchedAlmond = 36,
    Blue = 37,
    BlueViolet = 38,
    Brown = 39,
    BurlyWood = 40,
    CadetBlue = 41,
    Chartreuse = 42,
    Chocolate = 43,
    Coral = 44,
    CornflowerBlue = 45,
    Cornsilk = 46,
    Crimson = 47,
    Cyan = 48,
    DarkBlue = 49,
    DarkCyan = 50,
    DarkGoldenrod = 51,
    DarkGray = 52,
    DarkGreen = 53,
    DarkKhaki = 54,
    DarkMagenta = 55,
    DarkOliveGreen = 56,
    DarkOrange = 57,
    DarkOrchid = 58,
    DarkRed = 59,
    DarkSalmon = 60,
    DarkSeaGreen = 61,
    DarkSlateBlue = 62,
    DarkSlateGray = 63,
    DarkTurquoise = 64,
    DarkViolet = 65,
    DeepPink = 66,
    DeepSkyBlue = 67,
    DimGray = 68,
    DodgerBlue = 69,
    Firebrick = 70,
    FloralWhite = 71,
    ForestGreen = 72,
    Fuchsia = 73,
    Gainsboro = 74,
    GhostWhite = 75,
    Gold = 76,
    Goldenrod = 77,
    Gray = 78,
    Green = 79,
    GreenYellow = 80,
    Honeydew = 81,
    HotPink = 82,
    IndianRed = 83,
    Indigo = 84,
    Ivory = 85,
    Khaki = 86,
    Lavender = 87,
    LavenderBlush = 88,
    LawnGreen = 89,
    LemonChiffon = 90,
    LightBlue = 91,
    LightCoral = 92,
    LightCyan = 93,
    LightGoldenrodYellow = 94,
    LightGray = 95,
    LightGreen = 96,
    LightPink = 97,
    LightSalmon = 98,
    LightSeaGreen = 99,
    LightSkyBlue = 100,
    LightSlateGray = 101,
    LightSteelBlue = 102,
    LightYellow = 103,
    Lime = 104,
    LimeGreen = 105,
    Linen = 106,
    Magenta = 107,
    Maroon = 108,
    MediumAquamarine = 109,
    MediumBlue = 110,
    MediumOrchid = 111,
    MediumPurple = 112,
    MediumSeaGreen = 113,
    MediumSlateBlue = 114,
    MediumSpringGreen = 115,
    MediumTurquoise = 116,
    MediumVioletRed = 117,
    MidnightBlue = 118,
    MintCream = 119,
    MistyRose = 120,
    Moccasin = 121,
    NavajoWhite = 122,
    Navy = 123,
    OldLace = 124,
    Olive = 125,
    OliveDrab = 126,
    Orange = 127,
    OrangeRed = 128,
    Orchid = 129,
    PaleGoldenrod = 130,
    PaleGreen = 131,
    PaleTurquoise = 132,
    PaleVioletRed = 133,
    PapayaWhip = 134,
    PeachPuff = 135,
    Peru = 136,
    Pink = 137,
    Plum = 138,
    PowderBlue = 139,
    Purple = 140,
    Red = 141,
    RosyBrown = 142,
    RoyalBlue = 143,
    SaddleBrown = 144,
    Salmon = 145,
    SandyBrown = 146,
    SeaGreen = 147,
    SeaShell = 148,
    Sienna = 149,
    Silver = 150,
    SkyBlue = 151,
    SlateBlue = 152,
    SlateGray = 153,
    Snow = 154,
    SpringGreen = 155,
    SteelBlue = 156,
    Tan = 157,
    Teal = 158,
    Thistle = 159,
    Tomato = 160,
    Turquoise = 161,
    Violet = 162,
    Wheat = 163,
    White = 164,
    WhiteSmoke = 165,
    Yellow = 166,
    YellowGreen = 167,
    ButtonFace = 168,
    ButtonHighlight = 169,
    ButtonShadow = 170,
    GradientActiveCaption = 171,
    GradientInactiveCaption = 172,
    MenuBar = 173,
    MenuHighlight = 174
}

export class SystemPens {
    static ActiveBorder: Pen;
    static ActiveCaption: Pen;
    static ActiveCaptionText: Pen;
    static AppWorkspace: Pen;
    static ButtonFace: Pen;
    static ButtonHighlight: Pen;
    static ButtonShadow: Pen;
    static Control: Pen;
    static ControlText: Pen;
    static ControlDark: Pen;
    static ControlDarkDark: Pen;
    static ControlLight: Pen;
    static ControlLightLight: Pen;
    static Desktop: Pen;
    static GradientActiveCaption: Pen;
    static GradientInactiveCaption: Pen;
    static GrayText: Pen;
    static Highlight: Pen;
    static HighlightText: Pen;
    static HotTrack: Pen;
    static InactiveBorder: Pen;
    static InactiveCaption: Pen;
    static InactiveCaptionText: Pen;
    static Info: Pen;
    static InfoText: Pen;
    static Menu: Pen;
    static MenuBar: Pen;
    static MenuHighlight: Pen;
    static MenuText: Pen;
    static ScrollBar: Pen;
    static Window: Pen;
    static WindowFrame: Pen;
    static WindowText: Pen;
}

export class SystemBrushes {
    static ActiveBorder: Brush;
    static ActiveCaption: Brush;
    static ActiveCaptionText: Brush;
    static AppWorkspace: Brush;
    static ButtonFace: Brush;
    static ButtonHighlight: Brush;
    static ButtonShadow: Brush;
    static Control: Brush;
    static ControlLightLight: Brush;
    static ControlLight: Brush;
    static ControlDark: Brush;
    static ControlDarkDark: Brush;
    static ControlText: Brush;
    static Desktop: Brush;
    static GradientActiveCaption: Brush;
    static GradientInactiveCaption: Brush;
    static GrayText: Brush;
    static Highlight: Brush;
    static HighlightText: Brush;
    static HotTrack: Brush;
    static InactiveCaption: Brush;
    static InactiveBorder: Brush;
    static InactiveCaptionText: Brush;
    static Info: Brush;
    static InfoText: Brush;
    static Menu: Brush;
    static MenuBar: Brush;
    static MenuHighlight: Brush;
    static MenuText: Brush;
    static ScrollBar: Brush;
    static Window: Brush;
    static WindowFrame: Brush;
    static WindowText: Brush;
}

export enum PrintRange {
    AllPages = 0,
    Selection = 1,
    SomePages = 2,
    CurrentPage = 4194304
}

export enum RotateFlipType {
    Rotate180FlipXY = 0,
    RotateNoneFlipNone = 0,
    Rotate270FlipXY = 1,
    Rotate90FlipNone = 1,
    Rotate180FlipNone = 2,
    RotateNoneFlipXY = 2,
    Rotate270FlipNone = 3,
    Rotate90FlipXY = 3,
    Rotate180FlipY = 4,
    RotateNoneFlipX = 4,
    Rotate270FlipY = 5,
    Rotate90FlipX = 5,
    Rotate180FlipX = 6,
    RotateNoneFlipY = 6,
    Rotate270FlipX = 7,
    Rotate90FlipY = 7
}

export enum ContentAlignment {
    TopLeft = 1,
    TopCenter = 2,
    TopRight = 4,
    MiddleLeft = 16,
    MiddleCenter = 32,
    MiddleRight = 64,
    BottomLeft = 256,
    BottomCenter = 512,
    BottomRight = 1024
}

export function createCanvasElement(): any;
export function get2DCanvasContext(canvas: HTMLCanvasElement): CanvasRenderingContext2D;

export interface IMouseEventService {
    onMouseMove$: any;
    onMouseDown$: any;
    onMouseUp$: any;
}

/**
  * Tween.js - Licensed under the MIT license
  * https://github.com/tweenjs/tween.js
  * ----------------------------------------------
  *
  * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
  * Thank you all, you're awesome!
  */
export const TWEEN: any;
export const Easing: {
    Linear: {
        None: (k: any) => any;
    };
    Quadratic: {
        In: (k: any) => number;
        Out: (k: any) => number;
        InOut: (k: any) => number;
    };
    Cubic: {
        In: (k: any) => number;
        Out: (k: any) => number;
        InOut: (k: any) => number;
    };
    Quartic: {
        In: (k: any) => number;
        Out: (k: any) => number;
        InOut: (k: any) => number;
    };
    Quintic: {
        In: (k: any) => number;
        Out: (k: any) => number;
        InOut: (k: any) => number;
    };
    Sinusoidal: {
        In: (k: any) => number;
        Out: (k: any) => number;
        InOut: (k: any) => number;
    };
    Exponential: {
        In: (k: any) => number;
        Out: (k: any) => number;
        InOut: (k: any) => number;
    };
    Circular: {
        In: (k: any) => number;
        Out: (k: any) => number;
        InOut: (k: any) => number;
    };
    Elastic: {
        In: (k: any) => number;
        Out: (k: any) => number;
        InOut: (k: any) => number;
    };
    Back: {
        In: (k: any) => number;
        Out: (k: any) => number;
        InOut: (k: any) => number;
    };
    Bounce: {
        In: (k: any) => number;
        Out: (k: any) => number;
        InOut: (k: any) => number;
    };
};

export enum PixelFormat {
    Alpha = 262144,
    Canonical = 2097152,
    DontCare = 0,
    Extended = 1048576,
    Format16bppArgb1555 = 397319,
    Format16bppGrayScale = 1052676,
    Format16bppRgb555 = 135173,
    Format16bppRgb565 = 135174,
    Format1bppIndexed = 196865,
    Format24bppRgb = 137224,
    Format32bppArgb = 2498570,
    Format32bppPArgb = 925707,
    Format32bppRgb = 139273,
    Format48bppRgb = 1060876,
    Format4bppIndexed = 197634,
    Format64bppArgb = 3424269,
    Format64bppPArgb = 1851406,
    Format8bppIndexed = 198659,
    Gdi = 131072,
    Indexed = 65536,
    Max = 15,
    PAlpha = 524288,
    Undefined = 0
}

export class SystemFonts {
    static StaticConstructor(): void;
    static GetFontByName(systemFontName: string): Font;
    static CaptionFont: Font;
    static DefaultFont: Font;
    static DialogFont: Font;
    static IconTitleFont: Font;
    static MenuFont: Font;
    static MessageBoxFont: Font;
    static SmallCaptionFont: Font;
    static StatusFont: Font;
}

export class Tween extends AbstractTween {
        pluginData: any;
        target: any;
        passive: boolean;
        _stepHead: TweenStep;
        _stepTail: TweenStep;
        _stepPosition: number;
        _actionHead: TweenAction;
        _actionTail: TweenAction;
        duration: number;
        position: number;
        static IGNORE: any;
        static _tweens: Tween[];
        static _tweenHead: any;
        static _inTick: number;
        static _tweenTail: any;
        static _ticker: Ticker;
        static _plugins: any[];
        static _inited: boolean;
        constructor(target: any, props: any);
        /**
            * Returns a new tween instance. This is functionally identical to using `new Tween(...)`, but may look cleaner
            * with the chained syntax of TweenJS.
            *
            * @static
            * @example
            * let tween = Tween.get(target).to({ x: 100 }, 500);
            * // equivalent to:
            * let tween = new Tween(target).to({ x: 100 }, 500);
            *
            * @param {Object} target The target object that will have its properties tweened.
            * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).
            * @param {Boolean} [props.useTicks]
            * @param {Boolean} [props.ignoreGlobalPause]
            * @param {Number|Boolean} [props.loop]
            * @param {Boolean} [props.reversed]
            * @param {Boolean} [props.bounce]
            * @param {Number} [props.timeScale]
            * @param {Object} [props.pluginData]
            * @param {Boolean} [props.paused]
            * @param {*} [props.position] indicates the initial position for this tween
            * @param {*} [props.onChange] adds the specified function as a listener to the `change` event
            * @param {*} [props.onComplete] adds the specified function as a listener to the `complete` event
            * @param {*} [props.override] if true, removes all existing tweens for the target
            * @return {Tween} A reference to the created tween.
            */
        static get(target: any, props?: any): Tween;
        /**
            * Advances all tweens. This typically uses the {{#crossLink "Ticker"}}{{/crossLink}} class, but you can call it
            * manually if you prefer to use your own "heartbeat" implementation.
            *
            * @static
            *
            * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have
            * `useTicks` set to true.
            * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {@link tweenjs.Tween#ignoreGlobalPause}
            * will ignore this, but all others will pause if this is `true`.
            */
        static tick(delta: any, paused: any): void;
        /**
            * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle
            * {@link tweenjs.Ticker#event:tick} events from the {@link tweenjs.Ticker}.
            * No other events are handled in Tween.
            *
            * @static
            * @since 0.4.2
            *
            * @param {Object} event An event object passed in by the {@link core.EventDispatcher}. Will
            * usually be of type "tick".
            */
        static handleEvent(event: any): void;
        /**
            * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`
            * property is `true`.
            *
            * @static
            *
            * @param {Object} target The target object to remove existing tweens from.=
            */
        static removeTweens(target: any): void;
        /**
            * Stop and remove all existing tweens.
            *
            * @static
            * @since 0.4.1
            */
        static removeAllTweens(): void;
        /**
            * Indicates whether there are any active tweens on the target object (if specified) or in general.
            *
            * @static
            *
            * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate
            * if there are any active tweens on any target.
            * @return {Boolean} Indicates if there are active tweens.
            */
        static hasActiveTweens(target: any): boolean;
        /**
            * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink "SamplePlugin"}}{{/crossLink}}
            * for an example of how to write TweenJS plugins. Plugins should generally be installed via their own `install` method, in order to provide
            * the plugin with an opportunity to configure itself.
            *
            * @static
            *
            * @param {Object} plugin The plugin to install
            * @param {Object} props The props to pass to the plugin
            */
        static installPlugin(plugin: any, props: any): void;
        /**
            * Registers or unregisters a tween with the ticking system.
            *
            * @private
            * @static
            *
            * @param {Tween} tween The tween instance to register or unregister.
            * @param {Boolean} paused If `false`, the tween is registered. If `true` the tween is unregistered.
            */
        static _register(tween: any, paused: any): void;
        /**
            * @param {tweenjs.Tween} tween
            */
        static _delist(tween: any): void;
        /**
            * Adds a wait (essentially an empty tween).
            *
            * @example
            * // This tween will wait 1s before alpha is faded to 0.
            * Tween.get(target)
            *   .wait(1000)
            *   .to({ alpha: 0 }, 1000);
            *
            * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).
            * @param {Boolean} [passive=false] Tween properties will not be updated during a passive wait. This
            * is mostly useful for use with {@link tweenjs.Timeline} instances that contain multiple tweens
            * affecting the same target at different times.
            * @chainable
            */
        wait(duration: any, passive?: boolean): this;
        /**
            * Adds a tween from the current values to the specified properties. Set duration to 0 to jump to these value.
            * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric
            * properties will be set at the end of the specified duration.
            *
            * @example
            * Tween.get(target)
            *   .to({ alpha: 0, visible: false }, 1000);
            *
            * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x
            * property of the target to 300).
            * @param {Number} [duration=0] The duration of the tween in milliseconds (or in ticks if `useTicks` is true).
            * @param {Function} [ease=Ease.linear] The easing function to use for this tween. See the {@link tweenjs.Ease}
            * class for a list of built-in ease functions.
            * @chainable
            */
        to(props: any, duration?: number, ease?: typeof Ease.linear): this;
        /**
            * Adds a label that can be used with {@link tweenjs.Tween#gotoAndPlay}/{@link tweenjs.Tween#gotoAndStop}
            * at the current point in the tween.
            *
            * @example
            * let tween = Tween.get(foo)
            *   .to({ x: 100 }, 1000)
            *   .label("myLabel")
            *   .to({ x: 200 }, 1000);
            * // ...
            * tween.gotoAndPlay("myLabel"); // would play from 1000ms in.
            *
            * @param {String} label The label name.
            * @chainable
            */
        label(name: any): this;
        /**
            * Adds an action to call the specified function.
            *
            * @example
            * // would call myFunction() after 1 second.
            * Tween.get()
            *   .wait(1000)
            *   .call(myFunction);
            *
            * @param {Function} callback The function to call.
            * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function
            * will be called with a single param pointing to this tween.
            * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target's scope.
            * @chainable
            */
        call(callback: any, params?: any, scope?: any): this;
        /**
            * Adds an action to set the specified props on the specified target. If `target` is null, it will use this tween's
            * target. Note that for properties on the target object, you should consider using a zero duration {@link tweenjs.Tween#to}
            * operation instead so the values are registered as tweened props.
            *
            * @example
            * tween.wait(1000)
            *   .set({ visible: false }, foo);
            *
            * @param {Object} props The properties to set (ex. `{ visible: false }`).
            * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween's target.
            * @chainable
            */
        set(props: any, target: any): this;
        /**
            * Adds an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.
            *
            * @example
            * tween.to({ x: 100 }, 500)
            *   .play(otherTween);
            *
            * @param {Tween} [tween] The tween to play. Defaults to this tween.
            * @chainable
            */
        play(tween: any): this;
        /**
            * Adds an action to pause the specified tween.
            * At 60fps the tween will advance by ~16ms per tick, if the tween above was at 999ms prior to the current tick, it
        * will advance to 1015ms (15ms into the second "step") and then pause.
            *
            * @example
            * tween.pause(otherTween)
            *   .to({ alpha: 1 }, 1000)
            *   .play(otherTween);
            *
            * // Note that this executes at the end of a tween update,
            * // so the tween may advance beyond the time the pause action was inserted at.
        *
        * tween.to({ foo: 0 }, 1000)
        *   .pause()
        *   .to({ foo: 1 }, 1000);
            *
            * @param {Tween} [tween] The tween to pause. Defaults to this tween.
            * @chainable
            */
        pause(tween: any): this;
        /**
            * @throws Tween cannot be cloned.
            */
        clone(): void;
        /**
            * @private
            * @param {Object} plugin
            */
        _addPlugin(plugin: any): void;
        /**
            * @private
            * @param {} jump
            * @param {Boolean} end
        */
        _updatePosition(jump: any, end: any): void;
        /**
            * @private
            * @param {Object} step
            * @param {Number} ratio
            * @param {Boolean} end Indicates to plugins that the full tween has ended.
            */
        _updateTargetProps(step: any, ratio: any, end: any): void;
        /**
            * @private
            * @param {Number} startPos
            * @param {Number} endPos
            * @param {Boolean} includeStart
            */
        _runActionsRange(startPos: any, endPos: any, jump: any, includeStart: any): boolean;
        /**
            * @private
            * @param {Object} props
            */
        _appendProps(props: any, step: any, stepPlugins?: any): void;
        /**
            * Used by plugins to inject properties onto the current step. Called from within `Plugin.step` calls.
            * For example, a plugin dealing with color, could read a hex color, and inject red, green, and blue props into the tween.
            * See the SamplePlugin for more info.
            * @see tweenjs.SamplePlugin
            * @private
            * @param {String} name
            * @param {Object} value
            */
        _injectProp(name: any, value: any): void;
        /**
            * @private
            * @param {Number} duration
            * @param {Object} props
            * @param {Function} ease
            * @param {Boolean} [passive=false]
            */
        _addStep(duration: any, props: any, ease: any, passive?: boolean): TweenStep;
        /**
            * @private
            * @param {Object} scope
            * @param {Function} funct
            * @param {Array} params
            */
        _addAction(scope: any, funct: any, params: any): this;
        /**
            * @private
            * @param {Object} props
            */
        _set(props: any): void;
        /**
            * @private
            * @param {Object} props
            */
        _cloneProps(props: any): {};
}
/**
    * @private
    * @param {*} prev
    * @param {*} t
    * @param {*} d
    * @param {*} props
    * @param {*} ease
    * @param {*} passive
    */
class TweenStep {
        next: any;
        prev: any;
        t: any;
        d: any;
        props: any;
        ease: any;
        passive: any;
        index: number;
        constructor(prev: any, t: any, d: any, props: any, ease: any, passive: any);
}
/**
    * @private
    * @param {*} prev
    * @param {*} t
    * @param {*} scope
    * @param {*} funct
    * @param {*} params
    */
class TweenAction {
        next: any;
        d: any;
        prev: any;
        t: any;
        scope: any;
        funct: any;
        params: any;
        constructor(prev: any, t: any, scope: any, funct: any, params: any);
}
export {};

export enum CombineMode {
    Replace = 0,
    Intersect = 1,
    Union = 2,
    Xor = 3,
    Exclude = 4,
    Complement = 5
}

export class GraphicsContainer {
    constructor(graphicsContainer: number);
}

export enum PixelOffsetMode {
    Invalid = -1,
    Default = 0,
    HighSpeed = 1,
    HighQuality = 2,
    None = 3,
    Half = 4
}

export enum FlushIntention {
    Flush = 0,
    Sync = 1
}

export enum CoordinateSpace {
    World = 0,
    Page = 1,
    Device = 2
}

export class ImageAttributes implements ICloneable<ImageAttributes>, IDisposable {
    colorMatrix: ColorMatrix;
    colorMatrixFlags: ColorMatrixFlag;
    colorAdjustType: ColorAdjustType;
    gamma: float;
    isColorMatrixSet: boolean;
    isGammaSet: boolean;
    clearColorMatrix(): void;
    clearGamma(type?: ColorAdjustType): void;
    setColorMatrix(newColorMatrix: ColorMatrix): void;
    setColorMatrix(newColorMatrix: ColorMatrix, flags: ColorMatrixFlag): void;
    setColorMatrix(newColorMatrix: ColorMatrix, mode: ColorMatrixFlag, type: ColorAdjustType): void;
    setGamma(gamma: float): void;
    setGamma(gamma: float, type: ColorAdjustType): void;
    setWrapMode(mode: WrapMode): void;
    setWrapMode(mode: WrapMode, color: CGColor): void;
    setWrapMode(mode: WrapMode, color: CGColor, clamp: boolean): void;
    SetColorKey(lowColor: CGColor, highColor: CGColor): void;
    SetColorKey(lowColor: CGColor, highColor: CGColor, type: ColorAdjustType): void;
    Clone(): ImageAttributes;
    Dispose(): void;
}

export interface ICloneable<T> {
    Clone(): T;
}

export class PathData {
    Points: CGPoint[];
    Types: byte[];
    constructor(points: CGPoint[], types: byte[]);
}

export type Path = List<ClipPoint>;
export type Paths = List<List<ClipPoint>>;
export enum ClipType {
    ctIntersection = 0,
    ctUnion = 1,
    ctDifference = 2,
    ctXor = 3
}
export enum PolyType {
    ptSubject = 0,
    ptClip = 1
}
export enum JoinType {
    jtSquare = 0,
    jtRound = 1,
    jtMiter = 2
}
export enum PolyFillType {
    pftEvenOdd = 0,
    pftNonZero = 1,
    pftPositive = 2,
    pftNegative = 3
}
export enum EndType {
    etClosedPolygon = 0,
    etClosedLine = 1,
    etOpenButt = 2,
    etOpenSquare = 3,
    etOpenRound = 4
}
enum EdgeSide {
    esLeft = 0,
    esRight = 1
}
export class ClipPoint {
    readonly x: number;
    readonly y: number;
    constructor(x: number, y: number);
    equals(other: ClipPoint): boolean;
    notEquals(other: ClipPoint): boolean;
    static copy(other: ClipPoint): ClipPoint;
}
export class ClipRect {
    readonly left: number;
    readonly top: number;
    readonly right: number;
    readonly bottom: number;
    constructor(left: number, top: number, right: number, bottom: number);
    static copy(other: ClipRect): ClipRect;
}
export class PolyNode {
    parent: PolyNode;
    polygon: Path;
    index: number;
    joinType: JoinType;
    endType: EndType;
    children: Array<PolyNode>;
    isOpen: boolean;
    get isHole(): boolean;
    get childCount(): number;
    get contour(): Path;
    addChild(child: PolyNode): void;
    get next(): PolyNode;
    get nextSiblingUp(): PolyNode;
}
export class PolyTree extends PolyNode {
    allPolys: Array<PolyNode>;
    clear(): void;
    get first(): PolyNode;
    get total(): number;
}
class TEdge {
    bot: ClipPoint;
    curr: ClipPoint;
    top: ClipPoint;
    delta: ClipPoint;
    dx: number;
    polyTyp: PolyType;
    side: EdgeSide;
    windDelta: number;
    windCnt: number;
    windCnt2: number;
    outIdx: number;
    next: TEdge;
    prev: TEdge;
    nextInLML: TEdge;
    nextInAEL: TEdge;
    prevInAEL: TEdge;
    nextInSEL: TEdge;
    prevInSEL: TEdge;
}
class LocalMinima {
    readonly y: number;
    leftBound: TEdge;
    rightBound: TEdge;
    next: LocalMinima;
    constructor(y: number, leftBound: TEdge, rightBound: TEdge);
    clearLeftBound(): void;
    clearRightBound(): void;
}
class Scanbeam {
    readonly y: number;
    next: Scanbeam;
    constructor(y: number);
}
class OutPt {
    idx: number;
    pt: ClipPoint;
    next: OutPt;
    prev: OutPt;
}
class OutRec {
    idx: number;
    isHole: boolean;
    isOpen: boolean;
    firstLeft: OutRec;
    pts: OutPt;
    bottomPt: OutPt;
    polyNode: PolyNode;
    constructor();
}
class ClipperBase {
    m_MinimaList: LocalMinima;
    m_CurrentLM: LocalMinima;
    m_edges: Array<Array<TEdge>>;
    m_Scanbeam: Scanbeam;
    m_PolyOuts: Array<OutRec>;
    m_ActiveEdges: TEdge;
    m_HasOpenPaths: boolean;
    PreserveCollinear: boolean;
    constructor();
    protected Clear(): void;
    protected PopLocalMinima(Y: number): LocalMinima;
    protected Reset(): void;
    protected InsertScanbeam(Y: number): void;
    static GetBounds(paths: Paths): ClipRect;
    protected PopScanbeam(): {
        Y: number;
        r: boolean;
    };
    get LocalMinimaPending(): boolean;
    protected CreateOutRec(): OutRec;
    protected DisposeOutRec(index: number): void;
    protected UpdateEdgeIntoAEL(e: TEdge): TEdge;
    protected SwapPositionsInAEL(edge1: TEdge, edge2: TEdge): void;
    protected DeleteFromAEL(e: TEdge): void;
    AddPath(pg: Path, polyType: PolyType, Closed: boolean): boolean;
    AddPaths(ppg: Paths, polyType: PolyType, closed: boolean): boolean;
}
export class Clipper extends ClipperBase {
    ReverseSolution: boolean;
    StrictlySimple: boolean;
    constructor(InitOptions?: number);
    Execute(clipType: ClipType, solution: PolyTree | Paths, fillType?: PolyFillType): boolean;
    ExecutePaths(clipType: ClipType, solution: Paths, subjFillType: PolyFillType, clipFillType: PolyFillType): boolean;
    ExecutePolyTree(clipType: ClipType, polytree: PolyTree, subjFillType: PolyFillType, clipFillType: PolyFillType): boolean;
    static SimplifyPolygon(poly: Path, fillType?: PolyFillType): Paths;
    static SimplifyPolygons(polys: Paths, fillType?: PolyFillType): Paths;
    static CleanPolygon(path: Path, distance?: number): Path;
    static CleanPolygons(polys: Paths, distance?: number): Paths;
    static MinkowskiSumPath(pattern: Path, path: Path, pathIsClosed: boolean): Paths;
    static TranslatePath(path: Path, delta: ClipPoint): Path;
    static MinkowskiSumPaths(pattern: Path, paths: Paths, pathIsClosed: boolean): Paths;
    static MinkowskiDiff(poly1: Path, poly2: Path): Paths;
    static PolyTreeToPaths(polytree: PolyTree): Paths;
    static OpenPathsFromPolyTree(polytree: PolyTree): Paths;
    static ClosedPathsFromPolyTree(polytree: PolyTree): Paths;
}
export class ClipperOffset {
    ArcTolerance: number;
    MiterLimit: number;
    constructor(miterLimit?: number, arcTolerance?: number);
    clear(): void;
    AddPath(path: Path, joinType: JoinType, endType: EndType): void;
    AddPaths(paths: Paths, joinType: JoinType, endType: EndType): void;
    Execute(solution: Paths | PolyTree, delta: number): void;
}
export {};

export enum PenTypes {
    HatchFill = 0,
    LinearGradient = 1,
    PathGradient = 2,
    SolidColor = 3,
    TextureFill = 4,
    RadialGradient = 5,
    Custom = 6
}

export enum ImageLockMode {
    ReadOnly = 1,
    ReadWrite = 3,
    UserInputBuffer = 4,
    WriteOnly = 2
}

export class BitmapData {
    get Height(): int;
    set Height(value: int);
    get Width(): int;
    set Width(value: int);
    get PixelFormat(): PixelFormat;
    set PixelFormat(value: PixelFormat);
    get Reserved(): int;
    set Reserved(value: int);
    get Scan0(): IntPtr;
    set Scan0(value: IntPtr);
    get Stride(): int;
    set Stride(value: int);
}

export class EncoderParameters implements IDisposable {
    constructor();
    constructor(count: int);
    get Param(): EncoderParameter[];
    set Param(value: EncoderParameter[]);
    Dispose(): void;
    ToNativePtr(): IntPtr;
    static FromNativePtr(epPtr: IntPtr): EncoderParameters;
}

export class PropertyItem {
    constructor();
    get Id(): int;
    set Id(value: int);
    get Len(): int;
    set Len(value: int);
    get Type(): short;
    set Type(value: short);
    get Value(): ByteArray;
    set Value(value: ByteArray);
}

export class ImageFormat {
    constructor(guid: Guid);
    constructor(name: string, guid: string);
    Equals(o: ImageFormat): boolean;
    GetHashCode(): int;
    ToString(): string;
    get Guid(): Guid;
    static get Bmp(): ImageFormat;
    static get Emf(): ImageFormat;
    static get Exif(): ImageFormat;
    static get Gif(): ImageFormat;
    static get Icon(): ImageFormat;
    static get Jpeg(): ImageFormat;
    static get MemoryBmp(): ImageFormat;
    static get Png(): ImageFormat;
    static get Tiff(): ImageFormat;
    static get Wmf(): ImageFormat;
}

export class ImageCodecInfo {
    constructor();
    static GetImageDecoders(): ImageCodecInfo[];
    static GetImageEncoders(): ImageCodecInfo[];
    get Clsid(): Guid;
    set Clsid(value: Guid);
    get CodecName(): string;
    set CodecName(value: string);
    get DllName(): string;
    set DllName(value: string);
    get FilenameExtension(): string;
    set FilenameExtension(value: string);
    get Flags(): ImageCodecFlags;
    set Flags(value: ImageCodecFlags);
    get FormatDescription(): string;
    set FormatDescription(value: string);
    get FormatID(): Guid;
    set FormatID(value: Guid);
    get MimeType(): string;
    set MimeType(value: string);
    get SignatureMasks(): ByteArray[];
    set SignatureMasks(value: ByteArray[]);
    get SignaturePatterns(): ByteArray[];
    set SignaturePatterns(value: ByteArray[]);
    get Version(): int;
    set Version(value: int);
}

export class FrameDimension {
    constructor(guid: Guid);
    constructor(guid: Guid, name: string);
    get Guid(): Guid;
    static get Page(): FrameDimension;
    static get Resolution(): FrameDimension;
    static get Time(): FrameDimension;
    Equals(o: FrameDimension): boolean;
    GetHashCode(): int;
    ToString(): string;
}

export class ColorPalette {
    constructor();
    constructor(flags: int, colors: CGColor[]);
    get Entries(): CGColor[];
    get Flags(): int;
    getGDIPalette(): IntPtr;
    setFromGDIPalette(palette: IntPtr): void;
}

export class SketchGraphics extends CanvasGraphics<SketchCanvasRenderer2D> {
    _collideDebug: boolean;
    _pixelsDirty: boolean;
    antialias: boolean;
    _bezierDetail: any;
    _curveDetail: any;
    _contourInited: boolean;
    _contourVertices: any[];
    _pixelDensity: number;
    _gaussian_previous: boolean;
    _colorMode: string;
    _angleMode: string;
    _colorMaxes: {
        rgb: number[];
        hsb: number[];
        hsl: number[];
    };
    pixels: Uint8ClampedArray;
    imageData: ImageData;
    mouseX: number;
    mouseY: number;
    pmouseX: number;
    pmouseY: number;
    winMouseX: number;
    winMouseY: number;
    pwinMouseX: number;
    pwinMouseY: number;
    movedX: number;
    movedY: number;
    mouseButton: string;
    mouseIsPressed: boolean;
    mouseMoved: Function;
    mouseDragged: Function;
    touchMoved: Function;
    mousePressed: Function;
    touchStarted: Function;
    mouseReleased: Function;
    touchEnded: Function;
    mouseClicked: Function;
    doubleClicked: Function;
    mouseWheel: Function;
    windowResized: Function;
    isKeyPressed: boolean;
    keyIsPressed: boolean;
    key: string;
    keyCode: number;
    keyPressed: Function;
    keyReleased: Function;
    keyTyped: Function;
    get windowWidth(): number;
    get windowHeight(): number;
    provideRenderer2D(): SketchCanvasRenderer2D;
    provideRenderer2D(canvasContext: CanvasRenderingContext2D): SketchCanvasRenderer2D;
    init(): void;
    arc(x: number, y: number, w: number, h: number, start: number, stop: number, mode?: string, detail?: number): void;
    ellipse(x: any, y: any, w: any, h: any, detailX?: any): this;
    circle(x: number, y: number, d: number): void;
    line(...args: any[]): this;
    point(...args: any[]): this;
    quad(...args: any[]): this;
    rect(rect: CGRectangle): void;
    rect(x: int, y: int, w: int, h: int, tl?: int, tr?: int, br?: int, bl?: int): void;
    square(x: any, y: any, s: any, tl: any, tr: any, br: any, bl: any): void;
    triangle(...args: any[]): this;
    ellipseMode(m: string): this;
    noSmooth(): this;
    rectMode(m: any): this;
    smooth(): this;
    strokeCap(cap: any): this;
    strokeJoin(join: any): this;
    strokeWeight(w: any): this;
    bezier(...args: any[]): this;
    bezierDetail(d: any): this;
    bezierPoint(a: any, b: any, c: any, d: any, t: any): number;
    bezierTangent(a: any, b: any, c: any, d: any, t: any): number;
    curve(...args: any[]): this;
    curveDetail(d: any): this;
    curveTightness(t: any): this;
    curvePoint(a: any, b: any, c: any, d: any, t: any): number;
    curveTangent(a: any, b: any, c: any, d: any, t: any): number;
    beginContour(): this;
    beginShape(kind?: any): this;
    bezierVertex(...args: any[]): this;
    curveVertex(...args: any[]): this;
    endContour(): this;
    endShape(mode?: any): this;
    quadraticVertex(...args: any[]): this;
    vertex(x: int, y: int, moveTo?: any, u?: any, v?: any): this;
    alpha(c: any): number;
    blue(c: any): number;
    brightness(c: any): number;
    color(value: CGColor): CGColor;
    color(value: byte): CGColor;
    color(values: Array<byte>): CGColor;
    color(value: string): CGColor;
    color(gray: byte, alpha: byte): CGColor;
    color(v1: byte, v2: byte, v3: byte): CGColor;
    color(v1: byte, v2: byte, v3: byte, alpha: byte): CGColor;
    green(c: any): number;
    hue(c: any): number;
    lerpBrush(b1: SolidBrush, b2: SolidBrush, amt: number): SolidBrush;
    lerpPen(p1: Pen, p2: Pen, amt: number): Pen;
    lerpColor(c1: CGColor, c2: CGColor, amt: number): CGColor;
    lightness(c: any): number;
    red(c: any): number;
    saturation(c: any): number;
    background(value: byte): any;
    background(color: CGColor): any;
    background(values: Array<byte>): any;
    background(value: string): any;
    background(gray: byte, alpha: byte): any;
    background(v1: byte, v2: byte, v3: byte): any;
    background(v1: byte, v2: byte, v3: byte, alpha: byte): any;
    clear(): this;
    colorMode(mode: any, max1: any, max2: any, max3: any, maxA: any): this;
    fill(value: byte): any;
    fill(color: CGColor): any;
    fill(values: Array<byte>): any;
    fill(value: string): any;
    fill(gray: byte, alpha: byte): any;
    fill(v1: byte, v2: byte, v3: byte): any;
    fill(v1: byte, v2: byte, v3: byte, alpha: byte): any;
    noFill(): this;
    noStroke(): this;
    stroke(value: byte): any;
    stroke(color: CGColor): any;
    stroke(values: Array<byte>): any;
    stroke(value: string): any;
    stroke(gray: byte, alpha: byte): any;
    stroke(v1: byte, v2: byte, v3: byte): any;
    stroke(v1: byte, v2: byte, v3: byte, alpha: byte): any;
    createImage(width: any, height: any): SketchImage;
    saveCanvas(): void;
    saveGif(pImg: any, filename: any): void;
    saveFrames(fName: any, ext: any, _duration: any, _fps: any, callback: any): void;
    loadImage(path: any, successCallback: any, failureCallback: any): SketchImage;
    image(img: any, dx: any, dy: any, dWidth: any, dHeight: any, sx?: any, sy?: any, sWidth?: any, sHeight?: any): void;
    tint(value: byte): any;
    tint(color: CGColor): any;
    tint(values: Array<byte>): any;
    tint(value: string): any;
    tint(gray: byte, alpha: byte): any;
    tint(v1: byte, v2: byte, v3: byte): any;
    tint(v1: byte, v2: byte, v3: byte, alpha: byte): any;
    noTint(): void;
    imageMode(m: any): void;
    blend(...args: any[]): void;
    copy(...args: any[]): void;
    filter(operation: any, value: any): void;
    get(...args: any[]): any;
    loadPixels(...args: any[]): void;
    set(x: any, y: any, imgOrCol: any): void;
    updatePixels(x?: any, y?: any, w?: any, h?: any): void;
    abs(x: number): number;
    ceil(x: number): number;
    constrain(n: any, low: any, high: any): number;
    dist(...args: any[]): number;
    exp(x: number): number;
    floor(x: number): number;
    lerp(start: any, stop: any, amt: any): any;
    log(x: number): number;
    mag(x: number, y: number): number;
    map(n: any, start1: any, stop1: any, start2: any, stop2: any, withinBounds?: any): any;
    max(...args: any[]): number;
    min(...args: any[]): number;
    norm(n: any, start: any, stop: any): any;
    pow(x: number, y: number): number;
    round(x: number): number;
    sq(n: number): number;
    sqrt(x: number): number;
    createVector(x: any, y: any, z?: any): Vector;
    noise(x: any, y?: number, z?: number): number;
    noiseDetail(lod: any, falloff: any): void;
    noiseSeed(seed: any): void;
    randomSeed(seed: any): void;
    random(min?: any, max?: any): any;
    randomGaussian(mean: any, sd: any): any;
    acos(ratio: any): any;
    asin(ratio: any): any;
    atan(ratio: any): any;
    atan2(y: any, x: any): any;
    cos(angle: any): number;
    sin(angle: any): number;
    tan(angle: any): number;
    degrees(angle: any): void;
    radians(angle: any): number;
    angleMode(mode: string): void;
    textAlign(horizAlign?: any, vertAlign?: any): {
        horizontal: string;
        vertical: string;
    } | undefined;
    textLeading(theLeading?: any): number;
    textSize(theSize: any): number;
    textStyle(theStyle: any): string | SketchGraphics;
    textWidth(...args: any[]): any;
    textAscent(...args: any[]): any;
    textDescent(...args: any[]): any;
    loadFont(path: any, onSuccess: any, onError: any): SketchFont;
    text(str: any, x: any, y: any, maxWidth?: any, maxHeight?: any): any;
    textFont(theFont: any, theSize?: any): string | SketchGraphics;
    push(): void;
    pop(): void;
    _updateNextMouseCoords(e: any): void;
    _updateMouseCoords(): void;
    keyIsDown(code: any): any;
    applyMatrix(a: any, b: any, c: any, d: any, e: any, f: any): this;
    resetMatrix(): this;
    rotate(angle: any, axis?: any): this;
    scale(x: any, y: any, z: any): this;
    shearX(angle: any): this;
    shearY(angle: any): this;
    translate(vector: Vector): any;
    translate(x: number, y: number, z?: number): any;
    collideRectRect(x: any, y: any, w: any, h: any, x2: any, y2: any, w2: any, h2: any): boolean;
    collideRectCircle(rx: any, ry: any, rw: any, rh: any, cx: any, cy: any, diameter: any): boolean;
    collideCircleCircle(x: number, y: number, d: number, x2: number, y2: number, d2: number): boolean;
    collidePointCircle(x: any, y: any, cx: any, cy: any, d: any): boolean;
    collidePointEllipse(x: any, y: any, cx: any, cy: any, dx: any, dy: any): boolean;
    collidePointRect(pointX: any, pointY: any, x: any, y: any, xW: any, yW: any): boolean;
    collidePointLine(px: any, py: any, x1: any, y1: any, x2: any, y2: any, buffer?: any): boolean;
    collideLineCircle(x1: any, y1: any, x2: any, y2: any, cx: any, cy: any, diameter: any): boolean;
    collideLineLine(x1: any, y1: any, x2: any, y2: any, x3: any, y3: any, x4: any, y4: any, calcIntersection?: any): any;
    collideLineRect(x1: any, y1: any, x2: any, y2: any, rx: any, ry: any, rw: any, rh: any, calcIntersection?: any): any;
    collidePointPoly(px: any, py: any, vertices: any): boolean;
    collideCirclePoly(cx: number, cy: number, diameter: number, vertices: any[], interior: boolean): boolean;
    collideRectPoly(rx: any, ry: any, rw: any, rh: any, vertices: any, interior: any): boolean;
    collideLinePoly(x1: any, y1: any, x2: any, y2: any, vertices: any): boolean;
    collidePolyPoly(p1: any, p2: any, interior: any): boolean;
    collidePointTriangle(px: any, py: any, x1: any, y1: any, x2: any, y2: any, x3: any, y3: any): boolean;
    collidePointPoint(x: any, y: any, x2: any, y2: any, buffer: any): boolean;
    collidePointArc(px: any, py: any, ax: any, ay: any, arcRadius: any, arcHeading: any, arcAngle: any, buffer: any): boolean;
    cursor(type: any, x?: any, y?: any): void;
    createDraggablePoint(x: int, y: int): DraggablePoint;
    pixelDensity(val: number): any;
    resizeCanvas(w: number, h: number, noRedraw: boolean): void;
}

interface ISketchCommand {
    exec(sg: SketchGraphics, data?: any): void;
}
export class SketchBatch {
    protected m_instructions: ISketchCommand[];
    command: ISketchCommand;
    protected m_dirty: boolean;
    append(command: ISketchCommand, clean?: boolean): void;
    fill(color: string): void;
    rect(x: number, y: number, w: number, h: number): void;
    translate(x: number, y: number): void;
    draw(sg: SketchGraphics, data?: any): void;
    clear(): void;
}
export {};

export enum WrapMode {
    Tile = 0,
    TileFlipX = 1,
    TileFlipY = 2,
    TileFlipXY = 3,
    Clamp = 4
}

export enum HotkeyPrefix {
    None = 0,
    Show = 1,
    Hide = 2
}

export class CharacterRange {
    constructor(first: number, length: number);
    get First(): number;
    set First(value: number);
    get Length(): number;
    set Length(value: number);
    equals(cr: CharacterRange): boolean;
}

export enum HotkeyPrefix {
    None = 0,
    Show = 1,
    Hide = 2
}

/**
    * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.
    *
    * <pre>
    * This matrix can be visualized as:
    *
    * 	[ a  c  tx
    * 	 b  d  ty
    * 	0  0  1  ]
    *
    * Note the locations of b and c.
    * </pre>
    *
    * @param {Number} [a] Specifies the a property for the new matrix.
    * @param {Number} [b] Specifies the b property for the new matrix.
    * @param {Number} [c] Specifies the c property for the new matrix.
    * @param {Number} [d] Specifies the d property for the new matrix.
    * @param {Number} [tx] Specifies the tx property for the new matrix.
    * @param {Number} [ty] Specifies the ty property for the new matrix.
    */
export class Matrix2D {
        a: number;
        b: number;
        c: number;
        d: number;
        tx: number;
        ty: number;
        /**
            * Multiplier for converting degrees to radians. Used internally by Matrix2D.
            * @static
            * @type {Number}
            * @readonly
            */
        static DEG_TO_RAD: number;
        /**
            * An identity matrix, representing a null transformation.
            * @static
            * @type {Matrix2D}
            * @readonly
            */
        static identity: Matrix2D;
        constructor(a?: float, b?: float, c?: float, d?: float, tx?: float, ty?: float);
        /**
            * Sets the specified values on this instance.
            * @param {Number} [a=1] Specifies the a property for the new matrix.
            * @param {Number} [b=0] Specifies the b property for the new matrix.
            * @param {Number} [c=0] Specifies the c property for the new matrix.
            * @param {Number} [d=1] Specifies the d property for the new matrix.
            * @param {Number} [tx=0] Specifies the tx property for the new matrix.
            * @param {Number} [ty=0] Specifies the ty property for the new matrix.
            * @return {Matrix2D} This instance. Useful for chaining method calls.
            * @chainable
         */
        setValues(a: float, b: float, c: float, d: float, tx: float, ty: float): this;
        /**
            * Appends the specified matrix properties to this matrix. All parameters are required.
            * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
            * @param {Number} a
            * @param {Number} b
            * @param {Number} c
            * @param {Number} d
            * @param {Number} tx
            * @param {Number} ty
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
            */
        append(a: float, b: float, c: float, d: float, tx: float, ty: float): this;
        /**
            * Prepends the specified matrix properties to this matrix.
            * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
            * @param {Number} a
            * @param {Number} b
            * @param {Number} c
            * @param {Number} d
            * @param {Number} tx
            * @param {Number} ty
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
            */
        prepend(a: float, b: float, c: float, d: float, tx: float, ty: float): this;
        /**
            * Appends the specified matrix to this matrix.
            * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
            * @param {Matrix2D} matrix
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
            */
        appendMatrix(matrix: Matrix2D): Matrix2D;
        /**
            * Prepends the specified matrix to this matrix.
            * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
            *
            * @example <caption>Calculate the combined transformation for a child object</caption>
            * let o = displayObject;
            * let mtx = o.getMatrix();
            * while (o = o.parent) {
            * 	 // prepend each parent's transformation in turn:
            * 	 o.prependMatrix(o.getMatrix());
            * }
            *
            * @param {Matrix2D} matrix
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
            */
        prependMatrix(matrix: Matrix2D): Matrix2D;
        /**
            * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.
            *
            * @example <caption>Generate a matrix representing the transformations of a display object</caption>
            * let mtx = new Matrix2D();
            * mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
            *
            * @param {Number} x
            * @param {Number} y
            * @param {Number} scaleX
            * @param {Number} scaleY
            * @param {Number} rotation
            * @param {Number} skewX
            * @param {Number} skewY
            * @param {Number} [regX]
            * @param {Number} [regY]
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
            */
        appendTransform(x: float, y: float, scaleX: float, scaleY: float, rotation: float, skewX: float, skewY: float, regX: float, regY: float): Matrix2D;
        /**
            * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.
            *
            * Note that the above example would not account for {@link DisplayObject#transformMatrix} values.
            * See {@link Matrix2D#prependMatrix} for an example that does.
            *
            * @example <caption>Calculate the combined transformation for a child object</caption>
            * let o = displayObject;
            * let mtx = new Matrix2D();
            * do  {
            * 	 // prepend each parent's transformation in turn:
            * 	 mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
            * } while (o = o.parent);
            *
            * @param {Number} x
            * @param {Number} y
            * @param {Number} scaleX
            * @param {Number} scaleY
            * @param {Number} rotation
            * @param {Number} skewX
            * @param {Number} skewY
            * @param {Number} [regX]
            * @param {Number} [regY]
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            */
        prependTransform(x: float, y: float, scaleX: float, scaleY: float, rotation: float, skewX: float, skewY: float, regX: float, regY: float): Matrix2D;
        /**
            * Applies a clockwise rotation transformation to the matrix.
            * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `Math.PI/180`.
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
            */
        rotate(angle: float): Matrix2D;
        /**
            * Applies a skew transformation to the matrix.
            * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `Math.PI/180`.
            * @param {Number} skewY The amount to skew vertically in degrees.
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
         */
        skew(skewX: float, skewY: float): Matrix2D;
        /**
            * Applies a scale transformation to the matrix.
            * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.
            * @param {Number} y The amount to scale vertically.
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
            */
        scale(x: float, y: float): Matrix2D;
        /**
            * Translates the matrix on the x and y axes.
            * @param {Number} x
            * @param {Number} y
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
            */
        translate(x: float, y: float): Matrix2D;
        /**
            * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
            */
        identity(): Matrix2D;
        /**
            * Inverts the matrix, causing it to perform the opposite transformation.
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
            */
        invert(): Matrix2D;
        /**
            * Returns true if the matrix is an identity matrix.
            * @return {Boolean}
            */
        isIdentity(): boolean;
        /**
            * Returns true if this matrix is equal to the specified matrix (all property values are equal).
            * @param {Matrix2D} matrix The matrix to compare.
            * @return {Boolean}
            */
        equals(matrix: Matrix2D): boolean;
        /**
            * Transforms a point according to this matrix.
            * @param {Number} x The x component of the point to transform.
            * @param {Number} y The y component of the point to transform.
            * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.
            * @return {Point} This matrix. Useful for chaining method calls.
            */
        transformPoint(x: float, y: float, pt?: CGPoint): CGPoint;
        /**
            * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values
            * may not match the transform properties you used to generate the matrix, though they will produce the same visual
            * results.
            * @param {Object} [target] The object to apply the transform properties to. If null, then a new object will be returned.
            * @return {Object} The target, or a new generic object with the transform properties applied.
         */
        decompose(target?: any): any;
        /**
            * Copies all properties from the specified matrix to this matrix.
            * @param {Matrix2D} matrix The matrix to copy properties from.
            * @return {Matrix2D} This matrix. Useful for chaining method calls.
            * @chainable
         */
        copy(matrix: Matrix2D): Matrix2D;
        /**
            * Returns a clone of the Matrix2D instance.
            * @return {Matrix2D} a clone of the Matrix2D instance.
            */
        clone(): Matrix2D;
        /**
            * Returns a string representation of this object.
            * @return {String} a string representation of the instance.
            */
        toString(): string;
}

/**
    * Used for calculating and encapsulating display related properties.
    * @memberof easeljs
    * @param {Number} [visible] Visible value.
    * @param {Number} [alpha] Alpha value.
    * @param {Number} [shadow] A Shadow instance or null.
    * @param {Number} [compositeOperation] A compositeOperation value or null.
    * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.
    */
export class DisplayProps {
        visible: boolean;
        alpha: number;
        shadow: Shadow;
        compositeOperation: string;
        matrix: Matrix2D;
        constructor(visible?: boolean, alpha?: number, shadow?: Shadow, compositeOperation?: string, matrix?: Matrix2D);
        /**
            * Reinitializes the instance with the specified values.
            * @param {Number} [visible=true] Visible value.
            * @param {Number} [alpha=1] Alpha value.
            * @param {Number} [shadow] A Shadow instance or null.
            * @param {Number} [compositeOperation] A compositeOperation value or null.
            * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.
            * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.
            * @chainable
         */
        setValues(visible: boolean | undefined, alpha: number | undefined, shadow: Shadow, compositeOperation: string, matrix: Matrix2D): DisplayProps;
        /**
            * Appends the specified display properties. This is generally used to apply a child's properties its parent's.
            * @param {Boolean} visible desired visible value
            * @param {Number} alpha desired alpha value
            * @param {easeljs.Shadow} shadow desired shadow value
            * @param {String} compositeOperation desired composite operation value
            * @param {easeljs.Matrix2D} [matrix] a Matrix2D instance
            * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.
            * @chainable
         */
        append(visible: boolean, alpha: float, shadow: Shadow, compositeOperation: string, matrix: Matrix2D): DisplayProps;
        /**
            * Prepends the specified display properties. This is generally used to apply a parent's properties to a child's.
            * For example, to get the combined display properties that would be applied to a child, you could use:
            *
            * @example
            * let o = displayObject;
            * let props = new DisplayProps();
            * do {
            * 	 // prepend each parent's props in turn:
            * 	 props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());
            * } while (o = o.parent);
            *
            * @param {Boolean} visible desired visible value
            * @param {Number} alpha desired alpha value
            * @param {easeljs.Shadow} shadow desired shadow value
            * @param {String} compositeOperation desired composite operation value
            * @param {easeljs.Matrix2D} [matrix] a Matrix2D instance
            * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.
            * @chainable
         */
        prepend(visible: boolean, alpha: float, shadow: Shadow, compositeOperation: string, matrix?: Matrix2D): DisplayProps;
        /**
            * Resets this instance and its matrix to default values.
            * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.
            * @chainable
         */
        identity(): DisplayProps;
        /**
            * Returns a clone of the DisplayProps instance. Clones the associated matrix.
            * @return {easeljs.DisplayProps} a clone of the DisplayProps instance.
            */
        clone(): DisplayProps;
}

/**
    * A stage is the root level {@link Container} for a display list. Each time its {@link Stage#tick}
    * method is called, it will render its display list to its target canvas.
    *
    * @memberof easeljs
    * @extends Container
    * @example
    * let stage = new Stage("canvasElementId");
    * let image = new Bitmap("imagePath.png");
    * stage.addChild(image);
    * Ticker.addEventListener("tick", event => {
    *   image.x += 10;
    * 	 stage.update();
    * });
    *
    * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id
    * of a canvas object in the current document.
    */
export class Stage extends Container {
        /**
            * Indicates whether the stage should automatically clear the canvas before each render. You can set this to `false`
            * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for
            * example).
            *
            * @example
            * let stage = new Stage("canvasId");
            * stage.autoClear = false;
            *
            * @type {Boolean}
            * @default true
            */
        autoClear: boolean;
        /**
            * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the
            * first stage that will be ticked (or they will clear each other's render).
            *
            * When changing the canvas property you must disable the events on the old canvas, and enable events on the
            * new canvas or mouse events will not work as expected.
            *
            * @example
            * stage.enableDOMEvents(false);
            * stage.canvas = anotherCanvas;
            * stage.enableDOMEvents(true);
            *
            * @type {HTMLCanvasElement | Object}
            */
        canvas: HTMLCanvasElement | any;
        /**
            * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
            * position over the canvas, and mouseInBounds will be set to false.
            * @type {Number}
            * @default 0
            * @readonly
            */
        mouseX: number;
        /**
            * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
            * position over the canvas, and mouseInBounds will be set to false.
            * @type {Number}
            * @default 0
            * @readonly
            */
        mouseY: number;
        /**
            * Specifies the area of the stage to affect when calling update. This can be use to selectively
            * re-draw specific regions of the canvas. If null, the whole canvas area is drawn.
            * @type {Rectangle}
            */
        drawRect: CGRectangle;
        /**
            * Indicates whether display objects should be rendered on whole pixels. You can set the {@link DisplayObject.snapToPixelEnabled}
            * property of display objects to false to enable/disable this behaviour on a per instance basis.
            * @type {Boolean}
            * @default false
            */
        snapToPixelEnabled: boolean;
        /**
            * Indicates whether the mouse is currently within the bounds of the canvas.
            * @type {Boolean}
            * @default false
            */
        mouseInBounds: boolean;
        /**
            * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.
            * @type {Boolean}
            * @default true
            */
        tickOnUpdate: boolean;
        /**
            * If true, mouse move events will continue to be called when the mouse leaves the target canvas.
            * See {@link Stage#mouseInBounds}, and {@link MouseEvent} x/y/rawX/rawY.
            * @type {Boolean}
            * @default false
            */
        mouseMoveOutside: boolean;
        /**
            * Prevents selection of other elements in the html page if the user clicks and drags, or double clicks on the canvas.
            * This works by calling `preventDefault()` on any mousedown events (or touch equivalent) originating on the canvas.
            * @type {Boolean}
            * @default true
            */
        preventSelection: boolean;
        /**
            * Holds objects with data for each active pointer id. Each object has the following properties:
            * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)
            * @type {Object}
            * @private
            */
        protected _pointerData: any;
        /**
            * Number of active pointers.
            * @type {Number}
            * @private
            */
        protected _pointerCount: number;
        /**
            * The ID of the primary pointer.
            * @type {String}
            * @private
            */
        protected _primaryPointerID: string;
        /**
            * @protected
            * @type {Number}
            */
        protected _mouseOverIntervalID: number;
        /**
            * @protected
            * @type {Stage}
            */
        protected _nextStage: Stage;
        /**
            * @protected
            * @type {Stage}
            */
        protected _prevStage: Stage;
        protected _eventListeners: any;
        protected _mouseOverX: number;
        protected _mouseOverY: number;
        protected _mouseOverTarget: any[];
        isUpdateRequired: boolean;
        constructor(canvas: HTMLCanvasElement | String | Object);
        /**
            * Specifies a target stage that will have mouse/touch interactions relayed to it after this stage handles them.
            * This can be useful in cases where you have multiple layered canvases and want user interactions
            * events to pass through.
            *
            * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings
            * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.
            * Considerations when using roll over in relay targets:
            * <ol>
            *   <li> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</li>
            *   <li> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</li>
            *   <li> All relay targets will share the frequency value of the top-most stage</li>
            * </ol>
            *
            * @example <caption>Relay mouse events from topStage to bottomStage</caption>
            * topStage.nextStage = bottomStage;
            *
            * @example <caption>Disable DOM events</caption>
            * stage.enableDOMEvents(false);
            *
            * @type {Stage}
            */
        get nextStage(): Stage;
        set nextStage(stage: Stage);
        /**
            * Each time the update method is called, the stage will call {@link Stage#tick}
            * unless {@link Stage#tickOnupdate} is set to false,
            * and then render the display list to the canvas.
            *
            * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {@link core.Ticker} event object, or similar object with a delta property.
            */
        update(props?: any): void;
        draw(ctx: CanvasRenderingContext2D, ignoreCache: boolean): boolean;
        /**
            * Propagates a tick event through the display list. This is automatically called by {@link Stage#update}
            * unless {@link Stage#tickOnUpdate} is set to false.
            *
            * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is
            * propagated to listeners.
            *
            * Some time-based features in EaselJS (for example {@link Sprite#framerate} require that
            * a {@link core.Ticker#event:tick} event object (or equivalent object with a delta property) be
            * passed as the `props` parameter to `tick()`.
            *
            * @example
            * Ticker.on("tick", (evt) => {
            *   // clone the event object from Ticker, and add some custom data to it:
            * 	 let data = evt.clone().set({ greeting: "hello", name: "world" });
            * 	 // pass it to stage.update():
            * 	 stage.update(data); // subsequently calls tick() with the same param
            * });
            *
            * shape.on("tick", (evt) => {
            *   console.log(evt.delta); // the delta property from the Ticker tick event object
            * 	 console.log(evt.greeting, evt.name); // custom data: "hello world"
            * });
            *
            * @emits Stage#event:tickstart
            * @emits Stage#event:tickend
            * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.
            */
        tick(props: any): void;
        /**
            * Default event handler that calls the Stage {@link Stage#update} method when a {@link DisplayObject#event:tick}
            * event is received. This allows you to register a Stage instance as a event listener on {@link core.Ticker} directly.
            * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to
            * display object tick handlers, instead of `delta` and `paused` parameters.
            */
        handleEvent(evt: Event): void;
        /**
            * Clears the target canvas. Useful if {@link State#autoClear} is set to `false`.
            */
        clear(): void;
        /**
            * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can
            * be specified as the src value of an image element.
            *
            * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color
            * value is allowed. The default value is a transparent background.
            * @param {String} [mimeType="image/png"] The MIME type of the image format to be create. If an unknown MIME type
            * is passed in, or if the browser does not support the specified MIME type, the default value will be used.
            * @param {Number} [encoderOptions=0.92] A Number between 0 and 1 indicating the image quality to use for image
            * formats that use lossy  compression such as image/jpeg and image/webp.
            * @return {String} a Base64 encoded image.
            */
        toDataURL(backgroundColor: string, mimeType?: string, encoderOptions?: float): any;
        /**
            * Enables or disables (by passing a frequency of 0) mouse over {@link DisplayObject#event:mouseover}
            * and {@link DisplayObject#event:mouseout} and roll over events {@link DisplayObject#event:rollover}
            * and {@link DisplayObject#event:rollout} for this stage's display list. These events can
            * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled
            * independently of mouse move events via the optional `frequency` parameter.
            *
            * @example
            * const stage = new Stage("canvasId");
            * stage.enableMouseOver(10); // 10 updates per second
            *
            * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast
            * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less
            * responsive, but uses less CPU.
            */
        enableMouseOver(frequency?: number): void;
        /**
            * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good
            * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive
            * events from the page.
            * When changing the canvas property you must disable the events on the old canvas, and enable events on the
            * new canvas or mouse events will not work as expected.
            *
            * @example
            * stage.enableDOMEvents(false);
            * stage.canvas = anotherCanvas;
            * stage.enableDOMEvents(true);
            *
            * @param {Boolean} [enable=true] Indicates whether to enable or disable the events.
            */
        enableDOMEvents(enable?: boolean): void;
        /**
            * Stage instances cannot be cloned.
            * @throws Stage cannot be cloned
            * @override
            */
        clone(test: boolean): Stage;
        /**
            * @protected
            * @param {HTMLElement} e
            * @returns {Object}
            */
        protected _getElementRect(e: HTMLCanvasElement): {
                left: float;
                right: float;
                top: float;
                bottom: float;
        };
        /**
            * @protected
            * @param {Number} id
            * @returns {Object}
            */
        protected _getPointerData(id: any): any;
        /**
            * @protected
            * @param {MouseEvent} [e=window.event]
            */
        protected _handleMouseMove(e?: MouseEvent): void;
        onMouseMove(e: any): void;
        /**
            * @emits {@link DisplayObject#event:mouseleave}
            * @emits {@link DisplayObject#event:mouseenter}
            * @emits {@link DisplayObject#event:pressmove}
            * @emits {@link Stage#event:stagemousemove}
            * @protected
            * @param {Number} id
            * @param {MouseEvent | Event} e
            * @param {Number} pageX
            * @param {Number} pageY
            * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
            */
        protected _handlePointerMove(id: number, e: MouseEvent | Event, pageX: float, pageY: float, owner?: Stage): void;
        /**
            * @protected
            * @param {Number} id
            * @param {MouseEvent | Event} e
            * @param {Number} pageX
            * @param {Number} pageY
            */
        protected _updatePointerPosition(id: number, e: MouseEvent | Event, pageX: float, pageY: float): void;
        /**
            * @protected
            * @param {MouseEvent} e
            */
        protected _handleMouseUp(e: MouseEvent): void;
        onMouseUp(e: any): void;
        /**
            * @emits {@link Stage#event:stagemouseup}
            * @emits {@link DisplayObject#event:click}
            * @emits {@link DisplayObject#event:pressup}
            * @protected
            * @param {Number} id
            * @param {MouseEvent | Event} e
            * @param {Boolean} clear
            * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
            */
        protected _handlePointerUp(id: number, e: MouseEvent | Event, clear: boolean, owner?: Stage): void;
        /**
            * @protected
            * @param {MouseEvent} e
            */
        protected _handleMouseDown(e: MouseEvent): void;
        onMouseDown(e: any): void;
        /**
            * @emits {@link Stage#event:stagemousedown}
            * @emits {@link DisplayObject#event:mousedown}
            * @protected
            * @param {Number} id
            * @param {MouseEvent | Event} e
            * @param {Number} pageX
            * @param {Number} pageY
            * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
            */
        protected _handlePointerDown(id: number, e: MouseEvent | Event, pageX: number, pageY: number, owner?: Stage): void;
        /**
            * @emits {@link DisplayObject#event:mouseout}
            * @emits {@link DisplayObject#event:rollout}
            * @emits {@link DisplayObject#event:rollover}
            * @emits {@link DisplayObject#event:mouseover}
            * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)
            * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
            * @param {Stage} eventTarget The stage that the cursor is actively over.
            * @protected
            */
        protected _testMouseOver(clear?: boolean, owner?: Stage, eventTarget?: Stage): void;
        /**
            * @emits {@link DisplayObject#event:dblclick}
            * @protected
            * @param {MouseEvent} e
            * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
            */
        protected _handleDoubleClick(e: MouseEvent, owner?: Stage): void;
        onDbClick(e: any, owner?: Stage): void;
        /**
            * @protected
            * @param {DisplayObject} target
            * @param {String} type
            * @param {Boolean} bubbles
            * @param {Number} pointerId
            * @param {Object} o
            * @param {MouseEvent} [nativeEvent]
            * @param {DisplayObject} [relatedTarget]
            */
        protected _dispatchMouseEvent(target: DisplayObject, type: string, bubbles: boolean, pointerId: number, o: any, nativeEvent: MouseEvent, relatedTarget?: DisplayObject): void;
}

/**
    * A Container is a nestable display list that allows you to work with compound display elements. For  example you could
    * group arm, leg, torso and head {{#crossLink "Bitmap"}}{{/crossLink}} instances together into a Person Container, and
    * transform them as a group, while still being able to move the individual parts relative to each other. Children of
    * containers have their `transform` and `alpha` properties concatenated with their parent
    * Container.
    *
    * For example, a {{#crossLink "Shape"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with `x=50`
    * and `alpha=0.7` will be rendered to the canvas at `x=150` and `alpha=0.35`.
    * Containers have some overhead, so you generally shouldn't create a Container to hold a single child.
    *
    * @memberof Tuval
    * @extends DisplayObject
    * @example
    * const container = new Tuval.Container();
    * container.addChild(bitmapInstance, shapeInstance);
    * container.x = 100;
    */
export class Container extends DisplayObject {
        /**
            * The array of children in the display list. You should usually use the child management methods such as
            * {@link Container#addChild}, {@link Container#removeChild}, {@link Container#swapChildren},
            * etc, rather than accessing this directly, but it is included for advanced uses.
            * @type {Array}
            * @default []
            */
        children: Array<DisplayObject>;
        /**
            * Indicates whether the children of this container are independently enabled for mouse/pointer interaction.
            * If false, the children will be aggregated under the container - for example, a click on a child shape would
            * trigger a click event on the container.
            * @type {Boolean}
            * @default true
            */
        mouseChildren: boolean;
        /**
            * If false, the tick will not be propagated to children of this Container. This can provide some performance benefits.
            * In addition to preventing the {@link core.Ticker#event:tick} event from being dispatched, it will also prevent tick related updates
            * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).
            * @type {Boolean}
            * @default true
            */
        tickChildren: boolean;
        constructor();
        /**
            * Returns the number of children in the container.
            * @type {Number}
            * @readonly
            */
        get numChildren(): number;
        isVisible(): boolean;
        draw(ctx: any, ignoreCache?: boolean): boolean;
        /**
            * Adds a child to the top of the display list.
            *
            * @example
            * container.addChild(bitmapInstance);
            * // You can also add multiple children at once:
            * container.addChild(bitmapInstance, shapeInstance, textInstance);
            *
            * @param {...DisplayObject} children The display object(s) to add.
            * @return {DisplayObject} The child that was added, or the last child if multiple children were added.
            */
        addChild(...children: DisplayObject[]): DisplayObject | null;
        /**
            * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and
            * setting its parent to this container.
            *
            * @example
            * container.addChildAt(child1, index);
            * // You can also add multiple children, such as:
            * container.addChildAt(child1, child2, ..., index);
            * // The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list, you could use:
            * container.addChildAt(myShape, container.getChildIndex(otherShape));
            * // This would also bump otherShape's index up by one. Fails silently if the index is out of range.
            *
            * @param {...DisplayObject} children The display object(s) to add.
            * @param {Number} index The index to add the child at.
            * @return {DisplayObject} Returns the last child that was added, or the last child if multiple children were added.
            */
        addChildAt(...children: DisplayObject[]): DisplayObject;
        /**
            * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is
            * already known.
            *
            * @example
            * container.removeChild(child);
            * // You can also remove multiple children:
            * container.removeChild(child1, child2, ...);
            *
            * @param {...DisplayObject} children The display object(s) to remove.
            * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.
            */
        removeChild(...children: DisplayObject[]): boolean;
        /**
            * Removes the child at the specified index from the display list, and sets its parent to null.
            *
            * @example
            * container.removeChildAt(2);
            * // You can also remove multiple children:
            * container.removeChildAt(2, 7, ...)
            *
            * @param {...Number} indexes The indexes of children to remove.
            * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
            */
        removeChildAt(...indexes: any[]): boolean;
        /**
            * Removes all children from the display list.
            */
        removeAllChildren(): void;
        /**
            * Returns the child at the specified index.
            * @param {Number} index The index of the child to return.
            * @return {DisplayObject} The child at the specified index. Returns null if there is no child at the index.
            */
        getChildAt(index: number): DisplayObject;
        /**
            * Returns the child with the specified name.
            * @param {String} name The name of the child to return.
            * @return {DisplayObject} The child with the specified name.
            */
        getChildByName(name: string): DisplayObject;
        /**
            * Performs an array sort operation on the child list.
            *
            * @example
            * // Display children with a higher y in front.
            * container.sortChildren((obj1, obj2, options) => {
            * 	 if (obj1.y > obj2.y) { return 1; }
            *   if (obj1.y < obj2.y) { return -1; }
            *   return 0;
            * });
            *
            * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}
            * @param {Function} sortFunction the function to use to sort the child list.
            */
        sortChildren(sortFunction: Function): void;
        /**
            * Returns the index of the specified child in the display list, or -1 if it is not in the display list.
            * @param {DisplayObject} child The child to return the index of.
            * @return {Number} The index of the specified child. -1 if the child is not found.
            */
        getChildIndex(child: DisplayObject): number;
        /**
            * Swaps the children at the specified indexes. Fails silently if either index is out of range.
            * @param {Number} index1
            * @param {Number} index2
            */
        swapChildrenAt(index1: number, index2: number): void;
        /**
            * Swaps the specified children's depth in the display list. Fails silently if either child is not a child of this
            * Container.
            * @param {DisplayObject} child1
            * @param {DisplayObject} child2
            */
        swapChildren(child1: DisplayObject, child2: DisplayObject): void;
        /**
            * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.
            * @param {DisplayObject} child
            * @param {Number} index
            */
        setChildIndex(child: DisplayObject, index: number): void;
        /**
            * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)
            * of this container.
            * @param {DisplayObject} child The DisplayObject to be checked.
            * @return {Boolean} true if the specified display object either is this container or is a descendent.
            */
        contains(child: DisplayObject): boolean;
        /**
            * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the
            * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all
            * transform properties including regX/Y.
            * @param {Number} x The x position to check in the display object's local coordinates.
            * @param {Number} y The y position to check in the display object's local coordinates.
            * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified
            * coordinates.
            */
        hitTest(x: float, y: float): boolean;
        /**
            * Returns an array of all display objects under the specified coordinates that are in this container's display
            * list. This routine ignores any display objects with {@link DisplayObject#mouseEnabled} set to `false`.
            * The array will be sorted in order of visual depth, with the top-most display object at index 0.
            * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.
            * For example, if testing for objects under the mouse, test on tick (instead of on {@link DisplayObject#event:mousemove}),
            * and only if the mouse's position has changed.
            *
            * <ul>
            *   <li>By default (mode=0) this method evaluates all display objects.</li>
            *   <li>By setting the `mode` parameter to `1`, the {@link DisplayObject#mouseEnabled}
            *       and {@link DisplayObject#mouseChildren} properties will be respected.</li>
            *   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event
            *       listeners or a {@link DisplayObject#cursor} property. That is, only objects
            *       that would normally intercept mouse interaction will be included. This can significantly improve performance
            *       in some cases by reducing the number of display objects that need to be tested.</li>
            * </ul>
            *
            * This method accounts for both {@link DisplayObject#hitArea} and {@link DisplayObject#mask}.
            *
            * @param {Number} x The x position in the container to test.
            * @param {Number} y The y position in the container to test.
            * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
            * @return {Array<DisplayObject>} An array of DisplayObjects under the specified coordinates.
            */
        getObjectsUnderPoint(x: float, y: float, mode?: number): never[];
        /**
            * Similar to {@link Container#getObjectsUnderPoint}, but returns only the top-most display
            * object. This runs significantly faster than `getObjectsUnderPoint()`, but is still potentially an expensive
            * operation.
            *
            * @param {Number} x The x position in the container to test.
            * @param {Number} y The y position in the container to test.
            * @param {Number} [mode=0] The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
            * @return {DisplayObject} The top-most display object under the specified coordinates.
            */
        getObjectUnderPoint(x: float, y: float, mode?: number): any;
        getBounds(): CGRectangle;
        getTransformedBounds(): CGRectangle;
        /**
            * Returns a clone of this Container. Some properties that are specific to this instance's current context are
            * reverted to their defaults (for example `.parent`).
            * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the
            * properties of the container will be cloned, but the new instance will not have any children.
            * @return {Container} A clone of the current Container instance.
            */
        clone(recursive?: boolean): Container;
        _tick(evtObj: any): void;
        /**
            * Recursively clones all children of this container, and adds them to the target container.
            * @protected
            * @param {Container} o The target container.
            */
        protected _cloneChildren(o: Container): void;
        /**
            * Removes the child at the specified index from the display list, and sets its parent to null.
            * Used by `removeChildAt`, `addChild`, and `addChildAt`.
            *
            * @protected
            * @param {Number} index The index of the child to remove.
            * @param {Boolean} [silent=false] Prevents dispatch of `removed` event if true.
            * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
            */
        protected _removeChildAt(index: number, silent?: boolean): boolean;
        /**
            * @protected
            * @param {Number} x
            * @param {Number} y
            * @param {Array} arr
            * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.
            * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.
            * @param {Number} [currentDepth=0] Indicates the current depth of the search.
            * @return {DisplayObject}
            */
        protected _getObjectsUnderPoint(x: float, y: float, arr: Array<DisplayObject>, mouse: boolean, activeListener?: boolean, currentDepth?: number): any;
        /**
            * @protected
            * @param {DisplayObject} target
            * @param {Number} x
            * @param {Number} y
            * @return {Boolean} Indicates whether the x/y is within the masked region.
            */
        protected _testMask(target: any, x: number, y: number): boolean;
        /**
            * @protected
            * @param {Matrix2D} matrix
            * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
            * @return {Rectangle}
            */
        protected _getBounds(matrix?: Matrix2D, ignoreTransform?: boolean): CGRectangle;
}

export class DisplayObject extends EventDispatcher {
        /**
                * The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.
                * @type {Number}
                * @default 1
                */
        alpha: number;
        /**
             * If a cache is active, this returns the canvas that holds the image of this display object.
             * This will be a HTMLCanvasElement unless special cache rules have been deliberately enabled for this cache.
             * @see {@link DisplayObject#cache}
             * @type {HTMLCanvasElement|WebGLTexture|Object}
             * @default null
             * @readonly
             */
        readonly cacheCanvas: HTMLCanvasElement | WebGLTexture;
        /**
    * If a cache has been made, this returns the class that is managing the cacheCanvas and its properties.
    * Use this to control, inspect, and change the cache. In special circumstances this may be a modified or subclassed BitmapCache.
    * @see {@link BitmapCache}
    * @type {BitmapCache}
    * @default null
    * @readonly
    */
        bitmapCache: BitmapCache;
        /**
                * Unique ID for this display object. Makes display objects easier for some uses.
                * @type {Number}
                * @default -1
                */
        id: number;
        /**
            * Indicates whether to include this object when running mouse interactions. Setting this to `false` for children
            * of a {@link Container} will cause events on the Container to not fire when that child is
            * clicked. Setting this property to `false` does not prevent the {@link Container#getObjectsUnderPoint}
            * method from returning the child.
            * @type {Boolean}
            * @default true
            */
        mouseEnabled: boolean;
        /**
            * If false, the tick will not run on this display object (or its children). This can provide some performance benefits.
            * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates
            * on some display objects (ex. Sprite & MovieClip frame advancing, and DOMElement display properties).
            * @type Boolean
            * @default true
            */
        tickEnabled: boolean;
        /**
            * A reference to the {@link Container} or {@link Stage} object that
            * contains this display object, or null if it has not been added to one.
            * @type {Container}
            * @default null
            * @readonly
            */
        parent: Container;
        /**
         * The left offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate
         * around its center, you would set regX and {@link DisplayObject#regY} to 50.
         * Cached object's registration points should be set based on pre-cache conditions, not cached size.
         * @type {Number}
         * @default 0
         */
        regX: number;
        /**
            * The y offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate around
            * its center, you would set {@link DisplayObject#regX} and regY to 50.
            * Cached object's registration points should be set based on pre-cache conditions, not cached size.
            * @type {Number}
            * @default 0
            */
        regY: number;
        /**
            * The rotation in degrees for this display object.
            * @type {Number}
            * @default 0
            */
        rotation: number;
        /**
            * The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display
            * object to twice its nominal width. To horizontally flip an object, set the scale to a negative number.
            * @type {Number}
            * @default 1
            */
        scaleX: number;
        /**
            * The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display
            * object to half its nominal height. To vertically flip an object, set the scale to a negative number.
            * @type {Number}
            * @default 1
            */
        scaleY: number;
        /**
            * The factor to skew this display object horizontally.
            * @type {Number}
            * @default 0
            */
        skewX: number;
        /**
            * The factor to skew this display object vertically.
            * @type {Number}
            * @default 0
            */
        skewY: number;
        /**
            * A shadow object that defines the shadow to render on this display object. Set to `null` to remove a shadow. If
            * null, this property is inherited from the parent container.
            * @type {Shadow}
            * @default null
            */
        shadow: Shadow;
        /**
            * Indicates whether this display object should be rendered to the canvas and included when running the Stage
            * {@link Container#getObjectsUnderPoint} method.
            * @type {Boolean}
            * @default true
            */
        visible: boolean;
        /**
            * The x (horizontal) position of the display object, relative to its parent.
            * @type {Number}
            * @default 0
            */
        x: number;
        /** The y (vertical) position of the display object, relative to its parent.
            * @type {Number}
            * @default 0
            */
        y: number;
        /**
            * If set, defines the transformation for this display object, overriding all other transformation properties
            * (x, y, rotation, scale, skew).
            * @type {Matrix2D}
            * @default null
            */
        transformMatrix: Matrix2D;
        /**
            * The composite operation indicates how the pixels of this display object will be composited with the elements
            * behind it. If `null`, this property is inherited from the parent container.
            * @see {@link https://html.spec.whatwg.org/multipage/scripting.html#dom-context-2d-globalcompositeoperation "WHATWG spec on compositing"}
            * @see {@link https://drafts.fxtf.org/compositing/ "W3C draft on compositing and blending"}
            * @type {String}
            * @default null
            */
        compositeOperation: string;
        /**
            * Indicates whether the display object should be drawn to a whole pixel when {@link Stage.snapToPixelEnabled} is true.
            * To enable/disable snapping on whole categories of display objects, set this value on the prototype.
            * (ex. Text.prototype.snapToPixel = true).
            * @type {Boolean}
            * @default true
            */
        snapToPixel: boolean;
        /**
            * An array of {@link Filter} objects to apply to this display object. Filters are only applied/updated when {@link DisplayObject#cache}
            * or {@link DisplayObject#updateCache} is called on the display object, and only apply to the area that is cached.
            * @type {Array<Filter>}
            * @default null
            */
        filters: Array<Filter>;
        /**
            * A Shape instance that defines a vector mask (clipping path) for this display object. The shape's transformation
            * will be applied relative to the display object's parent coordinates (as if it were a child of the parent).
            * @type {Shape}
            * @default null
            */
        mask: Shape;
        /**
            * A display object that will be tested when checking mouse interactions or testing {@link Container#getObjectsUnderPoint}.
            * The hit area will have its transformation applied relative to this display object's coordinate space (as though
            * the hit test object were a child of this display object and relative to its regX/Y). The hitArea will be tested
            * using only its own `alpha` value regardless of the alpha value on the target display object, or the target's
            * ancestors (parents).
            *
            * If set on a {@link Container}, children of the Container will not receive mouse events.
            * This is similar to setting {@link DisplayObject#mouseChildren} to false.
            *
            * Note that hitArea is NOT currently used by the `hitTest()` method, nor is it supported for {@link Stage}.
            * @type {DisplayObject}
            * @default null
            */
        hitArea: DisplayObject;
        /**
            * A CSS cursor (ex. "pointer", "help", "text", etc) that will be displayed when the user hovers over this display
            * object. You must enable mouseover events using the {@link Stage#enableMouseOver} method to
            * use this property. Setting a non-null cursor on a Container will override the cursor set on its descendants.
            * @type {String}
            * @default null
            */
        cursor: string;
        tag: any;
        /**
            * @protected
            * @type {DisplayProps}
            * @default {DisplayProps}
            */
        protected _props: DisplayProps;
        /**
            * @protected
            * @type {Rectangle}
            * @default {Rectangle}
            */
        protected _rectangle: CGRectangle;
        /**
            * @protected
            * @type {Rectangle}
            * @default null
            */
        protected _bounds: CGRectangle;
        /**
            * Where StageGL should look for required display properties, matters only for leaf display objects. Containers
            * or cached objects won't use this property, it's for native display of terminal elements.
            * @protected
            * @type {Number}
            * @default 0
            */
        protected _webGLRenderStyle: number;
        /**
         * Enum like property for determining StageGL render lookup, i.e. where to expect properties.
         * @protected
         * @static
         * @type {Number}
         */
        static _StageGL_NONE: number;
        /**
                * Storage for the calculated position of an object in StageGL. If not using StageGL, you can null it to save memory.
                * @protected
                * @type {easeljsMatrix2D}
                * @default {Matrix2D}
                */
        protected _glMtx: Matrix2D;
        /**
         * {@link Stage#snapToPixelEnabled} is temporarily copied here during a draw to provide global access.
         * @protected
         * @static
         * @type {Boolean}
         * @default false
         */
        static _snapToPixelEnabled: boolean;
        /**
         * @type {CanvasRenderingContext2D}
         * @static
         * @protected
         */
        static _hitTestContext: CanvasRenderingContext2D;
        /**
         * Suppresses errors generated when using features like hitTest, mouse events, and {@link Container#getObjectsUnderPoint}
         * with cross domain content.
         * @static
         * @type {Boolean}
         * @default false
         */
        static suppressCrossDomainErrors: boolean;
        /**
         * Listing of mouse event names. Used in _hasMouseEventListener.
         * @protected
         * @static
         * @type {Array}
         */
        static _MOUSE_EVENTS: Array<string>;
        /**
         * Enum like property for determining StageGL render lookup, i.e. where to expect properties.
         * @protected
         * @static
         * @type {Number}
         */
        static _StageGL_SPRITE: number;
        /**
         * Enum like property for determining StageGL render lookup, i.e. where to expect properties.
         * @protected
         * @static
         * @type {Number}
         */
        static _StageGL_BITMAP: number;
        /**
         * @type {HTMLCanvasElement|Object}
         * @static
         * @protected
         */
        static _hitTestCanvas: HTMLCanvasElement;
        constructor();
        /**
            * Returns the {@link Stage} instance that this display object will be rendered on, or null if it has not been added to one.
            * @type {Stage}
            * @readonly
            */
        get stage(): Stage;
        /**
            * Set both the {@link DisplayObject#scaleX} and the {@link DisplayObject#scaleY} property to the same value.
            * @type {Number}
            * @default 1
            */
        set scale(value: number);
        /**
            * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
            * This does not account for whether it would be visible within the boundaries of the stage.
            *
            * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
            * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
            */
        isVisible(): boolean;
        /**
            * Alias for {@link DisplayObject#drawCache}. Use drawCache() directly from a grandchild to bypass
            * the middle parent's draw().
            *
            * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
            * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
            * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
            * @return {Boolean}
            */
        draw(ctx: CanvasRenderingContext2D, ignoreCache?: boolean): boolean;
        /**
            * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
            * Returns `true` if the draw was handled (useful for overriding functionality).
            *
            * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
            * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
            * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
            * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
            * @return {Boolean}
            */
        drawCache(ctx: CanvasRenderingContext2D, ignoreCache?: boolean): boolean;
        /**
            * Applies this display object's `transformation`, `alpha`, `globalCompositeOperation`, `mask` (clipping path), and `shadow`
            * to the specified context. This is typically called prior to {@link DisplayObject#draw}.
            * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.
            */
        updateContext(ctx: CanvasRenderingContext2D): void;
        /**
            * Draws the display object into a new element, which is then used for subsequent draws. Intended for complex content
            * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),
            * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The
            * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must manually
            * update the cache by calling `updateCache()` again. You must specify the cached area via the x, y, w, and h
            * parameters. This defines the rectangle that will be rendered and cached using this display object's coordinates.
            *
            * Filters need to be defined <em>before</em> the cache is applied or you will have to call updateCache after
            * application. Check out the {@link Filter} class for more information. Some filters
            * (ex. {@link BlurFilter}) may not work as expected in conjunction with the scale param.
            *
            * Usually, the resulting cacheCanvas will have the dimensions width * scale, height * scale, however some filters (ex. BlurFilter)
            * will add padding to the canvas dimensions.
            *
            * In previous versions, caching was handled on DisplayObject but has since been moved to {@link BitmapCache}.
            * This allows for easier interaction and alternate cache methods like WebGL with {@link StageGL}.
            * For more information on the options object, see the {@link BitmapCache#define}.
            *
            * @example
            * const shape = new Shape();
            * shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 25);
            * shape.cache(-25, -25, 50, 50);
            *
            * @param {Number} x The x coordinate origin for the cache region.
            * @param {Number} y The y coordinate origin for the cache region.
            * @param {Number} width The width of the cache region.
            * @param {Number} height The height of the cache region.
            * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using
            * 	myShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate
            * 	cached elements with greater fidelity.
            * @param {Object} [options] Specify additional parameters for the cache logic
            */
        cache(x: float, y: float, width: float, height: float, scale: number | undefined, options: any): void;
        /**
            * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.
            * If `compositeOperation` is null the current cache will be cleared prior to drawing. Otherwise the display object
            * will be drawn over the existing cache using the specified `compositeOperation`.
            *
            * In previous versions caching was handled on DisplayObject but has since been moved to {@link BitmapCache}
            * This allows for easier interaction and alternate cache methods like WebGL and {@link StageGL}.
            *
            * @example
            * // clear current graphics
            * shapeInstance.clear();
            * // draw some new instructions
            * shapeInstance.setStrokeStyle(3).beginStroke("#ff0000").moveTo(100, 100).lineTo(200,200);
            * // update cache, new line will be drawn on top of the old one
            * shapeInstance.updateCache();
            *
            * @see {@link https://html.spec.whatwg.org/multipage/scripting.html#dom-context-2d-globalcompositeoperation "WHATWG spec on compositing"}
            * @param {String} [compositeOperation] The composite operation to use, or nul to clear it
            */
        updateCache(compositeOperation: string): void;
        /**
            * Clears the current cache.
            * @see {@link DisplayObject#cache}
            */
        uncache(): void;
        /**
            * Returns a data URL for the cache, or null if this display object is not cached.
            * Only generated if the cache has changed, otherwise returns last result.
            * @param {} type
            * @params {} encoderOptions
            * @return {String} The image data url for the cache.
            */
        getCacheDataURL(type: string, encoderOptions: any): string;
        /**
            * Transforms the specified x and y position from the coordinate space of the display object
            * to the global (stage) coordinate space. For example, this could be used to position an HTML label
            * over a specific point on a nested display object. Returns a Point instance with x and y properties
            * correlating to the transformed coordinates on the stage.
            *
            * @example
            * displayObject.x = 300;
            * displayObject.y = 200;
            * stage.addChild(displayObject);
            * const point = displayObject.localToGlobal(100, 100);
            * // x=400, y=300
            *
            * @param {Number} x The x position in the source display object to transform.
            * @param {Number} y The y position in the source display object to transform.
            * @param {Point|Object} [pt=Point] An object to copy the result into.
            * @return {PointF} A Point instance with x and y properties correlating to the transformed coordinates
            * on the stage.
            */
        localToGlobal(x: float, y: float, pt?: CGPoint): CGPoint;
        /**
            * Transforms the specified x and y position from the global (stage) coordinate space to the
            * coordinate space of the display object. For example, this could be used to determine
            * the current mouse position within the display object. Returns a Point instance with x and y properties
            * correlating to the transformed position in the display object's coordinate space.
            *
            * @example
            * displayObject.x = 300;
            * displayObject.y = 200;
            * stage.addChild(displayObject);
            * const point = displayObject.globalToLocal(100, 100);
            * // x=-200, y=-100
            *
            * @method globalToLocal
            * @param {Number} x The x position on the stage to transform.
            * @param {Number} y The y position on the stage to transform.
            * @param {Point|Object} [pt=Point] An object to copy the result into.
            * @return {Point} A Point instance with x and y properties correlating to the transformed position in the
            * display object's coordinate space.
            */
        globalToLocal(x: float, y: float, pt?: CGPoint): CGPoint;
        /**
            * Transforms the specified x and y position from the coordinate space of this display object to the coordinate
            * space of the target display object. Returns a Point instance with x and y properties correlating to the
            * transformed position in the target's coordinate space. Effectively the same as using the following code with
            * {@link DisplayObject#localToGlobal} and {@link DisplayObject#globalToLocal}.
            *
            * @example
            * let pt = this.localToGlobal(x, y);
            * pt = target.globalToLocal(pt.x, pt.y);
            *
            * @param {Number} x The x position in the source display object to transform.
            * @param {Number} y The y position on the source display object to transform.
            * @param {DisplayObject} target The target display object to which the coordinates will be transformed.
            * @param {Point|Object} [pt=Point] An object to copy the result into.
            * @return {Point} Returns a Point instance with x and y properties correlating to the transformed position
            * in the target's coordinate space.
            */
        localToLocal(x: float, y: float, target: DisplayObject, pt?: CGPoint): CGPoint;
        /**
            * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.
            * Omitted parameters will have the default value set.
            *
            * @example
            * displayObject.setTransform(100, 100, 2, 2);
            *
            * @param {Number|Object} [x=0] The horizontal translation (x position) in pixels
            * @param {Number} [y=0] The vertical translation (y position) in pixels
            * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1
            * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1
            * @param {Number} [rotation=0] The rotation, in degrees
            * @param {Number} [skewX=0] The horizontal skew factor
            * @param {Number} [skewY=0] The vertical skew factor
            * @param {Number} [regX=0] The horizontal registration point in pixels
            * @param {Number} [regY=0] The vertical registration point in pixels
            * @return {DisplayObject} Returns this instance. Useful for chaining commands.
            * @chainable
         */
        setTransform(xOrParams?: float, y?: float, scaleX?: float, scaleY?: float, rotation?: float, skewX?: float, skewY?: float, regX?: float, regY?: float): DisplayObject;
        /**
            * Returns a matrix based on this object's current transform.
            * @param {Matrix2D} [matrix=Matrix2D] A Matrix2D object to populate with the calculated values. If null, a new
            * Matrix object is returned.
            * @return {Matrix2D} A matrix representing this display object's transform.
            */
        getMatrix(matrix?: Matrix2D): Matrix2D;
        /**
            * Generates a Matrix2D object representing the combined transform of the display object and all of its
            * parent Containers up to the highest level ancestor (usually the {@link Stage}). This can
            * be used to transform positions between coordinate spaces, such as with {@link DisplayObject#localToGlobal}
            * and {@link DisplayObject#globalToLocal}.
            * @param {Matrix2D} [matrix=Matrix2D] A Matrix2D object to populate with the calculated values.
            * If null, a new Matrix2D object is returned.
            * @return {Matrix2D} The combined matrix.
            */
        getConcatenatedMatrix(matrix?: Matrix2D): Matrix2D;
        /**
            * Generates a DisplayProps object representing the combined display properties of the  object and all of its
            * parent Containers up to the highest level ancestor (usually the {@link Stage}).
            * @param {DisplayProps} [props=DisplayProps] A DisplayProps object to populate with the calculated values.
            * If null, a new DisplayProps object is returned.
            * @return {DisplayProps} The combined display properties.
            */
        getConcatenatedDisplayProps(props?: DisplayProps): DisplayProps;
        /**
            * Tests whether the display object intersects the specified point in local coordinates (ie. draws a pixel with alpha > 0 at
            * the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation of the display object.
            *
            * Please note that shape-to-shape collision is not currently supported by
            *
            * @example
            * stage.addEventListener("stagemousedown", event => {
            *   const didHit = myShape.hitTest(event.stageX, event.stageY);
            * });
            *
            * @param {Number} x The x position to check in the display object's local coordinates.
            * @param {Number} y The y position to check in the display object's local coordinates.
            * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified
            * local Point.
         */
        hitTest(x: float, y: float): boolean;
        /**
            * Provides a chainable shortcut method for setting a number of properties on the instance.
            *
            * @example
            * const myGraphics = new Graphics().beginFill("#ff0000").drawCircle(0, 0, 25);
            * const shape = new Shape().set({ graphics: myGraphics, x: 100, y: 100, alpha: 0.5 });
            *
            * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
            * @return {DisplayObject} Returns the instance the method is called on (useful for chaining calls.)
            * @chainable
         */
        set(props: any): DisplayObject;
        /**
            * Returns a rectangle representing this object's bounds in its local coordinate system (ie. with no transformation).
            * Objects that have been cached will return the bounds of the cache.
            *
            * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use
            * {@link DisplayObject#setBounds} so that they are included when calculating Container bounds.
            *
            * <table>
            * 	<tr><td><b>All</b></td><td>
            * 		All display objects support setting bounds manually using setBounds(). Likewise, display objects that
            * 		have been cached using cache() will return the bounds of their cache. Manual and cache bounds will override
            * 		the automatic calculations listed below.
            * 	</td></tr>
            * 	<tr><td><b>Bitmap</b></td><td>
            * 		Returns the width and height of the {{#crossLink "Bitmap/sourceRect"}}{{/crossLink}} (if specified) or image,
            * 		extending from (x=0,y=0).
            * 	</td></tr>
            * 	<tr><td><b>Sprite</b></td><td>
            * 		Returns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified
            * 		in the spritesheet data. See also {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}}
            * 	</td></tr>
            * 	<tr><td><b>Container</b></td><td>
            * 		Returns the aggregate (combined) bounds of all children that return a non-null value from `getBounds()`.
            * 	</td></tr>
            * 	<tr><td><b>Shape</b></td><td>
            * 		Does not currently support automatic bounds calculations. Use `setBounds()` to manually define bounds.
            * 	</td></tr>
            * 	<tr><td><b>Text</b></td><td>
            * 		Returns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height)
            * 		are not, especially when using {{#crossLink "Text/textBaseline:property"}}{{/crossLink}} values other than "top".
            * 	</td></tr>
            * 	<tr><td><b>BitmapText</b></td><td>
            * 		Returns approximate bounds. Values will be more accurate if spritesheet frame registration points are close
            * 		to (x=0,y=0).
            * 	</td></tr>
         * </table>
            *
            * @example <caption>Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and
            * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the
            * bounds explicitly<caption>
            *
            * const bounds = obj.getBounds();
            * obj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
            * // getBounds will now use the set values, instead of recalculating
            *
            * @example <caption>To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
            * values if you need to retain it</caption>
            *
            * const bounds = obj.getBounds().clone();
            * // OR:
            * myRect.copy(obj.getBounds());
            *
            * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this
            * object.
            */
        getBounds(): CGRectangle;
        /**
            * Returns a rectangle representing this object's bounds in its parent's coordinate system (ie. with transformations applied).
            * Objects that have been cached will return the transformed bounds of the cache.
            *
            * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use
            * {@link DisplayObject#setBounds} so that they are included when calculating Container
            * bounds.
            *
            * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
            * values if you need to retain it.
            *
            * Container instances calculate aggregate bounds for all children that return bounds via getBounds.
            * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.
            */
        getTransformedBounds(): CGRectangle;
        /**
            * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &
            * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always
            * override calculated bounds.
            *
            * The bounds should be specified in the object's local (untransformed) coordinates. For example, a Shape instance
            * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).
            * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.
            * @param {Number} y The y origin of the bounds.
            * @param {Number} width The width of the bounds.
            * @param {Number} height The height of the bounds.
            */
        setBounds(x?: float, y?: float, width?: float, height?: float): void;
        /**
            * Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are
            * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements
            * are copied by reference (masks, individual filter instances, hit area)
            * @return {DisplayObject} A clone of the current DisplayObject instance.
            */
        clone(test?: boolean): DisplayObject;
        /**
            * Returns a string representation of this object.
            * @return {String} a string representation of the instance.
            */
        toString(): string;
        /**
            * Called before the object gets drawn and is a chance to ensure the display state of the object is correct.
            * Mostly used by {@link MovieClip} and {@link BitmapText} to
            * correct their internal state and children prior to being drawn.
            *
            * Is manually called via draw in a {@link Stage} but is automatically called when
            * present in a {@link StageGL} instance.
            *
            * @method _updateState
            * @protected
            */
        protected _updateState(): void;
        /**
            * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject
            * instance copied into.
            * @return {DisplayObject} o
            * @protected
            */
        protected _cloneProps(o: DisplayObject): DisplayObject;
        /**
            * @protected
            * @param {CanvasRenderingContext2D} ctx
            * @param {Shadow} shadow
            */
        protected _applyShadow(ctx: CanvasRenderingContext2D, shadow?: Shadow): void;
        /**
            * @param {Object} evt An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
            * @protected
            */
        protected _tick(evt: any): void;
        /**
            * @protected
            * @param {CanvasRenderingContext2D} ctx
            * @return {Boolean}
            */
        protected _testHit(ctx: CanvasRenderingContext2D): boolean;
        /**
            * @param {Matrix2D} matrix
            * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
            * @return {Rectangle}
            * @protected
            */
        protected _getBounds(matrix?: Matrix2D, ignoreTransform?: boolean): CGRectangle;
        /**
            * @param {Rectangle} bounds
            * @param {Matrix2D} matrix
            * @param {Boolean} ignoreTransform
            * @return {Rectangle}
            * @protected
            */
        protected _transformBounds(bounds: CGRectangle, matrix: Matrix2D, ignoreTransform: boolean): CGRectangle;
        /**
            * Indicates whether the display object has any mouse event listeners or a cursor.
            * @return {Boolean}
            * @protected
            */
        protected _hasMouseEventListener(): boolean;
}

/**
    * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a
    * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {@link Graphics#draw}
    * directly, or it can be used with the {@link Shape} object to draw vector graphics within the
    * context of an EaselJS display list.
    *
    * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the "Graphics API"), or
    * instantiating Graphics command objects and adding them to the graphics queue via {@link Graphics#append}.
    * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.
    *
    * <h4>Tiny API</h4>
    * The Graphics class also includes a "tiny API", which is one or two-letter methods that are shortcuts for all of the
    * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS
    * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected
    * descriptions in the docs.
    *
    * <table>
    *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>
    *     <tr><td>mt</td><td>{@link Graphics#moveTo}</td>
    *     <td>lt</td> <td>{@link Graphics#lineTo}</td></tr>
    *     <tr><td>a/at</td><td>{@link Graphics#arc} / {@link Graphics#arcTo}</td>
    *     <td>bt</td><td>{@link Graphics#bezierCurveTo}</td></tr>
    *     <tr><td>qt</td><td>{@link Graphics#quadraticCurveTo} (also curveTo)</td>
    *     <td>r</td><td>{@link Graphics#rect}</td></tr>
    *     <tr><td>cp</td><td>{@link Graphics#closePath}</td>
    *     <td>c</td><td>{@link Graphics#clear}</td></tr>
    *     <tr><td>f</td><td>{@link Graphics#beginFill}</td>
    *     <td>lf</td><td>{@link Graphics#beginLinearGradientFill}</td></tr>
    *     <tr><td>rf</td><td>{@link Graphics#beginRadialGradientFill}</td>
    *     <td>bf</td><td>{@link Graphics#beginBitmapFill}</td></tr>
    *     <tr><td>ef</td><td>{@link Graphics#endFill}</td>
    *     <td>ss / sd</td><td>{@link Graphics#setStrokeStyle} / {@link Graphics#setStrokeDash}</td></tr>
    *     <tr><td>s</td><td>{@link Graphics#beginStroke}</td>
    *     <td>ls</td><td>{@link Graphics#beginLinearGradientStroke}</td></tr>
    *     <tr><td>rs</td><td>{@link Graphics#beginRadialGradientStroke}</td>
    *     <td>bs</td><td>{@link Graphics#beginBitmapStroke}</td></tr>
    *     <tr><td>es</td><td>{@link Graphics#endStroke}</td>
    *     <td>dr</td><td>{@link Graphics#drawRect}</td></tr>
    *     <tr><td>rr</td><td>{@link Graphics#drawRoundRect}</td>
    *     <td>rc</td><td>{@link Graphics#drawRoundRectComplex}</td></tr>
    *     <tr><td>dc</td><td>{@link Graphics#drawCircle}</td>
    *     <td>de</td><td>{@link Graphics#drawEllipse}</td></tr>
    *     <tr><td>dp</td><td>{@link Graphics#drawPolyStar}</td>
    *     <td>p</td><td>{@link Graphics#decodePath}</td></tr>
    * </table>
    *
    * @example
    * var g = new Graphics();
    * g.setStrokeStyle(1);
    * g.beginStroke("#000000");
    * g.beginFill("red");
    * g.drawCircle(0,0,30);
    *
    * @example
    * // All drawing methods in Graphics return the Graphics instance, so they can be chained together.
    * graphics.beginStroke("red").beginFill("blue").drawRect(20, 20, 100, 50);
    *
    * @example
    * // Each graphics API call generates a command object (see below). The last command to be created can be accessed via .command
    * let fillCommand = graphics.beginFill("red").command;
    * fillCommand.style = "blue";
    * // or change it to a bitmap fill:
    * fillCommand.bitmap(img);
    *
    * @example
    * // For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly.
    * // In this case, you need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:
    *
    * // start a new path. Graphics.beginCmd is a reusable BeginPath instance:
    * graphics.append(Graphics.beginCmd);
    * // we need to define the path before applying the fill:
    * let circle = new Graphics.Circle(0,0,30);
    * graphics.append(circle);
    * // fill the path we just defined:
    * let fill = new Graphics.Fill("red");
    * graphics.append(fill);
    *
    * // These approaches can be used together, for example to insert a custom command:
    * graphics.beginFill("red");
    * let customCommand = new CustomSpiralCommand(etc);
    * graphics.append(customCommand);
    * graphics.beginFill("blue");
    * graphics.drawCircle(0, 0, 30);
    *
    * @example <caption>Using the Tiny API</caption>
    * graphics.s("red").f("blue").r(20, 20, 100, 50);
    *
    * @see {@link Graphics#append}
    * @memberof easeljs
    */
export class Graphics {
        /**
            * Holds a reference to the last command that was created or appended. For example, you could retain a reference
            * to a Fill command in order to dynamically update the color later by using:
            *
            * @example
            * let fill = graphics.beginFill("red").command;
            * // update color later:
            * fill.style = "yellow";
            *
            * @type {Object}
            * @default null
            */
        command: ICommand;
        /**
            * @protected
            * @type {Graphics.Stroke}
            */
        protected _stroke: Stroke;
        /**
            * @protected
            * @type {Graphics.StrokeStyle}
            */
        protected _strokeStyle: StrokeStyle;
        /**
            * @protected
            * @type {Graphics.StrokeStyle}
            */
        protected _oldStrokeStyle: any;
        /**
            * @protected
            * @type {Graphics.StrokeDash}
            */
        protected _strokeDash: StrokeDash;
        /**
            * @protected
            * @type {Graphics.StrokeDash}
            */
        protected _oldStrokeDash: any;
        /**
            * @protected
            * @type {Graphics.Fill}
            */
        protected _fill: Fill;
        /**
            * @protected
            * @type {Boolean}
            */
        protected _strokeIgnoreScale: boolean;
        /**
            * Indicates the last instruction index that was committed.
            * @protected
            * @type {Number}
            * @default 0
            */
        protected _commitIndex: number;
        /**
            * @protected
            * @type {Array}
            */
        protected _instructions: ICommand[];
        /**
            * Uncommitted instructions.
            * @protected
            * @type {Array}
            */
        protected _activeInstructions: ICommand[];
        /**
            * This indicates that there have been changes to the activeInstruction list since the last updateInstructions call.
            * @protected
            * @type {Boolean}
            * @default false
            */
        protected _dirty: boolean;
        /**
            * Index to draw from if a store operation has happened.
            * @protected
            * @type {Number}
            * @default 0
            */
        protected _storeIndex: number;
        /**
            * Maps the familiar ActionScript `curveTo()` method to the functionally similar {@link Graphics#quadraticCurveTo} method.
            * @param {Number} cpx
            * @param {Number} cpy
            * @param {Number} x
            * @param {Number} y
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        protected curveTo: (cpx: float, cpy: float, x: float, y: float) => Graphics;
        /**
            * Maps the familiar ActionScript `drawRect()` method to the functionally similar {@link Graphics#rect} method.
            * @param {Number} x
            * @param {Number} y
            * @param {Number} w Width of the rectangle
            * @param {Number} h Height of the rectangle
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        drawRect: (x: float, y: float, w: float, h: float) => Graphics;
        protected mt: (x: float, y: float) => Graphics;
        protected lt: (x: float, y: float) => Graphics;
        protected at: (x1: float, y1: float, x2: float, y2: float, radius: float) => Graphics;
        protected bt: (cp1x: float, cp1y: float, cp2x: float, cp2y: float, x: float, y: float) => Graphics;
        protected qt: (cpx: float, cpy: float, x: float, y: float) => Graphics;
        protected a: (x: float, y: float, radius: float, startAngle: float, endAngle: float, anticlockwise: boolean) => Graphics;
        protected r: (x: float, y: float, w: float, h: float) => Graphics;
        protected cp: () => Graphics;
        protected c: () => Graphics;
        protected f: (color: string) => Graphics;
        protected lf: (colors: string[], ratios: float[], x0: float, y0: float, x1: float, y1: float) => Graphics;
        protected rf: (colors: string[], ratios: float[], x0: float, y0: float, r0: float, x1: float, y1: float, r1: float) => Graphics;
        protected bf: (image: any, repetition: string, matrix: Matrix2D) => Graphics;
        protected ef: () => Graphics;
        protected ss: (thickness: any, caps?: number, joints?: number, miterLimit?: number, ignoreScale?: boolean) => Graphics;
        protected sd: (segments: any, offset?: number) => Graphics;
        protected s: (color: any) => Graphics;
        protected ls: (colors: any, ratios: any, x0: any, y0: any, x1: any, y1: any) => Graphics;
        protected rs: (colors: any, ratios: any, x0: any, y0: any, r0: any, x1: any, y1: any, r1: any) => Graphics;
        protected bs: (image: any, repetition?: string) => Graphics;
        protected es: () => Graphics;
        protected dr: any;
        protected rr: (x: any, y: any, w: any, h: any, radius: any) => Graphics;
        protected rc: (x: any, y: any, w: any, h: any, radiusTL: any, radiusTR: any, radiusBR: any, radiusBL: any) => Graphics;
        protected dc: (x: any, y: any, radius: any) => Graphics;
        protected de: (x: any, y: any, w: any, h: any) => Graphics;
        protected dp: (x: any, y: any, radius: any, sides: any, pointSize: any, angle: any) => Graphics;
        protected p: (str: any) => Graphics;
        static beginCmd: ICommand;
        static _BASE_64: any;
        static _ctx: any;
        static _STROKE_CAPS_MAP: any;
        static _STROKE_JOINTS_MAP: any;
        constructor();
        /**
            * Returns a CSS compatible color string based on the specified RGB numeric color values in the format
            * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".
            * It also supports passing a single hex color value as the first param, and an optional alpha value as the second
            * param.
            *
            * @example
            * Graphics.getRGB(50, 100, 150, 0.5); // rgba(50,100,150,0.5)
            * Graphics.getRGB(0xFF00FF, 0.2); // rgba(255,0,255,0.2)
            *
            * @static
            * @param {Number} r The red component for the color, between 0 and 0xFF (255).
            * @param {Number} g The green component for the color, between 0 and 0xFF (255).
            * @param {Number} b The blue component for the color, between 0 and 0xFF (255).
            * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
            * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format
            * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".
            */
        static getRGB(r: number, g: number, b: number, alpha: number): string;
        /**
            * Returns a CSS compatible color string based on the specified HSL numeric color values in the format "hsla(360,100,100,1.0)",
            * or if alpha is null then in the format "hsl(360,100,100)".
            *
            * @example
            * Graphics.getHSL(150, 100, 70); // hsl(150,100,70)
            *
            * @static
            * @param {Number} hue The hue component for the color, between 0 and 360.
            * @param {Number} saturation The saturation component for the color, between 0 and 100.
            * @param {Number} lightness The lightness component for the color, between 0 and 100.
            * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
            * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format
            * "hsla(360,100,100,1.0)", or if alpha is null then in the format "hsl(360,100,100)".
            */
        static getHSL(hue: number, saturation: number, lightness: number, alpha: number): string;
        /**
            * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)
            * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.
            *
            * This property is mainly intended for introspection of the instructions (ex. for graphics export).
            * @type {Array}
            * @readonly
            */
        get instructions(): ICommand[];
        /**
            * Returns true if this Graphics instance has no drawing commands.
            * @return {Boolean} Returns true if this Graphics instance has no drawing commands.
            */
        isEmpty(): boolean;
        /**
            * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
            * Returns true if the draw was handled (useful for overriding functionality).
            *
            * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
            *
            * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
            * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.
            */
        draw(ctx: CanvasRenderingContext2D, data: any): void;
        drawTGI(tg: TGI, data: any): void;
        /**
            * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and
            * stroke descriptions. Used for `DisplayObject.mask` to draw the clipping path, for example.
            *
            * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
            *
            * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
            */
        drawAsPath(ctx: CanvasRenderingContext2D): void;
        /**
            * Moves the drawing point to the specified position.
            * A tiny API method "mt" also exists.
            * @param {Number} x The x coordinate the drawing point should move to.
            * @param {Number} y The y coordinate the drawing point should move to.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
            * @chainable
            */
        moveTo(x: float, y: float): Graphics;
        /**
            * Draws a line from the current drawing point to the specified position, which become the new current drawing
            * point. Note that you *must* call {@link Graphics#moveTo} before the first `lineTo()`.
            * A tiny API method "lt" also exists.
            * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths) "WHATWG spec"}
            * @param {Number} x The x coordinate the drawing point should draw to.
            * @param {Number} y The y coordinate the drawing point should draw to.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        lineTo(x: float, y: float): Graphics;
        /**
    * Draws a line from the current drawing point to the specified position, which become the new current drawing
    * point. Note that you *must* call {@link Graphics#moveTo} before the first `lineTo()`.
    * A tiny API method "lt" also exists.
    * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths) "WHATWG spec"}
    * @param {Number} x The x coordinate the drawing point should draw to.
    * @param {Number} y The y coordinate the drawing point should draw to.
    * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
    * @chainable
    */
        drawLine(pen: Pen, x: float, y: float, x1: float, y1: float): Graphics;
        /**
            * Draws an arc with the specified control points and radius.
            * A tiny API method "at" also exists.
            * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto "WHATWG spec"}
            * @param {Number} x1
            * @param {Number} y1
            * @param {Number} x2
            * @param {Number} y2
            * @param {Number} radius
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        arcTo(x1: float, y1: float, x2: float, y2: float, radius: float): Graphics;
        /**
            * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y).
            * A tiny API method "a" also exists.
            *
            * @example
            * // draw a full circle with a radius of 20 centered at (100, 100)
            * arc(100, 100, 20, 0, Math.PI*2);
            *
            * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc "WHATWG spec"}
            * @param {Number} x
            * @param {Number} y
            * @param {Number} radius
            * @param {Number} startAngle Measured in radians.
            * @param {Number} endAngle Measured in radians.
            * @param {Boolean} anticlockwise
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        arc(x: float, y: float, radius: float, startAngle: float, endAngle: float, anticlockwise: boolean): Graphics;
        /**
            * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy).
            * A tiny API method "qt" also exists.
            * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto "WHATWG spec"}
            * @param {Number} cpx
            * @param {Number} cpy
            * @param {Number} x
            * @param {Number} y
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        quadraticCurveTo(cpx: float, cpy: float, x: float, y: float): Graphics;
        /**
            * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x, cp2y).
            * A tiny API method "bt" also exists.
            * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto "WHATWG spec"}
            * @param {Number} cp1x
            * @param {Number} cp1y
            * @param {Number} cp2x
            * @param {Number} cp2y
            * @param {Number} x
            * @param {Number} y
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        bezierCurveTo(cp1x: float, cp1y: float, cp2x: float, cp2y: float, x: float, y: float): Graphics;
        /**
            * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.
            * A tiny API method "r" also exists.
            * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect "WHATWG spec"}
            * @param {Number} x
            * @param {Number} y
            * @param {Number} w Width of the rectangle
            * @param {Number} h Height of the rectangle
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        rect(x: float, y: float, w: float, h: float): Graphics;
        /**
            * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified
            * since the fill or stroke was last set.
            * A tiny API method "cp" also exists.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        closePath(): Graphics;
        /**
            * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need
            * to be redefined to draw shapes following a clear call.
            * A tiny API method "c" also exists.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        clear(): Graphics;
        /**
            * Begins a fill with the specified color. This ends the current sub-path.
            * A tiny API method "f" also exists.
            * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
            * null will result in no fill.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        beginFill(color?: string): Graphics;
        /**
            * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1).
            * A tiny API method "lf" also exists.
            *
            * @example <caption>Define a black to white vertical gradient ranging from 20px to 120px, and draw a square to display it</caption>
            * graphics.beginLinearGradientFill(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
            *
            * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
            * drawing from red to blue.
            * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
            * the first color to 10% then interpolating to the second color at 90%.
            * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
            * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
            * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
            * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        beginLinearGradientFill(colors: string[], ratios: float[], x0: float, y0: float, x1: float, y1: float): Graphics;
        /**
            * Begins a radial gradient fill. This ends the current sub-path.
            * A tiny API method "rf" also exists.
            *
            * @example <caption>Define a red to blue radial gradient centered at (100, 100), with a radius of 50, and draw a circle to display it</caption>
            * graphics.beginRadialGradientFill(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);
            *
            * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
            * a gradient drawing from red to blue.
            * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
            * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
            * @param {Number} x0 Center position of the inner circle that defines the gradient.
            * @param {Number} y0 Center position of the inner circle that defines the gradient.
            * @param {Number} r0 Radius of the inner circle that defines the gradient.
            * @param {Number} x1 Center position of the outer circle that defines the gradient.
            * @param {Number} y1 Center position of the outer circle that defines the gradient.
            * @param {Number} r1 Radius of the outer circle that defines the gradient.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        beginRadialGradientFill(colors: string[], ratios: float[], x0: float, y0: float, r0: float, x1: float, y1: float, r1: float): Graphics;
        /**
            * Begins a pattern fill using the specified image. This ends the current sub-path.
            * A tiny API method "bf" also exists.
            * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
            * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
            * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
            * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
            * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
            * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
            * will be applied relative to the parent transform.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        beginBitmapFill(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, repetition: string, matrix: Matrix2D): Graphics;
        /**
            * Ends the current sub-path, and begins a new one with no fill. Functionally identical to `beginFill(null)`.
            * A tiny API method "ef" also exists.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        endFill(): Graphics;
        /**
            * Sets the stroke style.
            * A tiny API method "ss" also exists.
            *
            * @example
            * graphics.setStrokeStyle(8,"round").beginStroke("#F00");
            *
            * @param {Number} thickness The width of the stroke.
            * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
            * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
            * the tiny API.
            * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
            * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
            * for use with the tiny API.
            * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
            * controls at what point a mitered joint will be clipped.
            * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
            * of active transformations.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        setStrokeStyle(thickness: float, caps?: string | number, joints?: string | number, miterLimit?: number, ignoreScale?: boolean): Graphics;
        /**
            * Sets or clears the stroke dash pattern.
            * A tiny API method `sd` also exists.
            *
            * @example
            * graphics.setStrokeDash([20, 10], 0);
            *
            * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
            * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.
            * Passing null or an empty array will clear the existing stroke dash.
            * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        setStrokeDash(segments: number[], offset?: number): Graphics;
        /**
            * Begins a stroke with the specified color. This ends the current sub-path.
            * A tiny API method "s" also exists.
            *
            * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
            * null will result in no stroke.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        beginStroke(color?: string): Graphics;
        /**
            * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path.
            * A tiny API method "ls" also exists.
            *
            * @example <caption>Define a black to white vertical gradient ranging from 20px to 120px, and draw a square to display it</caption>
            * graphics.setStrokeStyle(10)
            *   .beginLinearGradientStroke(["#000","#FFF"], [0, 1], 0, 20, 0, 120)
            *   .drawRect(20, 20, 120, 120);
            *
            * @param {Array<String>} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
            * a gradient drawing from red to blue.
            * @param {Array<Number>} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
            * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
            * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
            * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
            * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
            * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        beginLinearGradientStroke(colors: string[], ratios: number[], x0: float, y0: float, x1: float, y1: float): Graphics;
        /**
            * Begins a radial gradient stroke. This ends the current sub-path.
            * A tiny API method "rs" also exists.
            *
            * @example <caption>Define a red to blue radial gradient centered at (100, 100), with a radius of 50, and draw a rectangle to display it</caption>
            * graphics.setStrokeStyle(10)
            *   .beginRadialGradientStroke(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50)
            *   .drawRect(50, 90, 150, 110);
            *
            * @param {Array<String>} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
            * a gradient drawing from red to blue.
            * @param {Array<Number>} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
            * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
            * to 100%.
            * @param {Number} x0 Center position of the inner circle that defines the gradient.
            * @param {Number} y0 Center position of the inner circle that defines the gradient.
            * @param {Number} r0 Radius of the inner circle that defines the gradient.
            * @param {Number} x1 Center position of the outer circle that defines the gradient.
            * @param {Number} y1 Center position of the outer circle that defines the gradient.
            * @param {Number} r1 Radius of the outer circle that defines the gradient.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        beginRadialGradientStroke(colors: string[], ratios: number[], x0: float, y0: float, r0: float, x1: float, y1: float, r1: float): Graphics;
        /**
            * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,
            * strokes do not currently support a matrix parameter due to limitations in the canvas API.
            * A tiny API method "bs" also exists.
            *
            * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
            * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
            * @param {String} [repetition="repeat"] Indicates whether to repeat the image in the fill area. One of
            * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        beginBitmapStroke(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, repetition?: string): Graphics;
        /**
            * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to `beginStroke(null)`.
            * A tiny API method "es" also exists.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        endStroke(): Graphics;
        /**
            * Draws a rounded rectangle with all corners with the specified radius.
            * @param {Number} x
            * @param {Number} y
            * @param {Number} w
            * @param {Number} h
            * @param {Number} radius Corner radius.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        drawRoundRect(x: float, y: float, w: float, h: float, radius: float): Graphics;
        /**
            * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii.
            * A tiny API method "rc" also exists.
            * @param {Number} x The horizontal coordinate to draw the round rect.
            * @param {Number} y The vertical coordinate to draw the round rect.
            * @param {Number} w The width of the round rect.
            * @param {Number} h The height of the round rect.
            * @param {Number} radiusTL Top left corner radius.
            * @param {Number} radiusTR Top right corner radius.
            * @param {Number} radiusBR Bottom right corner radius.
            * @param {Number} radiusBL Bottom left corner radius.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        drawRoundRectComplex(x: float, y: float, w: float, h: float, radiusTL: float, radiusTR: float, radiusBR: float, radiusBL: float): Graphics;
        /**
            * Draws a circle with the specified radius at (x, y).
            * A tiny API method "dc" also exists.
            *
            * @example
            * let g = new Graphics();
            * g.setStrokeStyle(1);
            * g.beginStroke(Graphics.getRGB(0,0,0));
            * g.beginFill(Graphics.getRGB(255,0,0));
            * g.drawCircle(0,0,3);
            * let s = new Shape(g);
            * s.x = 100;
            * s.y = 100;
            * stage.addChild(s);
            * stage.update();
            *
            * @param {Number} x x coordinate center point of circle.
            * @param {Number} y y coordinate center point of circle.
            * @param {Number} radius Radius of circle.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        drawCircle(x: float, y: float, radius: float): Graphics;
        /**
            * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {@link easels.Graphics#drawCircle},
            * except the width and height can be different.
            * A tiny API method "de" also exists.
            * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {@link easels.Graphics#drawCircle}
            * which draws from center.
            * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {@link easels.Graphics#drawCircle}
            * which draws from the center.
            * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
            * number.
            * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        drawEllipse(pen: Pen, x: float, y: float, w: float, h: float): Graphics;
        /**
            * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {@link easels.Graphics#drawCircle},
            * except the width and height can be different.
            * A tiny API method "de" also exists.
            * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {@link easels.Graphics#drawCircle}
            * which draws from center.
            * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {@link easels.Graphics#drawCircle}
            * which draws from the center.
            * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
            * number.
            * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        fillEllipse(brush: Brush, x: float, y: float, w: float, h: float): Graphics;
        /**
            * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of points.
            * A tiny API method "dp" also exists.
            *
            * @example <caption>Draw a 5 pointed star shape centered at 100, 100 and with a radius of 50</caption>
            * graphics.beginFill("#FF0").drawPolyStar(100, 100, 50, 5, 0.6, -90);
            * // Note: -90 makes the first point vertical
            *
            * @param {Number} x Position of the center of the shape.
            * @param {Number} y Position of the center of the shape.
            * @param {Number} radius The outer radius of the shape.
            * @param {Number} sides The number of points on the star or sides on the polygon.
            * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
            * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
            * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
            * directly to the right of the center.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        drawPolyStar(x: float, y: float, radius: float, sides: float, pointSize: float, angle: float): Graphics;
        /**
            * Appends a graphics command object to the graphics queue. Command objects expose an "exec" method
            * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into
            * {@link Graphics#draw}. The latter will usually be the Shape instance that called draw.
            *
            * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert
            * built-in or custom graphics commands.
            *
            * @example
            * // attach data to our shape, so we can access it during the draw:
            * shape.color = "red";
            *
            * // append a Circle command object:
            * shape.graphics.append(new Graphics.Circle(50, 50, 30));
            *
            * // append a custom command object with an exec method that sets the fill style
            * // based on the shape's data, and then fills the circle.
            * shape.graphics.append({
            *   exec: (ctx, shape) => {
            *     ctx.fillStyle = shape.color;
            *     ctx.fill();
            *   }
            * });
            *
            * @param {Object} command A graphics command object exposing an "exec" method.
            * @param {Boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        append(command: ICommand, clean?: boolean): Graphics;
        /**
            * Decodes a compact encoded path string into a series of draw instructions.
            * This format is not intended to be human readable, and is meant for use by authoring tools.
            * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw
            * commands.
            *
            * Each command is comprised of a single "header" character followed by a variable number of alternating x and y
            * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the
            * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4
            * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the
            * latter. Bits 5 and 6 are currently unused.
            *
            * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)
            * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the
            * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed
            * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the
            * case of move operations which are absolute, this value is a delta from the previous x or y position (as
            * appropriate).
            *
            * For example, the string "A3cAAMAu4AAA" represents a line starting at -150,0 and ending at 150,0.
            * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per
            * parameter.
            * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits
            * indicate 1500 tenths of a pixel.
            * <br />AA - 000000000000. Absolute y position of 0.
            * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.
            * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to
            * provide an absolute position of +150.0px.
            * <br />AAA - 000000000000000000. A y delta value of 0.
            *
            * A tiny API method "p" also exists.
            *
            * @param {String} str The path string to decode.
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        decodePath(str: string): Graphics;
        /**
            * Stores all graphics commands so they won't be executed in future draws. Calling store() a second time adds to
            * the existing store. This also affects `drawAsPath()`.
            *
            * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so
            * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all
            * of the vector instructions for later use (ex. scaling, modifying, or exporting).
            *
            * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing
            * the fill or stroke.
            *
            * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of
            * segments) are added to a Shape, it can be rasterized using {@link DisplayObject#updateCache},
            * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVGraphics.
            *
            * @example
            * // set up cache:
            * shape.cache(0,0,500,500,scale);
            *
            * // when the user drags, draw a new line:
            * shape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);
            * // then draw it into the existing cache:
            * shape.updateCache("source-over");
            * // store the new line, so it isn't redrawn next time:
            * shape.store();
            *
            * // then, when the window resizes, we can re-render at a different scale:
            * // first, unstore all our lines:
            * shape.unstore();
            * // then cache using the new scale:
            * shape.cache(0,0,500,500,newScale);
            * // finally, store the existing commands again:
            * shape.store();
            *
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        store(): Graphics;
        /**
            * Unstores any graphics commands that were previously stored using {@link Graphics#store}
            * so that they will be executed in subsequent draw calls.
            *
            * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
            * @chainable
            */
        unstore(): Graphics;
        /**
            * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.
            * @return {Graphics} A clone of the current Graphics instance.
            */
        clone(): Graphics;
        /**
            * Returns a string representation of this object.
            * @return {String} a string representation of the instance.
            */
        toString(): string;
        /**
            * @param {Boolean} commit
            * @protected
            */
        protected _updateInstructions(commit?: boolean): void;
        /**
            * @param {Graphics.Fill} fill
            * @protected
            */
        _setFill(fill: Fill): Graphics;
        /**
            * @param {Graphics.Stroke} stroke
            * @protected
            */
        _setStroke(stroke: Stroke): Graphics;
        static get LineTo(): typeof LineTo;
        static get MoveTo(): typeof MoveTo;
        static get ArcTo(): typeof ArcTo;
        static get Arc(): typeof Arc;
        static get QuadraticCurveTo(): typeof QuadraticCurveTo;
        static get BezierCurveTo(): typeof BezierCurveTo;
        static get Rect(): typeof Rect;
        static get ClosePath(): typeof ClosePath;
        static get BeginPath(): typeof BeginPath;
        static get Fill(): typeof Fill;
        static get Stroke(): typeof Stroke;
        static get StrokeStyle(): typeof StrokeStyle;
        static get StrokeDash(): typeof StrokeDash;
        static get RoundRect(): typeof RoundRect;
        static get Circle(): typeof Circle;
        static get Ellipse(): typeof Ellipse;
        static get PolyStar(): typeof PolyStar;
}
interface ICommand {
        exec(ctx: CanvasRenderingContext2D | TGI, data?: any): void;
}
/**
    * @see {@link Graphics#lineTo}
    * @alias Graphics.LineTo
    * @param {Number} x
    * @param {Number} y
    */
class LineTo implements ICommand {
        constructor(x: float, y: float);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#moveTo}
    * @alias Graphics.MoveTo
    * @param {Number} x
    * @param {Number} y
    */
class MoveTo implements ICommand {
        constructor(x: float, y: float);
        /**
            * @param {CanvasRenderingContext2D} ctx
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#arcTo}
    * @alias Graphics.ArcTo
    * @param {Number} x1
    * @param {Number} y1
    * @param {Number} x2
    * @param {Number} y2
    * @param {Number} radius
    */
class ArcTo implements ICommand {
        constructor(x1: float, y1: float, x2: float, y2: float, radius: float);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#arc}
    * @alias Graphics.Arc
    * @param {Number} x
    * @param {Number} y
    * @param {Number} radius
    * @param {Number} startAngle
    * @param {Number} endAngle
    * @param {Boolean} [anticlockwise=false]
    */
class Arc implements ICommand {
        constructor(x: float, y: float, radius: float, startAngle: float, endAngle: float, anticlockwise?: boolean);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#quadraticCurveTo}
    * @alias Graphics.QuadraticCurveTo
    * @param {Number} cpx
    * @param {Number} cpy
    * @param {Number} x
    * @param {Number} y
    */
class QuadraticCurveTo implements ICommand {
        constructor(cpx: float, cpy: float, x: float, y: float);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#bezierCurveTo}
    * @alias Graphics.BezierCurveTo
    * @param {Number} cp1x
    * @param {Number} cp1y
    * @param {Number} cp2x
    * @param {Number} cp2y
    * @param {Number} x
    * @param {Number} y
    */
class BezierCurveTo implements ICommand {
        constructor(cp1x: float, cp1y: float, cp2x: float, cp2y: float, x: float, y: float);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#rect}
    * @alias Graphics.Rect
    * @param {Number} x
    * @param {Number} y
    * @param {Number} w
    * @param {Number} h
    */
class Rect implements ICommand {
        constructor(x: float, y: float, w: float, h: float);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#closePath}
    * @alias Graphics.ClosePath
    */
class ClosePath implements ICommand {
        constructor();
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#beginPath}
    * @alias Graphics.BeginPath
    */
class BeginPath implements ICommand {
        constructor();
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#beginFill}
    * @alias Graphics.Fill
    * @param {Object} style A valid Context2D fillStyle.
    * @param {Matrix2D} matrix
    */
class Fill implements ICommand {
        /**
            * A valid Context2D fillStyle.
            * @type {Object}
            */
        protected style: any;
        /**
            * @type {Boolean}
            */
        protected path: boolean;
        constructor(style?: any, matrix?: Matrix2D);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
        /**
            * Creates a linear gradient style and assigns it to {@link Graphics.Fill#style}.
            * @see {@link Graphics#beginLinearGradientFill}
            * @param {Array<String>} colors
            * @param {Array<Number>} ratios
            * @param {Number} x0
            * @param {Number} y0
            * @param {Number} x1
            * @param {Number} y1
            * @return {Graphics.Fill} Returns this Fill object for chaining or assignment.
            */
        linearGradient(colors: string[], ratios: float[], x0: float, y0: float, x1: float, y1: float): Fill;
        /**
            * Creates a linear gradient style and assigns it to {@link Graphics.Fill#style}.
            * @see {@link Graphics#beginRadialGradientFill}
            * @param {Array<String>} colors
            * @param {Array<Number>} ratios
            * @param {Number} x0
            * @param {Number} y0
            * @param {Number} r0
            * @param {Number} x1
            * @param {Number} y1
            * @param {Number} r1
            * @return {Graphics.Fill} Returns this Fill object for chaining or assignment.
            */
        radialGradient(colors: string[], ratios: float[], x0: float, y0: float, r0: float, x1: float, y1: float, r1: float): Fill;
        /**
            * Creates a linear gradient style and assigns it to {@link Graphics.Fill#style}.
            * @see {@link Graphics#beginBitmapFill}
            * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.
            * @param {String} [repetition=""] One of: repeat, repeat-x, repeat-y, or no-repeat.
            * @return {Graphics.Fill} Returns this Fill object for chaining or assignment.
            */
        bitmap(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, repetition?: string): Fill;
}
/**
    * @see {@link Graphics#beginStroke}
    * @alias Graphics.Stroke
    * @extends Graphics.Fill
    * @param {Object} style A valid Context2D fillStyle.
    * @param {Boolean} ignoreScale
    */
class Stroke extends Fill implements ICommand {
        constructor(style?: any, ignoreScale?: any);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @override
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#setStrokeStyle}
    * @alias Graphics.StrokeStyle
    * @param {Number} [width=1]
    * @param {String} [caps=butt]
    * @param {String} [joints=miter]
    * @param {Number} [miterLimit=10]
    * @param {Boolean} [ignoreScale=false]
    */
class StrokeStyle implements ICommand {
        constructor(width?: float, caps?: string | number, joints?: string | number, miterLimit?: number, ignoreScale?: boolean);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#setStrokeDash}
    * @alias Graphics.StrokeDash
    * @param {Array} [segments=[]]
    * @param {Number} [offset=0]
    */
class StrokeDash implements ICommand {
        constructor(segments?: never[], offset?: number);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#drawRoundRectComplex}
    * @alias Graphics.RoundRect
    * @param {Number} x
    * @param {Number} y
    * @param {Number} w
    * @param {Number} h
    * @param {Number} radiusTL
    * @param {Number} radiusTR
    * @param {Number} radiusBR
    * @param {Number} radiusBL
    */
class RoundRect implements ICommand {
        constructor(x: float, y: float, w: float, h: float, radiusTL: float, radiusTR: float, radiusBR: float, radiusBL: float);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#drawCircle}
    * @alias Graphics.Circle
    * @param {Number} x
    * @param {Number} y
    * @param {Number} radius
    */
class Circle implements ICommand {
        constructor(x: any, y: any, radius: any);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
/**
    * @see {@link Graphics#drawEllipse}
    * @alias Graphics.Ellipse
    * @param {Number} x
    * @param {Number} y
    * @param {Number} w
    * @param {Number} h
    */
class Ellipse implements ICommand {
        constructor(pen: Pen, x: float, y: float, w: float, h: float);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D | TGI): void;
}
/**
    *  @see {@link Graphics#drawPolyStar}
    * @alias Graphics.PolyStar
    * @param {Number} x
    * @param {Number} y
    * @param {Number} radius
    * @param {Number} sides
    * @param {Number} [pointSize=0]
    * @param {Number} [angle=0]
    */
class PolyStar implements ICommand {
        constructor(x: float, y: float, radius: float, sides: float, pointSize?: number, angle?: float);
        /**
            * Execute the Graphics command in the provided Canvas context.
            * @param {CanvasRenderingContext2D} ctx The canvas rendering context
            */
        exec(ctx: CanvasRenderingContext2D): void;
}
export {};

/**
    * A Shape allows you to display vector art in the display list. It composites a {@link Graphics}
    * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape
    * instances to display the same vector graphics with different positions or transforms.
    *
    * If the vector art will not change between draws, you may want to use the {@link DisplayObject#cache}
    * method to reduce the rendering cost.
    *
    * @memberof easeljs
    * @example
    * var graphics = new Graphics().beginFill("#ff0000").drawRect(0, 0, 100, 100);
    * var shape = new Shape(graphics);
    * // Alternatively use can also use the graphics property of the Shape class to renderer the same as above.
    * var shape = new Shape();
    * shape.graphics.beginFill("#ff0000").drawRect(0, 0, 100, 100);
    *
    * @extends DisplayObject
    * @param {Graphics} [graphics] The graphics instance to display. If null, a new Graphics instance will be created.
    */
export class Shape extends DisplayObject {
        /**
            * The graphics instance to display.
            * @type {Graphics}
            */
        graphics: Graphics;
        constructor(graphics?: Graphics);
        isVisible(): boolean;
        draw(ctx: CanvasRenderingContext2D, ignoreCache?: boolean): boolean;
        /**
            * Returns a clone of this Shape. Some properties that are specific to this instance's current context are reverted to
            * their defaults (for example .parent).
            * @override
            * @param {Boolean} [recursive=false] If true, this Shape's {@link Graphics} instance will also be
            * cloned. If false, the Graphics instance will be shared with the new Shape.
            */
        clone(recursive?: boolean): Shape;
}

export class Text extends DisplayObject {
        text: string;
        font: string;
        color: string;
        textAlign: string;
        textBaseline: string;
        maxWidth: number;
        outline: number;
        lineHeight: number;
        lineWidth: number;
        constructor(text: string, font: string, color: string);
        isVisible(): boolean;
        draw(ctx: CanvasRenderingContext2D, ignoreCache?: boolean): boolean;
        /**
            * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.
            * @return {Number} The measured, untransformed width of the text.
            */
        getMeasuredWidth(): number;
        /**
            * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured
            * width of a "M" character multiplied by 1.2, which provides an approximate line height for most fonts.
            * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is
            * based on the measured width of a "M" character multiplied by 1.2, which approximates em for most fonts.
            */
        getMeasuredLineHeight(): number;
        /**
            * Returns the approximate height of multi-line text by multiplying the number of lines against either the
            * `lineHeight` (if specified) or {@link easeljs.Text#getMeasuredLineHeight}. Note that
            * this operation requires the text flowing logic to run, which has an associated CPU cost.
            * @return {Number} The approximate height of the untransformed multi-line text.
            */
        getMeasuredHeight(): number;
        getBounds(): CGRectangle;
        /**
            * Returns an object with width, height, and lines properties. The width and height are the visual width and height
            * of the drawn text. The lines property contains an array of strings, one for
            * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing
            * whitespace removed.
            * @return {Object} An object with width, height, and lines properties.
            */
        getMetrics(): any;
        /**
            * Returns a clone of the Text instance.
            * @return {easeljs.Text} a clone of the Text instance.
            */
        clone(test?: boolean): Text;
        /**
            * Returns a string representation of this object.
            * @override
            * @return {String} a string representation of the instance.
            */
        toString(): string;
        /**
            * @param {easeljs.Text} o
            * @protected
            * @return {easeljs.Text} o
            */
        protected _cloneProps(o: Text): Text;
        /**
            * @param {CanvasRenderingContext2D} ctx
            * @return {CanvasRenderingContext2D}
            * @protected
            */
        protected _prepContext(ctx: any): any;
        /**
            * Draws multiline text.
            * @param {CanvasRenderingContext2D} ctx
            * @param {Object} o
            * @param {Array} lines
            * @return {Object}
            * @protected
            */
        protected _drawText(ctx: any, o?: any, lines?: any): any;
        /**
            * @param {CanvasRenderingContext2D} ctx
            * @param {String} text
            * @param {Number} y
            * @protected
            */
        _drawTextLine(ctx: any, text: any, y: any): void;
        /**
            * @param {String} text
            * @protected
            */
        _getMeasuredWidth(text: any): any;
}

/**
    * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing
    * HTML element, or a string.
    *
    * <strong>Notes:</strong>
    * <ol>
    * 	<li>When using a video source that may loop or seek, use a {@link VideoBuffer} object to
    * 	 prevent blinking / flashing.
    * 	<li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it
    * 	 will be displayed.</li>
    * 	<li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,
    * 	the Bitmap can be cached.</li>
    * 	<li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This
    * 	happens in all browsers except recent Firefox builds.</li>
    * 	<li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using
    * 	methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting
    * 	`crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`</li>
    * </ol>
    *
    * @memberof easeljs
    * @extends DisplayObject
    * @example
    * const bitmap = new Bitmap("./imagePath.jpg");
    */
export class SceneBitmap extends DisplayObject {
        /**
            * The source image to display. This can be a CanvasImageSource
            * (image, video, canvas), an object with a `getImage` method that returns a CanvasImageSource, or a string URL to an image.
            * If the latter, a new Image instance with the URL as its src will be used.
            * @property image
            * @type {CanvasImageSource|Object}
            */
        image: HTMLImageElement;
        /**
            * Specifies an area of the source image to draw. If omitted, the whole image will be drawn.
            * Notes:
            * <ul>
            *     <li>that video sources must have a width / height set to work correctly with `sourceRect`</li>
            *     <li>Cached objects will ignore the `sourceRect` property</li>
            * </ul>
            * @type {RectangleF}
            * @default null
            */
        sourceRect: CGRectangle;
        /**
         * Set as compatible with WebGL.
         * @protected
         * @type {Number}
         */
        _webGLRenderStyle: number;
        /**
            * @param {CanvasImageSource|String|Object} imageOrUri The source image to display. This can be a CanvasImageSource
            * (image, video, canvas), an object with a `getImage` method that returns a CanvasImageSource, or a string URL to an image.
            * If the latter, a new Image instance with the URL as its src will be used.
            */
        constructor(imageOrUri: CanvasImageSource | String | Object);
        isVisible(): boolean;
        draw(ctx: any, ignoreCache?: boolean): boolean;
        getBounds(): CGRectangle;
        /**
            * Returns a clone of the Bitmap instance.
            * @param {Boolean} [node=false] Whether the underlying dom element should be cloned as well.
            * @return {Bitmap} a clone of the Bitmap instance.
            */
        clone(node?: boolean): SceneBitmap;
}

/**
  * Global utility for generating sequential unique ID numbers.
  *
  * @memberof easeljs
  * @name easeljs.uid
  * @example
  * import { uid } from "@createjs/easeljs";
  * var ids = [];
  * while (ids.length <= 3) {
  *   ids.push(uid());
  * }
  * // ids == [0, 1, 2, 3]
  */
export function uid(): number;

export function createCanvas(width?: number, height?: number): any;

/**
    * When an HTML video seeks, including when looping, there is an indeterminate period before a new frame is available.
    * This can result in the video blinking or flashing when it is drawn to a canvas. The VideoBuffer class resolves
    * this issue by drawing each frame to an off-screen canvas and preserving the prior frame during a seek.
    *
    * @example
    * let buffer = new VideoBuffer(video);
    * let bitmap = new Bitmap(buffer);
    *
    * @param {HTMLVideoElement} video The HTML video element to buffer.
    */
export class VideoBuffer {
        /**
            * Used by Bitmap to determine when the video buffer is ready to be drawn. Not intended for general use.
            * @protected
            * @type {Number}
            */
        readyState: number;
        /**
            * @protected
            * @type {HTMLVideoElement}
            */
        protected _video: HTMLVideoElement;
        /**
            * @protected
            * @type {HTMLCanvasElement}
            */
        protected _canvas: HTMLCanvasElement;
        /**
            * @protected
            * @type {Number}
            * @default -1
            */
        protected _lastTime: number;
        constructor(video: HTMLVideoElement);
        /**
            * Gets an HTML canvas element showing the current video frame, or the previous frame if in a seek / loop.
            * Primarily for use by {@link easeljs.Bitmap}.
            */
        getImage(): HTMLCanvasElement;
        /**
            * @protected
            */
        protected _videoReady(): void;
}

export class ButtonComponent extends GUIComponent {
    protected defaultCol: CGColor;
    protected highlightCol: CGColor;
    constructor(eventService: IMouseEventService, x: number, y: number, w: number, h: number, params: any);
    draw(tg: SketchGraphics): void;
}

export class CheckboxComponent extends ButtonComponent {
    checked: boolean;
    constructor(x: number, y: number, w: number, h: number, params: any);
    trigger(): void;
    protected mousePressed(): void;
    draw(tg: SketchGraphics): void;
}

export class DraggablePoint extends CGPoint {
    constructor(x: float, y: float, cursorService?: ICursorService);
    draw(tg: SketchGraphics): void;
    onMouseDown(): void;
    onMouseMove(/* evt: MouseEvent */ x: int, y: int, prevX: int, prevY: int): void;
    onMouseUp(): void;
    move(): void;
}

export class GUIComponent {
    protected x: float;
    protected y: float;
    protected w: float;
    protected h: float;
    protected name: string;
    protected selected: boolean;
    protected disabled: boolean;
    protected transition: number;
    protected activeCursor: string;
    protected mouseX: number;
    protected mouseY: number;
    constructor(eventService: IMouseEventService, x: float, y: float, w: float, h: float, name: string, updateFunction?: Function);
    draw(tg: SketchGraphics): void;
    protected mouseOver(): boolean;
    protected mousePressed(): void;
    protected mouseDragged(): void;
    protected trigger(): void;
    protected fade(): void;
}

export class ImageComponent extends LabelComponent {
    constructor(x: number, y: number, w: number, h: number, params: any);
    draw(tg: SketchGraphics): void;
}

export class LabelComponent extends GUIComponent {
    constructor(x: number, y: number, w: number, h: number, params: any);
    draw(tg: SketchGraphics): void;
}

export class RadioButtonComponent extends ButtonComponent {
    r: number;
    cx: number;
    cy: number;
    marked: boolean;
    constructor(x: number, y: number, w: number, h: number, name: string, trigger: Function);
    draw(tg: SketchGraphics): void;
}

export class SliderComponent extends GUIComponent {
    constructor(x: number, y: number, w: number, h: number, params: any);
    draw(tg: SketchGraphics): void;
    protected mouseOver(): boolean;
    protected mousePressed(): true | undefined;
    protected mouseDragged(): true | undefined;
    setValue(v: number): void;
}

export class ToolbarComponent extends GUIComponent {
    constructor(x: number, y: number, w: number);
    draw(tg: SketchGraphics): void;
    add(type: any, params: any): void;
    addButton(evetService: IMouseEventService, name: string, trigger: Function, height?: int): void;
    addRadioButtons(options: any, trigger: Function, defaultOption: any): void;
}

export class SDL_Palette {
    ncolors: int;
    colors: CGColor[];
    version: uint;
    refcount: int;
}
export class SDL_PixelFormat {
    format: uint;
    palette: SDL_Palette;
    BitsPerPixel: byte;
    BytesPerPixel: byte;
    padding: ByteArray;
    Rmask: uint;
    Gmask: uint;
    Bmask: uint;
    Amask: uint;
    Rloss: byte;
    Gloss: byte;
    Bloss: byte;
    Aloss: byte;
    Rshift: byte;
    Gshift: byte;
    Bshift: byte;
    Ashift: byte;
    refcount: int;
    next: SDL_PixelFormat;
}
export class SDL_Surface {
    Id: int;
    flags: uint; /**< Read-only */
    format: SDL_PixelFormat; /**< Read-only */
    w: int;
    h: int; /**< Read-only */
    pitch: int; /**< Read-only */
    pixels: ByteArray; /**< Read-write */
    /** Application data associated with the surface */
    userdata: ByteArray; /**< Read-write */
    /** information needed for surfaces requiring locks */
    locked: int; /**< Read-only */
    lock_data: ByteArray; /**< Read-only */
    /** clipping information */
    clip_rect: CGRectangle; /**< Read-only */
    /** info for fast blit mapping to other surfaces */
    map: ByteArray; /**< Private */
    /** Reference count -- used when freeing surface */
    refcount: int; /**< Read-mostly */
    constructor();
}
export class SDLModule extends CanvasModule {
    constructor(width: int, height: int);
    protected BlitSurface(src: SDL_Surface, srcrect: CGRectangle, dst: SDL_Surface, dstrect: CGRectangle, scale: any): number;
    protected requestFullscreen(lockPointer: any, resizeCanvas: any): void;
    protected requestFullScreen(): void;
    protected requestAnimationFrame(func: any): void;
    protected setCanvasSize(width: any, height: any, noUpdates: any): void;
    protected pauseMainLoop(): void;
    protected resumeMainLoop(): void;
    protected getUserMedia(): void;
    protected createContext(canvas: any, useWebGL: any, setInModule: any, webGLContextAttributes: any): CanvasRenderingContext2D;
    protected _emscripten_get_canvas_element_size(): CGSize;
}

type Lazy<T> = T | LazyValue<T>;
export class GuiConsole<T extends GuiTVC> extends TextConsole<T> {
        CreateTVC(canvas: HTMLCanvasElement, options: any): T;
        DrawLine(pen: Pen | LazyValue<Pen>, x1: int | LazyValue<int>, y1: int | LazyValue<int>, x2: int | LazyValue<int>, y2: int | LazyValue<int>): void;
        DrawRectangle(pen: Pen | LazyValue<Pen>, rect: CGRectangle | LazyValue<CGRectangle>): void;
        FillRectangle(brush: Brush | LazyValue<Pen>, rect: CGRectangle | LazyValue<CGRectangle>): void;
        DrawEllipse(pen: Pen | LazyValue<Pen>, rect: CGRectangle | LazyValue<CGRectangle>): void;
        FillEllipse(brush: Brush | LazyValue<Pen>, rect: CGRectangle | LazyValue<CGRectangle>): void;
        /**
            * Clear an area of the current screen
            * @param ink The index of the color in the palette to clear with
            * @param x The horizontal coordinate of the top-left pixel of the rectangle to clear
            * @param y The vertical coordinate of the top-left pixel of the rectangle to clear
            * @param width The horizontal coordinate of the bottom-right pixel of the rectangle to clear
            * @param height The vertical coordinate of the bottom-right pixel of the rectangle to clear
            */
        Cls(ink: Lazy<int>, x: Lazy<int>, y: Lazy<int>, width: Lazy<int>, height: Lazy<int>): void;
        /**
            * Draw a line with the current Ink from the last graphical position
            * @param x The horizontal coordinate of the point
            * @param y  The vertical coordinate of the point
            * @param width width of line
            * @param height height of line
            */
        Draw(x: Lazy<int>, y: Lazy<int>, width: Lazy<int>, height: Lazy<int>): void;
        /**
            * Draw an ellipse with the current Ink in the current screen
            * @param x The horizontal coordinate of the center of the ellipse
            * @param y The vertical coordinate of the center of the ellipse
            * @param xRadius The horizontal radius in pixels
            * @param yRadius The vertical radius in pixels
            */
        Ellipse(x: Lazy<int>, y: Lazy<int>, xRadius: Lazy<int>, yRadius: Lazy<int>): void;
        /**
            * Mouse Commands
            */
        get MouseX(): int;
        get MouseY(): int;
        get MouseKey(): int;
        HideMouse(): void;
        ShowMouse(): void;
        /**
            * Open a new screen
            * @param index The index of the screen to open. Any existing screen will be replaced by the new one
            * @param width The width of the screen in pixels
            * @param height The height of the screen in pixels
            * @param numberOfColor The number of colors of the palette (optional)
            * @param pixelMode Lowres, Hires, Laced or any combination
            * @param columns Number of columns in the text window associated with the screen
            * @param lines Number of lines in the text window associated with the screen
            * @param tags$ List of eventual tags
            */
        ScreenOpen(index: LazyValue<int>, width: LazyValue<int>, height: LazyValue<int>, numberOfColor?: LazyValue<int>, pixelMode?: LazyValue<int>, columns?: LazyValue<int>, lines?: LazyValue<int>, tags$?: LazyValue<int>): void;
        /**
            * Destroys the current screen or a given screen
            * @param index The index of the screen to destroy, if ommited will destroy the current screen
            */
        ScreenClose(index: LazyValue<int>, tags$?: LazyValue<int>): void;
        /**
            * Create an exact and synchronized copy of the current screen that can be displayed at another position and Z-order.
            * Both screen share the same internal pixel buffers. Graphical operations are fobidden in the cloned screen
            * @param index The index of the screen to create, will replace an existing screen
            */
        ScreenClone(index?: LazyValue<int>): void;
        /**
            * Make a screen disappear from display. The screen will remain active and drawing operation are still possible after this instruction
            * @param index The index of the screen, if ommited the instruction closes the current screen
            */
        ScreenHide(index?: int): void;
        SetTransparent(index: int | LazyValue<int>): void;
        Screen(index: int | LazyValue<int>): void;
        ScreenToFront(index: int | LazyValue<int>): void;
        ScreenCenter(index: int | LazyValue<int>, centerX: LazyValue<boolean>, centerY: LazyValue<int>): void;
        ScreenWidth(index?: int): int;
        ScreenHeight(index?: int): int;
        ScreenOffset(index: int, xOffset: int, yOffset: int): this;
        ScreenDisplay(index: int, x: int, y: int, width?: int, height?: int): this;
        ScreenScale(index: int, xScale: int, yScale: int): this;
        LoadImage(path: string): void;
        PasteBob(x: int, y: int, index: int): void;
}
export {};

export class AbstractTween extends EventDispatcher {
        ignoreGlobalPause: boolean;
        loop: number;
        useTicks: boolean;
        reversed: boolean;
        bounce: boolean;
        timeScale: number;
        duration: number;
        position: number;
        rawPosition: number;
        protected _actionHead: any;
        constructor(props: any);
        /**
            * Returns a list of the labels defined on this tween sorted by position.
            * @type {Object[]}
            */
        get labels(): any;
        set labels(labels: any);
        /**
            * Returns the name of the label on or immediately before the current position. For example, given a tween with
            * two labels, "first" on frame index 4, and "second" on frame 8, currentLabel would return:
            * <ul>
            *   <li>null if the current position is 2.</li>
            *   <li>"first" if the current position is 4.</li>
            *   <li>"first" if the current position is 7.</li>
            *   <li>"second" if the current position is 15.</li>
            * </ul>
            * @type {String}
            * @readonly
            */
        get currentLabel(): any;
        /**
            * Pauses or unpauses the tween. A paused tween is removed from the global registry and is eligible for garbage collection
            * if no other references to it exist.
            * @type {Boolean}
                */
        get paused(): boolean;
        set paused(paused: boolean);
        /**
            * Advances the tween by a specified amount.	 *
            * @param {Number} delta The amount to advance in milliseconds (or ticks if useTicks is true). Negative values are supported.
            * @param {Boolean} [ignoreActions=false] If true, actions will not be executed due to this change in position.
            */
        advance(delta: any, ignoreActions?: boolean): void;
        /**
            * Advances the tween to a specified position.
            *
            * @emits tweenjs.AbstractTween#event:change
            * @emits tweenjs.AbstractTween#event:complete
            *
            * @param {Number} rawPosition The raw position to seek to in milliseconds (or ticks if useTicks is true).
            * @param {Boolean} [ignoreActions=false] If true, do not run any actions that would be triggered by this operation.
            * @param {Boolean} [jump=false] If true, only actions at the new position will be run. If false, actions between the old and new position are run.
            * @param {Function} [callback] Primarily for use with MovieClip, this callback is called after properties are updated, but before actions are run.
            */
        setPosition(rawPosition: any, ignoreActions?: boolean, jump?: boolean, callback?: any): boolean | undefined;
        /**
            * Calculates a normalized position based on a raw position.
            *
            * @example
            * // given a tween with a duration of 3000ms set to loop:
            * console.log(myTween.calculatePosition(3700); // 700
            *
            * @param {Number} rawPosition A raw position.
            */
        calculatePosition(rawPosition: any): number;
        /**
            * Adds a label that can be used with {@link tweenjs.Timeline#gotoAndPlay}/{@link tweenjs.Timeline#gotoAndStop}.
            *
            * @param {String} label The label name.
            * @param {Number} position The position this label represents.
            */
        addLabel(label: any, position: any): void;
        /**
            * Unpauses this timeline and jumps to the specified position or label.
            *
            * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)
            * or label to jump to.
            */
        gotoAndPlay(positionOrLabel: any): void;
        /**
            * Pauses this timeline and jumps to the specified position or label.
            *
            * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label
            * to jump to.
            */
        gotoAndStop(positionOrLabel: any): void;
        /**
            * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the
            * corresponding frame label will be returned, or `null` if a matching label is not defined.
            *
            * @param {String|Number} positionOrLabel A numeric position value or label String.
            */
        resolve(positionOrLabel: any): any;
        /**
            * Returns a string representation of this object.
            *
            * @return {String} a string representation of the instance.
            */
        toString(): string;
        /**
            * @throws AbstractTween cannot be cloned.
            */
        clone(): void;
        /**
            * Shared logic that executes at the end of the subclass constructor.
            *
            * @private
            *
            * @param {Object} [props]
            */
        _init(props: any): void;
        /**
            * @private
            * @param {String|Number} positionOrLabel
            */
        _goto(positionOrLabel: any): void;
        /**
        * Runs actions between startPos & endPos. Separated to support action deferral.
        *
            * @private
            *
            * @param {Number} startRawPos
            * @param {Number} endRawPos
            * @param {Boolean} jump
            * @param {Boolean} includeStart
            */
        _runActions(startRawPos: any, endRawPos: any, jump: any, includeStart: any): boolean | undefined;
        /**
            * @private
            * @abstract
            * @throws Must be overridden by a subclass.
                */
        _runActionsRange(startPos: any, endPos: any, jump: any, includeStart: any): boolean;
        /**
                * @private
            * @abstract
            * @throws Must be overridden by a subclass.
                */
        _updatePosition(jump: any, end: any): void;
}

export class Ease {
        static linear(t: any): any;
        /**
            * Mimics the simple -100 to 100 easing in Flash Pro.
            * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.
            * @return {Function}
            */
        static get(amount: any): (t: any) => any;
        /**
            * Configurable exponential ease.
            * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
            * @return {Function}
            */
        static getPowIn(pow: any): (t: any) => number;
        /**
            * Configurable exponential ease.
            * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
            * @return {Function}
            */
        static getPowOut(pow: any): (t: any) => number;
        /**
            * Configurable exponential ease.
            * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
            * @return {Function}
            */
        static getPowInOut(pow: any): (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static sineIn(t: any): number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static sineOut(t: any): number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static sineInOut(t: any): number;
        /**
            * Configurable "back in" ease.
            * @param {Number} amount The strength of the ease.
            * @return {Function}
            */
        static getBackIn(amount: any): (t: any) => number;
        /**
            * Configurable "back out" ease.
            * @param {Number} amount The strength of the ease.
            * @return {Function}
            */
        static getBackOut(amount: any): (t: any) => number;
        /**
            * Configurable "back in out" ease.
            * @param {Number} amount The strength of the ease.
            * @return {Function}
            */
        static getBackInOut(amount: any): (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static circIn(t: any): number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static circOut(t: any): number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static circInOut(t: any): number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static bounceIn(t: any): number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static bounceOut(t: any): number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static bounceInOut(t: any): number;
        /**
            * Configurable elastic ease.
            * @param {Number} amplitude
            * @param {Number} period
            * @return {Function}
            */
        static getElasticIn(amplitude: any, period: any): (t: any) => any;
        /**
            * Configurable elastic ease.
            * @param {Number} amplitude
            * @param {Number} period
            * @return {Function}
            */
        static getElasticOut(amplitude: any, period: any): (t: any) => any;
        /**
            * Configurable elastic ease.
            * @param {Number} amplitude
            * @param {Number} period
            * @return {Function}
            */
        static getElasticInOut(amplitude: any, period: any): (t: any) => number;
        /**
            * Identical to linear.
            * @param {Number} t
            * @return {Number}
            */
        static none: typeof Ease.linear;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static quadIn: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static quadOut: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static quadInOut: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static cubicIn: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static cubicOut: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static cubicInOut: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static quartIn: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static quartOut: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static quartInOut: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static quintIn: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static quintOut: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static quintInOut: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static backIn: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static backOut: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static backInOut: (t: any) => number;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static elasticIn: (t: any) => any;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static elasticOut: (t: any) => any;
        /**
            * @param {Number} t
            * @return {Number}
            */
        static elasticInOut: (t: any) => number;
}

export enum ColorMatrixFlag {
    Default = 0,
    SkipGrays = 1,
    AltGrays = 2
}

export enum ColorAdjustType {
    Default = 0,
    Bitmap = 1,
    Brush = 2,
    Pen = 3,
    Text = 4,
    Count = 5,
    Any = 6
}

export class EncoderParameter implements IDisposable {
    constructor();
    get Encoder(): Encoder;
    set Encoder(value: Encoder);
    get NumberOfValues(): int;
    get Type(): EncoderParameterValueType;
    get ValueType(): EncoderParameterValueType;
    dispose(disposing: boolean): void;
    Dispose(): void;
    static NativeSize(): int;
    ToNativePtr(epPtr: IntPtr): void;
    static FromNativePtr(epPtr: IntPtr): EncoderParameter;
}

export enum ImageCodecFlags {
    BlockingDecode = 32,
    Builtin = 65536,
    Decoder = 2,
    Encoder = 1,
    SeekableEncode = 16,
    SupportBitmap = 4,
    SupportVector = 8,
    System = 131072,
    User = 262144
}

export interface ISketchRenderer2D {
    arc(x: number, y: number, w: number, h: number, start: number, stop: number, mode: string): void;
}
export class SketchCanvasRenderer2D extends CGContext2D implements ISketchRenderer2D {
    gifProperties: any;
    _textSize: int;
    _textLeading: int;
    _textFont: string;
    _rectMode: string;
    _ellipseMode: string;
    _curveTightness: number;
    _imageMode: string;
    _tint: any;
    _doStroke: boolean;
    _doFill: boolean;
    _strokeSet: boolean;
    _fillSet: boolean;
    isP3D: boolean;
    constructor(context: CanvasRenderingContext2D, pinst: SketchGraphics);
    _applyDefaults(): void;
    background(value: byte): any;
    background(color: CGColor): any;
    background(values: Array<byte>): any;
    background(value: string): any;
    background(gray: byte, alpha: byte): any;
    background(v1: byte, v2: byte, v3: byte): any;
    background(v1: byte, v2: byte, v3: byte, alpha: byte): any;
    clear(): void;
    fill(value: byte): any;
    fill(color: CGColor): any;
    fill(values: Array<byte>): any;
    fill(value: string): any;
    fill(gray: byte, alpha: byte): any;
    fill(v1: byte, v2: byte, v3: byte): any;
    fill(v1: byte, v2: byte, v3: byte, alpha: byte): any;
    stroke(value: byte): any;
    stroke(color: CGColor): any;
    stroke(values: Array<byte>): any;
    stroke(value: string): any;
    stroke(gray: byte, alpha: byte): any;
    stroke(v1: byte, v2: byte, v3: byte): any;
    stroke(v1: byte, v2: byte, v3: byte, alpha: byte): any;
    image(img: any, sx: any, sy: any, sWidth: any, sHeight: any, dx?: any, dy?: any, dWidth?: any, dHeight?: any): void;
    _getTintedImageCanvas(img: any): any;
    blendMode(mode: any): void;
    blend(...args: any[]): void;
    copy(...args: any[]): void;
    loadPixels(): void;
    set(x: any, y: any, imgOrCol: any): void;
    updatePixels(x: any, y: any, w: any, h: any): void;
    arc(x: number, y: number, w: number, h: number, start: number, stop: number, mode: string, detail?: any): void;
    ellipse(args: any): this | undefined;
    line(x1: any, y1: any, x2: any, y2: any): this;
    point(x: any, y: any): this | undefined;
    quad(x1: any, y1: any, x2: any, y2: any, x3: any, y3: any, x4: any, y4: any): this;
    rect(args: any): this;
    triangle(args: any): this | undefined;
    endShape(mode: any, vertices: any[][], isCurve: any, isBezier: any, isQuadratic: any, isContour: any, shapeKind?: any): this;
    strokeCap(cap: any): this;
    strokeJoin(join: any): this;
    strokeWeight(w: any): this;
    _getFill(): string | CanvasGradient | CanvasPattern;
    _setFill(fillStyle: any, force?: boolean): void;
    _getStroke(): string | CanvasGradient | CanvasPattern;
    _setStroke(strokeStyle: any, force?: boolean): void;
    bezier(x1: any, y1: any, x2: any, y2: any, x3: any, y3: any, x4: any, y4: any): this;
    curve(x1: any, y1: any, x2: any, y2: any, x3: any, y3: any, x4: any, y4: any): this;
    applyMatrix(a: any, b: any, c: any, d: any, e: any, f: any): void;
    resetMatrix(): this;
    rotate(rad: any, axis?: any): void;
    scale(x: any, y: any): this;
    translate(x: any, y?: any): this;
    text(str: any, x: any, y: any, maxWidth: any, maxHeight: any): any;
    textLeading(l: any): number;
    textSize(s: any): number;
    textStyle(s: any): string | SketchGraphics;
    textAscent(): any;
    _updateTextMetrics(): this;
    textDescent(): any;
    textAlign(h: any, v: any): {
        horizontal: string;
        vertical: string;
    } | undefined;
    textWidth(s: string): any;
    _applyTextProperties(): SketchGraphics;
    push(): {
        properties: {
            _doStroke: boolean;
            _strokeSet: boolean;
            _doFill: boolean;
            _fillSet: boolean;
            _tint: any;
            _imageMode: string;
            _rectMode: string;
            _ellipseMode: string;
            _textFont: string;
            _textLeading: number;
            _textSize: number;
            _textAlign: string;
            _textBaseline: string;
            _textStyle: string;
        };
    };
    pop(style: any): void;
    get(x: any, y: any, w: any, h: any): any;
    resize(w: number, h: number): void;
}

export class SketchImage {
    width: number;
    height: number;
    canvas: HTMLCanvasElement;
    drawingContext: CanvasRenderingContext2D;
    _pixelDensity: number;
    _modified: boolean;
    _pixelsDirty: boolean;
    pixels: any;
    imageData: any;
    constructor(width: number, height: number, inst?: any);
    _setProperty(prop: any, value: any): void;
    loadPixels(): void;
    updatePixels(x: any, y: any, w: any, h: any): void;
    get(x: any, y: any, w: any, h: any): any[] | SketchImage;
    set(x: int, y: int, imgOrCol: CGColor): void;
    resize(width: any, height: any): void;
    copy(): void;
    mask(p5Image: any): void;
    filter(operation: any, value: any): void;
    blend(): void;
    setModified: (val: any) => void;
    isModified(): boolean;
    save(filename: any, extension: any): void;
}

export class Vector {
    x: float;
    y: float;
    z: float;
    constructor(x?: number | SketchGraphics, y?: number | number[], z?: number);
    toString(): string;
    set(x?: number, y?: number, z?: number): Vector;
    set(value: Vector | number[]): Vector;
    copy(): Vector;
    add(x: number, y?: number, z?: number): Vector;
    add(value: Vector | number[]): Vector;
    sub(x: number, y?: number, z?: number): Vector;
    sub(value: Vector | number[]): Vector;
    mult(n: number): Vector;
    div(n: number): Vector;
    mag(): number;
    magSq(): number;
    dot(x: number, y?: number, z?: number): number;
    dot(value: Vector): number;
    cross(v: Vector): Vector;
    dist(v: Vector): number;
    normalize(): Vector;
    limit(max: number): Vector;
    setMag(len: number): Vector;
    heading(): number;
    rotate(angle: number): Vector;
    angleBetween(v: Vector): number;
    lerp(v: Vector, amt: number): Vector;
    lerp(x: number, y: number, z: number, amt?: number): Vector;
    array(): number[];
    equals(x: number, y?: number, z?: number): boolean;
    equals(value: Vector | any[]): boolean;
    static fromAngle(angle: number, length?: number): Vector;
    static fromAngles(theta: number, phi: number, length?: number): Vector;
    static random2D(): Vector;
    static random3D(): Vector;
    static add(v1: Vector, v2: Vector, target: Vector): void;
    static add(v1: Vector, v2: Vector): Vector;
    static sub(v1: Vector, v2: Vector, target: Vector): void;
    static sub(v1: Vector, v2: Vector): Vector;
    static mult(v: Vector, n: number, target: Vector): void;
    static mult(v: Vector, n: number): Vector;
    static div(v: Vector, n: number, target: Vector): void;
    static div(v: Vector, n: number): Vector;
    static dot(v1: Vector, v2: Vector): number;
    static cross(v1: Vector, v2: Vector): Vector;
    static dist(v1: Vector, v2: Vector): number;
    static lerp(v1: Vector, v2: Vector, amt: number, target: Vector): void;
    static lerp(v1: Vector, v2: Vector, amt: number): number;
    static mag(vecT: Vector): number;
}

export class SketchFont {
    parent: SketchGraphics;
    cache: {};
    font: any;
    constructor(p: SketchGraphics);
    list(): void;
    textBounds(str: any, x: any, y: any, fontSize: any, options: any): any;
    textToPoints(txt: any, x: any, y: any, fontSize: any, options: any): any[];
    _getGlyphs(str: any): any;
    _getPath(line: any, x: any, y: any, options: any): any;
    _getPathData(line: any, x: any, y: any, options: any): any;
    _getSVG(line: any, x: any, y: any, options: any): any;
    _renderPath(line: any, x: any, y: any, options: any): this;
    _textWidth(str: any, fontSize: any): any;
    _textAscent(fontSize: any): number;
    _textDescent(fontSize: any): number;
    _scale(fontSize: any): number;
    _handleAlignment(renderer: any, line: any, x: any, y: any, textWidth?: any): {
        x: any;
        y: any;
    };
}

/**
    * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,
    * see the {@link DisplayObject} and {@link Stage} event listings.
    * @extends core.Event
    * @param {String} type The event type.
    * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
    * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
    * @param {Number} stageX The normalized x position relative to the stage.
    * @param {Number} stageY The normalized y position relative to the stage.
    * @param {MouseEvent} nativeEvent The native DOM event related to this mouse event.
    * @param {Number} pointerID The unique id for the pointer.
    * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.
    * @param {Number} rawX The raw x position relative to the stage.
    * @param {Number} rawY The raw y position relative to the stage.
    * @param {DisplayObject} relatedTarget The secondary target for the event.
    */
export class MouseEvent extends Event {
        /**
            * The normalized x position on the stage. This will always be within the range 0 to stage width.
            * @type {Number}
         */
        stageX: number;
        /**
            * The normalized y position on the stage. This will always be within the range 0 to stage height.
            * @type {Number}
            */
        stageY: number;
        /**
            * The raw x position relative to the stage. Normally this will be the same as the stageX value, unless
            * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
            * @type {Number}
         */
        rawX: number;
        /**
            * The raw y position relative to the stage. Normally this will be the same as the stageY value, unless
            * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
            * @type {Number}
         */
        rawY: number;
        /**
            * The native MouseEvent generated by the browser. The properties and API for this
            * event may differ between browsers. This property will be null if the
            * EaselJS property was not directly generated from a native MouseEvent.
            * @type {HTMLMouseEvent}
            */
        nativeEvent: any;
        /**
            * The unique id for the pointer (touch point or cursor). This will be either -1 for the mouse, or the system
            * supplied id value.
            * @type {Number}
            */
        pointerID: number;
        /**
            * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.
            * For touch pointers, the first pointer in the current stack will be considered the primary pointer.
            * @type {Boolean}
            */
        primary: boolean;
        /**
                    * The secondary target for the event, if applicable. This is used for mouseout/rollout
                    * events to indicate the object that the mouse entered from, mouseover/rollover for the object the mouse exited,
                    * and stagemousedown/stagemouseup events for the object that was the under the cursor, if any.
                    *
                    * Only valid interaction targets will be returned (ie. objects with mouse listeners or a cursor set).
                    * @type {DisplayObject}
                    */
        relatedTarget: DisplayObject;
        currentTarget: DisplayObject;
        constructor(type: string, bubbles: boolean, cancelable: boolean, stageX: number, stageY: number, nativeEvent: MouseEvent, pointerID: number, primary: boolean, rawX: number, rawY: number, relatedTarget?: DisplayObject);
        /**
            * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
            * @type {Number}
            * @readonly
            */
        get localX(): number;
        /**
            * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
            * @type {Number}
            * @readonly
            */
        get localY(): any;
        /**
            * Indicates whether the event was generated by a touch input (versus a mouse input).
            * @type {Boolean}
            * @readonly
            */
        get isTouch(): boolean;
        /**
            * Returns a clone of the MouseEvent instance.
            * @return {MouseEvent} a clone of the MouseEvent instance.
            */
        clone(): MouseEvent;
        /**
            * Returns a string representation of this object.
            * @return {String} a string representation of the instance.
            */
        toString(): string;
}

/**
    * The BitmapCache is an internal representation of all the cache properties and logic required in order to "cache"
    * an object. This information and functionality used to be located on a {@link easeljs.DisplayObject#cache}
    * method in {@link easeljs.DisplayObject}, but was moved to its own class.
    *
    * Caching in this context is purely visual, and will render the DisplayObject out into an image to be used instead
    * of the object. The actual cache itself is still stored on the target with the {@link easeljs.DisplayObject#cacheCanvas}.
    * Working with a singular image like a {@link easeljs.Bitmap} there is little benefit to performing
    * a cache as it is already a single image. Caching is best done on containers containing multiple complex parts that
    * do not move often, so that rendering the image instead will improve overall rendering speed. A cached object will
    * not visually update until explicitly told to do so with a call to update, much like a Stage. If a cache is being
    * updated every frame it is likely not improving rendering performance. Cache are best used when updates will be sparse.
    *
    * Caching is also a co-requisite for applying filters to prevent expensive filters running constantly without need,
    * and to physically enable some effects. The BitmapCache is also responsible for applying filters to objects and
    * reads each {@link easeljs.Filter} due to this relationship. Real-time Filters are not recommended
    * performance wise when dealing with a Context2D canvas. On a StageGL performance is better so the presence of a
    * filter will automatically create a cache if one is not made manually.
    *
    * Some visual effects can be achieved with a {@link easeljs.DisplayObject#compositeOperation}
    * so check out that setting before settling on a filter.
    */
export class BitmapCache {
        /**
            * Internal tracking of whether this cache was automatically created and thus automatically controlled
            * @type {boolean}
            * @protected
            */
        _autoGenerated: boolean;
        /**
            * Internal tracking of intended cacheCanvas, may or may not be assigned based on disabled state.
            * @property _cacheCanvas
            * @type {HTMLCanvasElement | WebGLTexture | Object}
            * @protected
            */
        _cacheCanvas: HTMLCanvasElement | WebGLTexture | Object;
        constructor();
        /**
            * Returns the bounds that surround all applied filters, relies on each filter to describe how it changes bounds.
            * @param {easeljs.DisplayObject} target The object to check the filter bounds for.
            * @param {easeljs.Rectangle} [output=easeljs.Rectangle] Calculated bounds are applied to this rect
            * @return {easeljs.Rectangle} bounds object representing the bounds with filters.
            */
        static getFilterBounds(target: any, output?: CGRectangle): CGRectangle;
        /**
            * Utility function, use with `displayObject.filters.reduce(BitmapCache.filterCounter, 0);`
            * @param acc {Number}
            * @param o {Object}
            * @return {Number}
            */
        static filterCounter(acc: any, o: any): any;
        /**
            * Disable or enable the BitmapCache from displaying. Does not cause or block cache or cache updates when toggled.
            * Best used if the cached state is always identical, but the object will need temporary uncaching.
            * @type {Boolean}
            * @default false
            */
        get disabled(): boolean;
        set disabled(value: boolean);
        /**
            * Returns a string representation of this object.
            * @return {String}
            */
        toString(): string;
        /**
            * Actually create the correct cache surface and properties associated with it. Caching and it's benefits are discussed
            * by the {@link easeljs.DisplayObject#cache} function and this class description. Here are the detailed
            * specifics of how to use the options object.
            *
            * - If useGL is set to "new" a StageGL is created and contained on this for use when rendering the cache.
            * - If useGL is set to "stage" if the current stage is a StageGL it will be used. Must be added to a stage first to work.
            * - If useGL is a StageGL instance then it will use it to cache. Warning, caches made on one StageGL will not render on any other StageGL.
            * - If useGL is undefined a Context 2D cache will be performed.
            *
            * This means you can use any combination of StageGL and 2D with either, neither, or both the stage and cache being
            * WebGL. Using "new" with a StageGL display list is highly unrecommended, but still an option. It should be avoided
            * due to negative performance reasons and the Image loading limitation noted in the class complications above.
            *
            * When `useGL` is set to the parent stage of the target and WebGL, performance is increased by using
            * "RenderTextures" instead of canvas elements. These are internal Textures on the graphics card stored in the GPU.
            * Because they are no longer canvases you cannot perform operations you could with a regular canvas. The benefit
            * is that this avoids the slowdown of copying the texture back and forth from the GPU to a Canvas element.
            * This means "stage" is the recommended option when available.
            *
            * A StageGL cache does not infer the ability to draw objects a StageGL cannot currently draw, i.e. do not use a
            * WebGL context cache when caching a Shape, Text, etc.
            *
            * @example <caption>WebGL cache with a 2D context</caption>
            * const stage = new Stage();
            * const bmp = new Bitmap(src);
            * bmp.cache(0, 0, bmp.width, bmp.height, 1, {gl: "new"}); // no StageGL to use, so make one
            *
            * const shape = new Shape();
            * shape.graphics.clear().fill("red").drawRect(0, 0, 20, 20);
            * shape.cache(0, 0, 20, 20, 1); // cannot use WebGL cache
            *
            * @example <caption>WebGL cache with a WebGL context</caption>
            * const stageGL = new StageGL();
            * const bmp = new Bitmap(src);
            *
            * // option 1
            * stageGL.addChild(bmp);
            * bmp.cache(0, 0, bmp.width, bmp.height, 1, {gl: "stage"}); // when added to the display list we can look it up
            * // option 2
            * bmp.cache(0, 0, bmp.width, bmp.height, 1, {gl: stageGL}); // we can specify it explicitly if we add it later
            * stageGL.addChild(bmp);
            *
            * const shape = new Shape();
            * shape.graphics.clear().fill("red").drawRect(0, 0, 20, 20);
            * shape.cache(0, 0, 20, 20, 1); // cannot use WebGL cache
            *
            * You may wish to create your own StageGL instance to control factors like clear color, transparency, AA, and
            * others. If the specified stage is not rendering content and just the cache set {@link easeljs.StageGL#isCacheControlled}
            * to true on your instance. This will trigger it to behave correctly for rendering your output.
            *
            * @param {Number} x The x coordinate origin for the cache region.
            * @param {Number} y The y coordinate origin for the cache region.
            * @param {Number} width The width of the cache region.
            * @param {Number} height The height of the cache region.
            * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape
            * using myShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and
            * rotate cached elements with greater fidelity. Default is 1.
            * @param {Object} [options] Specify additional parameters for the cache logic
            * @param {String|StageGL} [options.useGL] Select whether to use context 2D, or WebGL rendering, and
            * whether to make a new stage instance or use an existing one. See above for extensive details on use.
            */
        define(target: any, x: number | undefined, y: number | undefined, width: number | undefined, height: number | undefined, scale: number | undefined, options: any): void;
        /**
            * Directly called via {@link easeljs.DisplayObject#updateCache}, but also internally. This
            * has the dual responsibility of making sure the surface is ready to be drawn to, and performing the draw. For
            * full details of each behaviour, check the protected functions {@link easeljs.BitmapCache#_updateSurface}
            * and {@link easeljs.BitmapCache#_drawToCache} respectively.
            * @param {String} [compositeOperation]
            */
        update(compositeOperation?: any): void;
        /**
            * Reset and release all the properties and memory associated with this cache.
            */
        release(): void;
        /**
            * Returns a data URL for the cache, or `null` if this display object is not cached.
            * Uses {@link easeljs.BitmapCache#cacheID} to ensure a new data URL is not generated if the
            * cache has not changed.
            * @param {} type
            * @parap {} encoderOptions
            * @return {String} The image data url for the cache.
            */
        getCacheDataURL(type: any, encoderOptions: any): number | null;
        /**
            * Use context2D drawing commands to display the cache canvas being used.
            * @param {CanvasRenderingContext2D} ctx The context to draw into.
            * @return {Boolean} Whether the draw was handled successfully.
            */
        draw(ctx: any): boolean;
        /**
            * Determine the bounds of the shape in local space.
            * @method getBounds
            * @return {easeljs.Rectangle}
            */
        getBounds(): CGRectangle;
        /**
            * Fetch the correct filter in order, complicated by multipass filtering.
            * @param {Number} lookup The filter in the list to return
            */
        _getGLFilter(lookup: any): any;
        /**
            * Create or resize the invisible canvas/surface that is needed for the display object(s) to draw to,
            * and in turn be used in their stead when drawing. The surface is resized to the size defined
            * by the width and height, factoring in scaling and filters. Adjust them to adjust the output size.
            * @protected
            */
        _updateSurface(): void;
        /**
            * Perform the cache draw out for context 2D now that the setup properties have been performed.
            * @protected
            * @param {String} compositeOperation
            */
        _drawToCache(compositeOperation: any): void;
        /**
            * Work through every filter and apply its individual visual transformation.
            * @protected
            * @param {} ctx
            */
        _applyFilters(ctx: any): void;
}

/**
    * Base class that all filters should inherit from.
    *
    * When on a regular Stage apply the Filters and then cache the object using the {@link easeljs.DisplayObject#cache} method.
    * When a cached object changes, please use {@link easeljs.DisplayObject#updateCache}.
    * When on a StageGL simply setting content in the `.filters` array will trigger an automatic and constantly updated cache.
    *
    * Note that each filter can implement a {@link easeljs.Filter#getBounds} method, which returns the
    * margins that need to be applied in order to fully display the filter. For example, the {@link easeljs.BlurFilter}
    * will cause an object to feather outwards, resulting in a margin around the shape.
    *
    * Any filter that consumes an external image stretches the image to cover the cached bounds. If this is an undesired
    * visual result, then use an intermediary cache to properly size and layout your data before passing it to a filter.
    *
    * <h4>EaselJS Filters</h4>
    * EaselJS comes with a number of pre-built filters:
    * <ul>
    *   <li>{@link easeljs.AberrationFilter}: Shift the RGB components separately along a given vector</li>
    *   <li>{@link easeljs.AlphaMapFilter}: Map a greyscale image to the alpha channel of a display object</li>
    *   <li>{@link easeljs.AlphaMaskFilter}: Map an image's alpha channel to the alpha channel of a display object</li>
    *   <li>{@link easeljs.BlurFilter}: Apply vertical and horizontal blur to a display object</li>
    *   <li>{@link easeljs.ColorFilter}: Color transform a display object</li>
    *   <li>{@link easeljs.ColorMatrixFilter}: Transform an image using a {{#crossLink "ColorMatrix"}}{{/crossLink}}</li>
    *   <li>{@link easeljs.DisplacementFilter}: Create localized distortions in supplied display object</li>
    * </ul>
    *
    * @memberof easeljs
    * @example
    * shape.filters = [
         *   new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),
         *   new createjs.BlurFilter(5, 5, 10)
         * ];
         * shape.cache(0, 0, 100, 100);
         */
export class Filter {
        /**
             * A flag stating that this filter uses a context draw mode and cannot be batched into imageData processing.
             * @type {Boolean}
             * @default false
             */
        protected usesContext: boolean;
        /**
            * Pre-processing shader code, will be parsed before being fed in.
            * This should be based upon StageGL.SHADER_VERTEX_BODY_REGULAR
            * @virtual
            * @type {String}
            * @readonly
            */
        VTX_SHADER_BODY: string;
        /**
             * Pre-processing shader code, will be parsed before being fed in.
             * This should be based upon StageGL.SHADER_FRAGMENT_BODY_REGULAR
             * @virtual
             * @type {String}
             * @readonly
             */
        protected FRAG_SHADER_BODY: string;
        /**
            * Check to see if an image source being provided is one that is valid.
            * <h4>Valid Sources:</h4>
            * <ul>
            *   <li>Image Object</li>
            *   <li>HTML Canvas Element</li>
            *   <li>`.cacheCanvas` on an object with the same stage</li>
            * </ul>
            * WebGLTextures CANNOT be shared between multiple WebGL contexts. This means the only safe source for a WebGLTexture
            * is an object cached using the same StageGL as the object trying to use it in a filter. This function does not
            * enforce that restriction, as it is difficult or expensive to detect. The render will crash or fail to load the
            * image data if the rule isn't followed.
            * @param {HTMLImageElement|HTMLCanvasElement|WebGLTexture} src The element to check for validity
            * @return {Boolean} Whether the source is valid
            */
        static isValidImageSource(src: HTMLImageElement | HTMLCanvasElement | WebGLTexture): boolean;
        /**
            * Provides padding values for this filter. That is, how much the filter will extend the visual bounds of an object it is applied to.
            * @abstract
            * @param {easeljs.Rectangle} [rect] If specified, the provided Rectangle instance will be expanded by the padding amounts and returned.
            * @return {easeljs.Rectangle} If a `rect` param was provided, it is returned. If not, either a new rectangle with the padding values, or null if no padding is required for this filter.
            */
        getBounds(rect: CGRectangle): CGRectangle;
        /**
            * @virtual
            * @abstract
            * @param {WebGLContext} gl The context associated with the stage performing the render.
            * @param {easeljs.StageGL} stage The stage instance that will be rendering.
            * @param {ShaderProgram} shaderProgram The compiled shader that is going to be sued to perform the render.
            */
        shaderParamSetup(gl: any, stage: any, shaderProgram: any): void;
        /**
            * Applies the filter to the specified context.
            * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
            * @param {Number} x The x position to use for the source rect.
            * @param {Number} y The y position to use for the source rect.
            * @param {Number} width The width to use for the source rect.
            * @param {Number} height The height to use for the source rect.
            * @param {CanvasRenderingContext2D} [targetCtx] The 2D context to draw the result to. Defaults to the context passed to ctx.
            * @return {Boolean} If the filter was applied successfully.
            */
        applyFilter(ctx: CanvasRenderingContext2D, x: float, y: float, width: float, height: float, targetCtx: CanvasRenderingContext2D): boolean;
        /**
            * Returns a string representation of this object.
            * @return {String} a string representation of the instance.
            */
        toString(): string;
        /**
            * Returns a clone of this Filter instance.
            * @return {easeljs.Filter} A clone of the current Filter instance.
            */
        clone(): Filter;
        /**
            * @abstract
            * @param {ImageData} imageData Target ImageData instance.
            * @return {Boolean}
            */
        protected _applyFilter(imageData: ImageData): boolean;
}

export class GuiTVC extends TVC<GuiScreen> {
    CreateScreen(args: any, tags: any): GuiScreen;
}

export class Encoder {
    static readonly ChrominanceTable: Encoder;
    static readonly ColorDepth: Encoder;
    static readonly Compression: Encoder;
    static readonly LuminanceTable: Encoder;
    static readonly Quality: Encoder;
    static readonly RenderMethod: Encoder;
    static readonly SaveFlag: Encoder;
    static readonly ScanMethod: Encoder;
    static readonly Transformation: Encoder;
    static readonly Version: Encoder;
    static StaticConstructor(): void;
    constructor(guid: string);
    constructor(guid: Guid);
    get Guid(): Guid;
}

export enum EncoderParameterValueType {
    ValueTypeAscii = 2,
    ValueTypeByte = 1,
    ValueTypeLong = 4,
    ValueTypeLongRange = 6,
    ValueTypeRational = 5,
    ValueTypeRationalRange = 8,
    ValueTypeShort = 3,
    ValueTypeUndefined = 7
}

export class Event {
        type: string;
        target: any;
        currentTarget: any;
        eventPhase: any;
        bubbles: boolean;
        cancelable: boolean;
        timeStamp: any;
        defaultPrevented: any;
        propagationStopped: boolean;
        immediatePropagationStopped: boolean;
        constructor(type: any, bubbles?: boolean, cancelable?: boolean);
        /**
            * Sets {@link core.Event#defaultPrevented} to true if the event is cancelable.
            * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will
            * cancel the default behaviour associated with the event.
            * @return {core.Event} this, chainable
            */
        preventDefault(): this;
        /**
            * Sets {@link core.Event#propagationStopped} to true.
            * Mirrors the DOM event standard.
            * @return {core.Event} this, chainable
            */
        stopPropagation(): this;
        /**
            * Sets {@link core.Event#propagationStopped} and {@link core.Event#immediatePropagationStopped} to true.
            * Mirrors the DOM event standard.
            * @return {core.Event} this, chainable
            */
        stopImmediatePropagation(): this;
        /**
            * Causes the active listener to be removed via removeEventListener();
            *
            * @example
            * myBtn.addEventListener("click", event => {
            *   event.remove(); // removes this listener.
            * });
            *
            * @return {core.Event} this, chainable
            */
        remove(): this;
        /**
            * Returns a clone of the Event instance.
            *
            * @return {core.Event} a clone of the Event instance.
            */
        clone(): Event;
        /**
            * Provides a return {core.Event} this, chainable shortcut method for setting a number of properties on the instance.
            *
            * @param {Object} props A generic object containing properties to copy to the instance.
            * @return {core.Event} this, chainable
            */
        set(props: any): this;
        /**
            * Returns a string representation of this object.
            *
            * @return {string} A string representation of the instance.
            */
        toString(): string;
}

export class GuiScreen extends Screen {
    constructor(tvc: GuiTVC, args: any, tags: any);
    DrawLine(pen: Pen, rect: CGRectangle): void;
    DrawRectangle(pen: Pen, rect: CGRectangle): void;
    FillRectangle(brush: Brush, rect: CGRectangle): void;
    DrawEllipse(pen: Pen, rect: CGRectangle): void;
    FillEllipse(brush: Brush, rect: CGRectangle): void;
}

