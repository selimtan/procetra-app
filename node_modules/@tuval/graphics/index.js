(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@tuval/core"), require("@tuval/cg"));
	else if(typeof define === 'function' && define.amd)
		define(["@tuval/core", "@tuval/cg"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("@tuval/core"), require("@tuval/cg")) : factory(root["@tuval/core"], root["@tuval/cg"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function(__WEBPACK_EXTERNAL_MODULE__tuval_core__, __WEBPACK_EXTERNAL_MODULE__tuval_cg__) {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/GDITypes.ts":
/*!*************************!*\
  !*** ./src/GDITypes.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphicTypes": () => (/* binding */ GraphicTypes)
/* harmony export */ });
var GraphicTypes = {
    Bitmap: Symbol('Tuval.Graphics.Bitmap'),
    GdipEncoderParameter: Symbol('Tuval.Graphics.GdipEncoderParameter'),
    Region: Symbol('Tuval.Graphics.Region'),
    Image: Symbol('Tuval.Graphics.Image'),
    ImageList: Symbol('Tuval.Graphics.ImageList'),
    StringFormat: Symbol('Tuval.Graphics.StringFormat'),
    Font: Symbol('Tuval.Graphics.Font'),
    Graphics: Symbol('Tuval.Graphics.Graphics'),
    GraphicsBase: Symbol('Tuval.Graphics.GraphicsBase'),
    ColorMatrix: Symbol('Tuval.Graphics.ColorMatrix'),
    SolidBrush: Symbol('Tuval.Graphics.SolidBrush'),
    Brush: Symbol('Tuval.Graphics.Brush'),
    LinearGradientBrush: Symbol('Tuval.Graphics.LinearGradientBrush'),
    PathGradientBrush: Symbol('Tuval.Graphics.PathGradientBrush'),
    GraphicsPath: Symbol('GraphicsPath'),
    HatchBrush: Symbol('HatchBrush'),
    Icon: Symbol('Tuval.Graphics.Icon'),
    Pen: Symbol('Pen'),
    TextureBrush: Symbol('TextureBrush'),
    RadialGradientBrush: Symbol('RadialGradientBrush'),
    PaintEventArgs: Symbol('PaintEventArgs'),
    Imaging: {
        ImageAttributes: Symbol('ImageAttributes'),
        FrameDimension: Symbol('FrameDimension'),
    },
    geom: {
        Shape: Symbol('Shape'),
        Point2D: Symbol('Point2D'),
        Line2D: Symbol('Line2D'),
        Rectangle2D: Symbol('Rectangle2D'),
        AffineTransform: Symbol('AffineTransform'),
    },
    Application: Symbol('Application'),
    Tgx: {
        graphics: {
            Color: Symbol('Color'),
            Pixmap: Symbol('Pixmap'),
        },
        files: {
            FileHandle: Symbol('FileHandle'),
        },
        backend: {
            preloader: {
                Preloader: Symbol('Preloader'),
            }
        },
        utils: {
            ObjectMap: {
                Keys: Symbol('Entries'),
                Values: Symbol('Entries'),
                Entries: Symbol('Entries'),
                MapIterator: Symbol('MapIterator'),
                ObjectMap: Symbol('ObjectMap'),
                Entry: Symbol('Entry'),
            },
            IntArray: Symbol('IntArray'),
            Array: Symbol('Array'),
        },
    }
};


/***/ }),

/***/ "./src/GUIConsole/Commands/ClsCommand.ts":
/*!***********************************************!*\
  !*** ./src/GUIConsole/Commands/ClsCommand.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClsCommand": () => (/* binding */ ClsCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ClsCommand = /** @class */ (function (_super) {
    __extends(ClsCommand, _super);
    function ClsCommand(console, ink, x, y, width, height) {
        var _this = _super.call(this, console) || this;
        _this.ink = ink;
        _this.x = x;
        _this.y = y;
        _this.width = width;
        _this.height = height;
        _this.CommandName = 'Cls';
        return _this;
    }
    ClsCommand.prototype.Execute = function (console) {
        console.tvc.currentScreen.cls(this.ink.Value, { x: this.x.Value, y: this.y.Value, width: this.width.Value, height: this.height.Value });
    };
    return ClsCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/DrawCommand.ts":
/*!************************************************!*\
  !*** ./src/GUIConsole/Commands/DrawCommand.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DrawCommand": () => (/* binding */ DrawCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var DrawCommand = /** @class */ (function (_super) {
    __extends(DrawCommand, _super);
    function DrawCommand(console, x, y, width, height) {
        var _this = _super.call(this, console) || this;
        _this.x = x;
        _this.y = y;
        _this.width = width;
        _this.height = height;
        _this.CommandName = 'Draw';
        return _this;
    }
    DrawCommand.prototype.Execute = function (console) {
        console.tvc.currentScreen.draw({ x: this.x.Value, y: this.y.Value, width: this.width.Value, height: this.height.Value });
    };
    return DrawCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/DrawEllipseCommand.ts":
/*!*******************************************************!*\
  !*** ./src/GUIConsole/Commands/DrawEllipseCommand.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DrawEllipseCommand": () => (/* binding */ DrawEllipseCommand)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _drawing_Pens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../drawing/Pens */ "./src/drawing/Pens.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var DrawEllipseCommand = /** @class */ (function (_super) {
    __extends(DrawEllipseCommand, _super);
    function DrawEllipseCommand(console, pen, rect) {
        var _this = _super.call(this, console) || this;
        _this.CommandName = 'DrawEllipse';
        _this.pen = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.lazy)(_drawing_Pens__WEBPACK_IMPORTED_MODULE_2__.Pens.White);
        _this.rect = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.lazy)(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty);
        _this.pen = pen;
        _this.rect = rect;
        return _this;
    }
    DrawEllipseCommand.prototype.Execute = function (console) {
        console.tvc.currentScreen.DrawEllipse(this.pen.Value, this.rect.Value);
    };
    return DrawEllipseCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/DrawLineConsoleCommand.ts":
/*!***********************************************************!*\
  !*** ./src/GUIConsole/Commands/DrawLineConsoleCommand.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DrawLineConsoleCommand": () => (/* binding */ DrawLineConsoleCommand)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _drawing_Pens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../drawing/Pens */ "./src/drawing/Pens.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var DrawLineConsoleCommand = /** @class */ (function (_super) {
    __extends(DrawLineConsoleCommand, _super);
    function DrawLineConsoleCommand(console, pen, x1, y1, x2, y2) {
        var _this = _super.call(this, console) || this;
        _this.CommandName = 'DrawLine';
        _this.pen = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.lazy)(_drawing_Pens__WEBPACK_IMPORTED_MODULE_2__.Pens.White);
        _this.x1 = null;
        _this.y1 = null;
        _this.x2 = null;
        _this.y2 = null;
        _this.pen = pen;
        _this.x1 = x1;
        _this.y1 = y1;
        _this.x2 = x2;
        _this.y2 = y2;
        return _this;
    }
    DrawLineConsoleCommand.prototype.Execute = function (console) {
        console.tvc.currentScreen.DrawLine(this.pen.Value, new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(this.x1.Value, this.y1.Value, this.x2.Value - this.x1.Value, this.y2.Value - this.y1.Value));
    };
    return DrawLineConsoleCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/DrawRectangleConsoleCommand.ts":
/*!****************************************************************!*\
  !*** ./src/GUIConsole/Commands/DrawRectangleConsoleCommand.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DrawRectangleConsoleCommand": () => (/* binding */ DrawRectangleConsoleCommand)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _drawing_Pens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../drawing/Pens */ "./src/drawing/Pens.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var DrawRectangleConsoleCommand = /** @class */ (function (_super) {
    __extends(DrawRectangleConsoleCommand, _super);
    function DrawRectangleConsoleCommand(console, pen, rect) {
        var _this = _super.call(this, console) || this;
        _this.CommandName = 'DrawLine';
        _this.pen = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.lazy)(_drawing_Pens__WEBPACK_IMPORTED_MODULE_2__.Pens.White);
        _this.rect = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.lazy)(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty);
        _this.pen = pen;
        _this.rect = rect;
        return _this;
    }
    DrawRectangleConsoleCommand.prototype.Execute = function (console) {
        console.tvc.currentScreen.DrawRectangle(this.pen.Value, this.rect.Value);
    };
    return DrawRectangleConsoleCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/EllipseCommand.ts":
/*!***************************************************!*\
  !*** ./src/GUIConsole/Commands/EllipseCommand.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EllipseCommand": () => (/* binding */ EllipseCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var EllipseCommand = /** @class */ (function (_super) {
    __extends(EllipseCommand, _super);
    function EllipseCommand(console, x, y, xRadius, yRadius) {
        var _this = _super.call(this, console) || this;
        _this.x = x;
        _this.y = y;
        _this.xRadius = xRadius;
        _this.yRadius = yRadius;
        _this.CommandName = 'Ellipse';
        return _this;
    }
    EllipseCommand.prototype.Execute = function (console) {
        console.tvc.currentScreen.ellipse({ x: this.x.Value, y: this.y.Value, width: this.xRadius.Value, height: this.yRadius.Value });
    };
    return EllipseCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/FillEllipseCommand.ts":
/*!*******************************************************!*\
  !*** ./src/GUIConsole/Commands/FillEllipseCommand.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FillEllipseCommand": () => (/* binding */ FillEllipseCommand)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _drawing_Brushes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../drawing/Brushes */ "./src/drawing/Brushes.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var FillEllipseCommand = /** @class */ (function (_super) {
    __extends(FillEllipseCommand, _super);
    function FillEllipseCommand(console, brush, rect) {
        var _this = _super.call(this, console) || this;
        _this.CommandName = 'Fill Ellipse';
        _this.brush = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.lazy)(_drawing_Brushes__WEBPACK_IMPORTED_MODULE_2__.Brushes.Yellow);
        _this.rect = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.lazy)(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty);
        _this.brush = brush;
        _this.rect = rect;
        return _this;
    }
    FillEllipseCommand.prototype.Execute = function (console) {
        console.tvc.currentScreen.FillEllipse(this.brush.Value, this.rect.Value);
    };
    return FillEllipseCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/FillRectangleConsoleCommand.ts":
/*!****************************************************************!*\
  !*** ./src/GUIConsole/Commands/FillRectangleConsoleCommand.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FillRectangleConsoleCommand": () => (/* binding */ FillRectangleConsoleCommand)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _drawing_Brushes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../drawing/Brushes */ "./src/drawing/Brushes.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var FillRectangleConsoleCommand = /** @class */ (function (_super) {
    __extends(FillRectangleConsoleCommand, _super);
    function FillRectangleConsoleCommand(console, brush, rect) {
        var _this = _super.call(this, console) || this;
        _this.CommandName = 'DrawLine';
        _this.brush = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.lazy)(_drawing_Brushes__WEBPACK_IMPORTED_MODULE_2__.Brushes.Yellow);
        _this.rect = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.lazy)(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty);
        _this.brush = brush;
        _this.rect = rect;
        return _this;
    }
    FillRectangleConsoleCommand.prototype.Execute = function (console) {
        console.tvc.currentScreen.FillRectangle(this.brush.Value, this.rect.Value);
    };
    return FillRectangleConsoleCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_1__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/LoadImageCommand.ts":
/*!*****************************************************!*\
  !*** ./src/GUIConsole/Commands/LoadImageCommand.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LoadImageCommand": () => (/* binding */ LoadImageCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var LoadImageCommand = /** @class */ (function (_super) {
    __extends(LoadImageCommand, _super);
    function LoadImageCommand(console, path, index) {
        var _this = _super.call(this, console) || this;
        _this.path = path;
        _this.index = index;
        _this.CommandName = 'Input';
        _this.imageBank = console.tvc.Banks.getBank(1, 'application'); /*  new ImageBank(console.tvc, path, ["#000000",
            "#FFFFFF", "#000000",
            "#222222", "#FF0000",
            "#00FF00", "#0000FF", "#666666", "#555555",
            "#333333", "#773333", "#337733", "#777733", "#333377", "#773377",
            "#337777", "#000000", "#EECC88", "#CC6600", "#EEAA00", "#2277FF",
            "#4499DD", "#55AAEE", "#AADDFF", "#BBDDFF", "#CCEEFF", "#FFFFFF", "#440088", "#AA00EE", "#EE00EE", "#EE0088", "#EEEEEE"
        ],
            {
                hotSpots: [{ x: 0, y: 0 }],
                alpha: false,
                domain: 'images',
                type: 'images',
                path: 'images'
            }); */
        return _this;
    }
    LoadImageCommand.prototype.Execute = function (console) {
        //console.tvc.currentScreen.currentTextWindow.print(this.Text, true);
    };
    LoadImageCommand.prototype.IsWaitable = function () {
        return true;
    };
    LoadImageCommand.prototype.GetReturnObject = function () {
        return {
            type: 8,
            instruction: "waitPromise",
            args: {
                promise: this.imageBank.load(this.path, {
                    hotSpots: [{ x: 0, y: 0 }],
                    alpha: false,
                    domain: 'images',
                    type: 'images',
                    path: 'images'
                }),
                callback: function () { },
                errorCallback: function () { }
            }
        };
    };
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Override,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Boolean)
    ], LoadImageCommand.prototype, "IsWaitable", null);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Override,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Object)
    ], LoadImageCommand.prototype, "GetReturnObject", null);
    return LoadImageCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.SubProcessCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/PasteBobCommand.ts":
/*!****************************************************!*\
  !*** ./src/GUIConsole/Commands/PasteBobCommand.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PasteBobCommand": () => (/* binding */ PasteBobCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var PasteBobCommand = /** @class */ (function (_super) {
    __extends(PasteBobCommand, _super);
    function PasteBobCommand(console, x, y, imageIndex) {
        var _this = _super.call(this, console) || this;
        _this.x = x;
        _this.y = y;
        _this.imageIndex = imageIndex;
        _this.CommandName = 'Paste Bob';
        return _this;
    }
    PasteBobCommand.prototype.Execute = function (console) {
        console.tvc.currentScreen.pasteImage('images', this.imageIndex.Value, this.x.Value, this.y.Value, 1, 1, -((0) * this.console.tvc.degreeRadian), 1);
    };
    return PasteBobCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/ScreenCenter.ts":
/*!*************************************************!*\
  !*** ./src/GUIConsole/Commands/ScreenCenter.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScreenCenterCommand": () => (/* binding */ ScreenCenterCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ScreenCenterCommand = /** @class */ (function (_super) {
    __extends(ScreenCenterCommand, _super);
    function ScreenCenterCommand(console, index, centerX, centerY) {
        var _this = _super.call(this, console) || this;
        _this.index = index;
        _this.centerX = centerX;
        _this.centerY = centerY;
        _this.CommandName = 'Screen';
        return _this;
    }
    ScreenCenterCommand.prototype.Execute = function (console) {
        console.tvc.getScreen(this.index.Value).setCenter(this.centerX.Value ? console.tvc.platformTrue : 0, this.centerY.Value ? console.tvc.platformTrue : 0, '#update');
        // console.tvc.screenToFront(console.tvc.getScreen(this.index.Value));
    };
    return ScreenCenterCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/ScreenClose.ts":
/*!************************************************!*\
  !*** ./src/GUIConsole/Commands/ScreenClose.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScreenCloseCommand": () => (/* binding */ ScreenCloseCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ScreenCloseCommand = /** @class */ (function (_super) {
    __extends(ScreenCloseCommand, _super);
    function ScreenCloseCommand(console, index) {
        var _this = _super.call(this, console) || this;
        _this.index = index;
        _this.CommandName = 'Screen Close';
        return _this;
    }
    ScreenCloseCommand.prototype.Execute = function (console) {
        console.tvc.screenClose(this.index.Value);
        // console.tvc.screenToFront(console.tvc.getScreen(this.index.Value));
    };
    return ScreenCloseCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/ScreenCommand.ts":
/*!**************************************************!*\
  !*** ./src/GUIConsole/Commands/ScreenCommand.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScreenCommand": () => (/* binding */ ScreenCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ScreenCommand = /** @class */ (function (_super) {
    __extends(ScreenCommand, _super);
    function ScreenCommand(console, index) {
        var _this = _super.call(this, console) || this;
        _this.index = index;
        _this.CommandName = 'Screen';
        return _this;
    }
    ScreenCommand.prototype.Execute = function (console) {
        console.tvc.setScreen(this.index.Value);
        // console.tvc.screenToFront(console.tvc.getScreen(this.index.Value));
    };
    return ScreenCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/ScreenDisplay.ts":
/*!**************************************************!*\
  !*** ./src/GUIConsole/Commands/ScreenDisplay.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScreenDisplayCommand": () => (/* binding */ ScreenDisplayCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ScreenDisplayCommand = /** @class */ (function (_super) {
    __extends(ScreenDisplayCommand, _super);
    function ScreenDisplayCommand(console, index, x, y, width, height) {
        var _this = _super.call(this, console) || this;
        _this.index = index;
        _this.x = x;
        _this.y = y;
        _this.width = width;
        _this.height = height;
        _this.CommandName = 'Screen Display';
        return _this;
    }
    ScreenDisplayCommand.prototype.Execute = function (console) {
        console.tvc.getScreen(this.index.Value).setPosition({ x: this.x.Value, y: this.y.Value }, '#update');
        console.tvc.getScreen(this.index.Value).setSize({ width: this.width.Value, height: this.height.Value }, '#update');
    };
    return ScreenDisplayCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/ScreenOffsetCommand.ts":
/*!********************************************************!*\
  !*** ./src/GUIConsole/Commands/ScreenOffsetCommand.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScreenOffsetCommand": () => (/* binding */ ScreenOffsetCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ScreenOffsetCommand = /** @class */ (function (_super) {
    __extends(ScreenOffsetCommand, _super);
    function ScreenOffsetCommand(console, index, x, y) {
        var _this = _super.call(this, console) || this;
        _this.index = index;
        _this.x = x;
        _this.y = y;
        _this.CommandName = 'Screen Offset';
        return _this;
    }
    ScreenOffsetCommand.prototype.Execute = function (console) {
        console.tvc.getScreen(this.index.Value).setOffset({ x: this.x.Value, y: this.y.Value }, '#update');
    };
    return ScreenOffsetCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/ScreenOpenCommand.ts":
/*!******************************************************!*\
  !*** ./src/GUIConsole/Commands/ScreenOpenCommand.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScreenOpenCommand": () => (/* binding */ ScreenOpenCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ScreenOpenCommand = /** @class */ (function (_super) {
    __extends(ScreenOpenCommand, _super);
    function ScreenOpenCommand(console, index, width, height, numberOfColor, pixelMode, columns, lines, tags$) {
        if (numberOfColor === void 0) { numberOfColor = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(32); }
        if (pixelMode === void 0) { pixelMode = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(0); }
        if (columns === void 0) { columns = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(undefined); }
        if (lines === void 0) { lines = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(undefined); }
        if (tags$ === void 0) { tags$ = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(undefined); }
        var _this = _super.call(this, console) || this;
        _this.index = index;
        _this.width = width;
        _this.height = height;
        _this.numberOfColor = numberOfColor;
        _this.pixelMode = pixelMode;
        _this.columns = columns;
        _this.lines = lines;
        _this.tags$ = tags$;
        _this.CommandName = 'Cls';
        return _this;
    }
    ScreenOpenCommand.prototype.Execute = function (console) {
        console.tvc.screenOpen({
            index: this.index.Value,
            width: this.width.Value,
            height: this.height.Value,
            depth: undefined,
            numberOfColors: this.numberOfColor.Value,
            pixelMode: 0,
            palette: undefined,
            columns: this.columns.Value,
            lines: this.lines.Value,
            x: undefined,
            y: undefined,
            z: undefined,
            hotspotX: undefined,
            hotspotY: undefined,
            hotspotZ: undefined,
            offsetX: undefined,
            offsetY: undefined,
            offsetZ: undefined,
            skewX: undefined,
            skewY: undefined,
            skewZ: undefined,
            scaleX: undefined,
            scaleY: undefined,
            scaleZ: undefined,
            angle: undefined,
            alpha: undefined,
            visible: undefined
        }, this.tags$.Value);
    };
    return ScreenOpenCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/ScreenScaleCommand.ts":
/*!*******************************************************!*\
  !*** ./src/GUIConsole/Commands/ScreenScaleCommand.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScreenScaleCommand": () => (/* binding */ ScreenScaleCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ScreenScaleCommand = /** @class */ (function (_super) {
    __extends(ScreenScaleCommand, _super);
    function ScreenScaleCommand(console, index, xScale, yScale) {
        var _this = _super.call(this, console) || this;
        _this.index = index;
        _this.xScale = xScale;
        _this.yScale = yScale;
        _this.CommandName = 'Screen Scale';
        return _this;
    }
    ScreenScaleCommand.prototype.Execute = function (console) {
        console.tvc.getScreen(this.index.Value).setScale({ x: this.xScale.Value, y: this.yScale.Value }, '#update');
    };
    return ScreenScaleCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/ScreenToFrontCommand.ts":
/*!*********************************************************!*\
  !*** ./src/GUIConsole/Commands/ScreenToFrontCommand.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScreenToFrontCommand": () => (/* binding */ ScreenToFrontCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ScreenToFrontCommand = /** @class */ (function (_super) {
    __extends(ScreenToFrontCommand, _super);
    function ScreenToFrontCommand(console, index) {
        var _this = _super.call(this, console) || this;
        _this.index = index;
        _this.CommandName = 'ScreenToFront';
        return _this;
    }
    ScreenToFrontCommand.prototype.Execute = function (console) {
        console.tvc.screenToFront(console.tvc.getScreen(this.index.Value));
    };
    return ScreenToFrontCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/Commands/SetTransparent.ts":
/*!***************************************************!*\
  !*** ./src/GUIConsole/Commands/SetTransparent.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SetTransparentCommand": () => (/* binding */ SetTransparentCommand)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var SetTransparentCommand = /** @class */ (function (_super) {
    __extends(SetTransparentCommand, _super);
    function SetTransparentCommand(console, index) {
        var _this = _super.call(this, console) || this;
        _this.index = index;
        _this.CommandName = 'Set Transparent';
        return _this;
    }
    SetTransparentCommand.prototype.Execute = function (console) {
        console.tvc.currentScreen.setTransparent([this.index.Value], true);
    };
    return SetTransparentCommand;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ConsoleCommandBase));



/***/ }),

/***/ "./src/GUIConsole/GUIScreen.ts":
/*!*************************************!*\
  !*** ./src/GUIConsole/GUIScreen.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GuiScreen": () => (/* binding */ GuiScreen)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _drawing_Graphics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../drawing/Graphics */ "./src/drawing/Graphics.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var GuiScreen = /** @class */ (function (_super) {
    __extends(GuiScreen, _super);
    function GuiScreen(tvc, args, tags) {
        var _this = _super.call(this, tvc, args, tags) || this;
        _this.graphics = null;
        _this.graphics = new _drawing_Graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics(_this.context);
        return _this;
    }
    GuiScreen.prototype.DrawLine = function (pen, rect) {
        this.startDrawing();
        this.graphics.DrawLine(pen, rect.X, rect.Y, rect.Right, rect.Bottom);
        this.endDrawing();
        this.grPosition.x = rect.X + rect.Width;
        this.grPosition.y = rect.Y + rect.Height;
    };
    GuiScreen.prototype.DrawRectangle = function (pen, rect) {
        this.startDrawing();
        this.graphics.DrawRectangle(pen, rect);
        this.endDrawing();
        this.grPosition.x = rect.X + rect.Width;
        this.grPosition.y = rect.Y + rect.Height;
    };
    GuiScreen.prototype.FillRectangle = function (brush, rect) {
        this.startDrawing();
        this.graphics.FillRectangle(brush, rect);
        this.endDrawing();
        this.grPosition.x = rect.X + rect.Width;
        this.grPosition.y = rect.Y + rect.Height;
    };
    GuiScreen.prototype.DrawEllipse = function (pen, rect) {
        this.startDrawing();
        this.graphics.DrawEllipse(pen, rect);
        this.endDrawing();
        this.grPosition.x = rect.X + rect.Width;
        this.grPosition.y = rect.Y + rect.Height;
    };
    GuiScreen.prototype.FillEllipse = function (brush, rect) {
        this.startDrawing();
        this.graphics.FillEllipse(brush, rect);
        this.endDrawing();
        this.grPosition.x = rect.X + rect.Width;
        this.grPosition.y = rect.Y + rect.Height;
    };
    return GuiScreen;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Screen));



/***/ }),

/***/ "./src/GUIConsole/GuiConsole.ts":
/*!**************************************!*\
  !*** ./src/GUIConsole/GuiConsole.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GuiConsole": () => (/* binding */ GuiConsole)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Commands_ClsCommand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Commands/ClsCommand */ "./src/GUIConsole/Commands/ClsCommand.ts");
/* harmony import */ var _Commands_DrawCommand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Commands/DrawCommand */ "./src/GUIConsole/Commands/DrawCommand.ts");
/* harmony import */ var _Commands_DrawLineConsoleCommand__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Commands/DrawLineConsoleCommand */ "./src/GUIConsole/Commands/DrawLineConsoleCommand.ts");
/* harmony import */ var _Commands_DrawRectangleConsoleCommand__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Commands/DrawRectangleConsoleCommand */ "./src/GUIConsole/Commands/DrawRectangleConsoleCommand.ts");
/* harmony import */ var _Commands_EllipseCommand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Commands/EllipseCommand */ "./src/GUIConsole/Commands/EllipseCommand.ts");
/* harmony import */ var _Commands_FillRectangleConsoleCommand__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Commands/FillRectangleConsoleCommand */ "./src/GUIConsole/Commands/FillRectangleConsoleCommand.ts");
/* harmony import */ var _GuiTVC__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GuiTVC */ "./src/GUIConsole/GuiTVC.ts");
/* harmony import */ var _Commands_DrawEllipseCommand__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Commands/DrawEllipseCommand */ "./src/GUIConsole/Commands/DrawEllipseCommand.ts");
/* harmony import */ var _Commands_FillEllipseCommand__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Commands/FillEllipseCommand */ "./src/GUIConsole/Commands/FillEllipseCommand.ts");
/* harmony import */ var _Commands_ScreenOpenCommand__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Commands/ScreenOpenCommand */ "./src/GUIConsole/Commands/ScreenOpenCommand.ts");
/* harmony import */ var _Commands_SetTransparent__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Commands/SetTransparent */ "./src/GUIConsole/Commands/SetTransparent.ts");
/* harmony import */ var _Commands_ScreenCommand__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Commands/ScreenCommand */ "./src/GUIConsole/Commands/ScreenCommand.ts");
/* harmony import */ var _Commands_ScreenToFrontCommand__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Commands/ScreenToFrontCommand */ "./src/GUIConsole/Commands/ScreenToFrontCommand.ts");
/* harmony import */ var _Commands_ScreenCenter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Commands/ScreenCenter */ "./src/GUIConsole/Commands/ScreenCenter.ts");
/* harmony import */ var _Commands_ScreenClose__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Commands/ScreenClose */ "./src/GUIConsole/Commands/ScreenClose.ts");
/* harmony import */ var _Commands_LoadImageCommand__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Commands/LoadImageCommand */ "./src/GUIConsole/Commands/LoadImageCommand.ts");
/* harmony import */ var _Commands_PasteBobCommand__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Commands/PasteBobCommand */ "./src/GUIConsole/Commands/PasteBobCommand.ts");
/* harmony import */ var _Commands_ScreenOffsetCommand__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Commands/ScreenOffsetCommand */ "./src/GUIConsole/Commands/ScreenOffsetCommand.ts");
/* harmony import */ var _Commands_ScreenDisplay__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./Commands/ScreenDisplay */ "./src/GUIConsole/Commands/ScreenDisplay.ts");
/* harmony import */ var _Commands_ScreenScaleCommand__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Commands/ScreenScaleCommand */ "./src/GUIConsole/Commands/ScreenScaleCommand.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






















var GuiConsole = /** @class */ (function (_super) {
    __extends(GuiConsole, _super);
    function GuiConsole() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GuiConsole.prototype.CreateTVC = function (canvas, options) {
        return new _GuiTVC__WEBPACK_IMPORTED_MODULE_7__.GuiTVC(this.Canvas, options);
    };
    GuiConsole.prototype.DrawLine = function (pen, x1, y1, x2, y2) {
        this.m_CurrentQueue.Enqueue(new _Commands_DrawLineConsoleCommand__WEBPACK_IMPORTED_MODULE_3__.DrawLineConsoleCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(pen), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(x1), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(y1), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(x2), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(y2)));
    };
    GuiConsole.prototype.DrawRectangle = function (pen, rect) {
        this.m_CurrentQueue.Enqueue(new _Commands_DrawRectangleConsoleCommand__WEBPACK_IMPORTED_MODULE_4__.DrawRectangleConsoleCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(pen), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(rect)));
    };
    GuiConsole.prototype.FillRectangle = function (brush, rect) {
        this.m_CurrentQueue.Enqueue(new _Commands_FillRectangleConsoleCommand__WEBPACK_IMPORTED_MODULE_6__.FillRectangleConsoleCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(brush), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(rect)));
    };
    GuiConsole.prototype.DrawEllipse = function (pen, rect) {
        this.m_CurrentQueue.Enqueue(new _Commands_DrawEllipseCommand__WEBPACK_IMPORTED_MODULE_8__.DrawEllipseCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(pen), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(rect)));
    };
    GuiConsole.prototype.FillEllipse = function (brush, rect) {
        this.m_CurrentQueue.Enqueue(new _Commands_FillEllipseCommand__WEBPACK_IMPORTED_MODULE_9__.FillEllipseCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(brush), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(rect)));
    };
    /**
     * Clear an area of the current screen
     * @param ink The index of the color in the palette to clear with
     * @param x The horizontal coordinate of the top-left pixel of the rectangle to clear
     * @param y The vertical coordinate of the top-left pixel of the rectangle to clear
     * @param width The horizontal coordinate of the bottom-right pixel of the rectangle to clear
     * @param height The vertical coordinate of the bottom-right pixel of the rectangle to clear
     */
    GuiConsole.prototype.Cls = function (ink, x, y, width, height) {
        this.m_CurrentQueue.Enqueue(new _Commands_ClsCommand__WEBPACK_IMPORTED_MODULE_1__.ClsCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(ink), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(x), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(y), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(width), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(height)));
    };
    /**
     * Draw a line with the current Ink from the last graphical position
     * @param x The horizontal coordinate of the point
     * @param y  The vertical coordinate of the point
     * @param width width of line
     * @param height height of line
     */
    GuiConsole.prototype.Draw = function (x, y, width, height) {
        this.m_CurrentQueue.Enqueue(new _Commands_DrawCommand__WEBPACK_IMPORTED_MODULE_2__.DrawCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(x), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(y), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(width), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(height)));
    };
    /**
     * Draw an ellipse with the current Ink in the current screen
     * @param x The horizontal coordinate of the center of the ellipse
     * @param y The vertical coordinate of the center of the ellipse
     * @param xRadius The horizontal radius in pixels
     * @param yRadius The vertical radius in pixels
     */
    GuiConsole.prototype.Ellipse = function (x, y, xRadius, yRadius) {
        this.m_CurrentQueue.Enqueue(new _Commands_EllipseCommand__WEBPACK_IMPORTED_MODULE_5__.EllipseCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(x), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(y), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(xRadius), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(yRadius)));
    };
    Object.defineProperty(GuiConsole.prototype, "MouseX", {
        /**
         * Mouse Commands
         */
        get: function () {
            return this.tvc.GetXMouse();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GuiConsole.prototype, "MouseY", {
        get: function () {
            return this.tvc.GetYMouse();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GuiConsole.prototype, "MouseKey", {
        get: function () {
            return this.tvc.mouseButtons;
        },
        enumerable: false,
        configurable: true
    });
    GuiConsole.prototype.HideMouse = function () {
        this.tvc.showMouse(false);
        ;
    };
    GuiConsole.prototype.ShowMouse = function () {
        this.tvc.showMouse(true);
        ;
    };
    /**
     * Screen Commands
     */
    /**
     * Open a new screen
     * @param index The index of the screen to open. Any existing screen will be replaced by the new one
     * @param width The width of the screen in pixels
     * @param height The height of the screen in pixels
     * @param numberOfColor The number of colors of the palette (optional)
     * @param pixelMode Lowres, Hires, Laced or any combination
     * @param columns Number of columns in the text window associated with the screen
     * @param lines Number of lines in the text window associated with the screen
     * @param tags$ List of eventual tags
     */
    GuiConsole.prototype.ScreenOpen = function (index, width, height, numberOfColor, pixelMode, columns, lines, tags$) {
        if (numberOfColor === void 0) { numberOfColor = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(32); }
        if (pixelMode === void 0) { pixelMode = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(0); }
        if (columns === void 0) { columns = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(undefined); }
        if (lines === void 0) { lines = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(undefined); }
        if (tags$ === void 0) { tags$ = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(undefined); }
        this.m_CurrentQueue.Enqueue(new _Commands_ScreenOpenCommand__WEBPACK_IMPORTED_MODULE_10__.ScreenOpenCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(index), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(width), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(height), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(numberOfColor), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(pixelMode), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(columns), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(lines), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(tags$)));
    };
    /**
     * Destroys the current screen or a given screen
     * @param index The index of the screen to destroy, if ommited will destroy the current screen
     */
    GuiConsole.prototype.ScreenClose = function (index, tags$) {
        if (tags$ === void 0) { tags$ = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(undefined); }
        this.m_CurrentQueue.Enqueue(new _Commands_ScreenClose__WEBPACK_IMPORTED_MODULE_15__.ScreenCloseCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(index)));
    };
    /**
     * Create an exact and synchronized copy of the current screen that can be displayed at another position and Z-order.
     * Both screen share the same internal pixel buffers. Graphical operations are fobidden in the cloned screen
     * @param index The index of the screen to create, will replace an existing screen
     */
    GuiConsole.prototype.ScreenClone = function (index) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    /**
     * Make a screen disappear from display. The screen will remain active and drawing operation are still possible after this instruction
     * @param index The index of the screen, if ommited the instruction closes the current screen
     */
    GuiConsole.prototype.ScreenHide = function (index) {
    };
    GuiConsole.prototype.SetTransparent = function (index) {
        this.m_CurrentQueue.Enqueue(new _Commands_SetTransparent__WEBPACK_IMPORTED_MODULE_11__.SetTransparentCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(index)));
    };
    GuiConsole.prototype.Screen = function (index) {
        this.m_CurrentQueue.Enqueue(new _Commands_ScreenCommand__WEBPACK_IMPORTED_MODULE_12__.ScreenCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(index)));
    };
    GuiConsole.prototype.ScreenToFront = function (index) {
        this.m_CurrentQueue.Enqueue(new _Commands_ScreenToFrontCommand__WEBPACK_IMPORTED_MODULE_13__.ScreenToFrontCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(index)));
    };
    GuiConsole.prototype.ScreenCenter = function (index, centerX, centerY) {
        this.m_CurrentQueue.Enqueue(new _Commands_ScreenCenter__WEBPACK_IMPORTED_MODULE_14__.ScreenCenterCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(index), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(centerX), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(centerY)));
    };
    GuiConsole.prototype.ScreenWidth = function (index) {
        if (index === undefined) {
            return this.tvc.fp2Int(this.tvc.currentScreen.dimension.width);
        }
        else {
            return this.tvc.fp2Int(this.tvc.getScreen(index).dimension.width);
        }
    };
    GuiConsole.prototype.ScreenHeight = function (index) {
        if (index === undefined) {
            return this.tvc.fp2Int(this.tvc.currentScreen.dimension.height);
        }
        else {
            return this.tvc.fp2Int(this.tvc.getScreen(index).dimension.height);
        }
    };
    GuiConsole.prototype.ScreenOffset = function (index, xOffset, yOffset) {
        this.m_CurrentQueue.Enqueue(new _Commands_ScreenOffsetCommand__WEBPACK_IMPORTED_MODULE_18__.ScreenOffsetCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(index), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(xOffset), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(yOffset)));
        return this;
    };
    GuiConsole.prototype.ScreenDisplay = function (index, x, y, width, height) {
        this.m_CurrentQueue.Enqueue(new _Commands_ScreenDisplay__WEBPACK_IMPORTED_MODULE_19__.ScreenDisplayCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(index), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(x), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(y), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(width), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(height)));
        return this;
    };
    GuiConsole.prototype.ScreenScale = function (index, xScale, yScale) {
        this.m_CurrentQueue.Enqueue(new _Commands_ScreenScaleCommand__WEBPACK_IMPORTED_MODULE_20__.ScreenScaleCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(index), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(xScale), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(yScale)));
        return this;
    };
    //--------------------------------------------------------------------
    GuiConsole.prototype.LoadImage = function (path) {
        this.m_CurrentQueue.Enqueue(new _Commands_LoadImageCommand__WEBPACK_IMPORTED_MODULE_16__.LoadImageCommand(this, path, 0));
    };
    GuiConsole.prototype.PasteBob = function (x, y, index) {
        this.m_CurrentQueue.Enqueue(new _Commands_PasteBobCommand__WEBPACK_IMPORTED_MODULE_17__.PasteBobCommand(this, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(x), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(y), (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.lazy)(index)));
    };
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Virtual,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [HTMLCanvasElement, Object]),
        __metadata("design:returntype", Object)
    ], GuiConsole.prototype, "CreateTVC", null);
    return GuiConsole;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.TextConsole));



/***/ }),

/***/ "./src/GUIConsole/GuiTVC.ts":
/*!**********************************!*\
  !*** ./src/GUIConsole/GuiTVC.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GuiTVC": () => (/* binding */ GuiTVC)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _GUIScreen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GUIScreen */ "./src/GUIConsole/GUIScreen.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var GuiTVC = /** @class */ (function (_super) {
    __extends(GuiTVC, _super);
    function GuiTVC() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GuiTVC.prototype.CreateScreen = function (args, tags) {
        return new _GUIScreen__WEBPACK_IMPORTED_MODULE_1__.GuiScreen(this, args, tags);
    };
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Override,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object]),
        __metadata("design:returntype", _GUIScreen__WEBPACK_IMPORTED_MODULE_1__.GuiScreen)
    ], GuiTVC.prototype, "CreateScreen", null);
    return GuiTVC;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.TVC));



/***/ }),

/***/ "./src/GUIConsole/index.ts":
/*!*********************************!*\
  !*** ./src/GUIConsole/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GuiConsole": () => (/* reexport safe */ _GuiConsole__WEBPACK_IMPORTED_MODULE_0__.GuiConsole)
/* harmony export */ });
/* harmony import */ var _GuiConsole__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GuiConsole */ "./src/GUIConsole/GuiConsole.ts");



/***/ }),

/***/ "./src/Math/Quantize.ts":
/*!******************************!*\
  !*** ./src/Math/Quantize.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "quantize": () => (/* binding */ quantize)
/* harmony export */ });
var sigbits = 5;
var rshift = 8 - sigbits;
var maxIterations = 1000;
var fractByPopulations = 0.75;
var pv = {
    map: function (array, f) {
        var o = {};
        return f ? array.map(function (d, i) {
            o.index = i;
            return f.call(o, d);
        }) : array.slice();
    },
    naturalOrder: function (a, b) {
        return (a < b) ? -1 : ((a > b) ? 1 : 0);
    },
    sum: function (array, f) {
        var o = {};
        return array.reduce(f ? function (p, d, i) {
            o.index = i;
            return p + f.call(o, d);
        } : function (p, d) {
            return p + d;
        }, 0);
    },
    max: function (array, f) {
        return Math.max.apply(null, f ? pv.map(array, f) : array);
    }
};
var VBox = /** @class */ (function () {
    function VBox(r1, r2, g1, g2, b1, b2, histo) {
        this.r1 = r1;
        this.r2 = r2;
        this.g1 = g1;
        this.g2 = g2;
        this.b1 = b1;
        this.b2 = b2;
        this.histo = histo;
        this._count = 0;
        this.r1 = r1;
        this.r2 = r2;
        this.g1 = g1;
        this.g2 = g2;
        this.b1 = b1;
        this.b2 = b2;
        this.histo = histo;
    }
    VBox.prototype.volume = function (force) {
        if (!this._volume || force) {
            this._volume = ((this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1));
        }
        return this._volume;
    };
    VBox.prototype.count = function (force) {
        var histo = this.histo;
        if (!this._count_set || force) {
            var npix = 0, i, j, k, index;
            for (i = this.r1; i <= this.r2; i++) {
                for (j = this.g1; j <= this.g2; j++) {
                    for (k = this.b1; k <= this.b2; k++) {
                        index = getColorIndex(i, j, k);
                        npix += (histo[index] || 0);
                    }
                }
            }
            this._count = npix;
            this._count_set = true;
        }
        return this._count;
    };
    VBox.prototype.copy = function () {
        return new VBox(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.histo);
    };
    VBox.prototype.avg = function (force) {
        var histo = this.histo;
        if (!this._avg || force) {
            var ntot = 0, mult = 1 << (8 - sigbits), rsum = 0, gsum = 0, bsum = 0, hval, i, j, k, histoindex;
            for (i = this.r1; i <= this.r2; i++) {
                for (j = this.g1; j <= this.g2; j++) {
                    for (k = this.b1; k <= this.b2; k++) {
                        histoindex = getColorIndex(i, j, k);
                        hval = histo[histoindex] || 0;
                        ntot += hval;
                        rsum += (hval * (i + 0.5) * mult);
                        gsum += (hval * (j + 0.5) * mult);
                        bsum += (hval * (k + 0.5) * mult);
                    }
                }
            }
            if (ntot) {
                this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];
            }
            else {
                //console.log('empty box');
                this._avg = [~~(mult * (this.r1 + this.r2 + 1) / 2), ~~(mult * (this.g1 + this.g2 + 1) / 2), ~~(mult * (this.b1 + this.b2 + 1) / 2)];
            }
        }
        return this._avg;
    };
    VBox.prototype.contains = function (pixel) {
        var rval = pixel[0] >> rshift;
        var gval = pixel[1] >> rshift;
        var bval = pixel[2] >> rshift;
        return (rval >= this.r1 && rval <= this.r2 &&
            gval >= this.g1 && gval <= this.g2 &&
            bval >= this.b1 && bval <= this.b2);
    };
    return VBox;
}());
// Simple priority queue
var PQueue = /** @class */ (function () {
    function PQueue(comparator) {
        var contents = [], sorted = false;
        function sort() {
            contents.sort(comparator);
            sorted = true;
        }
        return {
            push: function (o) {
                contents.push(o);
                sorted = false;
            },
            peek: function (index) {
                if (!sorted)
                    sort();
                if (index === undefined)
                    index = contents.length - 1;
                return contents[index];
            },
            pop: function () {
                if (!sorted)
                    sort();
                return contents.pop();
            },
            size: function () {
                return contents.length;
            },
            map: function (f) {
                return contents.map(f);
            },
            debug: function () {
                if (!sorted)
                    sort();
                return contents;
            }
        };
    }
    return PQueue;
}());
var CMap = /** @class */ (function () {
    function CMap() {
        this.vboxes = new PQueue(function (a, b) {
            return pv.naturalOrder(a.vbox.count() * a.vbox.volume(), b.vbox.count() * b.vbox.volume());
        });
        ;
    }
    CMap.prototype.push = function (vbox) {
        this.vboxes.push({
            vbox: vbox,
            color: vbox.avg()
        });
    };
    CMap.prototype.palette = function () {
        return this.vboxes.map(function (vb) {
            return vb.color;
        });
    };
    CMap.prototype.size = function () {
        return this.vboxes.size();
    };
    CMap.prototype.map = function (color) {
        var vboxes = this.vboxes;
        for (var i = 0; i < vboxes.size(); i++) {
            if (vboxes.peek(i).vbox.contains(color)) {
                return vboxes.peek(i).color;
            }
        }
        return this.nearest(color);
    };
    CMap.prototype.nearest = function (color) {
        var vboxes = this.vboxes, d1, d2, pColor;
        for (var i = 0; i < vboxes.size(); i++) {
            d2 = Math.sqrt(Math.pow(color[0] - vboxes.peek(i).color[0], 2) +
                Math.pow(color[1] - vboxes.peek(i).color[1], 2) +
                Math.pow(color[2] - vboxes.peek(i).color[2], 2));
            if (d2 < d1 || d1 === undefined) {
                d1 = d2;
                pColor = vboxes.peek(i).color;
            }
        }
        return pColor;
    };
    CMap.prototype.forcebw = function () {
        // XXX: won't  work yet
        var vboxes = this.vboxes;
        vboxes.sort(function (a, b) {
            return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));
        });
        // force darkest color to black if everything < 5
        var lowest = vboxes[0].color;
        if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)
            vboxes[0].color = [0, 0, 0];
        // force lightest color to white if everything > 251
        var idx = vboxes.length - 1, highest = vboxes[idx].color;
        if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)
            vboxes[idx].color = [255, 255, 255];
    };
    return CMap;
}());
function getColorIndex(r, g, b) {
    return (r << (2 * sigbits)) + (g << sigbits) + b;
}
// histo (1-d array, giving the number of pixels in
// each quantized region of color space), or null on error
function getHisto(pixels) {
    var histosize = 1 << (3 * sigbits), histo = new Array(histosize), index, rval, gval, bval;
    pixels.forEach(function (pixel) {
        rval = pixel[0] >> rshift;
        gval = pixel[1] >> rshift;
        bval = pixel[2] >> rshift;
        index = getColorIndex(rval, gval, bval);
        histo[index] = (histo[index] || 0) + 1;
    });
    return histo;
}
function vboxFromPixels(pixels, histo) {
    var rmin = 1000000, rmax = 0, gmin = 1000000, gmax = 0, bmin = 1000000, bmax = 0, rval, gval, bval;
    // find min/max
    pixels.forEach(function (pixel) {
        rval = pixel[0] >> rshift;
        gval = pixel[1] >> rshift;
        bval = pixel[2] >> rshift;
        if (rval < rmin)
            rmin = rval;
        else if (rval > rmax)
            rmax = rval;
        if (gval < gmin)
            gmin = gval;
        else if (gval > gmax)
            gmax = gval;
        if (bval < bmin)
            bmin = bval;
        else if (bval > bmax)
            bmax = bval;
    });
    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);
}
function medianCutApply(histo, vbox) {
    if (!vbox.count())
        return;
    var rw = vbox.r2 - vbox.r1 + 1, gw = vbox.g2 - vbox.g1 + 1, bw = vbox.b2 - vbox.b1 + 1, maxw = pv.max([rw, gw, bw]);
    // only one pixel, no split
    if (vbox.count() == 1) {
        return [vbox.copy()];
    }
    /* Find the partial sum arrays along the selected axis. */
    var total = 0, partialsum = [], lookaheadsum = [], i, j, k, sum, index;
    if (maxw == rw) {
        for (i = vbox.r1; i <= vbox.r2; i++) {
            sum = 0;
            for (j = vbox.g1; j <= vbox.g2; j++) {
                for (k = vbox.b1; k <= vbox.b2; k++) {
                    index = getColorIndex(i, j, k);
                    sum += (histo[index] || 0);
                }
            }
            total += sum;
            partialsum[i] = total;
        }
    }
    else if (maxw == gw) {
        for (i = vbox.g1; i <= vbox.g2; i++) {
            sum = 0;
            for (j = vbox.r1; j <= vbox.r2; j++) {
                for (k = vbox.b1; k <= vbox.b2; k++) {
                    index = getColorIndex(j, i, k);
                    sum += (histo[index] || 0);
                }
            }
            total += sum;
            partialsum[i] = total;
        }
    }
    else { /* maxw == bw */
        for (i = vbox.b1; i <= vbox.b2; i++) {
            sum = 0;
            for (j = vbox.r1; j <= vbox.r2; j++) {
                for (k = vbox.g1; k <= vbox.g2; k++) {
                    index = getColorIndex(j, k, i);
                    sum += (histo[index] || 0);
                }
            }
            total += sum;
            partialsum[i] = total;
        }
    }
    partialsum.forEach(function (d, i) {
        lookaheadsum[i] = total - d;
    });
    function doCut(color) {
        var dim1 = color + '1', dim2 = color + '2', left, right, vbox1, vbox2, d2, count2 = 0;
        for (i = vbox[dim1]; i <= vbox[dim2]; i++) {
            if (partialsum[i] > total / 2) {
                vbox1 = vbox.copy();
                vbox2 = vbox.copy();
                left = i - vbox[dim1];
                right = vbox[dim2] - i;
                if (left <= right)
                    d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));
                else
                    d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));
                // avoid 0-count boxes
                while (!partialsum[d2])
                    d2++;
                count2 = lookaheadsum[d2];
                while (!count2 && partialsum[d2 - 1])
                    count2 = lookaheadsum[--d2];
                // set dimensions
                vbox1[dim2] = d2;
                vbox2[dim1] = vbox1[dim2] + 1;
                // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());
                return [vbox1, vbox2];
            }
        }
    }
    // determine the cut planes
    return maxw == rw ? doCut('r') :
        maxw == gw ? doCut('g') :
            doCut('b');
}
function quantize(pixels, maxcolors) {
    // short-circuit
    if (!pixels.length || maxcolors < 2 || maxcolors > 256) {
        // console.log('wrong number of maxcolors');
        return false;
    }
    // XXX: check color content and convert to grayscale if insufficient
    var histo = getHisto(pixels), histosize = 1 << (3 * sigbits);
    // check that we aren't below maxcolors already
    var nColors = 0;
    histo.forEach(function () {
        nColors++;
    });
    if (nColors <= maxcolors) {
        // XXX: generate the new colors from the histo and return
    }
    // get the beginning vbox from the colors
    var vbox = vboxFromPixels(pixels, histo), pq = new PQueue(function (a, b) {
        return pv.naturalOrder(a.count(), b.count());
    });
    pq.push(vbox);
    // inner function to do the iteration
    function iter(lh, target) {
        var ncolors = 1, niters = 0, vbox;
        while (niters < maxIterations) {
            vbox = lh.pop();
            if (!vbox.count()) { /* just put it back */
                lh.push(vbox);
                niters++;
                continue;
            }
            // do the cut
            var vboxes = medianCutApply(histo, vbox), vbox1 = vboxes[0], vbox2 = vboxes[1];
            if (!vbox1) {
                // console.log("vbox1 not defined; shouldn't happen!");
                return;
            }
            lh.push(vbox1);
            if (vbox2) { /* vbox2 can be null */
                lh.push(vbox2);
                ncolors++;
            }
            if (ncolors >= target)
                return;
            if (niters++ > maxIterations) {
                // console.log("infinite loop; perhaps too few pixels!");
                return;
            }
        }
    }
    // first set of colors, sorted by population
    iter(pq, fractByPopulations * maxcolors);
    // console.log(pq.size(), pq.debug().length, pq.debug().slice());
    // Re-sort by the product of pixel occupancy times the size in color space.
    var pq2 = new PQueue(function (a, b) {
        return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume());
    });
    while (pq.size()) {
        pq2.push(pq.pop());
    }
    // next set - generate the median cuts using the (npix * vol) sorting.
    iter(pq2, maxcolors - pq2.size());
    // calculate the actual colors
    var cmap = new CMap();
    while (pq2.size()) {
        cmap.push(pq2.pop());
    }
    return cmap;
}


/***/ }),

/***/ "./src/Modules/SDLModule.ts":
/*!**********************************!*\
  !*** ./src/Modules/SDLModule.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SDL_Palette": () => (/* binding */ SDL_Palette),
/* harmony export */   "SDL_PixelFormat": () => (/* binding */ SDL_PixelFormat),
/* harmony export */   "SDL_Surface": () => (/* binding */ SDL_Surface),
/* harmony export */   "SDLModule": () => (/* binding */ SDLModule)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_1__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var tempDouble;
var tempI64;
var SDL_Palette = /** @class */ (function () {
    function SDL_Palette() {
        this.ncolors = 0;
        this.colors = [];
        this.version = 0;
        this.refcount = 0;
    }
    return SDL_Palette;
}());

var SDL_PixelFormat = /** @class */ (function () {
    function SDL_PixelFormat() {
        this.format = 0;
        this.palette = null;
        this.BitsPerPixel = 0;
        this.BytesPerPixel = 0;
        this.padding = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(2);
        this.Rmask = 0;
        this.Gmask = 0;
        this.Bmask = 0;
        this.Amask = 0;
        this.Rloss = 0;
        this.Gloss = 0;
        this.Bloss = 0;
        this.Aloss = 0;
        this.Rshift = 0;
        this.Gshift = 0;
        this.Bshift = 0;
        this.Ashift = 0;
        this.refcount = 0;
        this.next = null;
    }
    return SDL_PixelFormat;
}());

var SurfaceCounter = 0;
var SDL_Surface = /** @class */ (function () {
    function SDL_Surface() {
        this.Id = 0;
        this.flags = 0; /**< Read-only */
        this.format = null; /**< Read-only */
        this.w = 0;
        this.h = 0; /**< Read-only */
        this.pitch = 0; /**< Read-only */
        this.pixels = null; /**< Read-write */
        /** Application data associated with the surface */
        this.userdata = null; /**< Read-write */
        /** information needed for surfaces requiring locks */
        this.locked = 0; /**< Read-only */
        this.lock_data = null; /**< Read-only */
        /** clipping information */
        this.clip_rect = _tuval_cg__WEBPACK_IMPORTED_MODULE_1__.CGRectangle.Empty; /**< Read-only */
        /** info for fast blit mapping to other surfaces */
        this.map = null; /**< Private */
        /** Reference count -- used when freeing surface */
        this.refcount = 0; /**< Read-mostly */
        this.Id = SurfaceCounter++;
    }
    return SDL_Surface;
}());

var SDLModule = /** @class */ (function (_super) {
    __extends(SDLModule, _super);
    function SDLModule(width, height) {
        var _this = _super.call(this, width, height) || this;
        _this.width = 320;
        _this.height = 200;
        _this.copyOnLock = true;
        _this.discardOnLock = false;
        _this.opaqueFrontBuffer = true;
        _this.version = null;
        _this.surfaces = {};
        _this.canvasPool = [];
        _this.events = [];
        _this.fonts = [null];
        _this.audios = [null];
        _this.rwops = [null];
        _this.music_audio = null;
        _this.music_volume = 1;
        _this.mixerFrequency = 22050;
        _this.mixerFormat = 32784;
        _this.mixerNumChannels = 2;
        _this.mixerChunkSize = 1024;
        _this.channelMinimumNumber = 0;
        _this.GL = false;
        _this.glAttributes = { 0: 3, 1: 3, 2: 2, 3: 0, 4: 0, 5: 1, 6: 16, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 1, 16: 0, 17: 0, 18: 0 };
        _this.keyboardState = null;
        _this.keyboardMap = {};
        _this.canRequestFullscreen = false;
        _this.isRequestingFullscreen = false;
        _this.textInput = false;
        _this.startTime = null;
        _this.initFlags = 0;
        _this.buttonState = 0;
        _this.modState = 0;
        _this.DOMButtons = [0, 0, 0];
        _this.DOMEventToSDLEvent = {};
        _this.TOUCH_DEFAULT_ID = 0;
        _this.eventHandler = null;
        _this.eventHandlerContext = null;
        _this.eventHandlerTemp = 0;
        _this.keyCodes = {
            16: 1249, 17: 1248, 18: 1250, 20: 1081, 33: 1099, 34: 1102, 35: 1101, 36: 1098,
            37: 1104, 38: 1106, 39: 1103, 40: 1105, 44: 316,
            45: 1097, 46: 127, 91: 1251, 93: 1125, 96: 1122,
            97: 1113, 98: 1114, 99: 1115, 100: 1116, 101: 1117, 102: 1118, 103: 1119, 104: 1120, 105: 1121, 106: 1109, 107: 1111, 109: 1110, 110: 1123, 111: 1108, 112: 1082, 113: 1083,
            114: 1084, 115: 1085, 116: 1086, 117: 1087, 118: 1088, 119: 1089, 120: 1090, 121: 1091, 122: 1092, 123: 1093, 124: 1128, 125: 1129, 126: 1130, 127: 1131, 128: 1132, 129: 1133, 130: 1134, 131: 1135, 132: 1136, 133: 1137, 134: 1138,
            135: 1139, 144: 1107, 160: 94, 161: 33, 162: 34, 163: 35, 164: 36, 165: 37, 166: 38, 167: 95, 168: 40, 169: 41, 170: 42, 171: 43, 172: 124, 173: 45, 174: 123, 175: 125, 176: 126, 181: 127, 182: 129, 183: 128, 188: 44, 190: 46, 191: 47, 192: 96, 219: 91, 220: 92,
            221: 93, 222: 39, 224: 1251
        };
        _this.scanCodes = {
            8: 42, 9: 43, 13: 40, 27: 41, 32: 44, 35: 204, 39: 53, 44: 54, 46: 55, 47: 56,
            48: 39, 49: 30, 50: 31, 51: 32, 52: 33, 53: 34, 54: 35, 55: 36, 56: 37, 57: 38, 58: 203, 59: 51,
            61: 46, 91: 47, 92: 49, 93: 48, 96: 52, 97: 4, 98: 5, 99: 6, 100: 7, 101: 8, 102: 9, 103: 10,
            104: 11, 105: 12, 106: 13, 107: 14, 108: 15, 109: 16, 110: 17, 111: 18, 112: 19, 113: 20, 114: 21,
            115: 22, 116: 23, 117: 24, 118: 25, 119: 26, 120: 27, 121: 28, 122: 29, 127: 76, 305: 224,
            308: 226, 316: 70
        };
        _this.channels = [];
        _this.numChannels = 0;
        _this.audioContext = null;
        _this.downFingers = {};
        _this.savedKeydown = null;
        _this.joystickEventState = 1;
        _this.lastJoystickState = {};
        _this.joystickNamePool = {};
        _this.doNotCaptureKeyboard = false;
        _this.addedResizeListener = false;
        _this.settingVideoMode = false;
        _this.screenIsReadOnly = false;
        return _this;
    }
    SDLModule.prototype.loadRect = function (rect) {
        return {
            x: this.HEAP32[((rect + 0) >> 2)],
            y: this.HEAP32[((rect + 4) >> 2)],
            w: this.HEAP32[((rect + 8) >> 2)],
            h: this.HEAP32[((rect + 12) >> 2)]
        };
    };
    SDLModule.prototype.updateRect = function (rect, r) {
        rect.X = r.X;
        rect.Y = r.Y;
        rect.Width = r.Width;
        rect.Height = r.Height;
        return rect;
    };
    SDLModule.prototype.intersectionOfRects = function (first, second) {
        var leftX = Math.max(first.X, second.X);
        var leftY = Math.max(first.Y, second.Y);
        var rightX = Math.min(first.X + first.Width, second.X + second.Width);
        var rightY = Math.min(first.Y + first.Height, second.Y + second.Height);
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_1__.CGRectangle(leftX, leftY, Math.max(leftX, rightX) - leftX, Math.max(leftY, rightY) - leftY);
    };
    SDLModule.prototype.checkPixelFormat = function (fmt) {
        // Canvas screens are always RGBA.
        var format = this.HEAP32[((fmt) >> 2)];
        if (format !== -2042224636) {
            this.warnOnce('Unsupported pixel format!');
        }
    };
    SDLModule.prototype.loadColorToCSSRGB = function (color) {
        //var rgba = this.HEAP32[((color) >> 2)];
        return 'rgb(' + (color.R) + ',' + color.G + ',' + color.B + ')';
    };
    SDLModule.prototype.loadColorToCSSRGBA = function (color) {
        var rgba = this.HEAP32[((color) >> 2)];
        return 'rgba(' + (rgba & 255) + ',' + ((rgba >> 8) & 255) + ',' + ((rgba >> 16) & 255) + ',' + (((rgba >> 24) & 255) / 255) + ')';
    };
    SDLModule.prototype.translateColorToCSSRGBA = function (color) {
        return 'rgba(' + color.R + ',' + color.G + ',' + color.B + ',' + color.A + ')';
    };
    SDLModule.prototype.translateRGBAToCSSRGBA = function (r, g, b, a) {
        return 'rgba(' + (r & 0xff) + ',' + (g & 0xff) + ',' + (b & 0xff) + ',' + (a & 0xff) / 255 + ')';
    };
    SDLModule.prototype.translateRGBAToColor = function (r, g, b, a) {
        return r | g << 8 | b << 16 | a << 24;
    };
    SDLModule.prototype.makeSurface = function (width, height, flags, usePageCanvas, source, rmask, gmask, bmask, amask) {
        flags = flags || 0;
        var is_SDL_HWSURFACE = flags & 0x00000001;
        var is_SDL_HWPALETTE = flags & 0x00200000;
        var is_SDL_OPENGL = flags & 0x04000000;
        var surf = new SDL_Surface(); // this._malloc(60);
        var pixelFormat = new SDL_PixelFormat(); //this._malloc(44);
        //surface with SDL_HWPALETTE flag is 8bpp surface (1 byte)
        var bpp = is_SDL_HWPALETTE ? 1 : 4;
        var buffer = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(0);
        // preemptively initialize this for software surfaces,
        // otherwise it will be lazily initialized inside of SDL_LockSurface
        if (!is_SDL_HWSURFACE && !is_SDL_OPENGL) {
            buffer = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(width * height * 4); //this._malloc(width * height * 4);
        }
        surf.flags = flags;
        surf.format = pixelFormat;
        surf.w = width;
        surf.h = height;
        surf.pitch = width * bpp; // assuming RGBA or indexed for now,
        // since that is what ImageData gives us in browsers
        surf.pixels = buffer;
        /** Application data associated with the surface */
        /*   surf.userdata = New.ByteArray(0);
          surf.locked = 0;
          surf.lock_data */
        surf.clip_rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_1__.CGRectangle(0, 0, this.Canvas.width, this.Canvas.height);
        //surf.map
        surf.refcount = 1;
        /* this.HEAP32[((surf) >> 2)] = flags;
        this.HEAP32[(((surf) + (4)) >> 2)] = pixelFormat;
        this.HEAP32[(((surf) + (8)) >> 2)] = width;
        this.HEAP32[(((surf) + (12)) >> 2)] = height;
        this.HEAP32[(((surf) + (16)) >> 2)] = width * bpp;  // assuming RGBA or indexed for now,
        // since that is what ImageData gives us in browsers
        this.HEAP32[(((surf) + (20)) >> 2)] = buffer; */
        /*  this.HEAP32[(((surf) + (36)) >> 2)] = 0;
         this.HEAP32[(((surf) + (40)) >> 2)] = 0;
         this.HEAP32[(((surf) + (44)) >> 2)] = this.Canvas.width;
         this.HEAP32[(((surf) + (48)) >> 2)] = this.Canvas.height; */
        //this.HEAP32[(((surf) + (56)) >> 2)] = 1;
        surf.format.format = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Convert.ToUInt32(-2042224636);
        surf.format.BitsPerPixel = bpp * 8;
        surf.format.BytesPerPixel = bpp;
        surf.format.Rmask = rmask || 0x000000ff;
        surf.format.Gmask = gmask || 0x0000ff00;
        surf.format.Bmask = bmask || 0x00ff0000;
        surf.format.Amask = amask || 0xff000000;
        //this.HEAP32[((pixelFormat) >> 2)] = -2042224636;
        /*  this.HEAP32[(((pixelFormat) + (4)) >> 2)] = 0;// TODO
         this.HEAP8[(((pixelFormat) + (8)) >> 0)] = bpp * 8;
         this.HEAP8[(((pixelFormat) + (9)) >> 0)] = bpp; */
        /*  this.HEAP32[(((pixelFormat) + (12)) >> 2)] = rmask || 0x000000ff;
         this.HEAP32[(((pixelFormat) + (16)) >> 2)] = gmask || 0x0000ff00;
         this.HEAP32[(((pixelFormat) + (20)) >> 2)] = bmask || 0x00ff0000;
         this.HEAP32[(((pixelFormat) + (24)) >> 2)] = amask || 0xff000000; */
        // Decide if we want to use WebGL or not
        this.GL = this.GL || !!is_SDL_OPENGL;
        var canvas;
        if (!usePageCanvas) {
            if (this.canvasPool.length > 0) {
                canvas = this.canvasPool.pop();
            }
            else {
                canvas = document.createElement('canvas');
            }
            canvas.width = width;
            canvas.height = height;
        }
        else {
            canvas = this.Canvas;
        }
        var webGLContextAttributes = {
            antialias: ((this.glAttributes[13 /*SDL_GL_MULTISAMPLEBUFFERS*/] != 0) && (this.glAttributes[14 /*SDL_GL_MULTISAMPLESAMPLES*/] > 1)),
            depth: (this.glAttributes[6 /*SDL_GL_DEPTH_SIZE*/] > 0),
            stencil: (this.glAttributes[7 /*SDL_GL_STENCIL_SIZE*/] > 0),
            alpha: (this.glAttributes[3 /*SDL_GL_ALPHA_SIZE*/] > 0)
        };
        var ctx = this.Browser.CreateContext(canvas, !!is_SDL_OPENGL, usePageCanvas, webGLContextAttributes);
        this.surfaces[surf.Id] = {
            width: width,
            height: height,
            canvas: canvas,
            ctx: ctx,
            surf: surf,
            buffer: buffer,
            pixelFormat: pixelFormat,
            alpha: 255,
            flags: flags,
            locked: 0,
            usePageCanvas: usePageCanvas,
            source: source,
            isFlagSet: function (flag) {
                return flags & flag;
            }
        };
        return surf;
    };
    SDLModule.prototype.copyIndexedColorData = function (surfData, rX, rY, rW, rH) {
        // HWPALETTE works with palette
        // setted by SDL_SetColors
        if (!surfData.colors) {
            return;
        }
        var fullWidth = this.Canvas.width;
        var fullHeight = this.Canvas.height;
        var startX = rX || 0;
        var startY = rY || 0;
        var endX = (rW || (fullWidth - startX)) + startX;
        var endY = (rH || (fullHeight - startY)) + startY;
        var buffer = surfData.buffer;
        if (!surfData.image.data32) {
            surfData.image.data32 = new Uint32Array(surfData.image.data.buffer);
        }
        var data32 = surfData.image.data32;
        var colors32 = surfData.colors32;
        for (var y = startY; y < endY; ++y) {
            var base = y * fullWidth;
            for (var x = startX; x < endX; ++x) {
                data32[base + x] = colors32[this.HEAPU8[((buffer + base + x) >> 0)]];
            }
        }
    };
    SDLModule.prototype.freeSurface = function (surf) {
        /*  var refcountPointer = surf + 56;
         var refcount = this.HEAP32[((refcountPointer) >> 2)];
         if (refcount > 1) {
             this.HEAP32[((refcountPointer) >> 2)] = refcount - 1;
             return;
         } */
        var info = this.surfaces[surf.Id];
        if (!info.usePageCanvas && info.canvas) {
            this.canvasPool.push(info.canvas);
        }
        if (info.buffer) {
            info.buffer = undefined;
            //this._free(info.buffer);
        }
        // this._free(info.pixelFormat);
        // this._free(surf);
        this.surfaces[surf.Id] = null;
        if (surf === this.screen) {
            this.screen = null;
        }
    };
    SDLModule.prototype.BlitSurface = function (src, srcrect, dst, dstrect, scale) {
        var srcData = this.surfaces[src.Id];
        var dstData = this.surfaces[dst.Id];
        var sr, dr;
        if (srcrect) {
            sr = srcrect; //this.loadRect(srcrect);
        }
        else {
            sr = new _tuval_cg__WEBPACK_IMPORTED_MODULE_1__.CGRectangle(0, 0, srcData.width, srcData.height);
        }
        if (dstrect) {
            dr = dstrect; //this.loadRect(dstrect);
        }
        else {
            dr = new _tuval_cg__WEBPACK_IMPORTED_MODULE_1__.CGRectangle(0, 0, srcData.width, srcData.height);
        }
        if (dstData.clipRect) {
            var widthScale = (!scale || sr.Width === 0) ? 1 : sr.Width / dr.Width;
            var heightScale = (!scale || sr.Height === 0) ? 1 : sr.Height / dr.Height;
            dr = this.intersectionOfRects(dstData.clipRect, dr);
            sr.Width = dr.Width * widthScale;
            sr.Height = dr.Height * heightScale;
            if (dstrect) {
                this.updateRect(dstrect, dr);
            }
        }
        var blitw, blith;
        if (scale) {
            blitw = dr.Width;
            blith = dr.Height;
        }
        else {
            blitw = sr.Width;
            blith = sr.Height;
        }
        if (sr.Width === 0 || sr.Height === 0 || blitw === 0 || blith === 0) {
            return 0;
        }
        var oldAlpha = dstData.ctx.globalAlpha;
        dstData.ctx.globalAlpha = srcData.alpha / 255;
        dstData.ctx.drawImage(srcData.canvas, sr.X, sr.Y, sr.Width, sr.Height, dr.X, dr.Y, blitw, blith);
        dstData.ctx.globalAlpha = oldAlpha;
        if (dst !== this.screen) {
            // XXX As in IMG_Load, for compatibility we write out |pixels|
            this.warnOnce('WARNING: copying canvas data to memory for compatibility');
            this._SDL_LockSurface(dst);
            dstData.locked--; // The surface is not actually locked in this hack
        }
        return 0;
    };
    SDLModule.prototype.receiveEvent = function (event) {
        var _this = this;
        var unpressAllPressedKeys = function () {
            // Un-press all pressed keys: TODO
            for (var code in _this.keyboardMap) {
                _this.events.push({
                    type: 'keyup',
                    keyCode: _this.keyboardMap[code]
                });
            }
        };
        switch (event.type) {
            case 'touchstart':
            case 'touchmove': {
                event.preventDefault();
                var touches = [];
                // Clear out any touchstart events that we've already processed
                if (event.type === 'touchstart') {
                    for (var i = 0; i < event.touches.length; i++) {
                        var touch = event.touches[i];
                        if (this.downFingers[touch.identifier] !== true) {
                            this.downFingers[touch.identifier] = true;
                            touches.push(touch);
                        }
                    }
                }
                else {
                    touches = event.touches;
                }
                var firstTouch = touches[0];
                if (firstTouch) {
                    if (event.type === 'touchstart') {
                        this.DOMButtons[0] = 1;
                    }
                    var mouseEventType;
                    switch (event.type) {
                        case 'touchstart':
                            mouseEventType = 'mousedown';
                            break;
                        case 'touchmove':
                            mouseEventType = 'mousemove';
                            break;
                    }
                    var mouseEvent = {
                        type: mouseEventType,
                        button: 0,
                        pageX: firstTouch.clientX,
                        pageY: firstTouch.clientY
                    };
                    this.events.push(mouseEvent);
                }
                for (var i = 0; i < touches.length; i++) {
                    var touch = touches[i];
                    this.events.push({
                        type: event.type,
                        touch: touch
                    });
                }
                ;
                break;
            }
            case 'touchend': {
                event.preventDefault();
                // Remove the entry in the SDL.downFingers hash
                // because the finger is no longer down.
                for (var i = 0; i < event.changedTouches.length; i++) {
                    var touch = event.changedTouches[i];
                    if (this.downFingers[touch.identifier] === true) {
                        delete this.downFingers[touch.identifier];
                    }
                }
                var mouseEvent_1 = {
                    type: 'mouseup',
                    button: 0,
                    pageX: event.changedTouches[0].clientX,
                    pageY: event.changedTouches[0].clientY
                };
                this.DOMButtons[0] = 0;
                this.events.push(mouseEvent_1);
                for (var i = 0; i < event.changedTouches.length; i++) {
                    var touch = event.changedTouches[i];
                    this.events.push({
                        type: 'touchend',
                        touch: touch
                    });
                }
                ;
                break;
            }
            case 'DOMMouseScroll':
            case 'mousewheel':
            case 'wheel':
                var delta = -this.Browser.GetMouseWheelDelta(event); // Flip the wheel direction to translate from browser wheel direction (+:down) to SDL direction (+:up)
                delta = (delta == 0) ? 0 : (delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1)); // Quantize to integer so that minimum scroll is at least +/- 1.
                // Simulate old-style SDL events representing mouse wheel input as buttons
                var button = delta > 0 ? 3 /*SDL_BUTTON_WHEELUP-1*/ : 4 /*SDL_BUTTON_WHEELDOWN-1*/; // Subtract one since JS->C marshalling is defined to add one back.
                this.events.push({ type: 'mousedown', button: button, pageX: event.pageX, pageY: event.pageY });
                this.events.push({ type: 'mouseup', button: button, pageX: event.pageX, pageY: event.pageY });
                // Pass a delta motion event.
                this.events.push({ type: 'wheel', deltaX: 0, deltaY: delta });
                event.preventDefault(); // If we don't prevent this, then 'wheel' event will be sent again by the browser as 'DOMMouseScroll' and we will receive this same event the second time.
                break;
            case 'mousemove':
                if (this.DOMButtons[0] === 1) {
                    this.events.push({
                        type: 'touchmove',
                        touch: {
                            identifier: 0,
                            deviceID: -1,
                            pageX: event.pageX,
                            pageY: event.pageY
                        }
                    });
                }
                if (this.Browser.pointerLock) {
                    // workaround for firefox bug 750111
                    if ('mozMovementX' in event) {
                        event['movementX'] = event['mozMovementX'];
                        event['movementY'] = event['mozMovementY'];
                    }
                    // workaround for Firefox bug 782777
                    if (event['movementX'] == 0 && event['movementY'] == 0) {
                        // ignore a mousemove event if it doesn't contain any movement info
                        // (without pointer lock, we infer movement from pageX/pageY, so this check is unnecessary)
                        event.preventDefault();
                        return;
                    }
                }
            // fall through
            case 'keydown':
            case 'keyup':
            case 'keypress':
            case 'mousedown':
            case 'mouseup':
                // If we preventDefault on keydown events, the subsequent keypress events
                // won't fire. However, it's fine (and in some cases necessary) to
                // preventDefault for keys that don't generate a character. Otherwise,
                // preventDefault is the right thing to do in general.
                if (event.type !== 'keydown' || (!this.SDL_unicode() && !this.textInput) || (event.keyCode === 8 /* backspace */ || event.keyCode === 9 /* tab */)) {
                    event.preventDefault();
                }
                if (event.type == 'mousedown') {
                    this.DOMButtons[event.button] = 1;
                    this.events.push({
                        type: 'touchstart',
                        touch: {
                            identifier: 0,
                            deviceID: -1,
                            pageX: event.pageX,
                            pageY: event.pageY
                        }
                    });
                }
                else if (event.type == 'mouseup') {
                    // ignore extra ups, can happen if we leave the canvas while pressing down, then return,
                    // since we add a mouseup in that case
                    if (!this.DOMButtons[event.button]) {
                        return;
                    }
                    this.events.push({
                        type: 'touchend',
                        touch: {
                            identifier: 0,
                            deviceID: -1,
                            pageX: event.pageX,
                            pageY: event.pageY
                        }
                    });
                    this.DOMButtons[event.button] = 0;
                }
                // We can only request fullscreen as the result of user input.
                // Due to this limitation, we toggle a boolean on keydown which
                // SDL_WM_ToggleFullScreen will check and subsequently set another
                // flag indicating for us to request fullscreen on the following
                // keyup. This isn't perfect, but it enables SDL_WM_ToggleFullScreen
                // to work as the result of a keypress (which is an extremely
                // common use case).
                if (event.type === 'keydown' || event.type === 'mousedown') {
                    this.canRequestFullscreen = true;
                }
                else if (event.type === 'keyup' || event.type === 'mouseup') {
                    if (this.isRequestingFullscreen) {
                        this.requestFullscreen(/*lockPointer=*/ true, /*resizeCanvas=*/ true);
                        this.isRequestingFullscreen = false;
                    }
                    this.canRequestFullscreen = false;
                }
                // SDL expects a unicode character to be passed to its keydown events.
                // Unfortunately, the browser APIs only provide a charCode property on
                // keypress events, so we must backfill in keydown events with their
                // subsequent keypress event's charCode.
                if (event.type === 'keypress' && this.savedKeydown) {
                    // charCode is read-only
                    this.savedKeydown.keypressCharCode = event.charCode;
                    this.savedKeydown = null;
                }
                else if (event.type === 'keydown') {
                    this.savedKeydown = event;
                }
                // Don't push keypress events unless SDL_StartTextInput has been called.
                if (event.type !== 'keypress' || this.textInput) {
                    this.events.push(event);
                }
                break;
            case 'mouseout':
                // Un-press all pressed mouse buttons, because we might miss the release outside of the canvas
                for (var i = 0; i < 3; i++) {
                    if (this.DOMButtons[i]) {
                        this.events.push({
                            type: 'mouseup',
                            button: i,
                            pageX: event.pageX,
                            pageY: event.pageY
                        });
                        this.DOMButtons[i] = 0;
                    }
                }
                event.preventDefault();
                break;
            case 'focus':
                this.events.push(event);
                event.preventDefault();
                break;
            case 'blur':
                this.events.push(event);
                unpressAllPressedKeys();
                event.preventDefault();
                break;
            case 'visibilitychange':
                this.events.push({
                    type: 'visibilitychange',
                    visible: !document.hidden
                });
                unpressAllPressedKeys();
                event.preventDefault();
                break;
            case 'unload':
                if (this.Browser.mainLoop.Runner) {
                    this.events.push(event);
                    // Force-run a main event loop, since otherwise this event will never be caught!
                    this.Browser.mainLoop.Runner();
                }
                return;
            case 'resize':
                this.events.push(event);
                // manually triggered resize event doesn't have a preventDefault member
                if (event.preventDefault) {
                    event.preventDefault();
                }
                break;
        }
        if (this.events.length >= 10000) {
            this.err('SDL event queue full, dropping events');
            this.events = this.events.slice(0, 10000);
        }
        // If we have a handler installed, this will push the events to the app
        // instead of the app polling for them.
        this.flushEventsToHandler();
        return;
    };
    SDLModule.prototype.lookupKeyCodeForEvent = function (event) {
        var code = event.keyCode;
        if (code >= 65 && code <= 90) {
            code += 32; // make lowercase for SDL
        }
        else {
            code = this.keyCodes[event.keyCode] || event.keyCode;
            // If this is one of the modifier keys (224 | 1<<10 - 227 | 1<<10), and the event specifies that it is
            // a right key, add 4 to get the right key SDL key code.
            if (event.location === 2 /*KeyboardEvent.DOM_KEY_LOCATION_RIGHT*/ && code >= (224 | 1 << 10) && code <= (227 | 1 << 10)) {
                code += 4;
            }
        }
        return code;
    };
    SDLModule.prototype.handleEvent = function (event) {
        if (event.handled)
            return;
        event.handled = true;
        switch (event.type) {
            case 'touchstart':
            case 'touchend':
            case 'touchmove': {
                this.Browser.CalculateMouseEvent(event);
                break;
            }
            case 'keydown':
            case 'keyup': {
                var down = event.type === 'keydown';
                var code = this.lookupKeyCodeForEvent(event);
                // Assigning a boolean to HEAP8, that's alright but Closure would like to warn about it:
                /** @suppress{checkTypes} */
                this.HEAP8[(((this.keyboardState) + (code)) >> 0)] = down ? 1 : 0;
                // TODO: lmeta, rmeta, numlock, capslock, KMOD_MODE, KMOD_RESERVED
                this.modState = (this.HEAP8[(((this.keyboardState) + (1248)) >> 0)] ? 0x0040 : 0) | // KMOD_LCTRL
                    (this.HEAP8[(((this.keyboardState) + (1249)) >> 0)] ? 0x0001 : 0) | // KMOD_LSHIFT
                    (this.HEAP8[(((this.keyboardState) + (1250)) >> 0)] ? 0x0100 : 0) | // KMOD_LALT
                    (this.HEAP8[(((this.keyboardState) + (1252)) >> 0)] ? 0x0080 : 0) | // KMOD_RCTRL
                    (this.HEAP8[(((this.keyboardState) + (1253)) >> 0)] ? 0x0002 : 0) | // KMOD_RSHIFT
                    (this.HEAP8[(((this.keyboardState) + (1254)) >> 0)] ? 0x0200 : 0); //  KMOD_RALT
                if (down) {
                    this.keyboardMap[code] = event.keyCode; // save the DOM input, which we can use to unpress it during blur
                }
                else {
                    delete this.keyboardMap[code];
                }
                break;
            }
            case 'mousedown':
            case 'mouseup':
                if (event.type == 'mousedown') {
                    // SDL_BUTTON(x) is defined as (1 << ((x)-1)).  SDL buttons are 1-3,
                    // and DOM buttons are 0-2, so this means that the below formula is
                    // correct.
                    this.buttonState |= 1 << event.button;
                }
                else if (event.type === 'mouseup') {
                    this.buttonState &= ~(1 << event.button);
                }
            // fall through
            case 'mousemove': {
                this.Browser.CalculateMouseEvent(event);
                break;
            }
        }
    };
    SDLModule.prototype.flushEventsToHandler = function () {
        if (!this.eventHandler)
            return;
        while (this.pollEvent(this.eventHandlerTemp)) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
            //wasmTable.get(this.eventHandler)(this.eventHandlerContext, this.eventHandlerTemp);
        }
    };
    SDLModule.prototype.pollEvent = function (ptr) {
        if (this.initFlags & 0x200 && this.joystickEventState) {
            // If SDL_INIT_JOYSTICK was supplied AND the joystick system is configured
            // to automatically query for events, query for joystick events.
            this.queryJoysticks();
        }
        if (ptr) {
            while (this.events.length > 0) {
                if (this.makeCEvent(this.events.shift(), ptr) !== false)
                    return 1;
            }
            return 0;
        }
        else {
            // XXX: somewhat risky in that we do not check if the event is real or not (makeCEvent returns false) if no pointer supplied
            return this.events.length > 0 ? 1 : 0;
        }
    };
    SDLModule.prototype.makeCEvent = function (event, ptr) {
        if (typeof event === 'number') {
            // This is a pointer to a copy of a native C event that was SDL_PushEvent'ed
            this._memcpy(ptr, event, 28);
            this._free(event); // the copy is no longer needed
            return false;
        }
        this.handleEvent(event);
        switch (event.type) {
            case 'keydown':
            case 'keyup': {
                var down = event.type === 'keydown';
                //out('Received key event: ' + event.keyCode);
                var key = this.lookupKeyCodeForEvent(event);
                var scan;
                if (key >= 1024) {
                    scan = key - 1024;
                }
                else {
                    scan = this.scanCodes[key] || key;
                }
                this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                this.HEAP8[(((ptr) + (8)) >> 0)] = down ? 1 : 0;
                this.HEAP8[(((ptr) + (9)) >> 0)] = 0; // TODO
                this.HEAP32[(((ptr) + (12)) >> 2)] = scan;
                this.HEAP32[(((ptr) + (16)) >> 2)] = key;
                this.HEAP16[(((ptr) + (20)) >> 1)] = this.modState;
                // some non-character keys (e.g. backspace and tab) won't have keypressCharCode set, fill in with the keyCode.
                this.HEAP32[(((ptr) + (24)) >> 2)] = event.keypressCharCode || key;
                break;
            }
            case 'keypress': {
                this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                // Not filling in windowID for now
                var cStr = this.intArrayFromString(String.fromCharCode(event.charCode));
                for (var i = 0; i < cStr.length; ++i) {
                    this.HEAP8[(((ptr) + (8 + i)) >> 0)] = cStr[i];
                }
                break;
            }
            case 'mousedown':
            case 'mouseup':
            case 'mousemove': {
                if (event.type != 'mousemove') {
                    var down = event.type === 'mousedown';
                    this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                    this.HEAP32[(((ptr) + (4)) >> 2)] = 0;
                    this.HEAP32[(((ptr) + (8)) >> 2)] = 0;
                    this.HEAP32[(((ptr) + (12)) >> 2)] = 0;
                    this.HEAP8[(((ptr) + (16)) >> 0)] = event.button + 1; // DOM buttons are 0-2, SDL 1-3
                    this.HEAP8[(((ptr) + (17)) >> 0)] = down ? 1 : 0;
                    this.HEAP32[(((ptr) + (20)) >> 2)] = this.Browser.mouseX;
                    this.HEAP32[(((ptr) + (24)) >> 2)] = this.Browser.mouseY;
                }
                else {
                    this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                    this.HEAP32[(((ptr) + (4)) >> 2)] = 0;
                    this.HEAP32[(((ptr) + (8)) >> 2)] = 0;
                    this.HEAP32[(((ptr) + (12)) >> 2)] = 0;
                    this.HEAP32[(((ptr) + (16)) >> 2)] = this.buttonState;
                    this.HEAP32[(((ptr) + (20)) >> 2)] = this.Browser.mouseX;
                    this.HEAP32[(((ptr) + (24)) >> 2)] = this.Browser.mouseY;
                    this.HEAP32[(((ptr) + (28)) >> 2)] = this.Browser.mouseMovementX;
                    this.HEAP32[(((ptr) + (32)) >> 2)] = this.Browser.mouseMovementY;
                }
                break;
            }
            case 'wheel': {
                this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                this.HEAP32[(((ptr) + (16)) >> 2)] = event.deltaX;
                this.HEAP32[(((ptr) + (20)) >> 2)] = event.deltaY;
                break;
            }
            case 'touchstart':
            case 'touchend':
            case 'touchmove': {
                var touch = event.touch;
                if (!this.Browser.touches[touch.identifier])
                    break;
                var w = this.Canvas.width;
                var h = this.Canvas.height;
                var x = this.Browser.touches[touch.identifier].x / w;
                var y = this.Browser.touches[touch.identifier].y / h;
                var lx = this.Browser.lastTouches[touch.identifier].x / w;
                var ly = this.Browser.lastTouches[touch.identifier].y / h;
                var dx = x - lx;
                var dy = y - ly;
                if (touch['deviceID'] === undefined)
                    touch.deviceID = this.TOUCH_DEFAULT_ID;
                if (dx === 0 && dy === 0 && event.type === 'touchmove')
                    return false; // don't send these if nothing happened
                this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                this.HEAP32[(((ptr) + (4)) >> 2)] = this._SDL_GetTicks();
                (tempI64 = [touch.deviceID >>> 0, (tempDouble = touch.deviceID, (+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble) / 4294967296.0))), 4294967295.0)) | 0) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], this.HEAP32[(((ptr) + (8)) >> 2)] = tempI64[0], this.HEAP32[(((ptr) + (12)) >> 2)] = tempI64[1]);
                (tempI64 = [touch.identifier >>> 0, (tempDouble = touch.identifier, (+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble) / 4294967296.0))), 4294967295.0)) | 0) >>> 0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble))) >>> 0)) / 4294967296.0))))) >>> 0) : 0)], this.HEAP32[(((ptr) + (16)) >> 2)] = tempI64[0], this.HEAP32[(((ptr) + (20)) >> 2)] = tempI64[1]);
                this.HEAPF32[(((ptr) + (24)) >> 2)] = x;
                this.HEAPF32[(((ptr) + (28)) >> 2)] = y;
                this.HEAPF32[(((ptr) + (32)) >> 2)] = dx;
                this.HEAPF32[(((ptr) + (36)) >> 2)] = dy;
                if (touch.force !== undefined) {
                    this.HEAPF32[(((ptr) + (40)) >> 2)] = touch.force;
                }
                else { // No pressure data, send a digital 0/1 pressure.
                    this.HEAPF32[(((ptr) + (40)) >> 2)] = event.type == "touchend" ? 0 : 1;
                }
                break;
            }
            case 'unload': {
                this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                break;
            }
            case 'resize': {
                this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                this.HEAP32[(((ptr) + (4)) >> 2)] = event.w;
                this.HEAP32[(((ptr) + (8)) >> 2)] = event.h;
                break;
            }
            case 'joystick_button_up':
            case 'joystick_button_down': {
                var state = event.type === 'joystick_button_up' ? 0 : 1;
                this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                this.HEAP8[(((ptr) + (4)) >> 0)] = event.index;
                this.HEAP8[(((ptr) + (5)) >> 0)] = event.button;
                this.HEAP8[(((ptr) + (6)) >> 0)] = state;
                break;
            }
            case 'joystick_axis_motion': {
                this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                this.HEAP8[(((ptr) + (4)) >> 0)] = event.index;
                this.HEAP8[(((ptr) + (5)) >> 0)] = event.axis;
                this.HEAP32[(((ptr) + (8)) >> 2)] = this.joystickAxisValueConversion(event.value);
                break;
            }
            case 'focus': {
                var SDL_WINDOWEVENT_FOCUS_GAINED = 12 /* SDL_WINDOWEVENT_FOCUS_GAINED */;
                this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                this.HEAP32[(((ptr) + (4)) >> 2)] = 0;
                this.HEAP8[(((ptr) + (8)) >> 0)] = SDL_WINDOWEVENT_FOCUS_GAINED;
                break;
            }
            case 'blur': {
                var SDL_WINDOWEVENT_FOCUS_LOST = 13 /* SDL_WINDOWEVENT_FOCUS_LOST */;
                this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                this.HEAP32[(((ptr) + (4)) >> 2)] = 0;
                this.HEAP8[(((ptr) + (8)) >> 0)] = SDL_WINDOWEVENT_FOCUS_LOST;
                break;
            }
            case 'visibilitychange': {
                var SDL_WINDOWEVENT_SHOWN = 1 /* SDL_WINDOWEVENT_SHOWN */;
                var SDL_WINDOWEVENT_HIDDEN = 2 /* SDL_WINDOWEVENT_HIDDEN */;
                var visibilityEventID = event.visible ? SDL_WINDOWEVENT_SHOWN : SDL_WINDOWEVENT_HIDDEN;
                this.HEAP32[((ptr) >> 2)] = this.DOMEventToSDLEvent[event.type];
                this.HEAP32[(((ptr) + (4)) >> 2)] = 0;
                this.HEAP8[(((ptr) + (8)) >> 0)] = visibilityEventID;
                break;
            }
            default: throw 'Unhandled SDL event: ' + event.type;
        }
        throw 'Unhandled SDL event: ' + event.type;
    };
    SDLModule.prototype.makeFontString = function (height, fontName) {
        if (fontName.charAt(0) != "'" && fontName.charAt(0) != '"') {
            // https://developer.mozilla.org/ru/docs/Web/CSS/font-family
            // Font family names containing whitespace should be quoted.
            // BTW, quote all font names is easier than searching spaces
            fontName = '"' + fontName + '"';
        }
        return height + 'px ' + fontName + ', serif';
    };
    SDLModule.prototype.estimateTextWidth = function (fontData, text) {
        var h = fontData.size;
        var fontString = this.makeFontString(h, fontData.name);
        var tempCtx = this.SDL_ttfContext();
        this.assert(tempCtx, 'TTF_Init must have been called');
        tempCtx.font = fontString;
        var ret = tempCtx.measureText(text).width | 0;
        return ret;
    };
    SDLModule.prototype.allocateChannels = function (num) {
        if (this.numChannels && this.numChannels >= num && num !== 0)
            return;
        this.numChannels = num;
        this.channels = [];
        for (var i = 0; i < num; i++) {
            this.channels[i] = {
                audio: null,
                volume: 1.0
            };
        }
    };
    SDLModule.prototype.setGetVolume = function (info, volume) {
        if (!info) {
            return 0;
        }
        var ret = info.volume * 128; // MIX_MAX_VOLUME
        if (volume !== -1) {
            info.volume = Math.min(Math.max(volume, 0), 128) / 128;
            if (info.audio) {
                try {
                    info.audio.volume = info.volume; // For <audio> element
                    if (info.audio.webAudioGainNode)
                        info.audio.webAudioGainNode['gain']['value'] = info.volume; // For WebAudio playback
                }
                catch (e) {
                    this.err('setGetVolume failed to set audio volume: ' + e);
                }
            }
        }
        return ret;
    };
    SDLModule.prototype.setPannerPosition = function (info, x, y, z) {
        if (!info)
            return;
        if (info.audio) {
            if (info.audio.webAudioPannerNode) {
                info.audio.webAudioPannerNode['setPosition'](x, y, z);
            }
        }
    };
    SDLModule.prototype.playWebAudio = function (audio) {
        if (!audio)
            return;
        if (audio.webAudioNode)
            return; // This instance is already playing, don't start again.
        if (!this.webAudioAvailable())
            return;
        try {
            var webAudio = audio.resource.webAudio;
            audio.paused = false;
            if (!webAudio.decodedBuffer) {
                if (webAudio.onDecodeComplete === undefined)
                    this.abort("Cannot play back audio object that was not loaded");
                webAudio.onDecodeComplete.push(function () { if (!audio.paused)
                    this.playWebAudio(audio); });
                return;
            }
            audio.webAudioNode = this.audioContext['createBufferSource']();
            audio.webAudioNode['buffer'] = webAudio.decodedBuffer;
            audio.webAudioNode['loop'] = audio.loop;
            audio.webAudioNode['onended'] = function () { audio['onended'](); }; // For <media> element compatibility, route the onended signal to the instance.
            audio.webAudioPannerNode = this.audioContext['createPanner']();
            // avoid Chrome bug
            // If posz = 0, the sound will come from only the right.
            // By posz = -0.5 (slightly ahead), the sound will come from right and left correctly.
            audio.webAudioPannerNode["setPosition"](0, 0, -.5);
            audio.webAudioPannerNode['panningModel'] = 'equalpower';
            // Add an intermediate gain node to control volume.
            audio.webAudioGainNode = this.audioContext['createGain']();
            audio.webAudioGainNode['gain']['value'] = audio.volume;
            audio.webAudioNode['connect'](audio.webAudioPannerNode);
            audio.webAudioPannerNode['connect'](audio.webAudioGainNode);
            audio.webAudioGainNode['connect'](this.audioContext['destination']);
            audio.webAudioNode['start'](0, audio.currentPosition);
            audio.startTime = this.audioContext['currentTime'] - audio.currentPosition;
        }
        catch (e) {
            this.err('playWebAudio failed: ' + e);
        }
    };
    SDLModule.prototype.pauseWebAudio = function (audio) {
        if (!audio)
            return;
        if (audio.webAudioNode) {
            try {
                // Remember where we left off, so that if/when we resume, we can restart the playback at a proper place.
                audio.currentPosition = (this.audioContext['currentTime'] - audio.startTime) % audio.resource.webAudio.decodedBuffer.duration;
                // Important: When we reach here, the audio playback is stopped by the user. But when calling .stop() below, the Web Audio
                // graph will send the onended signal, but we don't want to process that, since pausing should not clear/destroy the audio
                // channel.
                audio.webAudioNode['onended'] = undefined;
                audio.webAudioNode.stop(0); // 0 is a default parameter, but WebKit is confused by it #3861
                audio.webAudioNode = undefined;
            }
            catch (e) {
                this.err('pauseWebAudio failed: ' + e);
            }
        }
        audio.paused = true;
    };
    SDLModule.prototype.openAudioContext = function () {
        // Initialize Web Audio API if we haven't done so yet. Note: Only initialize Web Audio context ever once on the web page,
        // since initializing multiple times fails on Chrome saying 'audio resources have been exhausted'.
        if (!this.audioContext) {
            if (typeof (AudioContext) !== 'undefined')
                this.audioContext = new AudioContext();
            else if (typeof (webkitAudioContext) !== 'undefined')
                this.audioContext = new webkitAudioContext();
        }
    };
    SDLModule.prototype.webAudioAvailable = function () {
        return !!this.audioContext;
    };
    SDLModule.prototype.fillWebAudioBufferFromHeap = function (heapPtr, sizeSamplesPerChannel, dstAudioBuffer) {
        // The input audio data is interleaved across the channels, i.e. [L, R, L, R, L, R, ...] and is either 8-bit, 16-bit or float as
        // supported by the SDL API. The output audio wave data for Web Audio API must be in planar buffers of [-1,1]-normalized Float32 data,
        // so perform a buffer conversion for the data.
        var audio = this.SDL_audio();
        var numChannels = audio.channels;
        for (var c = 0; c < numChannels; ++c) {
            var channelData = dstAudioBuffer['getChannelData'](c);
            if (channelData.length !== sizeSamplesPerChannel) {
                throw 'Web Audio output buffer length mismatch! Destination size: ' + channelData.length + ' samples vs expected ' + sizeSamplesPerChannel + ' samples!';
            }
            if (audio.format == 0x8010 /*AUDIO_S16LSB*/) {
                for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                    channelData[j] = (this.HEAP16[(((heapPtr) + ((j * numChannels + c) * 2)) >> 1)]) / 0x8000;
                }
            }
            else if (audio.format == 0x0008 /*AUDIO_U8*/) {
                for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                    var v = (this.HEAP8[(((heapPtr) + (j * numChannels + c)) >> 0)]);
                    channelData[j] = ((v >= 0) ? v - 128 : v + 128) / 128;
                }
            }
            else if (audio.format == 0x8120 /*AUDIO_F32*/) {
                for (var j = 0; j < sizeSamplesPerChannel; ++j) {
                    channelData[j] = (this.HEAPF32[(((heapPtr) + ((j * numChannels + c) * 4)) >> 2)]);
                }
            }
            else {
                throw 'Invalid SDL audio format ' + audio.format + '!';
            }
        }
    };
    SDLModule.prototype.debugSurface = function (surfData) {
        console.log('dumping surface ' + [surfData.surf, surfData.source, surfData.width, surfData.height]);
        var image = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
        var data = image.data;
        var num = Math.min(surfData.width, surfData.height);
        for (var i = 0; i < num; i++) {
            console.log('   diagonal ' + i + ':' + [data[i * surfData.width * 4 + i * 4 + 0], data[i * surfData.width * 4 + i * 4 + 1], data[i * surfData.width * 4 + i * 4 + 2], data[i * surfData.width * 4 + i * 4 + 3]]);
        }
    };
    SDLModule.prototype.recordJoystickState = function (joystick, state) {
        // Standardize button state.
        var buttons = new Array(state.buttons.length);
        for (var i = 0; i < state.buttons.length; i++) {
            buttons[i] = this.getJoystickButtonState(state.buttons[i]);
        }
        this.lastJoystickState[joystick] = {
            buttons: buttons,
            axes: state.axes.slice(0),
            timestamp: state.timestamp,
            index: state.index,
            id: state.id
        };
    };
    SDLModule.prototype.getJoystickButtonState = function (button) {
        if (typeof button === 'object') {
            // Current gamepad API editor's draft (Firefox Nightly)
            // https://dvcs.w3.org/hg/gamepad/raw-file/default/gamepad.html#idl-def-GamepadButton
            return button['pressed'];
        }
        else {
            // Current gamepad API working draft (Firefox / Chrome Stable)
            // http://www.w3.org/TR/2012/WD-gamepad-20120529/#gamepad-interface
            return button > 0;
        }
    };
    SDLModule.prototype.queryJoysticks = function () {
        var joystick;
        for (joystick in this.lastJoystickState) {
            var state = this.getGamepad(joystick - 1);
            var prevState = this.lastJoystickState[joystick];
            // If joystick was removed, state returns null.
            if (typeof state === 'undefined')
                return;
            if (state === null)
                return;
            // Check only if the timestamp has differed.
            // NOTE: Timestamp is not available in Firefox.
            // NOTE: Timestamp is currently not properly set for the GearVR controller
            //       on Samsung Internet: it is always zero.
            if (typeof state.timestamp !== 'number' || state.timestamp !== prevState.timestamp || !state.timestamp) {
                var i;
                for (i = 0; i < state.buttons.length; i++) {
                    var buttonState = this.getJoystickButtonState(state.buttons[i]);
                    // NOTE: The previous state already has a boolean representation of
                    //       its button, so no need to standardize its button state here.
                    if (buttonState !== prevState.buttons[i]) {
                        // Insert button-press event.
                        this.events.push({
                            type: buttonState ? 'joystick_button_down' : 'joystick_button_up',
                            joystick: joystick,
                            index: joystick - 1,
                            button: i
                        });
                    }
                }
                for (i = 0; i < state.axes.length; i++) {
                    if (state.axes[i] !== prevState.axes[i]) {
                        // Insert axes-change event.
                        this.events.push({
                            type: 'joystick_axis_motion',
                            joystick: joystick,
                            index: joystick - 1,
                            axis: i,
                            value: state.axes[i]
                        });
                    }
                }
                this.recordJoystickState(joystick, state);
            }
        }
    };
    SDLModule.prototype.joystickAxisValueConversion = function (value) {
        // Make sure value is properly clamped
        value = Math.min(1, Math.max(value, -1));
        // Ensures that 0 is 0, 1 is 32767, and -1 is 32768.
        return Math.ceil(((value + 1) * 32767.5) - 32768);
    };
    SDLModule.prototype.getGamepads = function () {
        var fcn = navigator.getGamepads || navigator.webkitGamepads || navigator.mozGamepads || navigator.gamepads || navigator.webkitGetGamepads;
        if (fcn !== undefined) {
            // The function must be applied on the navigator object.
            return fcn.apply(navigator);
        }
        else {
            return [];
        }
    };
    SDLModule.prototype.getGamepad = function (deviceIndex) {
        var gamepads = this.getGamepads();
        if (gamepads.length > deviceIndex && deviceIndex >= 0) {
            return gamepads[deviceIndex];
        }
        return null;
    };
    SDLModule.prototype._SDL_FillRect = function (surf, rect, color) {
        var surfData = this.surfaces[surf.Id];
        this.assert(!surfData.locked); // but we could unlock and re-lock if we must..
        if (_tuval_core__WEBPACK_IMPORTED_MODULE_0__.is.int(color)) {
            if (surfData.isFlagSet(0x00200000 /* SDL_HWPALETTE */)) {
                //in SDL_HWPALETTE color is index (0..255)
                //so we should translate 1 byte value to
                //32 bit canvas
                color = surfData.colors32[color];
            }
        }
        var r = rect != null ? rect : new _tuval_cg__WEBPACK_IMPORTED_MODULE_1__.CGRectangle(0, 0, surfData.width, surfData.height);
        if (surfData.clipRect) {
            r = this.intersectionOfRects(surfData.clipRect, r);
            if (rect) {
                this.updateRect(rect, r);
            }
        }
        surfData.ctx.save();
        surfData.ctx.fillStyle = this.translateColorToCSSRGBA(color);
        surfData.ctx.fillRect(r.X, r.Y, r.Width, r.Height);
        surfData.ctx.restore();
        return 0;
    };
    SDLModule.prototype._SDL_Flip = function (surf) {
        // We actually do this in Unlock, since the screen surface has as its canvas
        // backing the page canvas element
    };
    /** @param{number=} initFlags */
    SDLModule.prototype._SDL_Init = function (initFlags) {
        this.startTime = Date.now();
        this.initFlags = initFlags;
        // capture all key events. we just keep down and up, but also capture press to prevent default actions
        if (!this.doNotCaptureKeyboard) {
            var keyboardListeningElement = this.keyboardListeningElement || document;
            keyboardListeningElement.addEventListener("keydown", this.receiveEvent);
            keyboardListeningElement.addEventListener("keyup", this.receiveEvent);
            keyboardListeningElement.addEventListener("keypress", this.receiveEvent);
            window.addEventListener("focus", this.receiveEvent);
            window.addEventListener("blur", this.receiveEvent);
            document.addEventListener("visibilitychange", this.receiveEvent);
        }
        window.addEventListener("unload", this.receiveEvent);
        this.keyboardState = this._malloc(0x10000); // Our SDL needs 512, but 64K is safe for older SDLs
        this._memset(this.keyboardState, 0, 0x10000);
        // Initialize this structure carefully for closure
        this.DOMEventToSDLEvent['keydown'] = 0x300 /* SDL_KEYDOWN */;
        this.DOMEventToSDLEvent['keyup'] = 0x301 /* SDL_KEYUP */;
        this.DOMEventToSDLEvent['keypress'] = 0x303 /* SDL_TEXTINPUT */;
        this.DOMEventToSDLEvent['mousedown'] = 0x401 /* SDL_MOUSEBUTTONDOWN */;
        this.DOMEventToSDLEvent['mouseup'] = 0x402 /* SDL_MOUSEBUTTONUP */;
        this.DOMEventToSDLEvent['mousemove'] = 0x400 /* SDL_MOUSEMOTION */;
        this.DOMEventToSDLEvent['wheel'] = 0x403 /* SDL_MOUSEWHEEL */;
        this.DOMEventToSDLEvent['touchstart'] = 0x700 /* SDL_FINGERDOWN */;
        this.DOMEventToSDLEvent['touchend'] = 0x701 /* SDL_FINGERUP */;
        this.DOMEventToSDLEvent['touchmove'] = 0x702 /* SDL_FINGERMOTION */;
        this.DOMEventToSDLEvent['unload'] = 0x100 /* SDL_QUIT */;
        this.DOMEventToSDLEvent['resize'] = 0x7001 /* SDL_VIDEORESIZE/SDL_EVENT_COMPAT2 */;
        this.DOMEventToSDLEvent['visibilitychange'] = 0x200 /* SDL_WINDOWEVENT */;
        this.DOMEventToSDLEvent['focus'] = 0x200 /* SDL_WINDOWEVENT */;
        this.DOMEventToSDLEvent['blur'] = 0x200 /* SDL_WINDOWEVENT */;
        // These are not technically DOM events; the HTML gamepad API is poll-based.
        // However, we define them here, as the rest of the SDL code assumes that
        // all SDL events originate as DOM events.
        this.DOMEventToSDLEvent['joystick_axis_motion'] = 0x600 /* SDL_JOYAXISMOTION */;
        this.DOMEventToSDLEvent['joystick_button_down'] = 0x603 /* SDL_JOYBUTTONDOWN */;
        this.DOMEventToSDLEvent['joystick_button_up'] = 0x604 /* SDL_JOYBUTTONUP */;
        return 0; // success
    };
    SDLModule.prototype._SDL_MapRGBA = function (fmt, r, g, b, a) {
        this.checkPixelFormat(fmt);
        // We assume the machine is little-endian.
        return _tuval_cg__WEBPACK_IMPORTED_MODULE_1__.CGColor.FromRgba(r, g, b, a);
    };
    SDLModule.prototype._SDL_AudioQuit = function () {
        for (var i = 0; i < this.numChannels; ++i) {
            if (this.channels[i].audio) {
                this.channels[i].audio.pause();
                this.channels[i].audio = undefined;
            }
        }
        if (this.music_audio)
            this.music_audio.pause();
        this.music_audio = undefined;
    };
    SDLModule.prototype._SDL_Quit = function () {
        this._SDL_AudioQuit();
        this.out('SDL_Quit called (and ignored)');
    };
    SDLModule.prototype._SDL_SetVideoMode = function (width, height, depth, flags) {
        var _this = this;
        ['touchstart', 'touchend', 'touchmove', 'mousedown', 'mouseup', 'mousemove', 'DOMMouseScroll', 'mousewheel', 'wheel', 'mouseout'].forEach(function (event) {
            _this.Canvas.addEventListener(event, _this.receiveEvent, true);
        });
        var canvas = this.Canvas;
        // (0,0) means 'use fullscreen' in native; in Emscripten, use the current canvas size.
        if (width == 0 && height == 0) {
            width = canvas.width;
            height = canvas.height;
        }
        if (!this.addedResizeListener) {
            this.addedResizeListener = true;
            this.Browser.resizeListeners.push(function (w, h) {
                if (!_this.settingVideoMode) {
                    _this.receiveEvent({
                        type: 'resize',
                        w: w,
                        h: h
                    });
                }
            });
        }
        this.settingVideoMode = true; // SetVideoMode itself should not trigger resize events
        this.Browser.setCanvasSize(width, height);
        this.settingVideoMode = false;
        // Free the old surface first if there is one
        if (this.screen) {
            this.freeSurface(this.screen);
            this.assert(!this.screen);
        }
        if (this.GL)
            flags = flags | 0x04000000; // SDL_OPENGL - if we are using GL, then later calls to SetVideoMode may not mention GL, but we do need it. Once in GL mode, we never leave it.
        this.screen = this.makeSurface(width, height, flags, true, 'screen');
        return this.screen;
    };
    SDLModule.prototype._SDL_UnlockSurface = function (surf) {
        this.assert(!this.GL); // in GL mode we do not keep around 2D canvases and contexts
        var surfData = this.surfaces[surf.Id];
        if (!surfData.locked || --surfData.locked > 0) {
            return;
        }
        // Copy pixel data to image
        if (surfData.isFlagSet(0x00200000 /* SDL_HWPALETTE */)) {
            this.copyIndexedColorData(surfData);
        }
        else if (!surfData.colors) {
            var data = surfData.image.data;
            var buffer = surfData.buffer;
            //this.assert(buffer % 4 == 0, 'Invalid buffer offset: ' + buffer);
            var src = 0; /* buffer */ /* >> 2 */
            ;
            var dst = 0;
            var isScreen = surf === this.screen;
            var num = void 0;
            if (typeof CanvasPixelArray !== 'undefined' && data instanceof CanvasPixelArray) {
                // IE10/IE11: ImageData objects are backed by the deprecated CanvasPixelArray,
                // not UInt8ClampedArray. These don't have buffers, so we need to revert
                // to copying a byte at a time. We do the undefined check because modern
                // browsers do not define CanvasPixelArray anymore.
                num = data.length;
                while (dst < num) {
                    var val = /* this.HEAP32[ */ buffer[src]; //]; // This is optimized. Instead, we could do HEAP32[(((buffer)+(dst))>>2)];
                    data[dst] = val & 0xff;
                    data[dst + 1] = (val >> 8) & 0xff;
                    data[dst + 2] = (val >> 16) & 0xff;
                    data[dst + 3] = isScreen ? 0xff : ((val >> 24) & 0xff);
                    src++;
                    dst += 4;
                }
            }
            else {
                var data32 = new Uint32Array(data.buffer);
                if (isScreen && this.opaqueFrontBuffer) {
                    num = data32.length;
                    // logically we need to do
                    //      while (dst < num) {
                    //          data32[dst++] = HEAP32[src++] | 0xff000000
                    //      }
                    // the following code is faster though, because
                    // .set() is almost free - easily 10x faster due to
                    // native memcpy efficiencies, and the remaining loop
                    // just stores, not load + store, so it is faster
                    var heap32 = new Int32Array(buffer.buffer);
                    data32.set(heap32.subarray(0, num));
                    var data8 = new Uint8Array(data.buffer);
                    var i = 3;
                    var j = i + 4 * num;
                    if (num % 8 == 0) {
                        // unrolling gives big speedups
                        while (i < j) {
                            data8[i] = 0xff;
                            i = i + 4 | 0;
                            data8[i] = 0xff;
                            i = i + 4 | 0;
                            data8[i] = 0xff;
                            i = i + 4 | 0;
                            data8[i] = 0xff;
                            i = i + 4 | 0;
                            data8[i] = 0xff;
                            i = i + 4 | 0;
                            data8[i] = 0xff;
                            i = i + 4 | 0;
                            data8[i] = 0xff;
                            i = i + 4 | 0;
                            data8[i] = 0xff;
                            i = i + 4 | 0;
                        }
                    }
                    else {
                        while (i < j) {
                            data8[i] = 0xff;
                            i = i + 4 | 0;
                        }
                    }
                }
                else {
                    var heap32 = new Int32Array(buffer.buffer);
                    data32.set(heap32.subarray(0, data32.length));
                }
            }
        }
        else {
            var width = this.Canvas.width;
            var height = this.Canvas.height;
            var s = 0; //surfData.buffer
            var data = surfData.image.data;
            var colors = surfData.colors; // TODO: optimize using colors32
            for (var y = 0; y < height; y++) {
                var base = y * width * 4;
                for (var x = 0; x < width; x++) {
                    // See comment above about signs
                    var val_1 = surfData.buffer[s] * 4;
                    var start = base + x * 4;
                    data[start] = colors[val_1];
                    data[start + 1] = colors[val_1 + 1];
                    data[start + 2] = colors[val_1 + 2];
                }
                s += width * 3;
            }
        }
        // Copy to canvas
        surfData.ctx.putImageData(surfData.image, 0, 0);
        // Note that we save the image, so future writes are fast. But, memory is not yet released
    };
    SDLModule.prototype._SDL_UpperBlit = function (src, srcrect, dst, dstrect) {
        return this.BlitSurface(src, srcrect, dst, dstrect, false);
    };
    SDLModule.prototype._TTF_Init = function () {
        // OffscreenCanvas 2D is faster than Canvas for text operations, so we use
        // it if it's available.
        try {
            var offscreenCanvas = new OffscreenCanvas(0, 0);
            this.ttfContext = offscreenCanvas.getContext('2d');
        }
        catch (ex) {
            var canvas = document.createElement('canvas');
            this.ttfContext = canvas.getContext('2d');
        }
        return 0;
    };
    SDLModule.prototype._TTF_OpenFont = function (filename, size) {
        filename = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.PATH.normalize(/* this.UTF8ToString( */ filename /* ) */);
        var id = this.fonts.length;
        this.fonts.push({
            name: filename,
            size: size
        });
        return id;
    };
    SDLModule.prototype._TTF_RenderText_Solid = function (font, text, color) {
        // XXX the font and color are ignored
        //text = this.UTF8ToString(text) || ' '; // if given an empty string, still return a valid surface
        var fontData = this.fonts[font];
        var w = this.estimateTextWidth(fontData, text);
        var h = fontData.size;
        var colorStr = this.loadColorToCSSRGB(color); // XXX alpha breaks fonts?
        var fontString = this.makeFontString(h, fontData.name);
        var surf = this.makeSurface(w, h, 0, false, 'text:' + text); // bogus numbers..
        var surfData = this.surfaces[surf.Id];
        surfData.ctx.save();
        surfData.ctx.fillStyle = colorStr;
        surfData.ctx.font = fontString;
        // use bottom alignment, because it works
        // same in all browsers, more info here:
        // https://bugzilla.mozilla.org/show_bug.cgi?id=737852
        surfData.ctx.textBaseline = 'bottom';
        surfData.ctx.fillText(text, 0, h | 0);
        surfData.ctx.restore();
        return surf;
    };
    SDLModule.prototype._abort = function () {
        this.abort('');
    };
    SDLModule.prototype._SDL_GetTicks = function () {
        return (Date.now() - this.startTime) | 0;
    };
    SDLModule.prototype._SDL_LockSurface = function (surf) {
        var surfData = this.surfaces[surf.Id];
        surfData.locked++;
        if (surfData.locked > 1)
            return 0;
        if (!surfData.buffer) {
            surfData.buffer = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(surfData.width * surfData.height * 4); // this._malloc(surfData.width * surfData.height * 4);
            //this.HEAP32[(((surf) + (20)) >> 2)] = surfData.buffer;
            surf.pixels = surfData.buffer;
        }
        // Mark in C/C++-accessible SDL structure
        // SDL_Surface has the following fields: Uint32 flags, SDL_PixelFormat *format; int w, h; Uint16 pitch; void *pixels; ...
        // So we have fields all of the same size, and 5 of them before us.
        // TODO: Use macros like in library.js
        //this.HEAP32[(((surf) + (20)) >> 2)] = surfData.buffer;
        surf.pixels = surfData.buffer;
        if (surf == this.screen && this.screenIsReadOnly && surfData.image)
            return 0;
        if (this.discardOnLock) {
            if (!surfData.image) {
                surfData.image = surfData.ctx.createImageData(surfData.width, surfData.height);
            }
            if (!this.opaqueFrontBuffer) {
                return undefined;
            }
        }
        else {
            surfData.image = surfData.ctx.getImageData(0, 0, surfData.width, surfData.height);
        }
        // Emulate desktop behavior and kill alpha values on the locked surface. (very costly!) Set SDL.defaults.opaqueFrontBuffer = false
        // if you don't want this.
        if (surf == this.screen && this.opaqueFrontBuffer) {
            var data = surfData.image.data;
            var num = data.length;
            for (var i = 0; i < num / 4; i++) {
                data[i * 4 + 3] = 255; // opacity, as canvases blend alpha
            }
        }
        if (this.copyOnLock && !this.discardOnLock) {
            // Copy pixel data to somewhere accessible to 'C/C++'
            if (surfData.isFlagSet(0x00200000 /* SDL_HWPALETTE */)) {
                // If this is neaded then
                // we should compact the data from 32bpp to 8bpp index.
                // I think best way to implement this is use
                // additional colorMap hash (color->index).
                // Something like this:
                //
                // var size = surfData.width * surfData.height;
                // var data = '';
                // for (var i = 0; i<size; i++) {
                //   var color = SDL.translateRGBAToColor(
                //     surfData.image.data[i*4   ],
                //     surfData.image.data[i*4 +1],
                //     surfData.image.data[i*4 +2],
                //     255);
                //   var index = surfData.colorMap[color];
                //   HEAP8[(((surfData.buffer)+(i))>>0)] = index;
                // }
                throw 'CopyOnLock is not supported for SDL_LockSurface with SDL_HWPALETTE flag set' + new Error().stack;
            }
            else {
                _tuval_core__WEBPACK_IMPORTED_MODULE_0__.TArray.Copy(surfData.image.data, 0, surfData.buffer, 0, surfData.image.data.length);
                //this.HEAPU8.set(surfData.image.data, surfData.buffer);
            }
        }
        return 0;
    };
    /** @suppress{missingProperties} */
    SDLModule.prototype.SDL_unicode = function () { return this.unicode; };
    /** @suppress{missingProperties} */
    SDLModule.prototype.SDL_ttfContext = function () { return this.ttfContext; };
    /** @suppress{missingProperties} */
    SDLModule.prototype.SDL_audio = function () { return this.audio; };
    SDLModule.prototype.requestFullscreen = function (lockPointer, resizeCanvas) {
        this.Browser.requestFullscreen(lockPointer, resizeCanvas);
    };
    SDLModule.prototype.requestFullScreen = function () {
        this.Browser.requestFullScreen();
    };
    SDLModule.prototype.requestAnimationFrame = function (func) {
        this.Browser.requestAnimationFrame(func);
    };
    SDLModule.prototype.setCanvasSize = function (width, height, noUpdates) {
        this.Browser.setCanvasSize(width, height, noUpdates);
    };
    SDLModule.prototype.pauseMainLoop = function () {
        this.Browser.mainLoop.Pause();
    };
    SDLModule.prototype.resumeMainLoop = function () {
        this.Browser.mainLoop.Resume();
    };
    SDLModule.prototype.getUserMedia = function () {
        this.Browser.getUserMedia();
    };
    SDLModule.prototype.createContext = function (canvas, useWebGL, setInModule, webGLContextAttributes) {
        return this.Browser.CreateContext(canvas, useWebGL, setInModule, webGLContextAttributes);
    };
    SDLModule.prototype._emscripten_get_canvas_element_size = function () {
        /* var canvas = findCanvasEventTarget(target);
        if (!canvas) return -4; */
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_1__.CGSize(this.Canvas.width, this.Canvas.height);
        /* HEAP32[((width)>>2)]=canvas.width;
        HEAP32[((height)>>2)]=canvas.height; */
    };
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Virtual,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object]),
        __metadata("design:returntype", void 0)
    ], SDLModule.prototype, "requestFullscreen", null);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Virtual,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], SDLModule.prototype, "requestFullScreen", null);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Virtual,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SDLModule.prototype, "requestAnimationFrame", null);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Virtual,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Object]),
        __metadata("design:returntype", void 0)
    ], SDLModule.prototype, "setCanvasSize", null);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Virtual,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], SDLModule.prototype, "pauseMainLoop", null);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Virtual,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], SDLModule.prototype, "resumeMainLoop", null);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Virtual,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], SDLModule.prototype, "getUserMedia", null);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Virtual,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Object, Object]),
        __metadata("design:returntype", CanvasRenderingContext2D)
    ], SDLModule.prototype, "createContext", null);
    return SDLModule;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.CanvasModule));



/***/ }),

/***/ "./src/Modules/index.ts":
/*!******************************!*\
  !*** ./src/Modules/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SDLModule": () => (/* reexport safe */ _SDLModule__WEBPACK_IMPORTED_MODULE_0__.SDLModule),
/* harmony export */   "SDL_Palette": () => (/* reexport safe */ _SDLModule__WEBPACK_IMPORTED_MODULE_0__.SDL_Palette),
/* harmony export */   "SDL_PixelFormat": () => (/* reexport safe */ _SDLModule__WEBPACK_IMPORTED_MODULE_0__.SDL_PixelFormat),
/* harmony export */   "SDL_Surface": () => (/* reexport safe */ _SDLModule__WEBPACK_IMPORTED_MODULE_0__.SDL_Surface)
/* harmony export */ });
/* harmony import */ var _SDLModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SDLModule */ "./src/Modules/SDLModule.ts");



/***/ }),

/***/ "./src/TTween.ts":
/*!***********************!*\
  !*** ./src/TTween.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TWEEN": () => (/* binding */ TWEEN),
/* harmony export */   "Easing": () => (/* binding */ Easing)
/* harmony export */ });
/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var _Group = function () {
    this._tweens = {};
    this._tweensAddedDuringUpdate = {};
};
_Group.prototype = {
    getAll: function () {
        return Object.keys(this._tweens).map(function (tweenId) {
            return this._tweens[tweenId];
        }.bind(this));
    },
    removeAll: function () {
        this._tweens = {};
    },
    add: function (tween) {
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
    },
    remove: function (tween) {
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
    },
    update: function (time, preserve) {
        var tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0) {
            return false;
        }
        time = time !== undefined ? time : TWEEN.now();
        // Tweens are updated in "batches". If you add a new tween during an
        // update, then the new tween will be updated in the next batch.
        // If you remove a tween during an update, it may or may not be updated.
        // However, if the removed tween was added during the current batch,
        // then it will not be updated.
        while (tweenIds.length > 0) {
            this._tweensAddedDuringUpdate = {};
            for (var i = 0; i < tweenIds.length; i++) {
                var tween = this._tweens[tweenIds[i]];
                if (tween && tween.update(time) === false) {
                    tween._isPlaying = false;
                    if (!preserve) {
                        delete this._tweens[tweenIds[i]];
                    }
                }
            }
            tweenIds = Object.keys(this._tweensAddedDuringUpdate);
        }
        return true;
    }
};
var TWEEN = new _Group();
TWEEN.Group = _Group;
TWEEN._nextId = 0;
TWEEN.nextId = function () {
    return TWEEN._nextId++;
};
// Include a performance.now polyfill.
// In node.js, use process.hrtime.
if (typeof (self) === 'undefined' && typeof (process) !== 'undefined' && process.hrtime) {
    TWEEN.now = function () {
        var time = process.hrtime();
        // Convert [seconds, nanoseconds] to milliseconds.
        return time[0] * 1000 + time[1] / 1000000;
    };
}
// In a browser, use self.performance.now if it is available.
else if (typeof (self) !== 'undefined' &&
    self.performance !== undefined &&
    self.performance.now !== undefined) {
    // This must be bound, because directly assigning this function
    // leads to an invocation exception in Chrome.
    TWEEN.now = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
    TWEEN.now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
    TWEEN.now = function () {
        return new Date().getTime();
    };
}
TWEEN.Tween = function (object, group) {
    this._isPaused = false;
    this._pauseStart = null;
    this._object = object;
    this._valuesStart = {};
    this._valuesEnd = {};
    this._valuesStartRepeat = {};
    this._duration = 1000;
    this._repeat = 0;
    this._repeatDelayTime = undefined;
    this._yoyo = false;
    this._isPlaying = false;
    this._reversed = false;
    this._delayTime = 0;
    this._startTime = null;
    this._easingFunction = Easing.Linear.None;
    this._interpolationFunction = TWEEN.Interpolation.Linear;
    this._chainedTweens = [];
    this._onStartCallback = null;
    this._onStartCallbackFired = false;
    this._onUpdateCallback = null;
    this._onRepeatCallback = null;
    this._onCompleteCallback = null;
    this._onStopCallback = null;
    this._group = group || TWEEN;
    this._id = TWEEN.nextId();
};
TWEEN.Tween.prototype = {
    getId: function () {
        return this._id;
    },
    isPlaying: function () {
        return this._isPlaying;
    },
    isPaused: function () {
        return this._isPaused;
    },
    to: function (properties, duration) {
        this._valuesEnd = Object.create(properties);
        if (duration !== undefined) {
            this._duration = duration;
        }
        return this;
    },
    duration: function duration(d) {
        this._duration = d;
        return this;
    },
    start: function (time) {
        this._group.add(this);
        this._isPlaying = true;
        this._isPaused = false;
        this._onStartCallbackFired = false;
        this._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();
        this._startTime += this._delayTime;
        for (var property in this._valuesEnd) {
            // Check if an Array was provided as property value
            if (this._valuesEnd[property] instanceof Array) {
                if (this._valuesEnd[property].length === 0) {
                    continue;
                }
                // Create a local copy of the Array with the start value at the front
                this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);
            }
            // If `to()` specifies a property that doesn't exist in the source object,
            // we should not set that property in the object
            if (this._object[property] === undefined) {
                continue;
            }
            // Save the starting value, but only once.
            if (typeof (this._valuesStart[property]) === 'undefined') {
                this._valuesStart[property] = this._object[property];
            }
            if ((this._valuesStart[property] instanceof Array) === false) {
                this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
            }
            this._valuesStartRepeat[property] = this._valuesStart[property] || 0;
        }
        return this;
    },
    stop: function () {
        if (!this._isPlaying) {
            return this;
        }
        this._group.remove(this);
        this._isPlaying = false;
        this._isPaused = false;
        if (this._onStopCallback !== null) {
            this._onStopCallback(this._object);
        }
        this.stopChainedTweens();
        return this;
    },
    end: function () {
        this.update(Infinity);
        return this;
    },
    pause: function (time) {
        if (this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = true;
        this._pauseStart = time === undefined ? TWEEN.now() : time;
        this._group.remove(this);
        return this;
    },
    resume: function (time) {
        if (!this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = false;
        this._startTime += (time === undefined ? TWEEN.now() : time)
            - this._pauseStart;
        this._pauseStart = 0;
        this._group.add(this);
        return this;
    },
    stopChainedTweens: function () {
        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].stop();
        }
    },
    group: function (group) {
        this._group = group;
        return this;
    },
    delay: function (amount) {
        this._delayTime = amount;
        return this;
    },
    repeat: function (times) {
        this._repeat = times;
        return this;
    },
    repeatDelay: function (amount) {
        this._repeatDelayTime = amount;
        return this;
    },
    yoyo: function (yoyo) {
        this._yoyo = yoyo;
        return this;
    },
    easing: function (easingFunction) {
        this._easingFunction = easingFunction;
        return this;
    },
    interpolation: function (interpolationFunction) {
        this._interpolationFunction = interpolationFunction;
        return this;
    },
    chain: function () {
        this._chainedTweens = arguments;
        return this;
    },
    onStart: function (callback) {
        this._onStartCallback = callback;
        return this;
    },
    onUpdate: function (callback) {
        this._onUpdateCallback = callback;
        return this;
    },
    onRepeat: function onRepeat(callback) {
        this._onRepeatCallback = callback;
        return this;
    },
    onComplete: function (callback) {
        this._onCompleteCallback = callback;
        return this;
    },
    onStop: function (callback) {
        this._onStopCallback = callback;
        return this;
    },
    update: function (time) {
        var property;
        var elapsed;
        var value;
        if (time < this._startTime) {
            return true;
        }
        if (this._onStartCallbackFired === false) {
            if (this._onStartCallback !== null) {
                this._onStartCallback(this._object);
            }
            this._onStartCallbackFired = true;
        }
        elapsed = (time - this._startTime) / this._duration;
        elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;
        value = this._easingFunction(elapsed);
        for (property in this._valuesEnd) {
            // Don't update properties that do not exist in the source object
            if (this._valuesStart[property] === undefined) {
                continue;
            }
            var start = this._valuesStart[property] || 0;
            var end = this._valuesEnd[property];
            if (end instanceof Array) {
                this._object[property] = this._interpolationFunction(end, value);
            }
            else {
                // Parses relative end values with start as base (e.g.: +10, -3)
                if (typeof (end) === 'string') {
                    if (end.charAt(0) === '+' || end.charAt(0) === '-') {
                        end = start + parseFloat(end);
                    }
                    else {
                        end = parseFloat(end);
                    }
                }
                // Protect against non numeric properties.
                if (typeof (end) === 'number') {
                    this._object[property] = start + (end - start) * value;
                }
            }
        }
        if (this._onUpdateCallback !== null) {
            this._onUpdateCallback(this._object, elapsed);
        }
        if (elapsed === 1) {
            if (this._repeat > 0) {
                if (isFinite(this._repeat)) {
                    this._repeat--;
                }
                // Reassign starting values, restart by making startTime = now
                for (property in this._valuesStartRepeat) {
                    if (typeof (this._valuesEnd[property]) === 'string') {
                        this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                    }
                    if (this._yoyo) {
                        var tmp = this._valuesStartRepeat[property];
                        this._valuesStartRepeat[property] = this._valuesEnd[property];
                        this._valuesEnd[property] = tmp;
                    }
                    this._valuesStart[property] = this._valuesStartRepeat[property];
                }
                if (this._yoyo) {
                    this._reversed = !this._reversed;
                }
                if (this._repeatDelayTime !== undefined) {
                    this._startTime = time + this._repeatDelayTime;
                }
                else {
                    this._startTime = time + this._delayTime;
                }
                if (this._onRepeatCallback !== null) {
                    this._onRepeatCallback(this._object);
                }
                return true;
            }
            else {
                if (this._onCompleteCallback !== null) {
                    this._onCompleteCallback(this._object);
                }
                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                    // Make the chained tweens start exactly at the time they should,
                    // even if the `update()` method was called way past the duration of the tween
                    this._chainedTweens[i].start(this._startTime + this._duration);
                }
                return false;
            }
        }
        return true;
    }
};
var Easing = {
    Linear: {
        None: function (k) {
            return k;
        }
    },
    Quadratic: {
        In: function (k) {
            return k * k;
        },
        Out: function (k) {
            return k * (2 - k);
        },
        InOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k;
            }
            return -0.5 * (--k * (k - 2) - 1);
        }
    },
    Cubic: {
        In: function (k) {
            return k * k * k;
        },
        Out: function (k) {
            return --k * k * k + 1;
        },
        InOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k + 2);
        }
    },
    Quartic: {
        In: function (k) {
            return k * k * k * k;
        },
        Out: function (k) {
            return 1 - (--k * k * k * k);
        },
        InOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k * k;
            }
            return -0.5 * ((k -= 2) * k * k * k - 2);
        }
    },
    Quintic: {
        In: function (k) {
            return k * k * k * k * k;
        },
        Out: function (k) {
            return --k * k * k * k * k + 1;
        },
        InOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k * k * k + 2);
        }
    },
    Sinusoidal: {
        In: function (k) {
            return 1 - Math.cos(k * Math.PI / 2);
        },
        Out: function (k) {
            return Math.sin(k * Math.PI / 2);
        },
        InOut: function (k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
        }
    },
    Exponential: {
        In: function (k) {
            return k === 0 ? 0 : Math.pow(1024, k - 1);
        },
        Out: function (k) {
            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
        },
        InOut: function (k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if ((k *= 2) < 1) {
                return 0.5 * Math.pow(1024, k - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
        }
    },
    Circular: {
        In: function (k) {
            return 1 - Math.sqrt(1 - k * k);
        },
        Out: function (k) {
            return Math.sqrt(1 - (--k * k));
        },
        InOut: function (k) {
            if ((k *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        }
    },
    Elastic: {
        In: function (k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
        },
        Out: function (k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
        },
        InOut: function (k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            k *= 2;
            if (k < 1) {
                return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
            }
            return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
        }
    },
    Back: {
        In: function (k) {
            var s = 1.70158;
            return k * k * ((s + 1) * k - s);
        },
        Out: function (k) {
            var s = 1.70158;
            return --k * k * ((s + 1) * k + s) + 1;
        },
        InOut: function (k) {
            var s = 1.70158 * 1.525;
            if ((k *= 2) < 1) {
                return 0.5 * (k * k * ((s + 1) * k - s));
            }
            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        }
    },
    Bounce: {
        In: function (k) {
            return 1 - Easing.Bounce.Out(1 - k);
        },
        Out: function (k) {
            if (k < (1 / 2.75)) {
                return 7.5625 * k * k;
            }
            else if (k < (2 / 2.75)) {
                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
            }
            else if (k < (2.5 / 2.75)) {
                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
            }
            else {
                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
            }
        },
        InOut: function (k) {
            if (k < 0.5) {
                return Easing.Bounce.In(k * 2) * 0.5;
            }
            return Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
        }
    }
};
TWEEN.Interpolation = {
    Linear: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = TWEEN.Interpolation.Utils.Linear;
        if (k < 0) {
            return fn(v[0], v[1], f);
        }
        if (k > 1) {
            return fn(v[m], v[m - 1], m - f);
        }
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function (v, k) {
        var b = 0;
        var n = v.length - 1;
        var pw = Math.pow;
        var bn = TWEEN.Interpolation.Utils.Bernstein;
        for (var i = 0; i <= n; i++) {
            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        }
        return b;
    },
    CatmullRom: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = TWEEN.Interpolation.Utils.CatmullRom;
        if (v[0] === v[m]) {
            if (k < 0) {
                i = Math.floor(f = m * (1 + k));
            }
            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
        }
        else {
            if (k < 0) {
                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
            }
            if (k > 1) {
                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
            }
            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
        }
    },
    Utils: {
        Linear: function (p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        Bernstein: function (n, i) {
            var fc = TWEEN.Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: (function () {
            var a = [1];
            return function (n) {
                var s = 1;
                if (a[n]) {
                    return a[n];
                }
                for (var i = n; i > 1; i--) {
                    s *= i;
                }
                a[n] = s;
                return s;
            };
        })(),
        CatmullRom: function (p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
    }
};


/***/ }),

/***/ "./src/Text/TextMetrics.ts":
/*!*********************************!*\
  !*** ./src/Text/TextMetrics.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextMetrics": () => (/* binding */ TextMetrics)
/* harmony export */ });
/**
 * The TextMetrics object represents the measurement of a block of text with a specified style.
 *
 * ```js
 * let style = new PIXI.TextStyle({fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'})
 * let textMetrics = PIXI.TextMetrics.measureText('Your text', style)
 * ```
 *
 * @memberof PIXI
 */
var TextMetrics = /** @class */ (function () {
    /**
     * @param text - the text that was measured
     * @param style - the style that was measured
     * @param width - the measured width of the text
     * @param height - the measured height of the text
     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
     * @param lineWidths - an array of the line widths for each line matched to `lines`
     * @param lineHeight - the measured line height for this style
     * @param maxLineWidth - the maximum line width for all measured lines
     * @param {PIXI.IFontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
     */
    function TextMetrics(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
    }
    /**
     * Measures the supplied string of text and returns a Rectangle.
     *
     * @param text - The text to measure.
     * @param style - The text style to use for measuring
     * @param wordWrap - Override for if word-wrap should be applied to the text.
     * @param canvas - optional specification of the canvas to use for measuring.
     * @return Measured width and height of the text.
     */
    TextMetrics.measureText = function (text, style, wordWrap, canvas) {
        if (canvas === void 0) { canvas = TextMetrics._canvas; }
        wordWrap = (wordWrap === undefined || wordWrap === null) ? style.wordWrap : wordWrap;
        var font = style.toFontString();
        var fontProperties = TextMetrics.measureFont(font);
        // fallback in case UA disallow canvas data extraction
        // (toDataURI, getImageData functions)
        if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style.fontSize;
            fontProperties.ascent = style.fontSize;
        }
        var context = canvas.getContext('2d');
        context.font = font;
        var outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
            var lineWidth = context.measureText(lines[i]).width + ((lines[i].length - 1) * style.letterSpacing);
            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width = maxLineWidth + style.strokeThickness;
        if (style.dropShadow) {
            width += style.dropShadowDistance;
        }
        var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness)
            + ((lines.length - 1) * (lineHeight + style.leading));
        if (style.dropShadow) {
            height += style.dropShadowDistance;
        }
        return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
    };
    /**
     * Applies newlines to a string to have it optimally fit into the horizontal
     * bounds set by the Text object's wordWrapWidth property.
     *
     * @param text - String to apply word wrapping to
     * @param style - the style to use when wrapping
     * @param canvas - optional specification of the canvas to use for measuring.
     * @return New string with new lines applied where required
     */
    TextMetrics.wordWrap = function (text, style, canvas) {
        if (canvas === void 0) { canvas = TextMetrics._canvas; }
        var context = canvas.getContext('2d');
        var width = 0;
        var line = '';
        var lines = '';
        var cache = Object.create(null);
        var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;
        // How to handle whitespaces
        var collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);
        var collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);
        // whether or not spaces may be added to the beginning of lines
        var canPrependSpaces = !collapseSpaces;
        // There is letterSpacing after every char except the last one
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!
        // so for convenience the above needs to be compared to width + 1 extra letterSpace
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_
        // ________________________________________________
        // And then the final space is simply no appended to each line
        var wordWrapWidth = style.wordWrapWidth + letterSpacing;
        // break text into words, spaces and newline chars
        var tokens = TextMetrics.tokenize(text);
        for (var i = 0; i < tokens.length; i++) {
            // get the word, space or newlineChar
            var token = tokens[i];
            // if word is a new line
            if (TextMetrics.isNewline(token)) {
                // keep the new line
                if (!collapseNewlines) {
                    lines += TextMetrics.addLine(line);
                    canPrependSpaces = !collapseSpaces;
                    line = '';
                    width = 0;
                    continue;
                }
                // if we should collapse new lines
                // we simply convert it into a space
                token = ' ';
            }
            // if we should collapse repeated whitespaces
            if (collapseSpaces) {
                // check both this and the last tokens for spaces
                var currIsBreakingSpace = TextMetrics.isBreakingSpace(token);
                var lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]);
                if (currIsBreakingSpace && lastIsBreakingSpace) {
                    continue;
                }
            }
            // get word width from cache if possible
            var tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context);
            // word is longer than desired bounds
            if (tokenWidth > wordWrapWidth) {
                // if we are not already at the beginning of a line
                if (line !== '') {
                    // start newlines for overflow words
                    lines += TextMetrics.addLine(line);
                    line = '';
                    width = 0;
                }
                // break large word over multiple lines
                if (TextMetrics.canBreakWords(token, style.breakWords)) {
                    // break word into characters
                    var characters = TextMetrics.wordWrapSplit(token);
                    // loop the characters
                    for (var j = 0; j < characters.length; j++) {
                        var char = characters[j];
                        var k = 1;
                        // we are not at the end of the token
                        while (characters[j + k]) {
                            var nextChar = characters[j + k];
                            var lastChar = char[char.length - 1];
                            // should not split chars
                            if (!TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                                // combine chars & move forward one
                                char += nextChar;
                            }
                            else {
                                break;
                            }
                            k++;
                        }
                        j += char.length - 1;
                        var characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context);
                        if (characterWidth + width > wordWrapWidth) {
                            lines += TextMetrics.addLine(line);
                            canPrependSpaces = false;
                            line = '';
                            width = 0;
                        }
                        line += char;
                        width += characterWidth;
                    }
                }
                // run word out of the bounds
                else {
                    // if there are words in this line already
                    // finish that line and start a new one
                    if (line.length > 0) {
                        lines += TextMetrics.addLine(line);
                        line = '';
                        width = 0;
                    }
                    var isLastToken = i === tokens.length - 1;
                    // give it its own line if it's not the end
                    lines += TextMetrics.addLine(token, !isLastToken);
                    canPrependSpaces = false;
                    line = '';
                    width = 0;
                }
            }
            // word could fit
            else {
                // word won't fit because of existing words
                // start a new line
                if (tokenWidth + width > wordWrapWidth) {
                    // if its a space we don't want it
                    canPrependSpaces = false;
                    // add a new line
                    lines += TextMetrics.addLine(line);
                    // start a new line
                    line = '';
                    width = 0;
                }
                // don't add spaces to the beginning of lines
                if (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
                    // add the word to the current line
                    line += token;
                    // update width counter
                    width += tokenWidth;
                }
            }
        }
        lines += TextMetrics.addLine(line, false);
        return lines;
    };
    /**
     * Convienience function for logging each line added during the wordWrap method.
     *
     * @param line    - The line of text to add
     * @param newLine - Add new line character to end
     * @return A formatted line
     */
    TextMetrics.addLine = function (line, newLine) {
        if (newLine === void 0) { newLine = true; }
        line = TextMetrics.trimRight(line);
        line = (newLine) ? line + "\n" : line;
        return line;
    };
    /**
     * Gets & sets the widths of calculated characters in a cache object
     *
     * @param key            - The key
     * @param letterSpacing  - The letter spacing
     * @param cache          - The cache
     * @param context        - The canvas context
     * @return The from cache.
     */
    TextMetrics.getFromCache = function (key, letterSpacing, cache, context) {
        var width = cache[key];
        if (typeof width !== 'number') {
            var spacing = ((key.length) * letterSpacing);
            width = context.measureText(key).width + spacing;
            cache[key] = width;
        }
        return width;
    };
    /**
     * Determines whether we should collapse breaking spaces.
     *
     * @param whiteSpace - The TextStyle property whiteSpace
     * @return Should collapse
     */
    TextMetrics.collapseSpaces = function (whiteSpace) {
        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');
    };
    /**
     * Determines whether we should collapse newLine chars.
     *
     * @param whiteSpace - The white space
     * @return  should collapse
     */
    TextMetrics.collapseNewlines = function (whiteSpace) {
        return (whiteSpace === 'normal');
    };
    /**
     * Trims breaking whitespaces from string.
     *
     * @param  text - The text
     * @return Trimmed string
     */
    TextMetrics.trimRight = function (text) {
        if (typeof text !== 'string') {
            return '';
        }
        for (var i = text.length - 1; i >= 0; i--) {
            var char = text[i];
            if (!TextMetrics.isBreakingSpace(char)) {
                break;
            }
            text = text.slice(0, -1);
        }
        return text;
    };
    /**
     * Determines if char is a newline.
     *
     * @param  char - The character
     * @return True if newline, False otherwise.
     */
    TextMetrics.isNewline = function (char) {
        if (typeof char !== 'string') {
            return false;
        }
        return (TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0);
    };
    /**
     * Determines if char is a breaking whitespace.
     *
     * It allows one to determine whether char should be a breaking whitespace
     * For example certain characters in CJK langs or numbers.
     * It must return a boolean.
     *
     * @param char     - The character
     * @param [nextChar] - The next character
     * @return True if whitespace, False otherwise.
     */
    TextMetrics.isBreakingSpace = function (char, _nextChar) {
        if (typeof char !== 'string') {
            return false;
        }
        return (TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0);
    };
    /**
     * Splits a string into words, breaking-spaces and newLine characters
     *
     * @param  text - The text
     * @return  A tokenized array
     */
    TextMetrics.tokenize = function (text) {
        var tokens = [];
        var token = '';
        if (typeof text !== 'string') {
            return tokens;
        }
        for (var i = 0; i < text.length; i++) {
            var char = text[i];
            var nextChar = text[i + 1];
            if (TextMetrics.isBreakingSpace(char, nextChar) || TextMetrics.isNewline(char)) {
                if (token !== '') {
                    tokens.push(token);
                    token = '';
                }
                tokens.push(char);
                continue;
            }
            token += char;
        }
        if (token !== '') {
            tokens.push(token);
        }
        return tokens;
    };
    /**
     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
     *
     * It allows one to customise which words should break
     * Examples are if the token is CJK or numbers.
     * It must return a boolean.
     *
     * @param  token       - The token
     * @param  breakWords - The style attr break words
     * @return Whether to break word or not
     */
    TextMetrics.canBreakWords = function (_token, breakWords) {
        return breakWords;
    };
    /**
     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
     *
     * It allows one to determine whether a pair of characters
     * should be broken by newlines
     * For example certain characters in CJK langs or numbers.
     * It must return a boolean.
     *
     * @param  char        - The character
     * @param  nextChar    - The next character
     * @param  token       - The token/word the characters are from
     * @param  index       - The index in the token of the char
     * @param  breakWords - The style attr break words
     * @return whether to break word or not
     */
    TextMetrics.canBreakChars = function (_char, _nextChar, _token, _index, _breakWords) {
        return true;
    };
    /**
     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
     *
     * It is called when a token (usually a word) has to be split into separate pieces
     * in order to determine the point to break a word.
     * It must return an array of characters.
     *
     * @example
     * // Correctly splits emojis, eg "" will result in two element array, each with one emoji.
     * TextMetrics.wordWrapSplit = (token) => [...token];
     *
     * @param  token - The token to split
     * @return The characters of the token
     */
    TextMetrics.wordWrapSplit = function (token) {
        return token.split('');
    };
    /**
     * Calculates the ascent, descent and fontSize of a given font-style
     *
     * @param font - String representing the style of the font
     * @return Font properties object
     */
    TextMetrics.measureFont = function (font) {
        // as this method is used for preparing assets, don't recalculate things if we don't need to
        if (TextMetrics._fonts[font]) {
            return TextMetrics._fonts[font];
        }
        var properties = {
            ascent: 0,
            descent: 0,
            fontSize: 0,
        };
        var canvas = TextMetrics._canvas;
        var context = TextMetrics._context;
        context.font = font;
        var metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);
        var height = Math.ceil(TextMetrics.HEIGHT_MULTIPLIER * baseline);
        baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx += line;
            }
            else {
                break;
            }
        }
        properties.ascent = baseline - i;
        idx = pixels - line;
        stop = false;
        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; --i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx -= line;
            }
            else {
                break;
            }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        TextMetrics._fonts[font] = properties;
        return properties;
    };
    /**
     * Clear font metrics in metrics cache.
     *
     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
     */
    TextMetrics.clearMetrics = function (font) {
        if (font === void 0) { font = ''; }
        if (font) {
            delete TextMetrics._fonts[font];
        }
        else {
            TextMetrics._fonts = {};
        }
    };
    return TextMetrics;
}());

/**
 * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.
 *
 * @typedef {object} FontMetrics
 * @property {number} ascent - The ascent distance
 * @property {number} descent - The descent distance
 * @property {number} fontSize - Font size from ascent to descent
 * @memberof PIXI.TextMetrics
 * @private
 */
var canvas = (function () {
    try {
        // OffscreenCanvas2D measureText can be up to 40% faster.
        var c = new OffscreenCanvas(0, 0);
        var context = c.getContext('2d');
        if (context && context.measureText) {
            return c;
        }
        return document.createElement('canvas');
    }
    catch (ex) {
        return document.createElement('canvas');
    }
})();
canvas.width = canvas.height = 10;
/**
 * Cached canvas element for measuring text
 *
 * @memberof PIXI.TextMetrics
 * @type {HTMLCanvasElement}
 * @private
 */
TextMetrics._canvas = canvas;
/**
 * Cache for context to use.
 *
 * @memberof PIXI.TextMetrics
 * @type {CanvasRenderingContext2D}
 * @private
 */
TextMetrics._context = canvas.getContext('2d');
/**
 * Cache of {@see PIXI.TextMetrics.FontMetrics} objects.
 *
 * @memberof PIXI.TextMetrics
 * @type {Object}
 * @private
 */
TextMetrics._fonts = {};
/**
 * String used for calculate font metrics.
 * These characters are all tall to help calculate the height required for text.
 *
 * @static
 * @memberof PIXI.TextMetrics
 * @name METRICS_STRING
 * @type {string}
 * @default |q
 */
TextMetrics.METRICS_STRING = '|q';
/**
 * Baseline symbol for calculate font metrics.
 *
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_SYMBOL
 * @type {string}
 * @default M
 */
TextMetrics.BASELINE_SYMBOL = 'M';
/**
 * Baseline multiplier for calculate font metrics.
 *
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_MULTIPLIER
 * @type {number}
 * @default 1.4
 */
TextMetrics.BASELINE_MULTIPLIER = 1.4;
/**
 * Height multiplier for setting height of canvas to calculate font metrics.
 *
 * @static
 * @memberof PIXI.TextMetrics
 * @name HEIGHT_MULTIPLIER
 * @type {number}
 * @default 2.00
 */
TextMetrics.HEIGHT_MULTIPLIER = 2.0;
/**
 * Cache of new line chars.
 *
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._newlines = [
    0x000A,
    0x000D, // carriage return
];
/**
 * Cache of breaking spaces.
 *
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._breakingSpaces = [
    0x0009,
    0x0020,
    0x2000,
    0x2001,
    0x2002,
    0x2003,
    0x2004,
    0x2005,
    0x2006,
    0x2008,
    0x2009,
    0x200A,
    0x205F,
    0x3000, // ideographic space
];
/**
 * A number, or a string containing a number.
 *
 * @memberof PIXI
 * @typedef {object} IFontMetrics
 * @property {number} ascent - Font ascent
 * @property {number} descent - Font descent
 * @property {number} fontSize - Font size
 */ 


/***/ }),

/***/ "./src/Text/TextStyle.ts":
/*!*******************************!*\
  !*** ./src/Text/TextStyle.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextStyle": () => (/* binding */ TextStyle)
/* harmony export */ });
/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const */ "./src/Text/const.ts");
// disabling eslint for now, going to rewrite this in v5
/* eslint-disable */

function hex2string(hex) {
    var hexString = hex.toString(16);
    hexString = '000000'.substr(0, 6 - hexString.length) + hexString;
    return "#" + hexString;
}
var defaultStyle = {
    align: 'left',
    breakWords: false,
    dropShadow: false,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: 'black',
    dropShadowDistance: 5,
    fill: 'black',
    fillGradientType: _const__WEBPACK_IMPORTED_MODULE_0__.TEXT_GRADIENT.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: 'Arial',
    fontSize: 26,
    fontStyle: 'normal',
    fontVariant: 'normal',
    fontWeight: 'normal',
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: 'miter',
    miterLimit: 10,
    padding: 0,
    stroke: 'black',
    strokeThickness: 0,
    textBaseline: 'alphabetic',
    trim: false,
    whiteSpace: 'pre',
    wordWrap: false,
    wordWrapWidth: 100,
    leading: 0,
};
var genericFontFamilies = [
    'serif',
    'sans-serif',
    'monospace',
    'cursive',
    'fantasy',
    'system-ui',
];
/**
 * A TextStyle Object contains information to decorate a Text objects.
 *
 * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.
 *
 * A tool can be used to generate a text style [here](https://pixijs.io/pixi-text-style).
 *
 * @memberof PIXI
 */
var TextStyle = /** @class */ (function () {
    /**
     * @param {object} [style] - The style parameters
     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'),
     *  does not affect single line text
     * @param {boolean} [style.breakWords=false] - Indicates if lines can be wrapped within words, it
     *  needs wordWrap to be set to true
     * @param {boolean} [style.dropShadow=false] - Set a drop shadow for the text
     * @param {number} [style.dropShadowAlpha=1] - Set alpha for the drop shadow
     * @param {number} [style.dropShadowAngle=Math.PI/6] - Set a angle of the drop shadow
     * @param {number} [style.dropShadowBlur=0] - Set a shadow blur radius
     * @param {string|number} [style.dropShadowColor='black'] - A fill style to be used on the dropshadow e.g 'red', '#00FF00'
     * @param {number} [style.dropShadowDistance=5] - Set a distance of the drop shadow
     * @param {string|string[]|number|number[]|CanvasGradient|CanvasPattern} [style.fill='black'] - A canvas
     *  fillstyle that will be used on the text e.g 'red', '#00FF00'. Can be an array to create a gradient
     *  eg ['#000000','#FFFFFF']
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
     * @param {number} [style.fillGradientType=PIXI.TEXT_GRADIENT.LINEAR_VERTICAL] - If fill is an array of colours
     *  to create a gradient, this can change the type/direction of the gradient. See {@link PIXI.TEXT_GRADIENT}
     * @param {number[]} [style.fillGradientStops] - If fill is an array of colours to create a gradient, this array can set
     * the stop points (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
     * @param {string|string[]} [style.fontFamily='Arial'] - The font family
     * @param {number|string} [style.fontSize=26] - The font size (as a number it converts to px, but as a string,
     *  equivalents are '26px','20pt','160%' or '1.6em')
     * @param {string} [style.fontStyle='normal'] - The font style ('normal', 'italic' or 'oblique')
     * @param {string} [style.fontVariant='normal'] - The font variant ('normal' or 'small-caps')
     * @param {string} [style.fontWeight='normal'] - The font weight ('normal', 'bold', 'bolder', 'lighter' and '100',
     *  '200', '300', '400', '500', '600', '700', '800' or '900')
     * @param {number} [style.leading=0] - The space between lines
     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters, default is 0
     * @param {number} [style.lineHeight] - The line height, a number that represents the vertical space that a letter uses
     * @param {string} [style.lineJoin='miter'] - The lineJoin property sets the type of corner created, it can resolve
     *      spiked text issues. Possible values "miter" (creates a sharp corner), "round" (creates a round corner) or "bevel"
     *      (creates a squared corner).
     * @param {number} [style.miterLimit=10] - The miter limit to use when using the 'miter' lineJoin mode. This can reduce
     *      or increase the spikiness of rendered text.
     * @param {number} [style.padding=0] - Occasionally some fonts are cropped. Adding some padding will prevent this from
     *     happening by adding padding to all sides of the text.
     * @param {string|number} [style.stroke='black'] - A canvas fillstyle that will be used on the text stroke
     *  e.g 'blue', '#FCFF00'
     * @param {number} [style.strokeThickness=0] - A number that represents the thickness of the stroke.
     *  Default is 0 (no stroke)
     * @param {boolean} [style.trim=false] - Trim transparent borders
     * @param {string} [style.textBaseline='alphabetic'] - The baseline of the text that is rendered.
     * @param {string} [style.whiteSpace='pre'] - Determines whether newlines & spaces are collapsed or preserved "normal"
     *      (collapse, collapse), "pre" (preserve, preserve) | "pre-line" (preserve, collapse). It needs wordWrap to be set to true
     * @param {boolean} [style.wordWrap=false] - Indicates if word wrap should be used
     * @param {number} [style.wordWrapWidth=100] - The width at which text will wrap, it needs wordWrap to be set to true
     */
    function TextStyle(style) {
        this._align = undefined;
        this._breakWords = undefined;
        this._dropShadow = undefined;
        this._dropShadowAlpha = undefined;
        this._dropShadowAngle = undefined;
        this._dropShadowBlur = undefined;
        this._dropShadowColor = undefined;
        this._dropShadowDistance = undefined;
        this._fill = undefined;
        this._fillGradientType = undefined;
        this._fillGradientStops = undefined;
        this._fontFamily = undefined;
        this._fontSize = undefined;
        this._fontStyle = undefined;
        this._fontVariant = undefined;
        this._fontWeight = undefined;
        this._letterSpacing = undefined;
        this._lineHeight = undefined;
        this._lineJoin = undefined;
        this._miterLimit = undefined;
        this._padding = undefined;
        this._stroke = undefined;
        this._strokeThickness = undefined;
        this._textBaseline = undefined;
        this._trim = undefined;
        this._whiteSpace = undefined;
        this._wordWrap = undefined;
        this._wordWrapWidth = undefined;
        this._leading = undefined;
        this.styleID = 0;
        this.reset();
        deepCopyProperties(this, style, style);
    }
    /**
     * Creates a new TextStyle object with the same values as this one.
     * Note that the only the properties of the object are cloned.
     *
     * @return New cloned TextStyle object
     */
    TextStyle.prototype.clone = function () {
        var clonedProperties = {};
        deepCopyProperties(clonedProperties, this, defaultStyle);
        return new TextStyle(clonedProperties);
    };
    /** Resets all properties to the defaults specified in TextStyle.prototype._default */
    TextStyle.prototype.reset = function () {
        deepCopyProperties(this, defaultStyle, defaultStyle);
    };
    Object.defineProperty(TextStyle.prototype, "align", {
        /**
         * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
         *
         * @member {string}
         */
        get: function () {
            return this._align;
        },
        set: function (align) {
            if (this._align !== align) {
                this._align = align;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "breakWords", {
        /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
        get: function () {
            return this._breakWords;
        },
        set: function (breakWords) {
            if (this._breakWords !== breakWords) {
                this._breakWords = breakWords;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "dropShadow", {
        /** Set a drop shadow for the text. */
        get: function () {
            return this._dropShadow;
        },
        set: function (dropShadow) {
            if (this._dropShadow !== dropShadow) {
                this._dropShadow = dropShadow;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "dropShadowAlpha", {
        /** Set alpha for the drop shadow. */
        get: function () {
            return this._dropShadowAlpha;
        },
        set: function (dropShadowAlpha) {
            if (this._dropShadowAlpha !== dropShadowAlpha) {
                this._dropShadowAlpha = dropShadowAlpha;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "dropShadowAngle", {
        /** Set a angle of the drop shadow. */
        get: function () {
            return this._dropShadowAngle;
        },
        set: function (dropShadowAngle) {
            if (this._dropShadowAngle !== dropShadowAngle) {
                this._dropShadowAngle = dropShadowAngle;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "dropShadowBlur", {
        /** Set a shadow blur radius. */
        get: function () {
            return this._dropShadowBlur;
        },
        set: function (dropShadowBlur) {
            if (this._dropShadowBlur !== dropShadowBlur) {
                this._dropShadowBlur = dropShadowBlur;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "dropShadowColor", {
        /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */
        get: function () {
            return this._dropShadowColor;
        },
        set: function (dropShadowColor) {
            var outputColor = getColor(dropShadowColor);
            if (this._dropShadowColor !== outputColor) {
                this._dropShadowColor = outputColor;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "dropShadowDistance", {
        /** Set a distance of the drop shadow. */
        get: function () {
            return this._dropShadowDistance;
        },
        set: function (dropShadowDistance) {
            if (this._dropShadowDistance !== dropShadowDistance) {
                this._dropShadowDistance = dropShadowDistance;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "fill", {
        /**
         * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
         *
         * Can be an array to create a gradient eg ['#000000','#FFFFFF']
         * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
         *
         * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
         */
        get: function () {
            return this._fill;
        },
        set: function (fill) {
            // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as
            //       the setter converts to string. See this thread for more details:
            //       https://github.com/microsoft/TypeScript/issues/2521
            // TODO: Not sure if getColor works properly with CanvasGradient and/or CanvasPattern, can't pass in
            //       without casting here.
            var outputColor = getColor(fill);
            if (this._fill !== outputColor) {
                this._fill = outputColor;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "fillGradientType", {
        /**
         * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
         *
         * @see PIXI.TEXT_GRADIENT
         */
        get: function () {
            return this._fillGradientType;
        },
        set: function (fillGradientType) {
            if (this._fillGradientType !== fillGradientType) {
                this._fillGradientType = fillGradientType;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "fillGradientStops", {
        /**
         * If fill is an array of colours to create a gradient, this array can set the stop points
         * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
         */
        get: function () {
            return this._fillGradientStops;
        },
        set: function (fillGradientStops) {
            if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
                this._fillGradientStops = fillGradientStops;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "fontFamily", {
        /** The font family. */
        get: function () {
            return this._fontFamily;
        },
        set: function (fontFamily) {
            if (this.fontFamily !== fontFamily) {
                this._fontFamily = fontFamily;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "fontSize", {
        /**
         * The font size
         * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
         */
        get: function () {
            return this._fontSize;
        },
        set: function (fontSize) {
            if (this._fontSize !== fontSize) {
                this._fontSize = fontSize;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "fontStyle", {
        /**
         * The font style
         * ('normal', 'italic' or 'oblique')
         *
         * @member {string}
         */
        get: function () {
            return this._fontStyle;
        },
        set: function (fontStyle) {
            if (this._fontStyle !== fontStyle) {
                this._fontStyle = fontStyle;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "fontVariant", {
        /**
         * The font variant
         * ('normal' or 'small-caps')
         *
         * @member {string}
         */
        get: function () {
            return this._fontVariant;
        },
        set: function (fontVariant) {
            if (this._fontVariant !== fontVariant) {
                this._fontVariant = fontVariant;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "fontWeight", {
        /**
         * The font weight
         * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
         *
         * @member {string}
         */
        get: function () {
            return this._fontWeight;
        },
        set: function (fontWeight) {
            if (this._fontWeight !== fontWeight) {
                this._fontWeight = fontWeight;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "letterSpacing", {
        /** The amount of spacing between letters, default is 0. */
        get: function () {
            return this._letterSpacing;
        },
        set: function (letterSpacing) {
            if (this._letterSpacing !== letterSpacing) {
                this._letterSpacing = letterSpacing;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "lineHeight", {
        /** The line height, a number that represents the vertical space that a letter uses. */
        get: function () {
            return this._lineHeight;
        },
        set: function (lineHeight) {
            if (this._lineHeight !== lineHeight) {
                this._lineHeight = lineHeight;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "leading", {
        /** The space between lines. */
        get: function () {
            return this._leading;
        },
        set: function (leading) {
            if (this._leading !== leading) {
                this._leading = leading;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "lineJoin", {
        /**
         * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
         * Default is 'miter' (creates a sharp corner).
         *
         * @member {string}
         */
        get: function () {
            return this._lineJoin;
        },
        set: function (lineJoin) {
            if (this._lineJoin !== lineJoin) {
                this._lineJoin = lineJoin;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "miterLimit", {
        /**
         * The miter limit to use when using the 'miter' lineJoin mode.
         *
         * This can reduce or increase the spikiness of rendered text.
         */
        get: function () {
            return this._miterLimit;
        },
        set: function (miterLimit) {
            if (this._miterLimit !== miterLimit) {
                this._miterLimit = miterLimit;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "padding", {
        /**
         * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
         * by adding padding to all sides of the text.
         */
        get: function () {
            return this._padding;
        },
        set: function (padding) {
            if (this._padding !== padding) {
                this._padding = padding;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "stroke", {
        /**
         * A canvas fillstyle that will be used on the text stroke
         * e.g 'blue', '#FCFF00'
         */
        get: function () {
            return this._stroke;
        },
        set: function (stroke) {
            // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as
            //       the setter converts to string. See this thread for more details:
            //       https://github.com/microsoft/TypeScript/issues/2521
            var outputColor = getColor(stroke);
            if (this._stroke !== outputColor) {
                this._stroke = outputColor;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "strokeThickness", {
        /**
         * A number that represents the thickness of the stroke.
         *
         * @default 0
         */
        get: function () {
            return this._strokeThickness;
        },
        set: function (strokeThickness) {
            if (this._strokeThickness !== strokeThickness) {
                this._strokeThickness = strokeThickness;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "textBaseline", {
        /**
         * The baseline of the text that is rendered.
         *
         * @member {string}
         */
        get: function () {
            return this._textBaseline;
        },
        set: function (textBaseline) {
            if (this._textBaseline !== textBaseline) {
                this._textBaseline = textBaseline;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "trim", {
        /** Trim transparent borders. */
        get: function () {
            return this._trim;
        },
        set: function (trim) {
            if (this._trim !== trim) {
                this._trim = trim;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "whiteSpace", {
        /**
         * How newlines and spaces should be handled.
         * Default is 'pre' (preserve, preserve).
         *
         *  value       | New lines     |   Spaces
         *  ---         | ---           |   ---
         * 'normal'     | Collapse      |   Collapse
         * 'pre'        | Preserve      |   Preserve
         * 'pre-line'   | Preserve      |   Collapse
         *
         * @member {string}
         */
        get: function () {
            return this._whiteSpace;
        },
        set: function (whiteSpace) {
            if (this._whiteSpace !== whiteSpace) {
                this._whiteSpace = whiteSpace;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "wordWrap", {
        /** Indicates if word wrap should be used. */
        get: function () {
            return this._wordWrap;
        },
        set: function (wordWrap) {
            if (this._wordWrap !== wordWrap) {
                this._wordWrap = wordWrap;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextStyle.prototype, "wordWrapWidth", {
        /** The width at which text will wrap, it needs wordWrap to be set to true. */
        get: function () {
            return this._wordWrapWidth;
        },
        set: function (wordWrapWidth) {
            if (this._wordWrapWidth !== wordWrapWidth) {
                this._wordWrapWidth = wordWrapWidth;
                this.styleID++;
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Generates a font style string to use for `TextMetrics.measureFont()`.
     *
     * @return Font style string, for passing to `TextMetrics.measureFont()`
     */
    TextStyle.prototype.toFontString = function () {
        // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
        var fontSizeString = (typeof this.fontSize === 'number') ? this.fontSize + "px" : this.fontSize;
        // Clean-up fontFamily property by quoting each font name
        // this will support font names with spaces
        var fontFamilies = this.fontFamily;
        if (!Array.isArray(this.fontFamily)) {
            fontFamilies = this.fontFamily.split(',');
        }
        for (var i = fontFamilies.length - 1; i >= 0; i--) {
            // Trim any extra white-space
            var fontFamily = fontFamilies[i].trim();
            // Check if font already contains strings
            if (!(/([\"\'])[^\'\"]+\1/).test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
                fontFamily = "\"" + fontFamily + "\"";
            }
            fontFamilies[i] = fontFamily;
        }
        return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(',');
    };
    return TextStyle;
}());

/**
 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
 * @private
 * @param color
 * @return The color as a string.
 */
function getSingleColor(color) {
    if (typeof color === 'number') {
        return hex2string(color);
    }
    else if (typeof color === 'string') {
        if (color.indexOf('0x') === 0) {
            color = color.replace('0x', '#');
        }
    }
    return color;
}
function getColor(color) {
    if (!Array.isArray(color)) {
        return getSingleColor(color);
    }
    else {
        for (var i = 0; i < color.length; ++i) {
            color[i] = getSingleColor(color[i]);
        }
        return color;
    }
}
/**
 * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.
 * This version can also convert array of colors
 * @private
 * @param array1 - First array to compare
 * @param array2 - Second array to compare
 * @return Do the arrays contain the same values in the same order
 */
function areArraysEqual(array1, array2) {
    if (!Array.isArray(array1) || !Array.isArray(array2)) {
        return false;
    }
    if (array1.length !== array2.length) {
        return false;
    }
    for (var i = 0; i < array1.length; ++i) {
        if (array1[i] !== array2[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Utility function to ensure that object properties are copied by value, and not by reference
 * @private
 * @param target - Target object to copy properties into
 * @param source - Source object for the properties to copy
 * @param propertyObj - Object containing properties names we want to loop over
 */
function deepCopyProperties(target, source, propertyObj) {
    for (var prop in propertyObj) {
        if (Array.isArray(source[prop])) {
            target[prop] = source[prop].slice();
        }
        else {
            target[prop] = source[prop];
        }
    }
}


/***/ }),

/***/ "./src/Text/const.ts":
/*!***************************!*\
  !*** ./src/Text/const.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TEXT_GRADIENT": () => (/* binding */ TEXT_GRADIENT)
/* harmony export */ });
/**
 * Constants that define the type of gradient on text.
 *
 * @static
 * @constant
 * @name TEXT_GRADIENT
 * @memberof PIXI
 * @type {object}
 * @property {number} LINEAR_VERTICAL Vertical gradient
 * @property {number} LINEAR_HORIZONTAL Linear gradient
 */
var TEXT_GRADIENT;
(function (TEXT_GRADIENT) {
    TEXT_GRADIENT[TEXT_GRADIENT["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
    TEXT_GRADIENT[TEXT_GRADIENT["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));


/***/ }),

/***/ "./src/UI/ButtonComponent.ts":
/*!***********************************!*\
  !*** ./src/UI/ButtonComponent.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ButtonComponent": () => (/* binding */ ButtonComponent)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _GUIComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GUIComponent */ "./src/UI/GUIComponent.ts");
/* harmony import */ var _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../drawing/SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _drawing_Pen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../drawing/Pen */ "./src/drawing/Pen.ts");
/* harmony import */ var _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawing/StringFormat */ "./src/drawing/StringFormat.ts");
/* harmony import */ var _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../drawing/StringAlignment */ "./src/drawing/StringAlignment.ts");
/* harmony import */ var _drawing_Font__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../drawing/Font */ "./src/drawing/Font.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var ButtonComponent = /** @class */ (function (_super) {
    __extends(ButtonComponent, _super);
    function ButtonComponent(eventService, x, y, w, h, params) {
        var _this = _super.call(this, eventService, x, y, w, h, params.name, params.trigger) || this;
        _this.defaultCol = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(230, 230, 230, 200);
        _this.highlightCol = params.highlightCol || new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(210, 210, 210, 250);
        if (params.filled) {
            _this.makeFilled();
        }
        return _this;
    }
    ButtonComponent.prototype.draw = function (tg) {
        this.fade();
        var brush;
        var pen;
        if (this.disabled) {
            brush = new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__.SolidBrush(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(180));
            pen = new _drawing_Pen__WEBPACK_IMPORTED_MODULE_3__.Pen(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(200), 0);
        }
        else {
            var color = tg.lerpColor(this.defaultCol, this.highlightCol, this.transition / 10);
            brush = new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__.SolidBrush(color);
            pen = new _drawing_Pen__WEBPACK_IMPORTED_MODULE_3__.Pen(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(200));
        }
        tg.FillRectangle(brush, this.x, this.y, this.w, this.h, 12);
        tg.DrawRectangle(pen, this.x, this.y, this.w, this.h, 12);
        /* if (this.disabled) {
            tg.fill(180);
            tg.noStroke();
        } else {
            const color = tg.lerpColor(this.defaultCol, this.highlightCol, this.transition / 10)
            tg.fill(color);
            tg.strokeWeight(1);
            tg.stroke(200);
        }

        tg.rect(this.x, this.y - 1, this.w, this.h + 3, 12);

        if (this.disabled) {
            tg.fill(120);
        } else {
            tg.fill(20);
        }
 */
        // textFont(sansFont, 16);
        // textAlign(CENTER, CENTER);
        // text(this.name, this.x + this.w / 2, this.y + this.h/2 + 1);
        var sf = new _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_4__.StringFormat();
        sf.Alignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_5__.StringAlignment.Center;
        sf.LineAlignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_5__.StringAlignment.Center;
        tg.drawString(this.name, new _drawing_Font__WEBPACK_IMPORTED_MODULE_6__.Font('Tahoma', 12), new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__.SolidBrush(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(20)), this.x + this.w / 2, this.y + this.h / 2 + 1, sf);
    };
    ButtonComponent.prototype.drawFilled = function (tg) {
        this.fade();
        if (this.disabled) {
            tg.fill(180);
            tg.noStroke();
        }
        else {
            tg.fill(tg.lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
            tg.strokeWeight(1);
            tg.stroke(this.highlightCol);
        }
        tg.rect(this.x, this.y - 1, this.w, this.h + 3, 19);
        if (this.disabled) {
            tg.fill(120);
        }
        else {
            tg.fill(tg.lerpColor(this.highlightCol, _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromRgba(255, 255, 255), this.transition / 10));
        }
        //textFont(sansFont, 16);
        //textAlign(CENTER, CENTER);
        //text(this.name, this.x + this.w / 2, this.y + this.h/2);
    };
    ButtonComponent.prototype.makeFilled = function () {
        this.draw = this.drawFilled;
        this.defaultCol = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(0, 0, 0, 1);
    };
    return ButtonComponent;
}(_GUIComponent__WEBPACK_IMPORTED_MODULE_1__.GUIComponent));



/***/ }),

/***/ "./src/UI/CheckboxComponent.ts":
/*!*************************************!*\
  !*** ./src/UI/CheckboxComponent.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CheckboxComponent": () => (/* binding */ CheckboxComponent)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ButtonComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ButtonComponent */ "./src/UI/ButtonComponent.ts");
/* harmony import */ var _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../drawing/SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../drawing/StringFormat */ "./src/drawing/StringFormat.ts");
/* harmony import */ var _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawing/StringAlignment */ "./src/drawing/StringAlignment.ts");
/* harmony import */ var _drawing_Font__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../drawing/Font */ "./src/drawing/Font.ts");
/* harmony import */ var _drawing_Pen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../drawing/Pen */ "./src/drawing/Pen.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var CheckboxComponent = /** @class */ (function (_super) {
    __extends(CheckboxComponent, _super);
    function CheckboxComponent(x, y, w, h, params) {
        var _this = _super.call(this, null, x, y, w, h, { name: params.name }) || this;
        _this.checked = false;
        _this.box = _this.h - 6;
        _this.bx = _this.x + 5;
        _this.by = _this.y + 3;
        return _this;
    }
    CheckboxComponent.prototype.trigger = function () {
        // showing[this.name] = !showing[this.name];
    };
    CheckboxComponent.prototype.mousePressed = function () {
        this.checked = !this.checked;
    };
    CheckboxComponent.prototype.draw = function (tg) {
        this.fade();
        if (this.transition) {
            var brush = new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__.SolidBrush(tg.lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
            tg.FillRectangle(brush, this.x, this.y, this.w, this.h + 1, 4);
        }
        var sf = new _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_3__.StringFormat();
        sf.Alignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_4__.StringAlignment.Near;
        sf.LineAlignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_4__.StringAlignment.Center;
        tg.drawString(this.name, new _drawing_Font__WEBPACK_IMPORTED_MODULE_5__.Font('Tahoma', 12), new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__.SolidBrush(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(20)), this.x + this.box + 9, this.y + this.h / 2 + 1, sf);
        tg.DrawRectangle(new _drawing_Pen__WEBPACK_IMPORTED_MODULE_6__.Pen(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(100)), this.bx, this.y + 3, this.box, this.box);
        if (this.checked) {
            tg.DrawLine(new _drawing_Pen__WEBPACK_IMPORTED_MODULE_6__.Pen(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(100)), this.bx + 1, this.by + 1, this.bx + this.box, this.by + this.box);
            tg.DrawLine(new _drawing_Pen__WEBPACK_IMPORTED_MODULE_6__.Pen(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(100)), this.bx + this.box, this.by + 1, this.bx + 1, this.by + this.box);
        }
    };
    return CheckboxComponent;
}(_ButtonComponent__WEBPACK_IMPORTED_MODULE_1__.ButtonComponent));



/***/ }),

/***/ "./src/UI/DraggablePoint.ts":
/*!**********************************!*\
  !*** ./src/UI/DraggablePoint.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DraggablePoint": () => (/* binding */ DraggablePoint)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _drawing_Pen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../drawing/Pen */ "./src/drawing/Pen.ts");
/* harmony import */ var _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../drawing/SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _drawing_sketch_SketchGraphics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../drawing/sketch/SketchGraphics */ "./src/drawing/sketch/SketchGraphics.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var DraggablePoint = /** @class */ (function (_super) {
    __extends(DraggablePoint, _super);
    function DraggablePoint(x, y, cursorService) {
        var _this = _super.call(this, x, y) || this;
        _this.color = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Black;
        _this.cursorService = undefined;
        _this.animation = 0;
        _this.selected = false;
        _this.dragging = false;
        _this.enter = false;
        _this.mouseX = 0;
        _this.mouseY = 0;
        _this.pmouseX = 0;
        _this.pmouseY = 0;
        _this.cursorService = cursorService !== null && cursorService !== void 0 ? cursorService : undefined;
        _this.color = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromRgba(255, 165, 0);
        var self = _this;
        return _this;
        /*  window.addEventListener('mousedown', function (evt) {
             self.onMouseDown(evt);
         });
         window.addEventListener('mousemove', function (evt) {
             self.onMouseMove(evt);
         });
         window.addEventListener('mouseup', function (evt) {
             self.onMouseUp(evt);
         }); */
    }
    DraggablePoint.prototype.draw = function (tg) {
        if (this.selected || (!this.selected && this.mouseover())) {
            if (this.animation < 5) {
                this.animation++;
            }
        }
        else {
            this.animation = 0;
        }
        var pen = new _drawing_Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromRgba(240, 250, 255), 1);
        var r = 12 + this.animation;
        tg.FillEllipse(new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__.SolidBrush(this.color), this.X - (r / 2), this.Y - (r / 2), r, r);
        tg.DrawEllipse(pen, this.X - (r / 2), this.Y - (r / 2), r, r);
    };
    DraggablePoint.prototype.mouseover = function () {
        var dist = _drawing_sketch_SketchGraphics__WEBPACK_IMPORTED_MODULE_3__.SketchGraphics.prototype.dist(this.mouseX, this.mouseY, this.X, this.Y);
        return dist <= 12 / 2;
    };
    DraggablePoint.prototype.onMouseDown = function () {
        if (this.mouseover()) {
            this.dragging = true;
        }
    };
    DraggablePoint.prototype.onMouseMove = function (/* evt: MouseEvent */ x, y, prevX, prevY) {
        this.pmouseX = prevX; //this.mouseX;
        this.pmouseY = prevY; //this.mouseY;
        this.mouseX = x; //evt.offsetX;
        this.mouseY = y; //evt.offsetY;
        if (this.mouseover()) {
            this.enter = true;
            this.mouseenter();
        }
        else {
            if (this.enter) {
                this.enter = false;
                this.mouseout();
            }
        }
        if (this.dragging) {
            this.move();
        }
    };
    DraggablePoint.prototype.mouseenter = function () {
        if (this.cursorService != null) {
            this.cursorService('pointer');
        }
    };
    DraggablePoint.prototype.mouseout = function () {
        if (this.cursorService != null) {
            this.cursorService('default');
        }
    };
    DraggablePoint.prototype.onMouseUp = function () {
        this.dragging = false;
    };
    DraggablePoint.prototype.move = function () {
        this.X += this.mouseX - this.pmouseX;
        this.Y += this.mouseY - this.pmouseY;
    };
    return DraggablePoint;
}(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint));



/***/ }),

/***/ "./src/UI/GUIComponent.ts":
/*!********************************!*\
  !*** ./src/UI/GUIComponent.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GUIComponent": () => (/* binding */ GUIComponent)
/* harmony export */ });
var GUIComponent = /** @class */ (function () {
    function GUIComponent(eventService, x, y, w, h, name, updateFunction) {
        this.dragging = false;
        this.mouseX = 0;
        this.mouseY = 0;
        this.pmouseX = 0;
        this.pmouseY = 0;
        this.enter = false;
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.name = name;
        if (updateFunction) {
            this.trigger = updateFunction.bind(this);
        }
        this.selected = false;
        this.disabled = false;
        this.transition = 0;
        this.activeCursor = 'pointer';
        if (eventService != null) {
            eventService.onMouseDown$.subscribe(this.onMouseDown.bind(this));
            eventService.onMouseMove$.subscribe(this.onMouseMove.bind(this));
            eventService.onMouseUp$.subscribe(this.onMouseUp.bind(this));
        }
    }
    GUIComponent.prototype.draw = function (tg) { };
    GUIComponent.prototype.mouseOver = function () {
        return (this.mouseX >= this.x && this.mouseX <= this.x + this.w &&
            this.mouseY >= this.y && this.mouseY <= this.y + this.h);
    };
    ;
    GUIComponent.prototype.onMouseDown = function ( /* evt */) {
        if (this.mouseOver()) {
            this.mousePressed();
            this.dragging = true;
        }
    };
    GUIComponent.prototype.onMouseMove = function (evt) {
        this.pmouseX = evt.prevX; //this.mouseX;
        this.pmouseY = evt.prevY; //this.mouseY;
        this.mouseX = evt.x; //evt.offsetX;
        this.mouseY = evt.y; //evt.offsetY;
        if (this.mouseOver()) {
            this.enter = true;
            this.mouseenter();
        }
        else {
            if (this.enter) {
                this.enter = false;
                this.mouseout();
            }
        }
        if (this.dragging) {
            this.mouseDragged();
        }
    };
    GUIComponent.prototype.onMouseUp = function ( /* evt */) {
        this.dragging = false;
        this.mouseReleased();
    };
    GUIComponent.prototype.mouseenter = function () {
        document.body.style.cursor = this.activeCursor;
    };
    GUIComponent.prototype.mouseout = function () {
        document.body.style.cursor = 'default';
    };
    GUIComponent.prototype.mousePressed = function () {
        this.selected = this.mouseOver();
    };
    GUIComponent.prototype.mouseDragged = function () { };
    GUIComponent.prototype.mouseReleased = function () {
        if (this.selected && !this.disabled && this.mouseOver()) {
            this.trigger();
        }
        this.selected = false;
    };
    GUIComponent.prototype.trigger = function () {
        // To be over-written
    };
    GUIComponent.prototype.fade = function () {
        if (this.selected || this.mouseOver()) {
            this.transition = Math.min(10, this.transition + 1);
        }
        else {
            this.transition = Math.max(0, this.transition - 1);
        }
    };
    ;
    return GUIComponent;
}());



/***/ }),

/***/ "./src/UI/ImageComponent.ts":
/*!**********************************!*\
  !*** ./src/UI/ImageComponent.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageComponent": () => (/* binding */ ImageComponent)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _LabelComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LabelComponent */ "./src/UI/LabelComponent.ts");
/* harmony import */ var _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../drawing/StringFormat */ "./src/drawing/StringFormat.ts");
/* harmony import */ var _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../drawing/StringAlignment */ "./src/drawing/StringAlignment.ts");
/* harmony import */ var _drawing_Font__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawing/Font */ "./src/drawing/Font.ts");
/* harmony import */ var _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../drawing/SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _drawing_Pen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../drawing/Pen */ "./src/drawing/Pen.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var ImageComponent = /** @class */ (function (_super) {
    __extends(ImageComponent, _super);
    function ImageComponent(x, y, w, h, params) {
        var _this = _super.call(this, x, y, w, h, params) || this;
        _this.image = params.image;
        return _this;
    }
    ImageComponent.prototype.draw = function (tg) {
        var sf = new _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_2__.StringFormat();
        sf.Alignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_3__.StringAlignment.Center;
        sf.LineAlignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_3__.StringAlignment.Near;
        tg.drawString(this.name, new _drawing_Font__WEBPACK_IMPORTED_MODULE_4__.Font('Tahoma', 12), new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_5__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Black), this.x + (this.w / 2), this.y, sf);
        var x1 = this.x + 8;
        var x2 = this.x + this.w - 8;
        var y2 = this.y + 15;
        tg.DrawLine(new _drawing_Pen__WEBPACK_IMPORTED_MODULE_6__.Pen(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(180)), x1, y2, x2, y2);
        tg.DrawImage(this.image, (this.x + this.w / 2) - (this.image.Width / 2), this.y + 20);
    };
    return ImageComponent;
}(_LabelComponent__WEBPACK_IMPORTED_MODULE_1__.LabelComponent));



/***/ }),

/***/ "./src/UI/LabelComponent.ts":
/*!**********************************!*\
  !*** ./src/UI/LabelComponent.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelComponent": () => (/* binding */ LabelComponent)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _GUIComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GUIComponent */ "./src/UI/GUIComponent.ts");
/* harmony import */ var _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../drawing/StringFormat */ "./src/drawing/StringFormat.ts");
/* harmony import */ var _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../drawing/StringAlignment */ "./src/drawing/StringAlignment.ts");
/* harmony import */ var _drawing_Font__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawing/Font */ "./src/drawing/Font.ts");
/* harmony import */ var _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../drawing/SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _drawing_Pen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../drawing/Pen */ "./src/drawing/Pen.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var LabelComponent = /** @class */ (function (_super) {
    __extends(LabelComponent, _super);
    function LabelComponent(x, y, w, h, params) {
        var _this = _super.call(this, null, x, y, w, h, params.name) || this;
        _this.x1 = x + 8;
        _this.x2 = x + w - 8;
        _this.y2 = y + h / 2 + 5;
        _this.textColor = params.textColor || new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(50);
        return _this;
    }
    LabelComponent.prototype.draw = function (tg) {
        var sf = new _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_2__.StringFormat();
        sf.Alignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_3__.StringAlignment.Center;
        sf.LineAlignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_3__.StringAlignment.Near;
        tg.drawString(this.name, new _drawing_Font__WEBPACK_IMPORTED_MODULE_4__.Font('Tahoma', 12), new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_5__.SolidBrush(this.textColor), this.x + (this.w / 2), this.y, sf);
        tg.DrawLine(new _drawing_Pen__WEBPACK_IMPORTED_MODULE_6__.Pen(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(180)), this.x1, this.y2, this.x2, this.y2);
    };
    return LabelComponent;
}(_GUIComponent__WEBPACK_IMPORTED_MODULE_1__.GUIComponent));



/***/ }),

/***/ "./src/UI/RadioButtonComponent.ts":
/*!****************************************!*\
  !*** ./src/UI/RadioButtonComponent.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RadioButtonComponent": () => (/* binding */ RadioButtonComponent)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ButtonComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ButtonComponent */ "./src/UI/ButtonComponent.ts");
/* harmony import */ var _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../drawing/SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../drawing/StringFormat */ "./src/drawing/StringFormat.ts");
/* harmony import */ var _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawing/StringAlignment */ "./src/drawing/StringAlignment.ts");
/* harmony import */ var _drawing_Font__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../drawing/Font */ "./src/drawing/Font.ts");
/* harmony import */ var _drawing_Graphics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../drawing/Graphics */ "./src/drawing/Graphics.ts");
/* harmony import */ var _drawing_Pen__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../drawing/Pen */ "./src/drawing/Pen.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var RadioButtonComponent = /** @class */ (function (_super) {
    __extends(RadioButtonComponent, _super);
    function RadioButtonComponent(x, y, w, h, name, trigger) {
        var _this = _super.call(this, null, x, y, w, h, { name: name, trigger: trigger }) || this;
        _this.r = _this.h - 6;
        _this.cx = _this.x + _this.r / 2 + 5;
        _this.cy = _this.y + _this.h / 2;
        _this.marked = false;
        return _this;
    }
    RadioButtonComponent.prototype.draw = function (tg) {
        this.fade();
        if (this.transition) {
            var brush = new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__.SolidBrush(tg.lerpColor(this.defaultCol, this.highlightCol, this.transition / 10));
            tg.FillRectangle(brush, this.x, this.y, this.w, this.h + 1, 4);
        }
        var sf = new _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_3__.StringFormat();
        sf.Alignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_4__.StringAlignment.Near;
        sf.LineAlignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_4__.StringAlignment.Center;
        tg.drawString(this.name, new _drawing_Font__WEBPACK_IMPORTED_MODULE_5__.Font('Tahoma', 12), new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__.SolidBrush(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(20)), this.cx + this.r / 2 + 4, this.cy + 1, sf);
        tg.DrawEllipse(new _drawing_Pen__WEBPACK_IMPORTED_MODULE_7__.Pen(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(100)), this.cx, this.cy, this.r, this.r, _drawing_Graphics__WEBPACK_IMPORTED_MODULE_6__.EllipseModes.Center);
        if (this.marked) {
            tg.FillEllipse(new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_2__.SolidBrush(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(100)), this.cx, this.cy, this.r / 2, this.r / 2, _drawing_Graphics__WEBPACK_IMPORTED_MODULE_6__.EllipseModes.Center);
        }
    };
    return RadioButtonComponent;
}(_ButtonComponent__WEBPACK_IMPORTED_MODULE_1__.ButtonComponent));



/***/ }),

/***/ "./src/UI/SliderComponent.ts":
/*!***********************************!*\
  !*** ./src/UI/SliderComponent.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SliderComponent": () => (/* binding */ SliderComponent)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _GUIComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GUIComponent */ "./src/UI/GUIComponent.ts");
/* harmony import */ var _drawing_Pen__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../drawing/Pen */ "./src/drawing/Pen.ts");
/* harmony import */ var _drawing_sketch_SketchGraphics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../drawing/sketch/SketchGraphics */ "./src/drawing/sketch/SketchGraphics.ts");
/* harmony import */ var _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawing/StringFormat */ "./src/drawing/StringFormat.ts");
/* harmony import */ var _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../drawing/StringAlignment */ "./src/drawing/StringAlignment.ts");
/* harmony import */ var _drawing_Font__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../drawing/Font */ "./src/drawing/Font.ts");
/* harmony import */ var _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../drawing/SolidBrush */ "./src/drawing/SolidBrush.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var SliderComponent = /** @class */ (function (_super) {
    __extends(SliderComponent, _super);
    function SliderComponent(x, y, w, h, params) {
        var _this = _super.call(this, null, 0, 0, 0, 0, params.name, params.trigger) || this;
        _this.bx = 0;
        // Size of ball
        var ballR = params.ballR || h / 2;
        var ballD = ballR * 2;
        x += ballR;
        w -= ballR * 2;
        h = ballD + (params.name ? 16 : 0);
        y += h - ballR;
        // Size of ball
        _this.ballR = ballR;
        _this.ballD = ballD;
        _this.x2 = x + w;
        _this.fill = params.fill || new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(240);
        _this.stroke = params.stroke || new _drawing_Pen__WEBPACK_IMPORTED_MODULE_2__.Pen(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(180));
        _this.min = params.min || 0;
        _this.max = params.max === undefined ? 1 : params.max;
        _this.val = params.now === undefined ? _this.min : params.now;
        _this.decimalPlaces = params.decimalPlaces === undefined ? 0 : params.decimalPlaces;
        _this.setValue(_this.val);
        _this.trigger();
        _this.hideVal = params.hideVal;
        _this.activeCursor = 'ew-resize';
        _this.x = x;
        _this.y = y;
        _this.w = w;
        _this.h = h;
        return _this;
    }
    SliderComponent.prototype.draw = function (tg) {
        if (this.name) {
            //tg.fill(20);
            /*  tg.textSize(13);
             tg.textAlign(CENTER, BASELINE);
             text(this.name,  this.x + this.w / 2, this.y - 14); */
            //text(this.name + ": " + this.val,  this.x + this.w / 2, this.y - 14);
            var sf = new _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_4__.StringFormat();
            sf.Alignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_5__.StringAlignment.Center;
            sf.LineAlignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_5__.StringAlignment.Far;
            tg.drawString(this.name + ": " + this.val, new _drawing_Font__WEBPACK_IMPORTED_MODULE_6__.Font('Tahoma', 10), new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_7__.SolidBrush(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(20)), this.x + this.w / 2, this.y - 14, sf);
        }
        tg.DrawLine(this.stroke, this.x, this.y, this.x2, this.y);
        this.fade();
        var brush = new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_7__.SolidBrush(tg.lerpColor(this.fill, this.stroke.Color, this.transition / 10));
        if (!this.hideVal) {
            tg.FillEllipse(brush, this.bx - (this.ballD / 2), this.y - (this.ballD / 2), this.ballD, this.ballD);
            tg.DrawEllipse(this.stroke, this.bx - (this.ballD / 2), this.y - (this.ballD / 2), this.ballD, this.ballD);
            //tg.fill(20);
            /* tg.textSize(11);
            tg.textAlign(CENTER, CENTER);
            tg.text("" + this.val, this.bx, this.y); */
            var sf = new _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_4__.StringFormat();
            sf.Alignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_5__.StringAlignment.Center;
            sf.LineAlignment = _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_5__.StringAlignment.Center;
            tg.drawString('' + this.val, new _drawing_Font__WEBPACK_IMPORTED_MODULE_6__.Font('Tahoma', 10), new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_7__.SolidBrush(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(20)), this.bx, this.y, sf);
        }
        else {
            tg.FillEllipse(brush, this.bx - (this.ballD / 2), this.y - (this.ballD / 2), this.ballD, this.ballD);
            tg.DrawEllipse(this.stroke, this.bx - (this.ballD / 2), this.y - (this.ballD / 2), this.ballD, this.ballD);
        }
    };
    ;
    SliderComponent.prototype.mouseOver = function () {
        return _drawing_sketch_SketchGraphics__WEBPACK_IMPORTED_MODULE_3__.SketchGraphics.prototype.dist(this.mouseX, this.mouseY, this.bx, this.y) < this.ballR;
    };
    ;
    SliderComponent.prototype.mousePressed = function () {
        if (this.mouseOver()) {
            this.selected = true;
            return true;
        }
    };
    SliderComponent.prototype.mouseDragged = function () {
        if (this.selected) {
            this.bx = _drawing_sketch_SketchGraphics__WEBPACK_IMPORTED_MODULE_3__.SketchGraphics.prototype.constrain(this.mouseX, this.x, this.x2);
            var p = Math.pow(10, this.decimalPlaces);
            this.val = Math.round(_drawing_sketch_SketchGraphics__WEBPACK_IMPORTED_MODULE_3__.SketchGraphics.prototype.map(this.bx, this.x, this.x2, this.min, this.max) * p) / p;
            this.trigger();
            return true;
        }
    };
    ;
    SliderComponent.prototype.setValue = function (v) {
        this.val = _drawing_sketch_SketchGraphics__WEBPACK_IMPORTED_MODULE_3__.SketchGraphics.prototype.constrain(v, this.min, this.max);
        this.bx = _drawing_sketch_SketchGraphics__WEBPACK_IMPORTED_MODULE_3__.SketchGraphics.prototype.map(this.val, this.min, this.max, this.x, this.x2);
        this.trigger();
    };
    ;
    return SliderComponent;
}(_GUIComponent__WEBPACK_IMPORTED_MODULE_1__.GUIComponent));



/***/ }),

/***/ "./src/UI/ToolbarComponent.ts":
/*!************************************!*\
  !*** ./src/UI/ToolbarComponent.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToolbarComponent": () => (/* binding */ ToolbarComponent)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _GUIComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GUIComponent */ "./src/UI/GUIComponent.ts");
/* harmony import */ var _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../drawing/SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _drawing_Pen__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../drawing/Pen */ "./src/drawing/Pen.ts");
/* harmony import */ var _RadioButtonComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RadioButtonComponent */ "./src/UI/RadioButtonComponent.ts");
/* harmony import */ var _ButtonComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ButtonComponent */ "./src/UI/ButtonComponent.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var ToolbarComponent = /** @class */ (function (_super) {
    __extends(ToolbarComponent, _super);
    function ToolbarComponent(x, y, w) {
        var _this = _super.call(this, null, x, y, w, 8, '', undefined) || this;
        _this.components = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List();
        ;
        return _this;
    }
    ToolbarComponent.prototype.draw = function (tg) {
        if (!this.components.Count) {
            return;
        }
        var brush = new _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_3__.SolidBrush(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(250));
        var pen = new _drawing_Pen__WEBPACK_IMPORTED_MODULE_4__.Pen(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(180), 1);
        tg.FillRectangle(brush, this.x, this.y, this.w, this.h, 8);
        tg.DrawRectangle(pen, this.x, this.y, this.w, this.h, 8);
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.foreach)(this.components, function (item) {
            item.draw(tg);
        });
    };
    ;
    ToolbarComponent.prototype.add = function (type, params) {
        params = params || {};
        var h = params.h || 20;
        var component = new type(this.x + 5, this.y + this.h, this.w - 10, h, params);
        this.components.Add(component);
        this.h += component.h + 8;
    };
    ToolbarComponent.prototype.addButton = function (evetService, name, trigger, height) {
        var component = new _ButtonComponent__WEBPACK_IMPORTED_MODULE_6__.ButtonComponent(evetService, this.x + 5, this.y + this.h, this.w - 10, height !== null && height !== void 0 ? height : 20, { name: name, trigger: trigger });
        this.components.Add(component);
        this.h += component.h + 8;
    };
    ToolbarComponent.prototype.addRadioButtons = function (options, trigger, defaultOption) {
        var x = this.x + 3;
        var y = this.y + this.h + 2;
        var w = this.w - 6;
        var radioButtons = [];
        var triggerFunction = function () {
            if (!this.marked) {
                this.marked = true;
                // Deselected other buttons
                for (var i_1 = 0; i_1 < radioButtons.length; i_1++) {
                    if (radioButtons[i_1] !== this) {
                        radioButtons[i_1].marked = false;
                    }
                }
            }
            if (trigger) {
                trigger(this.name);
            }
        };
        for (var i = 0; i < options.length; i++) {
            var button = new _RadioButtonComponent__WEBPACK_IMPORTED_MODULE_5__.RadioButtonComponent(x, y, w, 22, options[i], triggerFunction);
            radioButtons.push(button);
            y += 27;
            this.h += 27;
        }
        radioButtons[defaultOption || 0].trigger();
        this.components.AddRange(radioButtons);
        this.h += 2;
    };
    ;
    return ToolbarComponent;
}(_GUIComponent__WEBPACK_IMPORTED_MODULE_2__.GUIComponent));



/***/ }),

/***/ "./src/UI/index.ts":
/*!*************************!*\
  !*** ./src/UI/index.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ButtonComponent": () => (/* reexport safe */ _ButtonComponent__WEBPACK_IMPORTED_MODULE_0__.ButtonComponent),
/* harmony export */   "CheckboxComponent": () => (/* reexport safe */ _CheckboxComponent__WEBPACK_IMPORTED_MODULE_1__.CheckboxComponent),
/* harmony export */   "DraggablePoint": () => (/* reexport safe */ _DraggablePoint__WEBPACK_IMPORTED_MODULE_2__.DraggablePoint),
/* harmony export */   "GUIComponent": () => (/* reexport safe */ _GUIComponent__WEBPACK_IMPORTED_MODULE_3__.GUIComponent),
/* harmony export */   "ImageComponent": () => (/* reexport safe */ _ImageComponent__WEBPACK_IMPORTED_MODULE_4__.ImageComponent),
/* harmony export */   "LabelComponent": () => (/* reexport safe */ _LabelComponent__WEBPACK_IMPORTED_MODULE_5__.LabelComponent),
/* harmony export */   "RadioButtonComponent": () => (/* reexport safe */ _RadioButtonComponent__WEBPACK_IMPORTED_MODULE_6__.RadioButtonComponent),
/* harmony export */   "SliderComponent": () => (/* reexport safe */ _SliderComponent__WEBPACK_IMPORTED_MODULE_7__.SliderComponent),
/* harmony export */   "ToolbarComponent": () => (/* reexport safe */ _ToolbarComponent__WEBPACK_IMPORTED_MODULE_8__.ToolbarComponent)
/* harmony export */ });
/* harmony import */ var _ButtonComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ButtonComponent */ "./src/UI/ButtonComponent.ts");
/* harmony import */ var _CheckboxComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CheckboxComponent */ "./src/UI/CheckboxComponent.ts");
/* harmony import */ var _DraggablePoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DraggablePoint */ "./src/UI/DraggablePoint.ts");
/* harmony import */ var _GUIComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GUIComponent */ "./src/UI/GUIComponent.ts");
/* harmony import */ var _ImageComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ImageComponent */ "./src/UI/ImageComponent.ts");
/* harmony import */ var _LabelComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LabelComponent */ "./src/UI/LabelComponent.ts");
/* harmony import */ var _RadioButtonComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RadioButtonComponent */ "./src/UI/RadioButtonComponent.ts");
/* harmony import */ var _SliderComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SliderComponent */ "./src/UI/SliderComponent.ts");
/* harmony import */ var _ToolbarComponent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ToolbarComponent */ "./src/UI/ToolbarComponent.ts");











/***/ }),

/***/ "./src/Utilities/ColorThief.ts":
/*!*************************************!*\
  !*** ./src/Utilities/ColorThief.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorThief": () => (/* binding */ ColorThief)
/* harmony export */ });
/* harmony import */ var _Math_Quantize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Math/Quantize */ "./src/Math/Quantize.ts");

function createPixelArray(imgData, pixelCount, quality) {
    var pixels = imgData;
    var pixelArray = [];
    for (var i = 0, offset = void 0, r = void 0, g = void 0, b = void 0, a = void 0; i < pixelCount; i = i + quality) {
        offset = i * 4;
        r = pixels[offset + 0];
        g = pixels[offset + 1];
        b = pixels[offset + 2];
        a = pixels[offset + 3];
        // If pixel is mostly opaque and not white
        //if (typeof a === 'undefined' || a >= 125) {
        if (!(r > 250 && g > 250 && b > 250)) {
            pixelArray.push([r, g, b]);
        }
        //}
    }
    return pixelArray;
}
function validateOptions(options) {
    var colorCount = options.colorCount, quality = options.quality;
    if (typeof colorCount === 'undefined' || !Number.isInteger(colorCount)) {
        colorCount = 10;
    }
    else if (colorCount === 1) {
        throw new Error('colorCount should be between 2 and 20. To get one color, call getColor() instead of getPalette()');
    }
    else {
        colorCount = Math.max(colorCount, 2);
        colorCount = Math.min(colorCount, 20);
    }
    if (typeof quality === 'undefined' || !Number.isInteger(quality) || quality < 1) {
        quality = 10;
    }
    return {
        colorCount: colorCount,
        quality: quality
    };
}
/*
  CanvasImage Class
  Class that wraps the html image element and canvas.
  It also simplifies some of the canvas context manipulation
  with a set of helper functions.
*/
var CanvasImage = function (image) {
    this.canvas = document.createElement('canvas');
    this.context = this.canvas.getContext('2d');
    this.width = this.canvas.width = image.naturalWidth;
    this.height = this.canvas.height = image.naturalHeight;
    this.context.drawImage(image, 0, 0, this.width, this.height);
};
CanvasImage.prototype.getImageData = function () {
    return this.context.getImageData(0, 0, this.width, this.height);
};
var ColorThief = /** @class */ (function () {
    function ColorThief() {
    }
    /*
     * getColor(sourceImage[, quality])
     * returns {r: num, g: num, b: num}
     *
     * Use the median cut algorithm provided by quantize.js to cluster similar
     * colors and return the base color from the largest cluster.
     *
     * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.
     * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the
     * faster a color will be returned but the greater the likelihood that it will not be the visually
     * most dominant color.
     *
     * */
    ColorThief.prototype.GetColor = function (sourceImage, quality) {
        if (quality === void 0) { quality = 10; }
        var palette = this.GetPalette(sourceImage, 5, quality);
        var dominantColor = palette[0];
        return dominantColor;
    };
    ColorThief.prototype.GetPalette = function (sourceImage, colorCount, quality) {
        var options = validateOptions({
            colorCount: colorCount,
            quality: quality
        });
        // Create custom CanvasImage object
        //const image      = new CanvasImage(sourceImage);
        sourceImage.loadPixels();
        var imageData = sourceImage.Pixels;
        var pixelCount = sourceImage.Width * sourceImage.Height;
        var pixelArray = createPixelArray(imageData, pixelCount, options.quality);
        // Send array to quantize function which clusters values
        // using median cut algorithm
        var cmap = (0,_Math_Quantize__WEBPACK_IMPORTED_MODULE_0__.quantize)(pixelArray, options.colorCount);
        var palette = cmap ? cmap.palette() : null;
        return palette;
    };
    ColorThief.prototype.GetColorFromUrl = function (imageUrl, callback, quality) {
        var _this = this;
        var sourceImage = document.createElement("img");
        sourceImage.addEventListener('load', function () {
            var palette = _this.GetPalette(sourceImage, 5, quality);
            var dominantColor = palette[0];
            callback(dominantColor, imageUrl);
        });
        sourceImage.src = imageUrl;
    };
    ColorThief.prototype.GetImageData = function (imageUrl, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', imageUrl, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function () {
            if (this.status == 200) {
                var uInt8Array = new Uint8Array(this.response);
                var i = uInt8Array.length;
                var binaryString = new Array(i);
                for (var i_1 = 0; i_1 < uInt8Array.length; i_1++) {
                    binaryString[i_1] = String.fromCharCode(uInt8Array[i_1]);
                }
                var data = binaryString.join('');
                var base64 = window.btoa(data);
                callback('data:image/png;base64,' + base64);
            }
        };
        xhr.send();
    };
    ;
    ColorThief.prototype.GetColorAsync = function (imageUrl, callback, quality) {
        var thief = this;
        this.GetImageData(imageUrl, function (imageData) {
            var sourceImage = document.createElement("img");
            sourceImage.addEventListener('load', function () {
                var palette = thief.GetPalette(sourceImage, 5, quality);
                var dominantColor = palette[0];
                callback(dominantColor, this);
            });
            sourceImage.src = imageData;
        });
    };
    return ColorThief;
}());

/*
 * getPalette(sourceImage[, colorCount, quality])
 * returns array[ {r: num, g: num, b: num}, {r: num, g: num, b: num}, ...]
 *
 * Use the median cut algorithm provided by quantize.js to cluster similar colors.
 *
 * colorCount determines the size of the palette; the number of colors returned. If not set, it
 * defaults to 10.
 *
 * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.
 * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the
 * faster the palette generation but the greater the likelihood that colors will be missed.
 *
 *
 */
/* ColorThief.prototype.getPalette = function(sourceImage, colorCount, quality) {
    const options = validateOptions({
        colorCount,
        quality
    });

    // Create custom CanvasImage object
    const image      = new CanvasImage(sourceImage);
    const imageData  = image.getImageData();
    const pixelCount = image.width * image.height;

    const pixelArray = createPixelArray(imageData.data, pixelCount, options.quality);

    // Send array to quantize function which clusters values
    // using median cut algorithm
    const cmap    = quantize(pixelArray, options.colorCount);
    const palette = cmap? cmap.palette() : null;

    return palette;
}; */


/***/ }),

/***/ "./src/drawing/Bitmap.ts":
/*!*******************************!*\
  !*** ./src/drawing/Bitmap.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bitmap": () => (/* binding */ Bitmap)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Graphics */ "./src/drawing/Graphics.ts");
/* harmony import */ var _Image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Image */ "./src/drawing/Image.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./imaging/PixelFormat */ "./src/drawing/imaging/PixelFormat.ts");
/* harmony import */ var _GDIPlus__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GDIPlus */ "./src/drawing/GDIPlus.ts");
/* harmony import */ var _gdipEnums__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./gdipEnums */ "./src/drawing/gdipEnums.ts");
/* harmony import */ var _imaging_BitmapData__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./imaging/BitmapData */ "./src/drawing/imaging/BitmapData.ts");
/* harmony import */ var _imaging_ImageAttributes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./imaging/ImageAttributes */ "./src/drawing/imaging/ImageAttributes.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();










/*
export class Bitmap extends DisposableBase {

    private canvasElement: HTMLCanvasElement;
    public context: CanvasRenderingContext2D;
    private myWidth: float = 0;
    private myHeight: float = 0;
    public Graphics: SketchGraphics = undefined as any;

    public get Width(): float {
        return this.myWidth;
    }
    public set Width(value: float) {
        this.myWidth = value;
    }

    public get Height(): float {
        return this.myHeight;
    }
    public set Height(value: float) {
        this.myHeight = value;
    }

    public constructor(width: number, height: number, graphics?: Graphics) {
        super();
        this.canvasElement = createCanvasElement();
        this.canvasElement.width = width;
        this.canvasElement.height = height;
        this.context = this.canvasElement.getContext('2d') as any;
        this.Graphics = new SketchGraphics(this.context);
    }

    public resize(newSize: CGSize) {
        this.canvasElement.width = newSize.Width;
        this.canvasElement.height = newSize.Height;
    }
} */
var Bitmap = /** @class */ (function (_super) {
    __extends(Bitmap, _super);
    function Bitmap() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _tuval_core__WEBPACK_IMPORTED_MODULE_1__.System.Types.IntPtr)) {
            var ptr = args[0];
            _this.constructor2(ptr);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _tuval_core__WEBPACK_IMPORTED_MODULE_1__.System.Types.IntPtr) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _tuval_core__WEBPACK_IMPORTED_MODULE_1__.System.Types.IO.Stream)) {
            var ptr = args[0];
            var stream = args[1];
            _this.constructor3(ptr, stream);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.int(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.int(args[1])) {
            var width = args[0];
            var height = args[1];
            _this.constructor4(width, height);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.int(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.int(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.Graphics)) {
            var width = args[0];
            var height = args[1];
            var g = args[2];
            _this.constructor5(width, height, g);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.int(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.int(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.int(args[2])) {
            var width = args[0];
            var height = args[1];
            var format = args[2];
            _this.constructor6(width, height, format);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.Image)) {
            var original = args[0];
            _this.constructor7(args[0]);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _tuval_core__WEBPACK_IMPORTED_MODULE_1__.System.Types.IO.Stream)) {
            var stream = args[0];
            _this.constructor8(stream);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.string(args[0])) {
            var filename = args[0];
            _this.constructor9(filename);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.Image) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CoreGraphicTypes.CGSize)) {
            var original = args[0];
            var newSize = args[1];
            _this.constructor10(original, newSize);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _tuval_core__WEBPACK_IMPORTED_MODULE_1__.System.Types.IO.Stream) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.boolean(args[1])) {
            var stream = args[0];
            var useIcm = args[1];
            _this.constructor11(stream, useIcm);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.string(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.boolean(args[1])) {
            var filename = args[0];
            var useIcm = args[1];
            _this.constructor12(filename, useIcm);
        }
        else if (args.length === 2 && args[0] instanceof _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Type && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.string(args[1])) {
            var type = args[0];
            var resource = args[1];
            _this.constructor13(type, resource);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.Image) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.int(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.int(args[2])) {
            var original = args[0];
            var width = args[1];
            var height = args[2];
            _this.constructor14(original, width, height);
        }
        return _this;
    }
    // required for XmlSerializer (#323246)
    Bitmap.prototype.constructor1 = function () {
    };
    Bitmap.prototype.constructor2 = function (ptr) {
        this.nativeObject = ptr;
    };
    // Usually called when cloning images that need to have
    // not only the handle saved, but also the underlying stream
    // (when using MS GDI+ and IStream we must ensure the stream stays alive for all the life of the Image)
    Bitmap.prototype.constructor3 = function (ptr, stream) {
        // under Win32 stream is owned by SD/GDI+ code
        if (_GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.RunningOnWindows())
            this.stream = stream;
        this.nativeObject = ptr;
    };
    Bitmap.prototype.constructor4 = function (width, height) {
        this.constructor6(width, height, _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_5__.PixelFormat.Format32bppArgb);
    };
    Bitmap.prototype.constructor5 = function (width, height, g) {
        if (g == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException("g");
        var bmp = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Out();
        var s = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipCreateBitmapFromGraphics(width, height, g.nativeObject, bmp);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(s);
        this.nativeObject = bmp.value;
    };
    Bitmap.prototype.constructor6 = function (width, height, format) {
        var bmp = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Out();
        var s = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipCreateBitmapFromScan0(width, height, 0, format, _tuval_core__WEBPACK_IMPORTED_MODULE_1__.IntPtr.Zero, bmp);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(s);
        this.nativeObject = bmp.value;
    };
    Bitmap.prototype.constructor7 = function (original) {
        this.constructor14(original, original.Width, original.Height);
    };
    Bitmap.prototype.constructor8 = function (stream) {
        this.constructor11(stream, false);
    };
    Bitmap.prototype.constructor9 = function (filename) {
        this.constructor12(filename, false);
    };
    Bitmap.prototype.constructor10 = function (original, newSize) {
        this.constructor14(original, newSize.Width, newSize.Height);
    };
    Bitmap.prototype.constructor11 = function (stream, useIcm) {
        // false: stream is owned by user code
        this.nativeObject = Bitmap.InitFromStream(stream);
    };
    Bitmap.prototype.constructor12 = function (filename, useIcm) {
        if (filename == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException("filename");
        var imagePtr = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Out();
        var st;
        if (useIcm)
            st = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipCreateBitmapFromFileICM(filename, imagePtr);
        else
            st = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipCreateBitmapFromFile(filename, imagePtr);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(st);
        this.nativeObject = imagePtr.value;
    };
    Bitmap.prototype.constructor13 = function (type, resource) {
        if (resource == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentException("resource");
        var s = type.Assembly.GetManifestResourceStream(type, resource);
        if (s == null) {
            var msg = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Locale.GetText("Resource '{0}' was not found.", resource);
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.FileNotFoundException(msg);
        }
        this.nativeObject = Bitmap.InitFromStream(s);
        // under Win32 stream is owned by SD/GDI+ code
        if (_GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.RunningOnWindows())
            this.stream = s;
    };
    Bitmap.prototype.constructor14 = function (original, width, height) {
        this.constructor6(width, height, _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_5__.PixelFormat.Format32bppArgb);
        var graphics = _Graphics__WEBPACK_IMPORTED_MODULE_2__.Graphics.FromImage(this);
        graphics.DrawImage(original, 0, 0, width, height);
        graphics.Dispose();
    };
    Bitmap.prototype.constructor15 = function (width, height, stride, format, scan0) {
        var bmp = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Out();
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipCreateBitmapFromScan0(width, height, stride, format, scan0, bmp);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(status);
        this.nativeObject = bmp.value;
    };
    // methods
    Bitmap.prototype.GetPixel = function (x, y) {
        var argb = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Out(0);
        var s = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipBitmapGetPixel(this.nativeObject, x, y, argb);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(s);
        return _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromRgba(argb.value);
    };
    Bitmap.prototype.SetPixel = function (x, y, color) {
        var s = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipBitmapSetPixel(this.nativeObject, x, y, color.toInt());
        if (s === _gdipEnums__WEBPACK_IMPORTED_MODULE_7__.Status.InvalidParameter) {
            // check is done in case of an error only to avoid another
            // unmanaged call for normal (successful) calls
            if ((this.PixelFormat & _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_5__.PixelFormat.Indexed) != 0) {
                var msg = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Locale.GetText("SetPixel cannot be called on indexed bitmaps.");
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.InvalidOperationException(msg);
            }
        }
        _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(s);
    };
    Bitmap.prototype.Clone = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 0) {
            return _super.prototype.Clone.call(this);
        }
        else if (args.length === 2) {
            var rect = args[0];
            var format = args[1];
            var bmp = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Out();
            var status_1 = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipCloneBitmapArea(rect.X, rect.Y, rect.Width, rect.Height, format, this.nativeObject, bmp);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(status_1);
            return new Bitmap(bmp.value);
        }
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentOutOfRangeException('');
    };
    Bitmap.FromHicon = function (hicon) {
        var bitmap = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Out();
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipCreateBitmapFromHICON(hicon, bitmap);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(status);
        return new Bitmap(bitmap.value);
    };
    Bitmap.FromResource = function (hinstance, bitmapName) {
        var bitmap = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Out();
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipCreateBitmapFromResource(hinstance, bitmapName, bitmap);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(status);
        return new Bitmap(bitmap.value);
    };
    Bitmap.prototype.GetHbitmap = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 0) {
            return this.GetHbitmap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Gray);
        }
        else if (args.length === 1) {
            var background = args[0];
            var HandleBmp = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Out();
            var status_2 = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipCreateHBITMAPFromBitmap(this.nativeObject, HandleBmp, background.toInt());
            _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(status_2);
            return HandleBmp.value;
        }
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentOutOfRangeException('');
    };
    Bitmap.prototype.GetHicon = function () {
        var HandleIcon = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Out();
        ;
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipCreateHICONFromBitmap(this.nativeObject, HandleIcon);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(status);
        return HandleIcon.value;
    };
    Bitmap.prototype.LockBits = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 3) {
            var rect = args[0];
            var flags = args[1];
            var format = args[2];
            var result = new _imaging_BitmapData__WEBPACK_IMPORTED_MODULE_8__.BitmapData();
            return this.LockBits(rect, flags, format, result);
        }
        else if (args.length === 4) {
            var rect = args[0];
            var flags = args[1];
            var format = args[2];
            var bitmapData = args[3];
            var _rect = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Out(rect);
            var status_3 = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipBitmapLockBits(this.nativeObject, _rect, flags, format, bitmapData);
            rect = _rect.value;
            //NOTE: scan0 points to piece of memory allocated in the unmanaged space
            _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(status_3);
            return bitmapData;
        }
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentOutOfRangeException('');
    };
    Bitmap.prototype.MakeTransparent = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 0) {
            var clr = this.GetPixel(0, 0);
            this.MakeTransparent(clr);
        }
        else if (args.length === 1) {
            var transparentColor = args[0];
            // We have to draw always over a 32-bitmap surface that supports alpha channel
            var bmp = new Bitmap(this.Width, this.Height, _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_5__.PixelFormat.Format32bppArgb);
            var gr = _Graphics__WEBPACK_IMPORTED_MODULE_2__.Graphics.FromImage(bmp);
            var destRect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, this.Width, this.Height);
            var imageAttr = new _imaging_ImageAttributes__WEBPACK_IMPORTED_MODULE_9__.ImageAttributes();
            imageAttr.SetColorKey(transparentColor, transparentColor);
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Exception('');
            //gr.DrawImage(this, destRect, 0, 0, this.Width, this.Height, GraphicsUnit.Pixel, imageAttr);
            var oldBmp = this.nativeObject;
            this.nativeObject = bmp.nativeObject;
            bmp.nativeObject = oldBmp;
            gr.Dispose();
            bmp.Dispose();
            imageAttr.Dispose();
        }
    };
    Bitmap.prototype.SetResolution = function (xDpi, yDpi) {
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipBitmapSetResolution(this.nativeObject, xDpi, yDpi);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(status);
    };
    Bitmap.prototype.UnlockBits = function (bitmapdata) {
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.GdipBitmapUnlockBits(this.nativeObject, bitmapdata);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_6__.GDIPlus.CheckStatus(status);
    };
    return Bitmap;
}(_Image__WEBPACK_IMPORTED_MODULE_3__.Image));



/***/ }),

/***/ "./src/drawing/Brush.ts":
/*!******************************!*\
  !*** ./src/drawing/Brush.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Brush": () => (/* binding */ Brush)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _Shadow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Shadow */ "./src/drawing/Shadow.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




var Brush = /** @class */ (function () {
    function Brush() {
        this.changed = true;
        this.Shadow = _Shadow__WEBPACK_IMPORTED_MODULE_3__.Shadow.identity.clone();
    }
    Brush.prototype.Dispose = function (disposing) {
    };
    Brush.prototype.Clone = function () { throw new Error('You must implement clone method of brush.'); };
    Brush.prototype.setup = function (graphics, fill) {
        graphics.renderer.setShadowWithColor(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize(this.Shadow.offsetX, this.Shadow.offsetY), this.Shadow.blur, this.Shadow.color);
    };
    Brush = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_2__.GraphicTypes.Brush,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_2__.GraphicTypes.Brush
            ]
        })
    ], Brush);
    return Brush;
}());



/***/ }),

/***/ "./src/drawing/Brushes.ts":
/*!********************************!*\
  !*** ./src/drawing/Brushes.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Brushes": () => (/* binding */ Brushes)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _SolidBrush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SolidBrush */ "./src/drawing/SolidBrush.ts");


var Brushes = /** @class */ (function () {
    function Brushes() {
    }
    Brushes.Transparent = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Transparent);
    Brushes.AliceBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.AliceBlue);
    Brushes.AntiqueWhite = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.AntiqueWhite);
    Brushes.Aqua = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Aqua);
    Brushes.Aquamarine = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Aquamarine);
    Brushes.Azure = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Azure);
    Brushes.Beige = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Beige);
    Brushes.Bisque = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Bisque);
    Brushes.Black = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Black);
    Brushes.BlanchedAlmond = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.BlanchedAlmond);
    Brushes.Blue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Blue);
    Brushes.BlueViolet = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.BlueViolet);
    Brushes.Brown = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Brown);
    Brushes.BurlyWood = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.BurlyWood);
    Brushes.CadetBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.CadetBlue);
    Brushes.Chartreuse = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Chartreuse);
    Brushes.Chocolate = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Chocolate);
    Brushes.Coral = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Coral);
    Brushes.CornflowerBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.CornflowerBlue);
    Brushes.Cornsilk = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Cornsilk);
    Brushes.Crimson = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Crimson);
    Brushes.Cyan = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Cyan);
    Brushes.DarkBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkBlue);
    Brushes.DarkCyan = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkCyan);
    Brushes.DarkGoldenrod = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkGoldenrod);
    Brushes.DarkGray = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkGray);
    Brushes.DarkGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkGreen);
    Brushes.DarkKhaki = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkKhaki);
    Brushes.DarkMagenta = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkMagenta);
    Brushes.DarkOliveGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkOliveGreen);
    Brushes.DarkOrange = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkOrange);
    Brushes.DarkOrchid = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkOrchid);
    Brushes.DarkRed = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkRed);
    Brushes.DarkSalmon = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkSalmon);
    Brushes.DarkSeaGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkSeaGreen);
    Brushes.DarkSlateBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkSlateBlue);
    Brushes.DarkSlateGray = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkSlateGray);
    Brushes.DarkTurquoise = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkTurquoise);
    Brushes.DarkViolet = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkViolet);
    Brushes.DeepPink = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DeepPink);
    Brushes.DeepSkyBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DeepSkyBlue);
    Brushes.DimGray = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DimGray);
    Brushes.DodgerBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DodgerBlue);
    Brushes.Firebrick = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Firebrick);
    Brushes.FloralWhite = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FloralWhite);
    Brushes.ForestGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.ForestGreen);
    Brushes.Fuchsia = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Fuchsia);
    Brushes.Gainsboro = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Gainsboro);
    Brushes.GhostWhite = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.GhostWhite);
    Brushes.Gold = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Gold);
    Brushes.Goldenrod = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Goldenrod);
    Brushes.Gray = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Gray);
    Brushes.Green = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Green);
    Brushes.GreenYellow = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.GreenYellow);
    Brushes.Honeydew = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Honeydew);
    Brushes.HotPink = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.HotPink);
    Brushes.IndianRed = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.IndianRed);
    Brushes.Indigo = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Indigo);
    Brushes.Ivory = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Ivory);
    Brushes.Khaki = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Khaki);
    Brushes.Lavender = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Lavender);
    Brushes.LavenderBlush = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LavenderBlush);
    Brushes.LawnGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LawnGreen);
    Brushes.LemonChiffon = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LemonChiffon);
    Brushes.LightBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightBlue);
    Brushes.LightCoral = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightCoral);
    Brushes.LightCyan = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightCyan);
    Brushes.LightGoldenrodYellow = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightGoldenrodYellow);
    Brushes.LightGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightGreen);
    Brushes.LightGray = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightGray);
    Brushes.LightPink = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightPink);
    Brushes.LightSalmon = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightSalmon);
    Brushes.LightSeaGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightSeaGreen);
    Brushes.LightSkyBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightSkyBlue);
    Brushes.LightSlateGray = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightSlateGray);
    Brushes.LightSteelBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightSteelBlue);
    Brushes.LightYellow = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightYellow);
    Brushes.Lime = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Lime);
    Brushes.LimeGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LimeGreen);
    Brushes.Linen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Linen);
    Brushes.Magenta = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Magenta);
    Brushes.Maroon = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Maroon);
    Brushes.MediumAquamarine = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumAquamarine);
    Brushes.MediumBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumBlue);
    Brushes.MediumOrchid = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumOrchid);
    Brushes.MediumPurple = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumPurple);
    Brushes.MediumSeaGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumSeaGreen);
    Brushes.MediumSlateBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumSlateBlue);
    Brushes.MediumSpringGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumSpringGreen);
    Brushes.MediumTurquoise = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumTurquoise);
    Brushes.MediumVioletRed = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumVioletRed);
    Brushes.MidnightBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MidnightBlue);
    Brushes.MintCream = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MintCream);
    Brushes.MistyRose = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MistyRose);
    Brushes.Moccasin = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Moccasin);
    Brushes.NavajoWhite = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.NavajoWhite);
    Brushes.Navy = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Navy);
    Brushes.OldLace = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.OldLace);
    Brushes.Olive = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Olive);
    Brushes.OliveDrab = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.OliveDrab);
    Brushes.Orange = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Orange);
    Brushes.OrangeRed = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.OrangeRed);
    Brushes.Orchid = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Orchid);
    Brushes.PaleGoldenrod = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PaleGoldenrod);
    Brushes.PaleGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PaleGreen);
    Brushes.PaleTurquoise = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PaleTurquoise);
    Brushes.PaleVioletRed = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PaleVioletRed);
    Brushes.PapayaWhip = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PapayaWhip);
    Brushes.PeachPuff = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PeachPuff);
    Brushes.Peru = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Peru);
    Brushes.Pink = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Pink);
    Brushes.Plum = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Plum);
    Brushes.PowderBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PowderBlue);
    Brushes.Purple = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Purple);
    Brushes.Red = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Red);
    Brushes.RosyBrown = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.RosyBrown);
    Brushes.RoyalBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.RoyalBlue);
    Brushes.SaddleBrown = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SaddleBrown);
    Brushes.Salmon = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Salmon);
    Brushes.SandyBrown = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SandyBrown);
    Brushes.SeaGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SeaGreen);
    Brushes.SeaShell = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SeaShell);
    Brushes.Sienna = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Sienna);
    Brushes.Silver = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Silver);
    Brushes.SkyBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SkyBlue);
    Brushes.SlateBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SlateBlue);
    Brushes.SlateGray = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SlateGray);
    Brushes.Snow = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Snow);
    Brushes.SpringGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SpringGreen);
    Brushes.SteelBlue = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SteelBlue);
    Brushes.Tan = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Tan);
    Brushes.Teal = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Teal);
    Brushes.Thistle = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Thistle);
    Brushes.Tomato = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Tomato);
    Brushes.Turquoise = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Turquoise);
    Brushes.Violet = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Violet);
    Brushes.Wheat = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Wheat);
    Brushes.White = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.White);
    Brushes.WhiteSmoke = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.WhiteSmoke);
    Brushes.Yellow = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Yellow);
    Brushes.YellowGreen = new _SolidBrush__WEBPACK_IMPORTED_MODULE_1__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.YellowGreen);
    return Brushes;
}());



/***/ }),

/***/ "./src/drawing/Clipper.ts":
/*!********************************!*\
  !*** ./src/drawing/Clipper.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ClipType": () => (/* binding */ ClipType),
/* harmony export */   "PolyType": () => (/* binding */ PolyType),
/* harmony export */   "JoinType": () => (/* binding */ JoinType),
/* harmony export */   "PolyFillType": () => (/* binding */ PolyFillType),
/* harmony export */   "EndType": () => (/* binding */ EndType),
/* harmony export */   "ClipPoint": () => (/* binding */ ClipPoint),
/* harmony export */   "ClipRect": () => (/* binding */ ClipRect),
/* harmony export */   "PolyNode": () => (/* binding */ PolyNode),
/* harmony export */   "PolyTree": () => (/* binding */ PolyTree),
/* harmony export */   "Clipper": () => (/* binding */ Clipper),
/* harmony export */   "ClipperOffset": () => (/* binding */ ClipperOffset)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var Horizontal = -3.4E+38;
var Skip = -2;
var Unassigned = -1;
var Tolerance = 1.0E-20;
var ioReverseSolution = 1;
var ioStrictlySimple = 2;
var ioPreserveCollinear = 4;
var TwoPI = Math.PI * 2;
var DefArcTolerance = 0.25;
function fltEquals(a, b) {
    return Math.abs(a - b) < Tolerance;
}
var ClipType;
(function (ClipType) {
    ClipType[ClipType["ctIntersection"] = 0] = "ctIntersection";
    ClipType[ClipType["ctUnion"] = 1] = "ctUnion";
    ClipType[ClipType["ctDifference"] = 2] = "ctDifference";
    ClipType[ClipType["ctXor"] = 3] = "ctXor";
})(ClipType || (ClipType = {}));
var PolyType;
(function (PolyType) {
    PolyType[PolyType["ptSubject"] = 0] = "ptSubject";
    PolyType[PolyType["ptClip"] = 1] = "ptClip";
})(PolyType || (PolyType = {}));
var JoinType;
(function (JoinType) {
    JoinType[JoinType["jtSquare"] = 0] = "jtSquare";
    JoinType[JoinType["jtRound"] = 1] = "jtRound";
    JoinType[JoinType["jtMiter"] = 2] = "jtMiter";
})(JoinType || (JoinType = {}));
//By far the most widely used winding rules for polygon filling are
//EvenOdd & NonZero (GDI, GDI+, XLib, OpenGL, Cairo, AGG, Quartz, SVG, Gr32)
//Others rules include Positive, Negative and ABS_GTR_EQ_TWO (only in OpenGL)
//see http://glprogramming.com/red/chapter11.html
var PolyFillType;
(function (PolyFillType) {
    PolyFillType[PolyFillType["pftEvenOdd"] = 0] = "pftEvenOdd";
    PolyFillType[PolyFillType["pftNonZero"] = 1] = "pftNonZero";
    PolyFillType[PolyFillType["pftPositive"] = 2] = "pftPositive";
    PolyFillType[PolyFillType["pftNegative"] = 3] = "pftNegative";
})(PolyFillType || (PolyFillType = {}));
var EndType;
(function (EndType) {
    EndType[EndType["etClosedPolygon"] = 0] = "etClosedPolygon";
    EndType[EndType["etClosedLine"] = 1] = "etClosedLine";
    EndType[EndType["etOpenButt"] = 2] = "etOpenButt";
    EndType[EndType["etOpenSquare"] = 3] = "etOpenSquare";
    EndType[EndType["etOpenRound"] = 4] = "etOpenRound";
})(EndType || (EndType = {}));
var EdgeSide;
(function (EdgeSide) {
    EdgeSide[EdgeSide["esLeft"] = 0] = "esLeft";
    EdgeSide[EdgeSide["esRight"] = 1] = "esRight";
})(EdgeSide || (EdgeSide = {}));
var Direction;
(function (Direction) {
    Direction[Direction["dRightToLeft"] = 0] = "dRightToLeft";
    Direction[Direction["dLeftToRight"] = 1] = "dLeftToRight";
})(Direction || (Direction = {}));
var NodeType;
(function (NodeType) {
    NodeType[NodeType["ntAny"] = 0] = "ntAny";
    NodeType[NodeType["ntOpen"] = 1] = "ntOpen";
    NodeType[NodeType["ntClosed"] = 2] = "ntClosed";
})(NodeType || (NodeType = {}));
var ClipPoint = /** @class */ (function () {
    function ClipPoint(x, y) {
        this.x = x;
        this.y = y;
    }
    ClipPoint.prototype.equals = function (other) {
        return fltEquals(this.x, other.x)
            && fltEquals(this.y, other.y);
    };
    ClipPoint.prototype.notEquals = function (other) {
        return !fltEquals(this.x, other.x)
            || !fltEquals(this.y, other.y);
    };
    ClipPoint.copy = function (other) {
        return new ClipPoint(other.x, other.y);
    };
    return ClipPoint;
}());

var ClipRect = /** @class */ (function () {
    function ClipRect(left, top, right, bottom) {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
    }
    ClipRect.copy = function (other) {
        return new ClipRect(other.left, other.top, other.right, other.bottom);
    };
    return ClipRect;
}());

var PolyNode = /** @class */ (function () {
    function PolyNode() {
        this.parent = null;
        this.polygon = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
        this.index = 0;
        this.joinType = undefined;
        this.endType = undefined;
        this.children = new Array();
        this.isOpen = false;
    }
    Object.defineProperty(PolyNode.prototype, "isHole", {
        get: function () {
            var result = true;
            var node = this.parent;
            while (node != null) {
                result = !result;
                node = node.parent;
            }
            return result;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PolyNode.prototype, "childCount", {
        get: function () {
            return this.children.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PolyNode.prototype, "contour", {
        get: function () {
            return this.polygon;
        },
        enumerable: false,
        configurable: true
    });
    PolyNode.prototype.addChild = function (child) {
        child.parent = this;
        child.index = this.children.length;
        this.children.push(child);
    };
    Object.defineProperty(PolyNode.prototype, "next", {
        get: function () {
            if (this.children.length > 0) {
                return this.children[0];
            }
            return this.nextSiblingUp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PolyNode.prototype, "nextSiblingUp", {
        get: function () {
            if (this.parent == null) {
                return null;
            }
            if (this.index == this.parent.children.length - 1) {
                return this.parent.nextSiblingUp;
            }
            return this.parent.children[this.index + 1];
        },
        enumerable: false,
        configurable: true
    });
    return PolyNode;
}());

var PolyTree = /** @class */ (function (_super) {
    __extends(PolyTree, _super);
    function PolyTree() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allPolys = new Array();
        return _this;
    }
    PolyTree.prototype.clear = function () {
        this.allPolys.length = 0;
        this.children.length = 0;
    };
    Object.defineProperty(PolyTree.prototype, "first", {
        get: function () {
            if (this.children.length > 0) {
                return this.children[0];
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PolyTree.prototype, "total", {
        get: function () {
            var result = this.allPolys.length;
            //with negative offsets, ignore the hidden outer polygon ...
            if (result > 0 && this.children[0] != this.allPolys[0]) {
                result--;
            }
            return result;
        },
        enumerable: false,
        configurable: true
    });
    return PolyTree;
}(PolyNode));

var TEdge = /** @class */ (function () {
    function TEdge() {
        this.bot = undefined;
        this.curr = undefined;
        this.top = undefined;
        this.delta = undefined;
        this.dx = 0;
        this.polyTyp = undefined;
        this.side = undefined; //side only refers to current side of solution poly
        this.windDelta = 0; //1 or -1 depending on winding direction
        this.windCnt = 0;
        this.windCnt2 = 0; //winding count of the opposite polytype
        this.outIdx = 0;
        this.next = null;
        this.prev = null;
        this.nextInLML = null;
        this.nextInAEL = null;
        this.prevInAEL = null;
        this.nextInSEL = null;
        this.prevInSEL = null;
    }
    ; //current (updated for every new scanbeam)
    ;
    ;
    return TEdge;
}());
var IntersectNode = /** @class */ (function () {
    function IntersectNode(edge1, edge2, pt) {
        this.edge1 = edge1;
        this.edge2 = edge2;
        this.pt = pt;
    }
    return IntersectNode;
}());
var LocalMinima = /** @class */ (function () {
    function LocalMinima(y, leftBound, rightBound) {
        this.y = y;
        this.leftBound = leftBound;
        this.rightBound = rightBound;
        this.next = null;
    }
    LocalMinima.prototype.clearLeftBound = function () {
        this.leftBound = null;
    };
    LocalMinima.prototype.clearRightBound = function () {
        this.rightBound = null;
    };
    return LocalMinima;
}());
var Scanbeam = /** @class */ (function () {
    function Scanbeam(y) {
        this.y = y;
        this.next = null;
    }
    return Scanbeam;
}());
var Maxima = /** @class */ (function () {
    function Maxima(x) {
        this.x = x;
        this.next = null;
        this.prev = null;
        this.next = null;
        this.prev = null;
    }
    return Maxima;
}());
var OutPt = /** @class */ (function () {
    function OutPt() {
        this.idx = 0;
        this.pt = undefined;
        this.next = null;
        this.prev = null;
    }
    return OutPt;
}());
//OutRec: contains a path in the clipping solution. Edges in the AEL will
//carry a pointer to an OutRec when they are part of the clipping solution.
var OutRec = /** @class */ (function () {
    function OutRec() {
        this.idx = Unassigned;
        this.isHole = false;
        this.isOpen = false;
        this.firstLeft = null;
        this.pts = null;
        this.bottomPt = null;
        this.polyNode = null;
    }
    return OutRec;
}());
var Join = /** @class */ (function () {
    function Join(outPt1, outPt2, offPt) {
        this.outPt1 = outPt1;
        this.outPt2 = outPt2;
        this.offPt = offPt;
    }
    return Join;
}());
function MyIntersectNodeSort(node1, node2) {
    return node2.pt.y - node1.pt.y;
}
function NearZero(val) {
    return Math.abs(val) < Tolerance;
}
function IsHorizontal(e) {
    return NearZero(e.delta.y);
}
function PointIsVertex(pt, pp) {
    var pp2 = pp;
    do {
        if (pp2.pt.equals(pt)) {
            return true;
        }
        pp2 = pp2.next;
    } while (pp2 != pp);
    return false;
}
function PointOnLineSegment(pt, linePt1, linePt2) {
    return (fltEquals(pt.x, linePt1.x) && fltEquals(pt.y, linePt1.y))
        || (fltEquals(pt.x, linePt2.x) && fltEquals(pt.y, linePt2.y))
        || ((pt.x > linePt1.x) == (pt.x < linePt2.x)
            && (pt.y > linePt1.y) == (pt.y < linePt2.y)
            && fltEquals((pt.x - linePt1.x) * (linePt2.y - linePt1.y), (linePt2.x - linePt1.x) * (pt.y - linePt1.y)));
}
function PointOnPolygon(pt, pp) {
    var pp2 = pp;
    do {
        if (PointOnLineSegment(pt, pp2.pt, pp2.next.pt)) {
            return true;
        }
        pp2 = pp2.next;
    } while (pp2 != pp);
    return false;
}
function SlopesEqual2E(e1, e2) {
    return fltEquals(e1.delta.y * e2.delta.x, e1.delta.x * e2.delta.y);
}
function SlopesEqual3P(pt1, pt2, pt3) {
    return fltEquals((pt1.y - pt2.y) * (pt2.x - pt3.x), (pt1.x - pt2.x) * (pt2.y - pt3.y));
}
function SlopesEqual4P(pt1, pt2, pt3, pt4) {
    return fltEquals((pt1.y - pt2.y) * (pt3.x - pt4.x), (pt1.x - pt2.x) * (pt3.y - pt4.y));
}
function SetDx(e) {
    var dx = e.top.x - e.bot.x;
    var dy = e.top.y - e.bot.y;
    e.delta = new ClipPoint(dx, dy);
    if (NearZero(dy)) {
        e.dx = Horizontal;
    }
    else {
        e.dx = e.delta.x / e.delta.y;
    }
}
function InitEdge(e, eNext, ePrev, pt) {
    e.next = eNext;
    e.prev = ePrev;
    e.curr = new ClipPoint(pt.x, pt.y);
    e.outIdx = Unassigned;
}
function InitEdge2(e, polyType) {
    if (e.curr.y >= e.next.curr.y) {
        e.bot = new ClipPoint(e.curr.x, e.curr.y);
        e.top = new ClipPoint(e.next.curr.x, e.next.curr.y);
    }
    else {
        e.top = new ClipPoint(e.curr.x, e.curr.y);
        e.bot = new ClipPoint(e.next.curr.x, e.next.curr.y);
    }
    SetDx(e);
    e.polyTyp = polyType;
}
function FindNextLocMin(e) {
    var e2;
    for (;;) {
        while (e.bot.notEquals(e.prev.bot) || e.curr.equals(e.top)) {
            e = e.next;
        }
        if (e.dx != Horizontal && e.prev.dx != Horizontal) {
            break;
        }
        while (e.prev.dx == Horizontal) {
            e = e.prev;
        }
        e2 = e;
        while (e.dx == Horizontal) {
            e = e.next;
        }
        if (fltEquals(e.top.y, e.prev.bot.y)) {
            continue; //ie just an intermediate horz.
        }
        if (e2.prev.bot.x < e.bot.x) {
            e = e2;
        }
        break;
    }
    return e;
}
function Pt2IsBetweenPt1AndPt3(pt1, pt2, pt3) {
    if (pt1.equals(pt3) || pt1.equals(pt2) || pt3.equals(pt2)) {
        return false;
    }
    if (!fltEquals(pt1.x, pt3.x)) {
        return (pt2.x > pt1.x) == (pt2.x < pt3.x);
    }
    return (pt2.y > pt1.y) == (pt2.y < pt3.y);
}
function RemoveEdge(e) {
    //removes e from double_linked_list (but without removing from memory)
    e.prev.next = e.next;
    e.next.prev = e.prev;
    var result = e.next;
    e.prev = null; //flag as removed (see ClipperBase.Clear)
    return result;
}
function ReverseHorizontal(e) {
    //swap horizontal edges' top and bottom x's so they follow the natural
    //progression of the bounds - ie so their xbots will align with the
    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]
    var top = new ClipPoint(e.bot.x, e.top.y);
    var bot = new ClipPoint(e.top.x, e.bot.y);
    e.top = top;
    e.bot = bot;
}
function TopX(edge, currentY) {
    if (fltEquals(currentY, edge.top.y)) {
        return edge.top.x;
    }
    return edge.bot.x + edge.dx * (currentY - edge.bot.y);
}
function E2InsertsBeforeE1(e1, e2) {
    if (fltEquals(e2.curr.x, e1.curr.x)) {
        if (e2.top.y > e1.top.y) {
            return e2.top.x < TopX(e1, e2.top.y);
        }
        return e1.top.x > TopX(e2, e1.top.y);
    }
    return e2.curr.x < e1.curr.x;
}
function HorzSegmentsOverlap(s1a, s1b, s2a, s2b) {
    if (s1a > s1b) {
        var t = s1b;
        s1b = s1a;
        s1a = t;
    }
    if (s2a > s2b) {
        var t = s2b;
        s2b = s2a;
        s2a = t;
    }
    return (s1a < s2b) && (s2a < s1b);
}
function GetDx(pt1, pt2) {
    if (fltEquals(pt1.y, pt2.y)) {
        return Horizontal;
    }
    return (pt2.x - pt1.x) / (pt2.y - pt1.y);
}
function FirstIsBottomPt(btmPt1, btmPt2) {
    var p = btmPt1.prev;
    while (p.pt.equals(btmPt1.pt) && p != btmPt1) {
        p = p.prev;
    }
    var dx1p = Math.abs(GetDx(btmPt1.pt, p.pt));
    p = btmPt1.next;
    while (p.pt.equals(btmPt1.pt) && p != btmPt1) {
        p = p.next;
    }
    var dx1n = Math.abs(GetDx(btmPt1.pt, p.pt));
    p = btmPt2.prev;
    while (p.pt.equals(btmPt2.pt) && p != btmPt2) {
        p = p.prev;
    }
    var dx2p = Math.abs(GetDx(btmPt2.pt, p.pt));
    p = btmPt2.next;
    while (p.pt.equals(btmPt2.pt) && p != btmPt2) {
        p = p.next;
    }
    var dx2n = Math.abs(GetDx(btmPt2.pt, p.pt));
    if (Math.max(dx1p, dx1n) == Math.max(dx2p, dx2n)
        && Math.min(dx1p, dx1n) == Math.min(dx2p, dx2n)) {
        return this.Area(btmPt1) > 0; //if otherwise identical use orientation
    }
    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);
}
function GetBottomPt(pp) {
    var dups = null;
    var p = pp.next;
    while (p != pp) {
        if (p.pt.y > pp.pt.y) {
            pp = p;
            dups = null;
        }
        else if (fltEquals(p.pt.y, pp.pt.y) && p.pt.x <= pp.pt.x) {
            if (p.pt.x < pp.pt.x) {
                dups = null;
                pp = p;
            }
            else {
                if (p.next != pp && p.prev != pp) {
                    dups = p;
                }
            }
        }
        p = p.next;
    }
    if (dups != null) {
        //there appears to be at least 2 vertices at bottomPt so ...
        while (dups != p) {
            if (!FirstIsBottomPt(p, dups)) {
                pp = dups;
            }
            dups = dups.next;
            while (dups.pt.notEquals(pp.pt)) {
                dups = dups.next;
            }
        }
    }
    return pp;
}
function GetLowermostRec(outRec1, outRec2) {
    //work out which polygon fragment has the correct hole state ...
    if (outRec1.bottomPt == null) {
        outRec1.bottomPt = GetBottomPt(outRec1.pts);
    }
    if (outRec2.bottomPt == null) {
        outRec2.bottomPt = GetBottomPt(outRec2.pts);
    }
    var bPt1 = outRec1.bottomPt;
    var bPt2 = outRec2.bottomPt;
    if (bPt1.pt.y > bPt2.pt.y) {
        return outRec1;
    }
    else if (bPt1.pt.y < bPt2.pt.y) {
        return outRec2;
    }
    else if (bPt1.pt.x < bPt2.pt.x) {
        return outRec1;
    }
    else if (bPt1.pt.x > bPt2.pt.x) {
        return outRec2;
    }
    else if (bPt1.next == bPt1) {
        return outRec2;
    }
    else if (bPt2.next == bPt2) {
        return outRec1;
    }
    else if (FirstIsBottomPt(bPt1, bPt2)) {
        return outRec1;
    }
    return outRec2;
}
function OutRec1RightOfOutRec2(outRec1, outRec2) {
    do {
        outRec1 = outRec1.firstLeft;
        if (outRec1 == outRec2) {
            return true;
        }
    } while (outRec1 != null);
    return false;
}
function ReversePolyPtLinks(pp) {
    if (pp == null) {
        return;
    }
    var pp1;
    var pp2;
    pp1 = pp;
    do {
        pp2 = pp1.next;
        pp1.next = pp1.prev;
        pp1.prev = pp2;
        pp1 = pp2;
    } while (pp1 != pp);
}
function SwapSides(edge1, edge2) {
    var side = edge1.side;
    edge1.side = edge2.side;
    edge2.side = side;
}
function SwapPolyIndexes(edge1, edge2) {
    var outIdx = edge1.outIdx;
    edge1.outIdx = edge2.outIdx;
    edge2.outIdx = outIdx;
}
function GetHorzDirection(horzEdge) {
    if (horzEdge.bot.x < horzEdge.top.x) {
        return {
            Left: horzEdge.bot.x,
            Right: horzEdge.top.x,
            Dir: Direction.dLeftToRight
        };
    }
    else {
        return {
            Left: horzEdge.top.x,
            Right: horzEdge.bot.x,
            Dir: Direction.dRightToLeft
        };
    }
}
function GetNextInAEL(e, direction) {
    return direction == Direction.dLeftToRight ? e.nextInAEL : e.prevInAEL;
}
function IsMinima(e) {
    return e != null
        && e.prev.nextInLML != e
        && e.next.nextInLML != e;
}
function IsMaxima(e, y) {
    return e != null
        && fltEquals(e.top.y, y)
        && e.nextInLML == null;
}
function IsIntermediate(e, y) {
    return fltEquals(e.top.y, y)
        && e.nextInLML != null;
}
function GetMaximaPair(e) {
    if (e.next.top.equals(e.top) && e.next.nextInLML == null) {
        return e.next;
    }
    else if (e.prev.top.equals(e.top) && e.prev.nextInLML == null) {
        return e.prev;
    }
    return null;
}
function GetMaximaPairEx(e) {
    //as above but returns null if MaxPair isn't in AEL (unless it's horizontal)
    var result = GetMaximaPair(e);
    if (result == null
        || result.outIdx == Skip
        || (result.nextInAEL == result.prevInAEL && !IsHorizontal(result))) {
        return null;
    }
    return result;
}
function IntersectPoint(edge1, edge2) {
    var b1;
    var b2;
    var ipx;
    var ipy;
    //nb: with very large coordinate values, it's possible for SlopesEqual() to
    //return false but for the edge.Dx value be equal due to double precision rounding.
    if (edge1.dx == edge2.dx) {
        ipy = edge1.curr.y;
        ipx = TopX(edge1, ipy);
        return new ClipPoint(ipx, ipy);
    }
    if (NearZero(edge1.delta.x)) {
        ipx = edge1.bot.x;
        if (IsHorizontal(edge2)) {
            ipy = edge2.bot.y;
        }
        else {
            b2 = edge2.bot.y - edge2.bot.x / edge2.dx;
            ipy = ipx / edge2.dx + b2;
        }
    }
    else if (NearZero(edge2.delta.x)) {
        ipx = edge2.bot.x;
        if (IsHorizontal(edge1)) {
            ipy = edge1.bot.y;
        }
        else {
            b1 = edge1.bot.y - edge1.bot.x / edge1.dx;
            ipy = ipx / edge1.dx + b1;
        }
    }
    else {
        b1 = edge1.bot.x - edge1.bot.y * edge1.dx;
        b2 = edge2.bot.x - edge2.bot.y * edge2.dx;
        var q = (b2 - b1) / (edge1.dx - edge2.dx);
        ipy = q;
        if (Math.abs(edge1.dx) < Math.abs(edge2.dx)) {
            ipx = edge1.dx * q + b1;
        }
        else {
            ipx = edge2.dx * q + b2;
        }
    }
    if (ipy < edge1.top.y || ipy < edge2.top.y) {
        if (edge1.top.y > edge2.top.y) {
            ipy = edge1.top.y;
        }
        else {
            ipy = edge2.top.y;
        }
        if (Math.abs(edge1.dx) < Math.abs(edge2.dx)) {
            ipx = TopX(edge1, ipy);
        }
        else {
            ipx = TopX(edge2, ipy);
        }
    }
    //finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...
    if (ipy > edge1.curr.y) {
        ipy = edge1.curr.y;
        //better to use the more vertical edge to derive X ...
        if (Math.abs(edge1.dx) > Math.abs(edge2.dx)) {
            ipx = TopX(edge2, ipy);
        }
        else {
            ipx = TopX(edge1, ipy);
        }
    }
    return new ClipPoint(ipx, ipy);
}
function EdgesAdjacent(inode) {
    return (inode.edge1.nextInSEL == inode.edge2) ||
        (inode.edge1.prevInSEL == inode.edge2);
}
function IntersectNodeSort(node1, node2) {
    //the following typecast is safe because the differences in Pt.Y will
    //be limited to the height of the scanbeam.
    return node2.pt.y - node1.pt.y;
}
function ReversePaths(polys) {
    (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.foreach)(polys, function (poly) {
        poly.Reverse();
    });
}
function AreaPoly(poly) {
    var cnt = poly.Count;
    if (cnt < 3) {
        return 0;
    }
    var a = 0;
    for (var i = 0, j = cnt - 1; i < cnt; ++i) {
        a += (poly[j].x + poly[i].x) * (poly[j].y - poly[i].y);
        j = i;
    }
    return -a * 0.5;
}
function AreaOutRec(outRec) {
    return AreaOutPt(outRec.pts);
}
function AreaOutPt(op) {
    var opFirst = op;
    if (op == null) {
        return 0;
    }
    var a = 0;
    do {
        a += (op.prev.pt.x + op.pt.x) * (op.prev.pt.y - op.pt.y);
        op = op.next;
    } while (op != opFirst);
    return a * 0.5;
}
function Area(shape) {
    if (shape instanceof OutPt) {
        return AreaOutPt(shape);
    }
    if (shape instanceof OutRec) {
        return AreaOutRec(shape);
    }
    return AreaPoly(shape);
}
function Orientation(poly) {
    return Area(poly) >= 0;
}
function PointCount(pts) {
    if (pts == null) {
        return 0;
    }
    var result = 0;
    var p = pts;
    do {
        result++;
        p = p.next;
    } while (p != pts);
    return result;
}
function DupOutPt(outPt, insertAfter) {
    var result = new OutPt();
    result.pt = new ClipPoint(outPt.pt.x, outPt.pt.y);
    result.idx = outPt.idx;
    if (insertAfter) {
        result.next = outPt.next;
        result.prev = outPt;
        outPt.next.prev = result;
        outPt.next = result;
    }
    else {
        result.prev = outPt.prev;
        result.next = outPt;
        outPt.prev.next = result;
        outPt.prev = result;
    }
    return result;
}
function GetOverlap(a1, a2, b1, b2) {
    var Left;
    var Right;
    if (a1 < a2) {
        if (b1 < b2) {
            Left = Math.max(a1, b1);
            Right = Math.min(a2, b2);
        }
        else {
            Left = Math.max(a1, b2);
            Right = Math.min(a2, b1);
        }
    }
    else {
        if (b1 < b2) {
            Left = Math.max(a2, b1);
            Right = Math.min(a1, b2);
        }
        else {
            Left = Math.max(a2, b2);
            Right = Math.min(a1, b1);
        }
    }
    return {
        r: Left < Right,
        Left: Left,
        Right: Right
    };
}
function PointInPolygonPath(pt, path) {
    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
    //See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
    var result = 0;
    var cnt = path.Count;
    if (cnt < 3) {
        return 0;
    }
    var ip = path[0];
    for (var i = 1; i <= cnt; ++i) {
        var ipNext = (i == cnt ? path[0] : path[i]);
        if (fltEquals(ipNext.y, pt.y)) {
            if (fltEquals(ipNext.x, pt.x)
                || (fltEquals(ip.y, pt.y)
                    && ((ipNext.x > pt.x) == (ip.x < pt.x)))) {
                return -1;
            }
        }
        if ((ip.y < pt.y) != (ipNext.y < pt.y)) {
            if (ip.x >= pt.x) {
                if (ipNext.x > pt.x) {
                    result = 1 - result;
                }
                else {
                    var d = (ip.x - pt.x) * (ipNext.y - pt.y) -
                        (ipNext.x - pt.x) * (ip.y - pt.y);
                    if (NearZero(d)) {
                        return -1;
                    }
                    if ((d > 0) == (ipNext.y > ip.y)) {
                        result = 1 - result;
                    }
                }
            }
            else {
                if (ipNext.x > pt.x) {
                    var d = (ip.x - pt.x) * (ipNext.y - pt.y) -
                        (ipNext.x - pt.x) * (ip.y - pt.y);
                    if (NearZero(d)) {
                        return -1;
                    }
                    if ((d > 0) == (ipNext.y > ip.y)) {
                        result = 1 - result;
                    }
                }
            }
        }
        ip = ipNext;
    }
    return result;
}
//See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
//http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
function PointInPolygonOutPt(pt, op) {
    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
    var result = 0;
    var startOp = op;
    var ptx = pt.x;
    var pty = pt.y;
    var poly0x = op.pt.x;
    var poly0y = op.pt.y;
    do {
        op = op.next;
        var poly1x = op.pt.x;
        var poly1y = op.pt.y;
        if (fltEquals(poly1y, pty)) {
            if (fltEquals(poly1x, ptx)
                || (fltEquals(poly0y, pty) && ((poly1x > ptx) == (poly0x < ptx)))) {
                return -1;
            }
        }
        if ((poly0y < pty) != (poly1y < pty)) {
            if (poly0x >= ptx) {
                if (poly1x > ptx) {
                    result = 1 - result;
                }
                else {
                    var d = (poly0x - ptx) * (poly1y - pty) -
                        (poly1x - ptx) * (poly0y - pty);
                    if (d == 0) {
                        return -1;
                    }
                    if ((d > 0) == (poly1y > poly0y)) {
                        result = 1 - result;
                    }
                }
            }
            else {
                if (poly1x > ptx) {
                    var d = (poly0x - ptx) * (poly1y - pty) -
                        (poly1x - ptx) * (poly0y - pty);
                    if (d == 0) {
                        return -1;
                    }
                    if ((d > 0) == (poly1y > poly0y)) {
                        result = 1 - result;
                    }
                }
            }
        }
        poly0x = poly1x;
        poly0y = poly1y;
    } while (startOp != op);
    return result;
}
function PointInPolygon(pt, shape) {
    if (shape instanceof OutPt) {
        return PointInPolygonOutPt(pt, shape);
    }
    return PointInPolygonPath(pt, shape);
}
function Poly2ContainsPoly1(outPt1, outPt2) {
    var op = outPt1;
    do {
        //nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon
        var res = PointInPolygon(op.pt, outPt2);
        if (res >= 0) {
            return res > 0;
        }
        op = op.next;
    } while (op != outPt1);
    return true;
}
function ParseFirstLeft(firstLeft) {
    while (firstLeft != null && firstLeft.pts == null) {
        firstLeft = firstLeft.firstLeft;
    }
    return firstLeft;
}
function UpdateOutPtIdxs(outrec) {
    var op = outrec.pts;
    do {
        op.idx = outrec.idx;
        op = op.prev;
    } while (op != outrec.pts);
}
function DistanceSqrd(pt1, pt2) {
    var dx = pt1.x - pt2.x;
    var dy = pt1.y - pt2.y;
    return dx * dx + dy * dy;
}
function DistanceFromLineSqrd(pt, ln1, ln2) {
    //The equation of a line in general form (Ax + By + C = 0)
    //given 2 points (x,y) & (x,y) is ...
    //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0
    //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y
    //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)
    //see http://en.wikipedia.org/wiki/Perpendicular_distance
    var A = ln1.y - ln2.y;
    var B = ln2.x - ln1.x;
    var C = A * ln1.x + B * ln1.y;
    C = A * pt.x + B * pt.y - C;
    return (C * C) / (A * A + B * B);
}
function SlopesNearCollinear(pt1, pt2, pt3, distSqrd) {
    //this function is more accurate when the point that's GEOMETRICALLY
    //between the other 2 points is the one that's tested for distance.
    //nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts
    if (Math.abs(pt1.x - pt2.x) > Math.abs(pt1.y - pt2.y)) {
        if ((pt1.x > pt2.x) == (pt1.x < pt3.x)) {
            return DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
        }
        else if ((pt2.x > pt1.x) == (pt2.x < pt3.x)) {
            return DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
        }
        return DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
    }
    if ((pt1.y > pt2.y) == (pt1.y < pt3.y)) {
        return DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
    }
    else if ((pt2.y > pt1.y) == (pt2.y < pt3.y)) {
        return DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
    }
    return DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
}
function PointsAreClose(pt1, pt2, distSqrd) {
    return DistanceSqrd(pt1, pt2) <= distSqrd;
}
function ExcludeOp(op) {
    var result = op.prev;
    result.next = op.next;
    op.next.prev = result;
    result.idx = 0;
    return result;
}
function XOR(a, b) {
    return (a || b) && !(a && b);
}
function GetUnitNormal(pt1, pt2) {
    var dx = pt2.x - pt1.x;
    var dy = pt2.y - pt1.y;
    if (dx == 0 && dy == 0) {
        return new ClipPoint(0, 0);
    }
    var f = 1 * 1.0 / Math.sqrt(dx * dx + dy * dy);
    dx *= f;
    dy *= f;
    return new ClipPoint(dy, -dx);
}
var ClipperBase = /** @class */ (function () {
    function ClipperBase() {
        this.m_edges = new Array();
        this.m_Scanbeam = undefined;
        this.m_PolyOuts = undefined;
        this.m_ActiveEdges = undefined;
        this.m_HasOpenPaths = false;
        this.PreserveCollinear = false;
        this.m_MinimaList = null;
        this.m_CurrentLM = null;
        this.m_HasOpenPaths = false;
    }
    ClipperBase.prototype.Clear = function () {
        this.DisposeLocalMinimaList();
        this.m_edges.length = 0;
        this.m_HasOpenPaths = false;
    };
    ClipperBase.prototype.DisposeLocalMinimaList = function () {
        this.m_MinimaList = null;
        this.m_CurrentLM = null;
    };
    ClipperBase.prototype.InsertLocalMinima = function (newLm) {
        if (this.m_MinimaList == null) {
            this.m_MinimaList = newLm;
        }
        else if (newLm.y >= this.m_MinimaList.y) {
            newLm.next = this.m_MinimaList;
            this.m_MinimaList = newLm;
        }
        else {
            var tmpLm = this.m_MinimaList;
            while (tmpLm.next != null && newLm.y < tmpLm.next.y) {
                tmpLm = tmpLm.next;
            }
            newLm.next = tmpLm.next;
            tmpLm.next = newLm;
        }
    };
    ClipperBase.prototype.PopLocalMinima = function (Y) {
        var current = this.m_CurrentLM;
        if (this.m_CurrentLM != null && fltEquals(this.m_CurrentLM.y, Y)) {
            this.m_CurrentLM = this.m_CurrentLM.next;
            return current;
        }
        return null;
    };
    ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward) {
        var EStart;
        var Result = E;
        var Horz;
        if (Result.outIdx == Skip) {
            //check if there are edges beyond the skip edge in the bound and if so
            //create another LocMin and calling ProcessBound once more ...
            E = Result;
            if (LeftBoundIsForward) {
                while (fltEquals(E.top.y, E.next.bot.y)) {
                    E = E.next;
                }
                while (E != Result && E.dx == Horizontal) {
                    E = E.prev;
                }
            }
            else {
                while (fltEquals(E.top.y, E.prev.bot.y)) {
                    E = E.prev;
                }
                while (E != Result && E.dx == Horizontal) {
                    E = E.next;
                }
            }
            if (E == Result) {
                Result = LeftBoundIsForward ? E.next : E.prev;
            }
            else {
                //there are more edges in the bound beyond result starting with E
                E = LeftBoundIsForward ? Result.next : Result.prev;
                var locMin = new LocalMinima(E.bot.y, null, E);
                E.windDelta = 0;
                Result = this.ProcessBound(E, LeftBoundIsForward);
                this.InsertLocalMinima(locMin);
            }
            return Result;
        }
        if (E.dx == Horizontal) {
            //We need to be careful with open paths because this may not be a
            //true local minima (ie E may be following a skip edge).
            //Also, consecutive horz. edges may start heading left before going right.
            EStart = LeftBoundIsForward ? E.prev : E.next;
            if (EStart.dx == Horizontal) { //ie an adjoining horizontal skip edge
                if (!fltEquals(EStart.bot.x, E.bot.x)
                    && !fltEquals(EStart.top.x, E.bot.x)) {
                    ReverseHorizontal(E);
                }
            }
            else if (!fltEquals(EStart.bot.x, E.bot.x)) {
                ReverseHorizontal(E);
            }
        }
        EStart = E;
        if (LeftBoundIsForward) {
            while (fltEquals(Result.top.y, Result.next.bot.y)
                && Result.next.outIdx != Skip) {
                Result = Result.next;
            }
            if (Result.dx == Horizontal && Result.next.outIdx != Skip) {
                //nb: at the top of a bound, horizontals are added to the bound
                //only when the preceding edge attaches to the horizontal's left vertex
                //unless a Skip edge is encountered when that becomes the top divide
                Horz = Result;
                while (Horz.prev.dx == Horizontal) {
                    Horz = Horz.prev;
                }
                if (Horz.prev.top.x > Result.next.top.x) {
                    Result = Horz.prev;
                }
            }
            while (E != Result) {
                E.nextInLML = E.next;
                if (E.dx == Horizontal && E != EStart && !fltEquals(E.bot.x, E.prev.top.x)) {
                    ReverseHorizontal(E);
                }
                E = E.next;
            }
            if (E.dx == Horizontal && E != EStart && !fltEquals(E.bot.x, E.prev.top.x)) {
                ReverseHorizontal(E);
            }
            Result = Result.next; //move to the edge just beyond current bound
        }
        else {
            while (fltEquals(Result.top.y, Result.prev.bot.y)
                && Result.prev.outIdx != Skip) {
                Result = Result.prev;
            }
            if (Result.dx == Horizontal && Result.prev.outIdx != Skip) {
                Horz = Result;
                while (Horz.next.dx == Horizontal)
                    Horz = Horz.next;
                if (Horz.next.top.x >= Result.prev.top.x) {
                    Result = Horz.next;
                }
            }
            while (E != Result) {
                E.nextInLML = E.prev;
                if (E.dx == Horizontal && E != EStart && !fltEquals(E.bot.x, E.next.top.x)) {
                    ReverseHorizontal(E);
                }
                E = E.prev;
            }
            if (E.dx == Horizontal && E != EStart && !fltEquals(E.bot.x, E.next.top.x)) {
                ReverseHorizontal(E);
            }
            Result = Result.prev; //move to the edge just beyond current bound
        }
        return Result;
    };
    ClipperBase.prototype.Reset = function () {
        this.m_CurrentLM = this.m_MinimaList;
        if (this.m_CurrentLM == null) {
            return; //ie nothing to process
        }
        //reset all edges ...
        this.m_Scanbeam = null;
        var lm = this.m_MinimaList;
        while (lm != null) {
            this.InsertScanbeam(lm.y);
            var e = lm.leftBound;
            if (e != null) {
                e.curr = new ClipPoint(e.bot.x, e.bot.y);
                e.outIdx = Unassigned;
            }
            e = lm.rightBound;
            if (e != null) {
                e.curr = new ClipPoint(e.bot.x, e.bot.y);
                e.outIdx = Unassigned;
            }
            lm = lm.next;
        }
        this.m_ActiveEdges = null;
    };
    ClipperBase.prototype.InsertScanbeam = function (Y) {
        //single-linked list: sorted descending, ignoring dups.
        if (this.m_Scanbeam == null) {
            this.m_Scanbeam = new Scanbeam(Y);
        }
        else if (Y > this.m_Scanbeam.y) {
            var newSb = new Scanbeam(Y);
            newSb.next = this.m_Scanbeam;
            this.m_Scanbeam = newSb;
        }
        else {
            var sb2 = this.m_Scanbeam;
            while (sb2.next != null && Y <= sb2.next.y) {
                sb2 = sb2.next;
            }
            if (fltEquals(Y, sb2.y)) {
                return; //ie ignores duplicates
            }
            var newSb = new Scanbeam(Y);
            newSb.next = sb2.next;
            sb2.next = newSb;
        }
    };
    ClipperBase.GetBounds = function (paths) {
        var i = 0;
        var cnt = paths.Count;
        while (i < cnt && paths[i].Count == 0) {
            i++;
        }
        if (i == cnt) {
            return new ClipRect(0, 0, 0, 0);
        }
        var resultLeft = paths[i][0].x;
        var resultRight = resultLeft;
        var resultTop = paths[i][0].y;
        var resultBottom = resultTop;
        for (; i < cnt; i++) {
            for (var j = 0; j < paths[i].length; j++) {
                if (paths[i][j].x < resultLeft) {
                    resultLeft = paths[i][j].x;
                }
                else if (paths[i][j].x > resultRight) {
                    resultRight = paths[i][j].x;
                }
                if (paths[i][j].y < resultTop) {
                    resultTop = paths[i][j].y;
                }
                else if (paths[i][j].y > resultBottom) {
                    resultBottom = paths[i][j].y;
                }
            }
        }
        return new ClipRect(resultLeft, resultTop, resultRight, resultBottom);
    };
    ClipperBase.prototype.PopScanbeam = function () {
        if (this.m_Scanbeam == null) {
            return { Y: 0, r: false };
        }
        var Y = this.m_Scanbeam.y;
        this.m_Scanbeam = this.m_Scanbeam.next;
        return { Y: Y, r: true };
    };
    Object.defineProperty(ClipperBase.prototype, "LocalMinimaPending", {
        get: function () {
            return this.m_CurrentLM != null;
        },
        enumerable: false,
        configurable: true
    });
    ClipperBase.prototype.CreateOutRec = function () {
        var result = new OutRec();
        this.m_PolyOuts.push(result);
        result.idx = this.m_PolyOuts.length - 1;
        return result;
    };
    ClipperBase.prototype.DisposeOutRec = function (index) {
        this.m_PolyOuts[index] = null;
    };
    ClipperBase.prototype.UpdateEdgeIntoAEL = function (e) {
        if (e.nextInLML == null) {
            throw new Error("UpdateEdgeIntoAEL: invalid call");
        }
        var AelPrev = e.prevInAEL;
        var AelNext = e.nextInAEL;
        e.nextInLML.outIdx = e.outIdx;
        if (AelPrev != null) {
            AelPrev.nextInAEL = e.nextInLML;
        }
        else {
            this.m_ActiveEdges = e.nextInLML;
        }
        if (AelNext != null) {
            AelNext.prevInAEL = e.nextInLML;
        }
        e.nextInLML.side = e.side;
        e.nextInLML.windDelta = e.windDelta;
        e.nextInLML.windCnt = e.windCnt;
        e.nextInLML.windCnt2 = e.windCnt2;
        e = e.nextInLML;
        e.curr = new ClipPoint(e.bot.x, e.bot.y);
        e.prevInAEL = AelPrev;
        e.nextInAEL = AelNext;
        if (!IsHorizontal(e)) {
            this.InsertScanbeam(e.top.y);
        }
        return e;
    };
    ClipperBase.prototype.SwapPositionsInAEL = function (edge1, edge2) {
        //check that one or other edge hasn't already been removed from AEL ...
        if (edge1.nextInAEL == edge1.prevInAEL
            || edge2.nextInAEL == edge2.prevInAEL)
            return;
        if (edge1.nextInAEL == edge2) {
            var next = edge2.nextInAEL;
            if (next != null)
                next.prevInAEL = edge1;
            var prev = edge1.prevInAEL;
            if (prev != null)
                prev.nextInAEL = edge2;
            edge2.prevInAEL = prev;
            edge2.nextInAEL = edge1;
            edge1.prevInAEL = edge2;
            edge1.nextInAEL = next;
        }
        else if (edge2.nextInAEL == edge1) {
            var next = edge1.nextInAEL;
            if (next != null)
                next.prevInAEL = edge2;
            var prev = edge2.prevInAEL;
            if (prev != null)
                prev.nextInAEL = edge1;
            edge1.prevInAEL = prev;
            edge1.nextInAEL = edge2;
            edge2.prevInAEL = edge1;
            edge2.nextInAEL = next;
        }
        else {
            var next = edge1.nextInAEL;
            var prev = edge1.prevInAEL;
            edge1.nextInAEL = edge2.nextInAEL;
            if (edge1.nextInAEL != null)
                edge1.nextInAEL.prevInAEL = edge1;
            edge1.prevInAEL = edge2.prevInAEL;
            if (edge1.prevInAEL != null)
                edge1.prevInAEL.nextInAEL = edge1;
            edge2.nextInAEL = next;
            if (edge2.nextInAEL != null)
                edge2.nextInAEL.prevInAEL = edge2;
            edge2.prevInAEL = prev;
            if (edge2.prevInAEL != null)
                edge2.prevInAEL.nextInAEL = edge2;
        }
        if (edge1.prevInAEL == null)
            this.m_ActiveEdges = edge1;
        else if (edge2.prevInAEL == null)
            this.m_ActiveEdges = edge2;
    };
    ClipperBase.prototype.DeleteFromAEL = function (e) {
        var AelPrev = e.prevInAEL;
        var AelNext = e.nextInAEL;
        if (AelPrev == null && AelNext == null && e != this.m_ActiveEdges) {
            return; //already deleted
        }
        if (AelPrev != null) {
            AelPrev.nextInAEL = AelNext;
        }
        else {
            this.m_ActiveEdges = AelNext;
        }
        if (AelNext != null) {
            AelNext.prevInAEL = AelPrev;
        }
        e.nextInAEL = null;
        e.prevInAEL = null;
    };
    ClipperBase.prototype.AddPath = function (pg, polyType, Closed) {
        if (!Closed && polyType == PolyType.ptClip)
            throw new Error("AddPath: Open paths must be subject.");
        var highI = pg.Count - 1;
        if (Closed) {
            while (highI > 0 && (pg[highI].equals(pg[0]))) {
                highI--;
            }
        }
        while (highI > 0 && (pg[highI].equals(pg[highI - 1]))) {
            highI--;
        }
        if ((Closed && highI < 2) || (!Closed && highI < 1)) {
            return false;
        }
        //create a new edge array ...
        var edges = new Array(highI + 1);
        for (var i = 0; i <= highI; i++) {
            edges[i] = new TEdge();
        }
        var IsFlat = true;
        //1. Basic (first) edge initialization ...
        edges[1].curr = pg[1];
        InitEdge(edges[0], edges[1], edges[highI], pg[0]);
        InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);
        for (var i = highI - 1; i >= 1; --i) {
            InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);
        }
        var eStart = edges[0];
        //2. Remove duplicate vertices, and (when closed) collinear edges ...
        var E = eStart;
        var eLoopStop = eStart;
        for (;;) {
            //nb: allows matching start and end points when not Closed ...
            if (E.curr.equals(E.next.curr) && (Closed || E.next != eStart)) {
                if (E == E.next)
                    break;
                if (E == eStart)
                    eStart = E.next;
                E = RemoveEdge(E);
                eLoopStop = E;
                continue;
            }
            if (E.prev == E.next) {
                break; //only two vertices
            }
            else if (Closed
                && SlopesEqual3P(E.prev.curr, E.curr, E.next.curr)
                && (!this.PreserveCollinear
                    || !Pt2IsBetweenPt1AndPt3(E.prev.curr, E.curr, E.next.curr))) {
                //Collinear edges are allowed for open paths but in closed paths
                //the default is to merge adjacent collinear edges into a single edge.
                //However, if the PreserveCollinear property is enabled, only overlapping
                //collinear edges (ie spikes) will be removed from closed paths.
                if (E == eStart)
                    eStart = E.next;
                E = RemoveEdge(E);
                E = E.prev;
                eLoopStop = E;
                continue;
            }
            E = E.next;
            if ((E == eLoopStop) || (!Closed && E.next == eStart))
                break;
        }
        if ((!Closed && (E == E.next)) || (Closed && (E.prev == E.next))) {
            return false;
        }
        if (!Closed) {
            this.m_HasOpenPaths = true;
            eStart.prev.outIdx = Skip;
        }
        //3. Do second stage of edge initialization ...
        E = eStart;
        do {
            InitEdge2(E, polyType);
            E = E.next;
            if (IsFlat && !fltEquals(E.curr.y, eStart.curr.y)) {
                IsFlat = false;
            }
        } while (E != eStart);
        //4. Finally, add edge bounds to LocalMinima list ...
        //Totally flat paths must be handled differently when adding them
        //to LocalMinima list to avoid endless loops etc ...
        if (IsFlat) {
            if (Closed) {
                return false;
            }
            E.prev.outIdx = Skip;
            var locMin = new LocalMinima(E.bot.y, null, E);
            locMin.rightBound.side = EdgeSide.esRight;
            locMin.rightBound.windDelta = 0;
            for (;;) {
                if (!fltEquals(E.bot.x, E.prev.top.x)) {
                    ReverseHorizontal(E);
                }
                if (E.next.outIdx == Skip) {
                    break;
                }
                E.nextInLML = E.next;
                E = E.next;
            }
            this.InsertLocalMinima(locMin);
            this.m_edges.push(edges);
            return true;
        }
        this.m_edges.push(edges);
        var leftBoundIsForward;
        var EMin = null;
        //workaround to avoid an endless loop in the while loop below when
        //open paths have matching start and end points ...
        if (E.prev.bot.equals(E.prev.top)) {
            E = E.next;
        }
        for (;;) {
            E = FindNextLocMin(E);
            if (E == EMin) {
                break;
            }
            if (EMin == null) {
                EMin = E;
            }
            //E and E.Prev now share a local minima (left aligned if horizontal).
            //Compare their slopes to find which starts which bound ...
            var locMin = void 0;
            if (E.dx < E.prev.dx) {
                locMin = new LocalMinima(E.bot.y, E.prev, E);
                leftBoundIsForward = false; //Q.nextInLML = Q.prev
            }
            else {
                locMin = new LocalMinima(E.bot.y, E, E.prev);
                leftBoundIsForward = true; //Q.nextInLML = Q.next
            }
            locMin.leftBound.side = EdgeSide.esLeft;
            locMin.rightBound.side = EdgeSide.esRight;
            if (!Closed) {
                locMin.leftBound.windDelta = 0;
            }
            else if (locMin.leftBound.next == locMin.rightBound) {
                locMin.leftBound.windDelta = -1;
            }
            else {
                locMin.leftBound.windDelta = 1;
            }
            locMin.rightBound.windDelta = -locMin.leftBound.windDelta;
            E = this.ProcessBound(locMin.leftBound, leftBoundIsForward);
            if (E.outIdx == Skip) {
                E = this.ProcessBound(E, leftBoundIsForward);
            }
            var E2 = this.ProcessBound(locMin.rightBound, !leftBoundIsForward);
            if (E2.outIdx == Skip) {
                E2 = this.ProcessBound(E2, !leftBoundIsForward);
            }
            if (locMin.leftBound.outIdx == Skip) {
                locMin.clearLeftBound();
            }
            else if (locMin.rightBound.outIdx == Skip) {
                locMin.clearRightBound();
            }
            this.InsertLocalMinima(locMin);
            if (!leftBoundIsForward) {
                E = E2;
            }
        }
        return true;
    };
    ClipperBase.prototype.AddPaths = function (ppg, polyType, closed) {
        var _this = this;
        var result = false;
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.foreach)(ppg, function (path) {
            if (_this.AddPath(path, polyType, closed)) {
                result = true;
            }
        });
        return result;
    };
    return ClipperBase;
}()); //end ClipperBase
var Clipper = /** @class */ (function (_super) {
    __extends(Clipper, _super);
    function Clipper(InitOptions) {
        if (InitOptions === void 0) { InitOptions = 0; }
        var _this = _super.call(this) || this;
        //InitOptions that can be passed to the constructor ...
        _this.m_ClipType = undefined;
        _this.m_ClipFillType = undefined;
        _this.m_SubjFillType = undefined;
        _this.m_Scanbeam = null;
        _this.m_Maxima = null;
        _this.m_ActiveEdges = null;
        _this.m_SortedEdges = null;
        _this.m_IntersectList = new Array();
        _this.m_ExecuteLocked = false;
        _this.m_UsingPolyTree = false;
        _this.m_PolyOuts = new Array();
        _this.m_Joins = new Array();
        _this.m_GhostJoins = new Array();
        _this.ReverseSolution = (ioReverseSolution & InitOptions) != 0;
        _this.StrictlySimple = (ioStrictlySimple & InitOptions) != 0;
        _this.PreserveCollinear = (ioPreserveCollinear & InitOptions) != 0;
        return _this;
    }
    Clipper.prototype.InsertMaxima = function (X) {
        //double-linked list: sorted ascending, ignoring dups.
        var newMax = new Maxima(X);
        if (this.m_Maxima == null) {
            this.m_Maxima = newMax;
            this.m_Maxima.next = null;
            this.m_Maxima.prev = null;
        }
        else if (X < this.m_Maxima.x) {
            newMax.next = this.m_Maxima;
            newMax.prev = null;
            this.m_Maxima = newMax;
        }
        else {
            var m = this.m_Maxima;
            while (m.next != null && X >= m.next.x) {
                m = m.next;
            }
            if (fltEquals(X, m.x)) {
                return; //ie ignores duplicates (& CG to clean up newMax)
            }
            //insert newMax between m and m.Next ...
            newMax.next = m.next;
            newMax.prev = m;
            if (m.next != null) {
                m.next.prev = newMax;
            }
            m.next = newMax;
        }
    };
    Clipper.prototype.Execute = function (clipType, solution, fillType) {
        if (fillType === void 0) { fillType = PolyFillType.pftEvenOdd; }
        if (solution instanceof PolyTree) {
            return this.ExecutePolyTree(clipType, solution, fillType, fillType);
        }
        return this.ExecutePaths(clipType, solution, fillType, fillType);
    };
    Clipper.prototype.ExecutePaths = function (clipType, solution, subjFillType, clipFillType) {
        if (this.m_ExecuteLocked) {
            return false;
        }
        if (this.m_HasOpenPaths) {
            throw new Error("Error: PolyTree struct is needed for open path clipping.");
        }
        this.m_ExecuteLocked = true;
        solution.Clear();
        this.m_SubjFillType = subjFillType;
        this.m_ClipFillType = clipFillType;
        this.m_ClipType = clipType;
        this.m_UsingPolyTree = false;
        var succeeded;
        try {
            succeeded = this.ExecuteInternal();
            //build the return polygons ...
            if (succeeded) {
                this.BuildResult(solution);
            }
        }
        finally {
            this.DisposeAllPolyPts();
            this.m_ExecuteLocked = false;
        }
        return succeeded;
    };
    Clipper.prototype.ExecutePolyTree = function (clipType, polytree, subjFillType, clipFillType) {
        if (this.m_ExecuteLocked) {
            return false;
        }
        this.m_ExecuteLocked = true;
        this.m_SubjFillType = subjFillType;
        this.m_ClipFillType = clipFillType;
        this.m_ClipType = clipType;
        this.m_UsingPolyTree = true;
        var succeeded;
        try {
            succeeded = this.ExecuteInternal();
            //build the return polygons ...
            if (succeeded) {
                this.BuildResult2(polytree);
            }
        }
        finally {
            this.DisposeAllPolyPts();
            this.m_ExecuteLocked = false;
        }
        return succeeded;
    };
    Clipper.prototype.FixHoleLinkage = function (outRec) {
        //skip if an outermost polygon or
        //already already points to the correct FirstLeft ...
        if (outRec.firstLeft == null
            || (outRec.isHole != outRec.firstLeft.isHole
                && outRec.firstLeft.pts != null)) {
            return;
        }
        var orfl = outRec.firstLeft;
        while (orfl != null
            && (orfl.isHole == outRec.isHole || orfl.pts == null)) {
            orfl = orfl.firstLeft;
        }
        outRec.firstLeft = orfl;
    };
    Clipper.prototype.ExecuteInternal = function () {
        try {
            this.Reset();
            this.m_SortedEdges = null;
            this.m_Maxima = null;
            var botY = void 0;
            var topY = void 0;
            var r = this.PopScanbeam();
            if (!r.r) {
                return false;
            }
            botY = r.Y;
            this.InsertLocalMinimaIntoAEL(botY);
            r = this.PopScanbeam();
            while (r.r || this.LocalMinimaPending) {
                topY = r.Y;
                this.ProcessHorizontals();
                this.m_GhostJoins.length = 0;
                if (!this.ProcessIntersections(topY)) {
                    return false;
                }
                this.ProcessEdgesAtTopOfScanbeam(topY);
                botY = topY;
                this.InsertLocalMinimaIntoAEL(botY);
                r = this.PopScanbeam();
            }
            //fix orientations ...
            for (var _i = 0, _a = this.m_PolyOuts; _i < _a.length; _i++) {
                var outRec = _a[_i];
                if (outRec.pts == null || outRec.isOpen) {
                    continue;
                }
                if (XOR(outRec.isHole, this.ReverseSolution) == (Area(outRec) > 0)) {
                    ReversePolyPtLinks(outRec.pts);
                }
            }
            this.JoinCommonEdges();
            for (var _b = 0, _c = this.m_PolyOuts; _b < _c.length; _b++) {
                var outRec = _c[_b];
                if (outRec.pts == null) {
                    continue;
                }
                else if (outRec.isOpen) {
                    this.FixupOutPolyline(outRec);
                }
                else {
                    this.FixupOutPolygon(outRec);
                }
            }
            if (this.StrictlySimple) {
                this.DoSimplePolygons();
            }
            return true;
        }
        finally {
            this.m_Joins.length = 0;
            this.m_GhostJoins.length = 0;
        }
    };
    Clipper.prototype.DisposeAllPolyPts = function () {
        for (var i = 0; i < this.m_PolyOuts.length; ++i) {
            this.DisposeOutRec(i);
        }
        this.m_PolyOuts.length = 0;
    };
    Clipper.prototype.AddJoin = function (Op1, Op2, OffPt) {
        var j = new Join(Op1, Op2, OffPt);
        this.m_Joins.push(j);
    };
    Clipper.prototype.AddGhostJoin = function (Op, OffPt) {
        var j = new Join(Op, null, OffPt);
        this.m_GhostJoins.push(j);
    };
    Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY) {
        var lm;
        while ((lm = this.PopLocalMinima(botY)) != null) {
            var lb = lm.leftBound;
            var rb = lm.rightBound;
            var Op1 = null;
            if (lb == null) {
                this.InsertEdgeIntoAEL(rb, null);
                this.SetWindingCount(rb);
                if (this.IsContributing(rb)) {
                    Op1 = this.AddOutPt(rb, rb.bot);
                }
            }
            else if (rb == null) {
                this.InsertEdgeIntoAEL(lb, null);
                this.SetWindingCount(lb);
                if (this.IsContributing(lb)) {
                    Op1 = this.AddOutPt(lb, lb.bot);
                }
                this.InsertScanbeam(lb.top.y);
            }
            else {
                this.InsertEdgeIntoAEL(lb, null);
                this.InsertEdgeIntoAEL(rb, lb);
                this.SetWindingCount(lb);
                rb.windCnt = lb.windCnt;
                rb.windCnt2 = lb.windCnt2;
                if (this.IsContributing(lb)) {
                    Op1 = this.AddLocalMinPoly(lb, rb, lb.bot);
                }
                this.InsertScanbeam(lb.top.y);
            }
            if (rb != null) {
                if (IsHorizontal(rb)) {
                    if (rb.nextInLML != null) {
                        this.InsertScanbeam(rb.nextInLML.top.y);
                    }
                    this.AddEdgeToSEL(rb);
                }
                else {
                    this.InsertScanbeam(rb.top.y);
                }
            }
            if (lb == null || rb == null) {
                continue;
            }
            //if output polygons share an Edge with a horizontal rb, they'll need joining later ...
            if (Op1 != null
                && IsHorizontal(rb)
                && this.m_GhostJoins.length > 0
                && rb.windDelta != 0) {
                for (var i = 0; i < this.m_GhostJoins.length; i++) {
                    //if the horizontal Rb and a 'ghost' horizontal overlap, then convert
                    //the 'ghost' join to a real join ready for later ...
                    var j = this.m_GhostJoins[i];
                    if (HorzSegmentsOverlap(j.outPt1.pt.x, j.offPt.x, rb.bot.x, rb.top.x)) {
                        this.AddJoin(j.outPt1, Op1, j.offPt);
                    }
                }
            }
            if (lb.outIdx >= 0
                && lb.prevInAEL != null
                && fltEquals(lb.prevInAEL.curr.x, lb.bot.x)
                && lb.prevInAEL.outIdx >= 0
                && SlopesEqual4P(lb.prevInAEL.curr, lb.prevInAEL.top, lb.curr, lb.top)
                && lb.windDelta != 0
                && lb.prevInAEL.windDelta != 0) {
                var Op2 = this.AddOutPt(lb.prevInAEL, lb.bot);
                this.AddJoin(Op1, Op2, lb.top);
            }
            if (lb.nextInAEL != rb) {
                if (rb.outIdx >= 0
                    && rb.prevInAEL.outIdx >= 0
                    && SlopesEqual4P(rb.prevInAEL.curr, rb.prevInAEL.top, rb.curr, rb.top)
                    && rb.windDelta != 0
                    && rb.prevInAEL.windDelta != 0) {
                    var Op2 = this.AddOutPt(rb.prevInAEL, rb.bot);
                    this.AddJoin(Op1, Op2, rb.top);
                }
                var e = lb.nextInAEL;
                if (e != null) {
                    while (e != rb) {
                        //nb: For calculating winding counts etc, IntersectEdges() assumes
                        //that param1 will be to the right of param2 ABOVE the intersection ...
                        this.IntersectEdges(rb, e, lb.curr); //order important here
                        e = e.nextInAEL;
                    }
                }
            }
        }
    };
    Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge) {
        if (this.m_ActiveEdges == null) {
            edge.prevInAEL = null;
            edge.nextInAEL = null;
            this.m_ActiveEdges = edge;
        }
        else if (startEdge == null
            && E2InsertsBeforeE1(this.m_ActiveEdges, edge)) {
            edge.prevInAEL = null;
            edge.nextInAEL = this.m_ActiveEdges;
            this.m_ActiveEdges.prevInAEL = edge;
            this.m_ActiveEdges = edge;
        }
        else {
            if (startEdge == null) {
                startEdge = this.m_ActiveEdges;
            }
            while (startEdge.nextInAEL != null
                && !E2InsertsBeforeE1(startEdge.nextInAEL, edge)) {
                startEdge = startEdge.nextInAEL;
            }
            edge.nextInAEL = startEdge.nextInAEL;
            if (startEdge.nextInAEL != null) {
                startEdge.nextInAEL.prevInAEL = edge;
            }
            edge.prevInAEL = startEdge;
            startEdge.nextInAEL = edge;
        }
    };
    Clipper.prototype.IsEvenOddFillType = function (edge) {
        if (edge.polyTyp == PolyType.ptSubject) {
            return this.m_SubjFillType == PolyFillType.pftEvenOdd;
        }
        return this.m_ClipFillType == PolyFillType.pftEvenOdd;
    };
    Clipper.prototype.IsEvenOddAltFillType = function (edge) {
        if (edge.polyTyp == PolyType.ptSubject) {
            return this.m_ClipFillType == PolyFillType.pftEvenOdd;
        }
        return this.m_SubjFillType == PolyFillType.pftEvenOdd;
    };
    Clipper.prototype.IsContributing = function (edge) {
        var pft;
        var pft2;
        if (edge.polyTyp == PolyType.ptSubject) {
            pft = this.m_SubjFillType;
            pft2 = this.m_ClipFillType;
        }
        else {
            pft = this.m_ClipFillType;
            pft2 = this.m_SubjFillType;
        }
        switch (pft) {
            case PolyFillType.pftEvenOdd:
                //return false if a subj line has been flagged as inside a subj polygon
                if (edge.windDelta == 0 && edge.windCnt != 1) {
                    return false;
                }
                break;
            case PolyFillType.pftNonZero:
                if (Math.abs(edge.windCnt) != 1) {
                    return false;
                }
                break;
            case PolyFillType.pftPositive:
                if (edge.windCnt != 1) {
                    return false;
                }
                break;
            default: //PolyFillType.pftNegative
                if (edge.windCnt != -1) {
                    return false;
                }
                break;
        }
        switch (this.m_ClipType) {
            case ClipType.ctIntersection:
                switch (pft2) {
                    case PolyFillType.pftEvenOdd:
                    case PolyFillType.pftNonZero:
                        return (edge.windCnt2 != 0);
                    case PolyFillType.pftPositive:
                        return (edge.windCnt2 > 0);
                    default:
                        return (edge.windCnt2 < 0);
                }
            case ClipType.ctUnion:
                switch (pft2) {
                    case PolyFillType.pftEvenOdd:
                    case PolyFillType.pftNonZero:
                        return (edge.windCnt2 == 0);
                    case PolyFillType.pftPositive:
                        return (edge.windCnt2 <= 0);
                    default:
                        return (edge.windCnt2 >= 0);
                }
            case ClipType.ctDifference:
                if (edge.polyTyp == PolyType.ptSubject) {
                    switch (pft2) {
                        case PolyFillType.pftEvenOdd:
                        case PolyFillType.pftNonZero:
                            return (edge.windCnt2 == 0);
                        case PolyFillType.pftPositive:
                            return (edge.windCnt2 <= 0);
                        default:
                            return (edge.windCnt2 >= 0);
                    }
                }
                else {
                    switch (pft2) {
                        case PolyFillType.pftEvenOdd:
                        case PolyFillType.pftNonZero:
                            return (edge.windCnt2 != 0);
                        case PolyFillType.pftPositive:
                            return (edge.windCnt2 > 0);
                        default:
                            return (edge.windCnt2 < 0);
                    }
                }
            case ClipType.ctXor:
                if (edge.windDelta == 0) { //XOr always contributing unless open
                    switch (pft2) {
                        case PolyFillType.pftEvenOdd:
                        case PolyFillType.pftNonZero:
                            return (edge.windCnt2 == 0);
                        case PolyFillType.pftPositive:
                            return (edge.windCnt2 <= 0);
                        default:
                            return (edge.windCnt2 >= 0);
                    }
                }
                return true;
        }
        return true;
    };
    Clipper.prototype.SetWindingCount = function (edge) {
        var e = edge.prevInAEL;
        //find the edge of the same polytype that immediately preceeds 'edge' in AEL
        while (e != null
            && (e.polyTyp != edge.polyTyp || e.windDelta == 0)) {
            e = e.prevInAEL;
        }
        if (e == null) {
            var pft = void 0;
            pft = edge.polyTyp == PolyType.ptSubject ? this.m_SubjFillType : this.m_ClipFillType;
            if (edge.windDelta == 0) {
                edge.windCnt = pft == PolyFillType.pftNegative ? -1 : 1;
            }
            else {
                edge.windCnt = edge.windDelta;
            }
            edge.windCnt2 = 0;
            e = this.m_ActiveEdges; //ie get ready to calc WindCnt2
        }
        else if (edge.windDelta == 0 && this.m_ClipType != ClipType.ctUnion) {
            edge.windCnt = 1;
            edge.windCnt2 = e.windCnt2;
            e = e.nextInAEL; //ie get ready to calc WindCnt2
        }
        else if (this.IsEvenOddFillType(edge)) {
            //EvenOdd filling ...
            if (edge.windDelta == 0) {
                //are we inside a subj polygon ...
                var Inside = true;
                var e2 = e.prevInAEL;
                while (e2 != null) {
                    if (e2.polyTyp == e.polyTyp && e2.windDelta != 0) {
                        Inside = !Inside;
                    }
                    e2 = e2.prevInAEL;
                }
                edge.windCnt = Inside ? 0 : 1;
            }
            else {
                edge.windCnt = edge.windDelta;
            }
            edge.windCnt2 = e.windCnt2;
            e = e.nextInAEL; //ie get ready to calc WindCnt2
        }
        else {
            //nonZero, Positive or Negative filling ...
            if (e.windCnt * e.windDelta < 0) {
                //prev edge is 'decreasing' WindCount (WC) toward zero
                //so we're outside the previous polygon ...
                if (Math.abs(e.windCnt) > 1) {
                    //outside prev poly but still inside another.
                    //when reversing direction of prev poly use the same WC
                    if (e.windDelta * edge.windDelta < 0) {
                        edge.windCnt = e.windCnt;
                        //otherwise continue to 'decrease' WC ...
                    }
                    else {
                        edge.windCnt = e.windCnt + edge.windDelta;
                    }
                }
                else {
                    //now outside all polys of same polytype so set own WC ...
                    edge.windCnt = (edge.windDelta == 0 ? 1 : edge.windDelta);
                }
            }
            else {
                //prev edge is 'increasing' WindCount (WC) away from zero
                //so we're inside the previous polygon ...
                if (edge.windDelta == 0) {
                    edge.windCnt = e.windCnt < 0 ? e.windCnt - 1 : e.windCnt + 1;
                    //if wind direction is reversing prev then use same WC
                }
                else if (e.windDelta * edge.windDelta < 0) {
                    edge.windCnt = e.windCnt;
                    //otherwise add to WC ...
                }
                else {
                    edge.windCnt = e.windCnt + edge.windDelta;
                }
            }
            edge.windCnt2 = e.windCnt2;
            e = e.nextInAEL; //ie get ready to calc WindCnt2
        }
        //update WindCnt2 ...
        if (this.IsEvenOddAltFillType(edge)) {
            //EvenOdd filling ...
            while (e != edge) {
                if (e.windDelta != 0) {
                    edge.windCnt2 = edge.windCnt2 == 0 ? 1 : 0;
                }
                e = e.nextInAEL;
            }
        }
        else {
            //nonZero, Positive or Negative filling ...
            while (e != edge) {
                edge.windCnt2 += e.windDelta;
                e = e.nextInAEL;
            }
        }
    };
    Clipper.prototype.AddEdgeToSEL = function (edge) {
        //SEL pointers in PEdge are use to build transient lists of horizontal edges.
        //However, since we don't need to worry about processing order, all additions
        //are made to the front of the list ...
        if (this.m_SortedEdges == null) {
            this.m_SortedEdges = edge;
            edge.prevInSEL = null;
            edge.nextInSEL = null;
        }
        else {
            edge.nextInSEL = this.m_SortedEdges;
            edge.prevInSEL = null;
            this.m_SortedEdges.prevInSEL = edge;
            this.m_SortedEdges = edge;
        }
    };
    Clipper.prototype.PopEdgeFromSEL = function () {
        //Pop edge from front of SEL (ie SEL is a FILO list)
        if (this.m_SortedEdges == null) {
            return null;
        }
        var oldE = this.m_SortedEdges;
        this.m_SortedEdges = this.m_SortedEdges.nextInSEL;
        if (this.m_SortedEdges != null) {
            this.m_SortedEdges.prevInSEL = null;
        }
        oldE.nextInSEL = null;
        oldE.prevInSEL = null;
        return oldE;
    };
    Clipper.prototype.CopyAELToSEL = function () {
        var e = this.m_ActiveEdges;
        this.m_SortedEdges = e;
        while (e != null) {
            e.prevInSEL = e.prevInAEL;
            e.nextInSEL = e.nextInAEL;
            e = e.nextInAEL;
        }
    };
    Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2) {
        if (edge1.nextInSEL == null && edge1.prevInSEL == null) {
            return;
        }
        if (edge2.nextInSEL == null && edge2.prevInSEL == null) {
            return;
        }
        if (edge1.nextInSEL == edge2) {
            var next = edge2.nextInSEL;
            if (next != null) {
                next.prevInSEL = edge1;
            }
            var prev = edge1.prevInSEL;
            if (prev != null) {
                prev.nextInSEL = edge2;
            }
            edge2.prevInSEL = prev;
            edge2.nextInSEL = edge1;
            edge1.prevInSEL = edge2;
            edge1.nextInSEL = next;
        }
        else if (edge2.nextInSEL == edge1) {
            var next = edge1.nextInSEL;
            if (next != null) {
                next.prevInSEL = edge2;
            }
            var prev = edge2.prevInSEL;
            if (prev != null) {
                prev.nextInSEL = edge1;
            }
            edge1.prevInSEL = prev;
            edge1.nextInSEL = edge2;
            edge2.prevInSEL = edge1;
            edge2.nextInSEL = next;
        }
        else {
            var next = edge1.nextInSEL;
            var prev = edge1.prevInSEL;
            edge1.nextInSEL = edge2.nextInSEL;
            if (edge1.nextInSEL != null) {
                edge1.nextInSEL.prevInSEL = edge1;
            }
            edge1.prevInSEL = edge2.prevInSEL;
            if (edge1.prevInSEL != null) {
                edge1.prevInSEL.nextInSEL = edge1;
            }
            edge2.nextInSEL = next;
            if (edge2.nextInSEL != null) {
                edge2.nextInSEL.prevInSEL = edge2;
            }
            edge2.prevInSEL = prev;
            if (edge2.prevInSEL != null) {
                edge2.prevInSEL.nextInSEL = edge2;
            }
        }
        if (edge1.prevInSEL == null) {
            this.m_SortedEdges = edge1;
        }
        else if (edge2.prevInSEL == null) {
            this.m_SortedEdges = edge2;
        }
    };
    Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt) {
        this.AddOutPt(e1, pt);
        if (e2.windDelta == 0) {
            this.AddOutPt(e2, pt);
        }
        if (e1.outIdx == e2.outIdx) {
            e1.outIdx = Unassigned;
            e2.outIdx = Unassigned;
        }
        else if (e1.outIdx < e2.outIdx) {
            this.AppendPolygon(e1, e2);
        }
        else {
            this.AppendPolygon(e2, e1);
        }
    };
    Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt) {
        var result;
        var e;
        var prevE;
        if (IsHorizontal(e2) || e1.dx > e2.dx) {
            result = this.AddOutPt(e1, pt);
            e2.outIdx = e1.outIdx;
            e1.side = EdgeSide.esLeft;
            e2.side = EdgeSide.esRight;
            e = e1;
            if (e.prevInAEL == e2) {
                prevE = e2.prevInAEL;
            }
            else {
                prevE = e.prevInAEL;
            }
        }
        else {
            result = this.AddOutPt(e2, pt);
            e1.outIdx = e2.outIdx;
            e1.side = EdgeSide.esRight;
            e2.side = EdgeSide.esLeft;
            e = e2;
            if (e.prevInAEL == e1)
                prevE = e1.prevInAEL;
            else
                prevE = e.prevInAEL;
        }
        if (prevE != null
            && prevE.outIdx >= 0
            && prevE.top.y < pt.y
            && e.top.y < pt.y) {
            var xPrev = TopX(prevE, pt.y);
            var xE = TopX(e, pt.y);
            if (fltEquals(xPrev, xE)
                && e.windDelta != 0
                && prevE.windDelta != 0
                && SlopesEqual4P(new ClipPoint(xPrev, pt.y), prevE.top, new ClipPoint(xE, pt.y), e.top)) {
                var outPt = this.AddOutPt(prevE, pt);
                this.AddJoin(result, outPt, e.top);
            }
        }
        return result;
    };
    Clipper.prototype.AddOutPt = function (e, pt) {
        if (e.outIdx < 0) {
            var outRec = this.CreateOutRec();
            outRec.isOpen = (e.windDelta == 0);
            var newOp = new OutPt();
            outRec.pts = newOp;
            newOp.idx = outRec.idx;
            newOp.pt = new ClipPoint(pt.x, pt.y);
            newOp.next = newOp;
            newOp.prev = newOp;
            if (!outRec.isOpen) {
                this.SetHoleState(e, outRec);
            }
            e.outIdx = outRec.idx; //nb: do this after SetZ !
            return newOp;
        }
        else {
            var outRec = this.m_PolyOuts[e.outIdx];
            //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'
            var op = outRec.pts;
            var ToFront = (e.side == EdgeSide.esLeft);
            if (ToFront && pt.equals(op.pt)) {
                return op;
            }
            else if (!ToFront && pt.equals(op.prev.pt)) {
                return op.prev;
            }
            var newOp = new OutPt();
            newOp.idx = outRec.idx;
            newOp.pt = new ClipPoint(pt.x, pt.y);
            newOp.next = op;
            newOp.prev = op.prev;
            newOp.prev.next = newOp;
            op.prev = newOp;
            if (ToFront) {
                outRec.pts = newOp;
            }
            return newOp;
        }
    };
    Clipper.prototype.GetLastOutPt = function (e) {
        var outRec = this.m_PolyOuts[e.outIdx];
        if (e.side == EdgeSide.esLeft) {
            return outRec.pts;
        }
        return outRec.pts.prev;
    };
    Clipper.prototype.SetHoleState = function (e, outRec) {
        var e2 = e.prevInAEL;
        var eTmp = null;
        while (e2 != null) {
            if (e2.outIdx >= 0 && e2.windDelta != 0) {
                if (eTmp == null) {
                    eTmp = e2;
                }
                else if (eTmp.outIdx == e2.outIdx) {
                    eTmp = null; //paired
                }
            }
            e2 = e2.prevInAEL;
        }
        if (eTmp == null) {
            outRec.firstLeft = null;
            outRec.isHole = false;
        }
        else {
            outRec.firstLeft = this.m_PolyOuts[eTmp.outIdx];
            outRec.isHole = !outRec.firstLeft.isHole;
        }
    };
    Clipper.prototype.GetOutRec = function (idx) {
        var outrec = this.m_PolyOuts[idx];
        while (outrec != this.m_PolyOuts[outrec.idx]) {
            outrec = this.m_PolyOuts[outrec.idx];
        }
        return outrec;
    };
    Clipper.prototype.AppendPolygon = function (e1, e2) {
        var outRec1 = this.m_PolyOuts[e1.outIdx];
        var outRec2 = this.m_PolyOuts[e2.outIdx];
        var holeStateRec;
        if (OutRec1RightOfOutRec2(outRec1, outRec2)) {
            holeStateRec = outRec2;
        }
        else if (OutRec1RightOfOutRec2(outRec2, outRec1)) {
            holeStateRec = outRec1;
        }
        else {
            holeStateRec = GetLowermostRec(outRec1, outRec2);
        }
        //get the start and ends of both output polygons and
        //join E2 poly onto E1 poly and delete pointers to E2 ...
        var p1_lft = outRec1.pts;
        var p1_rt = p1_lft.prev;
        var p2_lft = outRec2.pts;
        var p2_rt = p2_lft.prev;
        //join e2 poly onto e1 poly and delete pointers to e2 ...
        if (e1.side == EdgeSide.esLeft) {
            if (e2.side == EdgeSide.esLeft) {
                //z y x a b c
                ReversePolyPtLinks(p2_lft);
                p2_lft.next = p1_lft;
                p1_lft.prev = p2_lft;
                p1_rt.next = p2_rt;
                p2_rt.prev = p1_rt;
                outRec1.pts = p2_rt;
            }
            else {
                //x y z a b c
                p2_rt.next = p1_lft;
                p1_lft.prev = p2_rt;
                p2_lft.prev = p1_rt;
                p1_rt.next = p2_lft;
                outRec1.pts = p2_lft;
            }
        }
        else {
            if (e2.side == EdgeSide.esRight) {
                //a b c z y x
                ReversePolyPtLinks(p2_lft);
                p1_rt.next = p2_rt;
                p2_rt.prev = p1_rt;
                p2_lft.next = p1_lft;
                p1_lft.prev = p2_lft;
            }
            else {
                //a b c x y z
                p1_rt.next = p2_lft;
                p2_lft.prev = p1_rt;
                p1_lft.prev = p2_rt;
                p2_rt.next = p1_lft;
            }
        }
        outRec1.bottomPt = null;
        if (holeStateRec == outRec2) {
            if (outRec2.firstLeft != outRec1) {
                outRec1.firstLeft = outRec2.firstLeft;
            }
            outRec1.isHole = outRec2.isHole;
        }
        outRec2.pts = null;
        outRec2.bottomPt = null;
        outRec2.firstLeft = outRec1;
        var OKIdx = e1.outIdx;
        var ObsoleteIdx = e2.outIdx;
        e1.outIdx = Unassigned; //nb: safe because we only get here via AddLocalMaxPoly
        e2.outIdx = Unassigned;
        var e = this.m_ActiveEdges;
        while (e != null) {
            if (e.outIdx == ObsoleteIdx) {
                e.outIdx = OKIdx;
                e.side = e1.side;
                break;
            }
            e = e.nextInAEL;
        }
        outRec2.idx = outRec1.idx;
    };
    Clipper.prototype.IntersectEdges = function (e1, e2, pt) {
        //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before
        //e2 in AEL except when e1 is being inserted at the intersection point ...
        var e1Contributing = (e1.outIdx >= 0);
        var e2Contributing = (e2.outIdx >= 0);
        //if either edge is on an OPEN path ...
        if (e1.windDelta == 0 || e2.windDelta == 0) {
            //ignore subject-subject open path intersections UNLESS they
            //are both open paths, AND they are both 'contributing maximas' ...
            if (e1.windDelta == 0 && e2.windDelta == 0) {
                return;
            }
            else if (e1.polyTyp == e2.polyTyp
                && e1.windDelta != e2.windDelta
                && this.m_ClipType == ClipType.ctUnion) { //if intersecting a subj line with a subj poly ...
                if (e1.windDelta == 0) {
                    if (e2Contributing) {
                        this.AddOutPt(e1, pt);
                        if (e1Contributing) {
                            e1.outIdx = Unassigned;
                        }
                    }
                }
                else {
                    if (e1Contributing) {
                        this.AddOutPt(e2, pt);
                        if (e2Contributing) {
                            e2.outIdx = Unassigned;
                        }
                    }
                }
            }
            else if (e1.polyTyp != e2.polyTyp) {
                if (e1.windDelta == 0
                    && Math.abs(e2.windCnt) == 1
                    && (this.m_ClipType != ClipType.ctUnion || e2.windCnt2 == 0)) {
                    this.AddOutPt(e1, pt);
                    if (e1Contributing) {
                        e1.outIdx = Unassigned;
                    }
                }
                else if (e2.windDelta == 0
                    && Math.abs(e1.windCnt) == 1
                    && (this.m_ClipType != ClipType.ctUnion || e1.windCnt2 == 0)) {
                    this.AddOutPt(e2, pt);
                    if (e2Contributing) {
                        e2.outIdx = Unassigned;
                    }
                }
            }
            return;
        }
        //update winding counts...
        //assumes that e1 will be to the Right of e2 ABOVE the intersection
        if (e1.polyTyp == e2.polyTyp) {
            if (this.IsEvenOddFillType(e1)) {
                var oldE1WindCnt = e1.windCnt;
                e1.windCnt = e2.windCnt;
                e2.windCnt = oldE1WindCnt;
            }
            else {
                if (e1.windCnt + e2.windDelta == 0) {
                    e1.windCnt = -e1.windCnt;
                }
                else {
                    e1.windCnt += e2.windDelta;
                }
                if (e2.windCnt - e1.windDelta == 0) {
                    e2.windCnt = -e2.windCnt;
                }
                else {
                    e2.windCnt -= e1.windDelta;
                }
            }
        }
        else {
            if (!this.IsEvenOddFillType(e2)) {
                e1.windCnt2 += e2.windDelta;
            }
            else {
                e1.windCnt2 = (e1.windCnt2 == 0) ? 1 : 0;
            }
            if (!this.IsEvenOddFillType(e1)) {
                e2.windCnt2 -= e1.windDelta;
            }
            else {
                e2.windCnt2 = (e2.windCnt2 == 0) ? 1 : 0;
            }
        }
        var e1FillType;
        var e2FillType;
        var e1FillType2;
        var e2FillType2;
        if (e1.polyTyp == PolyType.ptSubject) {
            e1FillType = this.m_SubjFillType;
            e1FillType2 = this.m_ClipFillType;
        }
        else {
            e1FillType = this.m_ClipFillType;
            e1FillType2 = this.m_SubjFillType;
        }
        if (e2.polyTyp == PolyType.ptSubject) {
            e2FillType = this.m_SubjFillType;
            e2FillType2 = this.m_ClipFillType;
        }
        else {
            e2FillType = this.m_ClipFillType;
            e2FillType2 = this.m_SubjFillType;
        }
        var e1Wc;
        var e2Wc;
        switch (e1FillType) {
            case PolyFillType.pftPositive:
                e1Wc = e1.windCnt;
                break;
            case PolyFillType.pftNegative:
                e1Wc = -e1.windCnt;
                break;
            default:
                e1Wc = Math.abs(e1.windCnt);
                break;
        }
        switch (e2FillType) {
            case PolyFillType.pftPositive:
                e2Wc = e2.windCnt;
                break;
            case PolyFillType.pftNegative:
                e2Wc = -e2.windCnt;
                break;
            default:
                e2Wc = Math.abs(e2.windCnt);
                break;
        }
        if (e1Contributing && e2Contributing) {
            if ((e1Wc != 0 && e1Wc != 1)
                || (e2Wc != 0 && e2Wc != 1)
                || (e1.polyTyp != e2.polyTyp && this.m_ClipType != ClipType.ctXor)) {
                this.AddLocalMaxPoly(e1, e2, pt);
            }
            else {
                this.AddOutPt(e1, pt);
                this.AddOutPt(e2, pt);
                SwapSides(e1, e2);
                SwapPolyIndexes(e1, e2);
            }
        }
        else if (e1Contributing) {
            if (e2Wc == 0 || e2Wc == 1) {
                this.AddOutPt(e1, pt);
                SwapSides(e1, e2);
                SwapPolyIndexes(e1, e2);
            }
        }
        else if (e2Contributing) {
            if (e1Wc == 0 || e1Wc == 1) {
                this.AddOutPt(e2, pt);
                SwapSides(e1, e2);
                SwapPolyIndexes(e1, e2);
            }
        }
        else if ((e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1)) {
            //neither edge is currently contributing ...
            var e1Wc2 = void 0;
            var e2Wc2 = void 0;
            switch (e1FillType2) {
                case PolyFillType.pftPositive:
                    e1Wc2 = e1.windCnt2;
                    break;
                case PolyFillType.pftNegative:
                    e1Wc2 = -e1.windCnt2;
                    break;
                default:
                    e1Wc2 = Math.abs(e1.windCnt2);
                    break;
            }
            switch (e2FillType2) {
                case PolyFillType.pftPositive:
                    e2Wc2 = e2.windCnt2;
                    break;
                case PolyFillType.pftNegative:
                    e2Wc2 = -e2.windCnt2;
                    break;
                default:
                    e2Wc2 = Math.abs(e2.windCnt2);
                    break;
            }
            if (e1.polyTyp != e2.polyTyp) {
                this.AddLocalMinPoly(e1, e2, pt);
            }
            else if (e1Wc == 1 && e2Wc == 1) {
                switch (this.m_ClipType) {
                    case ClipType.ctIntersection:
                        if (e1Wc2 > 0 && e2Wc2 > 0) {
                            this.AddLocalMinPoly(e1, e2, pt);
                        }
                        break;
                    case ClipType.ctUnion:
                        if (e1Wc2 <= 0 && e2Wc2 <= 0) {
                            this.AddLocalMinPoly(e1, e2, pt);
                        }
                        break;
                    case ClipType.ctDifference:
                        if ((e1.polyTyp == PolyType.ptClip && e1Wc2 > 0 && e2Wc2 > 0)
                            || (e1.polyTyp == PolyType.ptSubject && e1Wc2 <= 0 && e2Wc2 <= 0)) {
                            this.AddLocalMinPoly(e1, e2, pt);
                        }
                        break;
                    case ClipType.ctXor:
                        this.AddLocalMinPoly(e1, e2, pt);
                        break;
                }
            }
            else {
                SwapSides(e1, e2);
            }
        }
    };
    Clipper.prototype.DeleteFromSEL = function (e) {
        var SelPrev = e.prevInSEL;
        var SelNext = e.nextInSEL;
        if (SelPrev == null && SelNext == null && (e != this.m_SortedEdges)) {
            return; //already deleted
        }
        if (SelPrev != null) {
            SelPrev.nextInSEL = SelNext;
        }
        else {
            this.m_SortedEdges = SelNext;
        }
        if (SelNext != null) {
            SelNext.prevInSEL = SelPrev;
        }
        e.nextInSEL = null;
        e.prevInSEL = null;
    };
    Clipper.prototype.ProcessHorizontals = function () {
        var horzEdge; //m_SortedEdges;
        while ((horzEdge = this.PopEdgeFromSEL()) != null) {
            this.ProcessHorizontal(horzEdge);
        }
    };
    Clipper.prototype.ProcessHorizontal = function (horzEdge) {
        var dir;
        var horzLeft;
        var horzRight;
        var IsOpen = horzEdge.windDelta == 0;
        var r = GetHorzDirection(horzEdge);
        dir = r.Dir;
        horzLeft = r.Left;
        horzRight = r.Right;
        var eLastHorz = horzEdge;
        var eMaxPair = null;
        while (eLastHorz.nextInLML != null
            && IsHorizontal(eLastHorz.nextInLML)) {
            eLastHorz = eLastHorz.nextInLML;
        }
        if (eLastHorz.nextInLML == null) {
            eMaxPair = GetMaximaPair(eLastHorz);
        }
        var currMax = this.m_Maxima;
        if (currMax != null) {
            //get the first maxima in range (X) ...
            if (dir == Direction.dLeftToRight) {
                while (currMax != null && currMax.x < horzEdge.bot.x) {
                    currMax = currMax.next;
                }
                if (currMax != null && currMax.x >= eLastHorz.top.x) {
                    currMax = null;
                }
            }
            else {
                while (currMax.next != null && currMax.next.x < horzEdge.bot.x) {
                    currMax = currMax.next;
                }
                if (currMax.x <= eLastHorz.top.x) {
                    currMax = null;
                }
            }
        }
        var op1 = null;
        for (;;) { //loop through consec. horizontal edges
            var IsLastHorz = (horzEdge == eLastHorz);
            var e = GetNextInAEL(horzEdge, dir);
            while (e != null) {
                //this code block inserts extra coords into horizontal edges (in output
                //polygons) whereever maxima touch these horizontal edges. This helps
                //'simplifying' polygons (ie if the Simplify property is set).
                if (currMax != null) {
                    if (dir == Direction.dLeftToRight) {
                        while (currMax != null && currMax.x < e.curr.x) {
                            if (horzEdge.outIdx >= 0 && !IsOpen) {
                                this.AddOutPt(horzEdge, new ClipPoint(currMax.x, horzEdge.bot.y));
                            }
                            currMax = currMax.next;
                        }
                    }
                    else {
                        while (currMax != null && currMax.x > e.curr.x) {
                            if (horzEdge.outIdx >= 0 && !IsOpen) {
                                this.AddOutPt(horzEdge, new ClipPoint(currMax.x, horzEdge.bot.y));
                            }
                            currMax = currMax.prev;
                        }
                    }
                }
                if ((dir == Direction.dLeftToRight && e.curr.x > horzRight)
                    || (dir == Direction.dRightToLeft && e.curr.x < horzLeft)) {
                    break;
                }
                //Also break if we've got to the end of an intermediate horizontal edge ...
                //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.
                if (fltEquals(e.curr.x, horzEdge.top.x)
                    && horzEdge.nextInLML != null
                    && e.dx < horzEdge.nextInLML.dx) {
                    break;
                }
                if (horzEdge.outIdx >= 0 && !IsOpen) { //note: may be done multiple times
                    op1 = this.AddOutPt(horzEdge, e.curr);
                    var eNextHorz = this.m_SortedEdges;
                    while (eNextHorz != null) {
                        if (eNextHorz.outIdx >= 0 &&
                            HorzSegmentsOverlap(horzEdge.bot.x, horzEdge.top.x, eNextHorz.bot.x, eNextHorz.top.x)) {
                            var op2 = this.GetLastOutPt(eNextHorz);
                            this.AddJoin(op2, op1, eNextHorz.top);
                        }
                        eNextHorz = eNextHorz.nextInSEL;
                    }
                    this.AddGhostJoin(op1, horzEdge.bot);
                }
                //OK, so far we're still in range of the horizontal Edge  but make sure
                //we're at the last of consec. horizontals when matching with eMaxPair
                if (e == eMaxPair && IsLastHorz) {
                    if (horzEdge.outIdx >= 0) {
                        this.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.top);
                    }
                    this.DeleteFromAEL(horzEdge);
                    this.DeleteFromAEL(eMaxPair);
                    return;
                }
                if (dir == Direction.dLeftToRight) {
                    var Pt = new ClipPoint(e.curr.x, horzEdge.curr.y);
                    this.IntersectEdges(horzEdge, e, Pt);
                }
                else {
                    var Pt = new ClipPoint(e.curr.x, horzEdge.curr.y);
                    this.IntersectEdges(e, horzEdge, Pt);
                }
                var eNext = GetNextInAEL(e, dir);
                this.SwapPositionsInAEL(horzEdge, e);
                e = eNext;
            } //end while(e != null)
            //Break out of loop if HorzEdge.NextInLML is not also horizontal ...
            if (horzEdge.nextInLML == null || !IsHorizontal(horzEdge.nextInLML)) {
                break;
            }
            horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
            if (horzEdge.outIdx >= 0) {
                this.AddOutPt(horzEdge, horzEdge.bot);
            }
            r = GetHorzDirection(horzEdge);
            dir = r.Dir;
            horzLeft = r.Left;
            horzRight = r.Right;
        } //end for (;;)
        if (horzEdge.outIdx >= 0 && op1 == null) {
            op1 = this.GetLastOutPt(horzEdge);
            var eNextHorz = this.m_SortedEdges;
            while (eNextHorz != null) {
                if (eNextHorz.outIdx >= 0
                    && HorzSegmentsOverlap(horzEdge.bot.x, horzEdge.top.x, eNextHorz.bot.x, eNextHorz.top.x)) {
                    var op2 = this.GetLastOutPt(eNextHorz);
                    this.AddJoin(op2, op1, eNextHorz.top);
                }
                eNextHorz = eNextHorz.nextInSEL;
            }
            this.AddGhostJoin(op1, horzEdge.top);
        }
        if (horzEdge.nextInLML != null) {
            if (horzEdge.outIdx >= 0) {
                op1 = this.AddOutPt(horzEdge, horzEdge.top);
                horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
                if (horzEdge.windDelta == 0) {
                    return;
                }
                //nb: HorzEdge is no longer horizontal here
                var ePrev = horzEdge.prevInAEL;
                var eNext = horzEdge.nextInAEL;
                if (ePrev != null
                    && fltEquals(ePrev.curr.x, horzEdge.bot.x)
                    && fltEquals(ePrev.curr.y, horzEdge.bot.y)
                    && ePrev.windDelta != 0
                    && ePrev.outIdx >= 0
                    && ePrev.curr.y > ePrev.top.y
                    && SlopesEqual2E(horzEdge, ePrev)) {
                    var op2 = this.AddOutPt(ePrev, horzEdge.bot);
                    this.AddJoin(op1, op2, horzEdge.top);
                }
                else if (eNext != null
                    && fltEquals(eNext.curr.x, horzEdge.bot.x)
                    && fltEquals(eNext.curr.y, horzEdge.bot.y)
                    && eNext.windDelta != 0
                    && eNext.outIdx >= 0
                    && eNext.curr.y > eNext.top.y
                    && SlopesEqual2E(horzEdge, eNext)) {
                    var op2 = this.AddOutPt(eNext, horzEdge.bot);
                    this.AddJoin(op1, op2, horzEdge.top);
                }
            }
            else {
                horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
            }
        }
        else {
            if (horzEdge.outIdx >= 0) {
                this.AddOutPt(horzEdge, horzEdge.top);
            }
            this.DeleteFromAEL(horzEdge);
        }
    };
    Clipper.prototype.ProcessIntersections = function (topY) {
        if (this.m_ActiveEdges == null) {
            return true;
        }
        try {
            this.BuildIntersectList(topY);
            if (this.m_IntersectList.length == 0) {
                return true;
            }
            if (this.m_IntersectList.length == 1
                || this.FixupIntersectionOrder()) {
                this.ProcessIntersectList();
            }
            else {
                return false;
            }
        }
        catch (e) {
            this.m_SortedEdges = null;
            this.m_IntersectList.length = 0;
            throw new Error("ProcessIntersections error");
        }
        this.m_SortedEdges = null;
        return true;
    };
    Clipper.prototype.BuildIntersectList = function (topY) {
        if (this.m_ActiveEdges == null) {
            return;
        }
        //prepare for sorting ...
        var e = this.m_ActiveEdges;
        this.m_SortedEdges = e;
        while (e != null) {
            e.prevInSEL = e.prevInAEL;
            e.nextInSEL = e.nextInAEL;
            e.curr = new ClipPoint(TopX(e, topY), e.curr.y);
            e = e.nextInAEL;
        }
        //bubblesort ...
        var isModified = true;
        while (isModified && this.m_SortedEdges != null) {
            isModified = false;
            e = this.m_SortedEdges;
            while (e.nextInSEL != null) {
                var eNext = e.nextInSEL;
                var pt = void 0;
                if (e.curr.x > eNext.curr.x) {
                    pt = IntersectPoint(e, eNext);
                    if (pt.y < topY) {
                        pt = new ClipPoint(TopX(e, topY), topY);
                    }
                    this.m_IntersectList.push(new IntersectNode(e, eNext, pt));
                    this.SwapPositionsInSEL(e, eNext);
                    isModified = true;
                }
                else {
                    e = eNext;
                }
            }
            if (e.prevInSEL != null) {
                e.prevInSEL.nextInSEL = null;
            }
            else {
                break;
            }
        }
        this.m_SortedEdges = null;
    };
    Clipper.prototype.FixupIntersectionOrder = function () {
        //pre-condition: intersections are sorted bottom-most first.
        //Now it's crucial that intersections are made only between adjacent edges,
        //so to ensure this the order of intersections may need adjusting ...
        this.m_IntersectList.sort(MyIntersectNodeSort);
        this.CopyAELToSEL();
        var cnt = this.m_IntersectList.length;
        for (var i = 0; i < cnt; i++) {
            if (!EdgesAdjacent(this.m_IntersectList[i])) {
                var j = i + 1;
                while (j < cnt && !EdgesAdjacent(this.m_IntersectList[j])) {
                    j++;
                }
                if (j == cnt) {
                    return false;
                }
                var tmp = this.m_IntersectList[i];
                this.m_IntersectList[i] = this.m_IntersectList[j];
                this.m_IntersectList[j] = tmp;
            }
            this.SwapPositionsInSEL(this.m_IntersectList[i].edge1, this.m_IntersectList[i].edge2);
        }
        return true;
    };
    Clipper.prototype.ProcessIntersectList = function () {
        for (var _i = 0, _a = this.m_IntersectList; _i < _a.length; _i++) {
            var iNode = _a[_i];
            this.IntersectEdges(iNode.edge1, iNode.edge2, iNode.pt);
            this.SwapPositionsInAEL(iNode.edge1, iNode.edge2);
        }
        this.m_IntersectList.length = 0;
    };
    Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY) {
        var e = this.m_ActiveEdges;
        while (e != null) {
            //1. process maxima, treating them as if they're 'bent' horizontal edges,
            //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.
            var IsMaximaEdge = IsMaxima(e, topY);
            if (IsMaximaEdge) {
                var eMaxPair = GetMaximaPairEx(e);
                IsMaximaEdge = (eMaxPair == null || !IsHorizontal(eMaxPair));
            }
            if (IsMaximaEdge) {
                if (this.StrictlySimple) {
                    this.InsertMaxima(e.top.x);
                }
                var ePrev = e.prevInAEL;
                this.DoMaxima(e);
                if (ePrev == null) {
                    e = this.m_ActiveEdges;
                }
                else {
                    e = ePrev.nextInAEL;
                }
            }
            else {
                //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...
                if (IsIntermediate(e, topY) && IsHorizontal(e.nextInLML)) {
                    e = this.UpdateEdgeIntoAEL(e);
                    if (e.outIdx >= 0) {
                        this.AddOutPt(e, e.bot);
                    }
                    this.AddEdgeToSEL(e);
                }
                else {
                    e.curr = new ClipPoint(TopX(e, topY), topY);
                }
                //When StrictlySimple and 'e' is being touched by another edge, then
                //make sure both edges have a vertex here ...
                if (this.StrictlySimple) {
                    var ePrev = e.prevInAEL;
                    if (e.outIdx >= 0
                        && e.windDelta != 0
                        && ePrev != null
                        && ePrev.outIdx >= 0
                        && fltEquals(ePrev.curr.x, e.curr.x)
                        && ePrev.windDelta != 0) {
                        var ip = new ClipPoint(e.curr.x, e.curr.y);
                        var op = this.AddOutPt(ePrev, ip);
                        var op2 = this.AddOutPt(e, ip);
                        this.AddJoin(op, op2, ip); //StrictlySimple (type-3) join
                    }
                }
                e = e.nextInAEL;
            }
        }
        //3. Process horizontals at the Top of the scanbeam ...
        this.ProcessHorizontals();
        this.m_Maxima = null;
        //4. Promote intermediate vertices ...
        e = this.m_ActiveEdges;
        while (e != null) {
            if (IsIntermediate(e, topY)) {
                var op = null;
                if (e.outIdx >= 0) {
                    op = this.AddOutPt(e, e.top);
                }
                e = this.UpdateEdgeIntoAEL(e);
                //if output polygons share an edge, they'll need joining later ...
                var ePrev = e.prevInAEL;
                var eNext = e.nextInAEL;
                if (ePrev != null
                    && fltEquals(ePrev.curr.x, e.bot.x)
                    && fltEquals(ePrev.curr.y, e.bot.y)
                    && op != null
                    && ePrev.outIdx >= 0
                    && ePrev.curr.y > ePrev.top.y
                    && SlopesEqual4P(e.curr, e.top, ePrev.curr, ePrev.top)
                    && e.windDelta != 0
                    && ePrev.windDelta != 0) {
                    var op2 = this.AddOutPt(ePrev, e.bot);
                    this.AddJoin(op, op2, e.top);
                }
                else if (eNext != null
                    && fltEquals(eNext.curr.x, e.bot.x)
                    && fltEquals(eNext.curr.y, e.bot.y)
                    && op != null
                    && eNext.outIdx >= 0
                    && eNext.curr.y > eNext.top.y
                    && SlopesEqual4P(e.curr, e.top, eNext.curr, eNext.top)
                    && e.windDelta != 0
                    && eNext.windDelta != 0) {
                    var op2 = this.AddOutPt(eNext, e.bot);
                    this.AddJoin(op, op2, e.top);
                }
            }
            e = e.nextInAEL;
        }
    };
    Clipper.prototype.DoMaxima = function (e) {
        var eMaxPair = GetMaximaPairEx(e);
        if (eMaxPair == null) {
            if (e.outIdx >= 0) {
                this.AddOutPt(e, e.top);
            }
            this.DeleteFromAEL(e);
            return;
        }
        var eNext = e.nextInAEL;
        while (eNext != null && eNext != eMaxPair) {
            this.IntersectEdges(e, eNext, e.top);
            this.SwapPositionsInAEL(e, eNext);
            eNext = e.nextInAEL;
        }
        if (e.outIdx == Unassigned && eMaxPair.outIdx == Unassigned) {
            this.DeleteFromAEL(e);
            this.DeleteFromAEL(eMaxPair);
        }
        else if (e.outIdx >= 0 && eMaxPair.outIdx >= 0) {
            if (e.outIdx >= 0) {
                this.AddLocalMaxPoly(e, eMaxPair, e.top);
            }
            this.DeleteFromAEL(e);
            this.DeleteFromAEL(eMaxPair);
        }
        else if (e.windDelta == 0) {
            if (e.outIdx >= 0) {
                this.AddOutPt(e, e.top);
                e.outIdx = Unassigned;
            }
            this.DeleteFromAEL(e);
            if (eMaxPair.outIdx >= 0) {
                this.AddOutPt(eMaxPair, e.top);
                eMaxPair.outIdx = Unassigned;
            }
            this.DeleteFromAEL(eMaxPair);
        }
        else {
            throw new Error("DoMaxima error");
        }
    };
    Clipper.prototype.BuildResult = function (polyg) {
        polyg.Clear();
        //polyg.length = this.m_PolyOuts.length;
        for (var _i = 0, _a = this.m_PolyOuts; _i < _a.length; _i++) {
            var outRec = _a[_i];
            if (outRec.pts == null) {
                continue;
            }
            var p = outRec.pts.prev;
            var cnt = PointCount(p);
            if (cnt < 2) {
                continue;
            }
            var pg = new Array();
            for (var j = 0; j < cnt; j++) {
                pg.push(p.pt);
                p = p.prev;
            }
            var list = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
            for (var j = 0; j < pg.length; j++) {
                list.Add(pg[j]);
            }
            polyg.Add(list);
        }
    };
    Clipper.prototype.BuildResult2 = function (polytree) {
        polytree.clear();
        //add each output polygon/contour to polytree ...
        //polytree.m_AllPolys.length = this.m_PolyOuts.length;
        for (var _i = 0, _a = this.m_PolyOuts; _i < _a.length; _i++) {
            var outRec = _a[_i];
            var cnt = PointCount(outRec.pts);
            if ((outRec.isOpen && cnt < 2)
                || (!outRec.isOpen && cnt < 3)) {
                continue;
            }
            this.FixHoleLinkage(outRec);
            var pn = new PolyNode();
            polytree.allPolys.push(pn);
            outRec.polyNode = pn;
            //pn.m_polygon.length = cnt;
            var op = outRec.pts.prev;
            for (var j = 0; j < cnt; j++) {
                pn.polygon.Add(op.pt);
                op = op.prev;
            }
        }
        //fixup PolyNode links etc ...
        //polytree.m_Childs.length = m_PolyOuts.length;
        for (var _b = 0, _c = this.m_PolyOuts; _b < _c.length; _b++) {
            var outRec = _c[_b];
            if (outRec.polyNode == null) {
                continue;
            }
            else if (outRec.isOpen) {
                outRec.polyNode.isOpen = true;
                polytree.addChild(outRec.polyNode);
            }
            else if (outRec.firstLeft != null
                && outRec.firstLeft.polyNode != null) {
                outRec.firstLeft.polyNode.addChild(outRec.polyNode);
            }
            else {
                polytree.addChild(outRec.polyNode);
            }
        }
    };
    Clipper.prototype.FixupOutPolyline = function (outrec) {
        var pp = outrec.pts;
        var lastPP = pp.prev;
        while (pp !== lastPP) {
            pp = pp.next;
            if (pp.pt.equals(pp.prev.pt)) {
                if (pp === lastPP) {
                    lastPP = pp.prev;
                }
                var tmpPP = pp.prev;
                tmpPP.next = pp.next;
                pp.next.prev = tmpPP;
                pp = tmpPP;
            }
        }
        if (pp === pp.prev) {
            outrec.pts = null;
        }
    };
    Clipper.prototype.FixupOutPolygon = function (outRec) {
        //FixupOutPolygon() - removes duplicate points and simplifies consecutive
        //parallel edges by removing the middle vertex.
        var lastOK = null;
        outRec.bottomPt = null;
        var pp = outRec.pts;
        var preserveCol = this.PreserveCollinear || this.StrictlySimple;
        for (;;) {
            if (pp.prev == pp || pp.prev == pp.next) {
                outRec.pts = null;
                return;
            }
            //test for duplicate points and collinear edges ...
            if (pp.pt.equals(pp.next.pt)
                || pp.pt.equals(pp.prev.pt)
                || (SlopesEqual3P(pp.prev.pt, pp.pt, pp.next.pt)
                    && (!preserveCol || !Pt2IsBetweenPt1AndPt3(pp.prev.pt, pp.pt, pp.next.pt)))) {
                lastOK = null;
                pp.prev.next = pp.next;
                pp.next.prev = pp.prev;
                pp = pp.prev;
            }
            else if (pp === lastOK) {
                break;
            }
            else {
                if (lastOK == null) {
                    lastOK = pp;
                }
                pp = pp.next;
            }
        }
        outRec.pts = pp;
    };
    Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft) {
        var Dir1 = op1.pt.x > op1b.pt.x ?
            Direction.dRightToLeft : Direction.dLeftToRight;
        var Dir2 = op2.pt.x > op2b.pt.x ?
            Direction.dRightToLeft : Direction.dLeftToRight;
        if (Dir1 == Dir2) {
            return false;
        }
        //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we
        //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)
        //So, to facilitate this while inserting Op1b and Op2b ...
        //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,
        //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)
        if (Dir1 === Direction.dLeftToRight) {
            while (op1.next.pt.x <= Pt.x
                && op1.next.pt.x >= op1.pt.x
                && fltEquals(op1.next.pt.y, Pt.y)) {
                op1 = op1.next;
            }
            if (DiscardLeft && !fltEquals(op1.pt.x, Pt.x)) {
                op1 = op1.next;
            }
            op1b = DupOutPt(op1, !DiscardLeft);
            if (op1b.pt.notEquals(Pt)) {
                op1 = op1b;
                op1.pt = new ClipPoint(Pt.x, Pt.y);
                op1b = DupOutPt(op1, !DiscardLeft);
            }
        }
        else {
            while (op1.next.pt.x >= Pt.x
                && op1.next.pt.x <= op1.pt.x
                && fltEquals(op1.next.pt.y, Pt.y)) {
                op1 = op1.next;
            }
            if (!DiscardLeft && !fltEquals(op1.pt.x, Pt.x)) {
                op1 = op1.next;
            }
            op1b = DupOutPt(op1, DiscardLeft);
            if (op1b.pt.notEquals(Pt)) {
                op1 = op1b;
                op1.pt = new ClipPoint(Pt.x, Pt.y);
                op1b = DupOutPt(op1, DiscardLeft);
            }
        }
        if (Dir2 === Direction.dLeftToRight) {
            while (op2.next.pt.x <= Pt.x
                && op2.next.pt.x >= op2.pt.x
                && fltEquals(op2.next.pt.y, Pt.y)) {
                op2 = op2.next;
            }
            if (DiscardLeft && !fltEquals(op2.pt.x, Pt.x)) {
                op2 = op2.next;
            }
            op2b = DupOutPt(op2, !DiscardLeft);
            if (op2b.pt.notEquals(Pt)) {
                op2 = op2b;
                op2.pt = new ClipPoint(Pt.x, Pt.y);
                op2b = DupOutPt(op2, !DiscardLeft);
            }
        }
        else {
            while (op2.next.pt.x >= Pt.x
                && op2.next.pt.x <= op2.pt.x
                && fltEquals(op2.next.pt.y, Pt.y)) {
                op2 = op2.next;
            }
            if (!DiscardLeft && !fltEquals(op2.pt.x, Pt.x)) {
                op2 = op2.next;
            }
            op2b = DupOutPt(op2, DiscardLeft);
            if (op2b.pt.notEquals(Pt)) {
                op2 = op2b;
                op2.pt = new ClipPoint(Pt.x, Pt.y);
                op2b = DupOutPt(op2, DiscardLeft);
            }
        }
        if ((Dir1 === Direction.dLeftToRight) === DiscardLeft) {
            op1.prev = op2;
            op2.next = op1;
            op1b.next = op2b;
            op2b.prev = op1b;
        }
        else {
            op1.next = op2;
            op2.prev = op1;
            op1b.prev = op2b;
            op2b.next = op1b;
        }
        return true;
    };
    Clipper.prototype.JoinPoints = function (j, outRec1, outRec2) {
        var op1 = j.outPt1;
        var op1b;
        var op2 = j.outPt2;
        var op2b;
        //There are 3 kinds of joins for output polygons ...
        //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are vertices anywhere
        //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).
        //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same
        //location at the Bottom of the overlapping segment (& Join.OffPt is above).
        //3. StrictlySimple joins where edges touch but are not collinear and where
        //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.
        var isHorizontal = fltEquals(j.outPt1.pt.y, j.offPt.y);
        if (isHorizontal
            && j.offPt.equals(j.outPt1.pt)
            && j.offPt.equals(j.outPt2.pt)) {
            //Strictly Simple join ...
            if (outRec1 !== outRec2) {
                return false;
            }
            op1b = j.outPt1.next;
            while (op1b !== op1 && op1b.pt.equals(j.offPt)) {
                op1b = op1b.next;
            }
            var reverse1 = op1b.pt.y > j.offPt.y;
            op2b = j.outPt2.next;
            while (op2b !== op2 && op2b.pt.equals(j.offPt)) {
                op2b = op2b.next;
            }
            var reverse2 = op2b.pt.y > j.offPt.y;
            if (reverse1 === reverse2) {
                return false;
            }
            if (reverse1) {
                op1b = DupOutPt(op1, false);
                op2b = DupOutPt(op2, true);
                op1.prev = op2;
                op2.next = op1;
                op1b.next = op2b;
                op2b.prev = op1b;
                j.outPt1 = op1;
                j.outPt2 = op1b;
                return true;
            }
            else {
                op1b = DupOutPt(op1, true);
                op2b = DupOutPt(op2, false);
                op1.next = op2;
                op2.prev = op1;
                op1b.prev = op2b;
                op2b.next = op1b;
                j.outPt1 = op1;
                j.outPt2 = op1b;
                return true;
            }
        }
        else if (isHorizontal) {
            //treat horizontal joins differently to non-horizontal joins since with
            //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt
            //may be anywhere along the horizontal edge.
            op1b = op1;
            while (fltEquals(op1.prev.pt.y, op1.pt.y)
                && op1.prev !== op1b
                && op1.prev !== op2) {
                op1 = op1.prev;
            }
            while (fltEquals(op1b.next.pt.y, op1b.pt.y)
                && op1b.next !== op1
                && op1b.next !== op2) {
                op1b = op1b.next;
            }
            if (op1b.next === op1 || op1b.next === op2) {
                return false; //a flat 'polygon'
            }
            op2b = op2;
            while (fltEquals(op2.prev.pt.y, op2.pt.y)
                && op2.prev !== op2b
                && op2.prev !== op1b) {
                op2 = op2.prev;
            }
            while (fltEquals(op2b.next.pt.y, op2b.pt.y)
                && op2b.next !== op2
                && op2b.next !== op1) {
                op2b = op2b.next;
            }
            if (op2b.next === op2 || op2b.next === op1) {
                return false; //a flat 'polygon'
            }
            var r = GetOverlap(op1.pt.x, op1b.pt.x, op2.pt.x, op2b.pt.x);
            //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges
            if (!r.r) {
                return false;
            }
            var Left = r.Left;
            var Right = r.Right;
            //DiscardLeftSide: when overlapping edges are joined, a spike will created
            //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up
            //on the discard Side as either may still be needed for other joins ...
            var Pt = void 0;
            var DiscardLeftSide = void 0;
            if (op1.pt.x >= Left && op1.pt.x <= Right) {
                Pt = op1.pt;
                DiscardLeftSide = op1.pt.x > op1b.pt.x;
            }
            else if (op2.pt.x >= Left && op2.pt.x <= Right) {
                Pt = op2.pt;
                DiscardLeftSide = op2.pt.x > op2b.pt.x;
            }
            else if (op1b.pt.x >= Left && op1b.pt.x <= Right) {
                Pt = op1b.pt;
                DiscardLeftSide = op1b.pt.x > op1.pt.x;
            }
            else {
                Pt = op2b.pt;
                DiscardLeftSide = op2b.pt.x > op2.pt.x;
            }
            j.outPt1 = op1;
            j.outPt2 = op2;
            return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);
        }
        else {
            //nb: For non-horizontal joins ...
            //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y
            //    2. Jr.OutPt1.Pt > Jr.OffPt.Y
            //make sure the polygons are correctly oriented ...
            op1b = op1.next;
            while (op1b.pt.equals(op1.pt) && op1b !== op1) {
                op1b = op1b.next;
            }
            var Reverse1 = op1b.pt.y > op1.pt.y
                || !SlopesEqual3P(op1.pt, op1b.pt, j.offPt);
            if (Reverse1) {
                op1b = op1.prev;
                while (op1b.pt.equals(op1.pt) && op1b !== op1) {
                    op1b = op1b.prev;
                }
                if (op1b.pt.y > op1.pt.y
                    || !SlopesEqual3P(op1.pt, op1b.pt, j.offPt)) {
                    return false;
                }
            }
            op2b = op2.next;
            while (op2b.pt.equals(op2.pt) && op2b !== op2) {
                op2b = op2b.next;
            }
            var Reverse2 = op2b.pt.y > op2.pt.y
                || !SlopesEqual3P(op2.pt, op2b.pt, j.offPt);
            if (Reverse2) {
                op2b = op2.prev;
                while (op2b.pt.equals(op2.pt) && op2b !== op2) {
                    op2b = op2b.prev;
                }
                if (op2b.pt.y > op2.pt.y
                    || !SlopesEqual3P(op2.pt, op2b.pt, j.offPt)) {
                    return false;
                }
            }
            if (op1b == op1 || op2b == op2 || op1b == op2b ||
                (outRec1 == outRec2 && Reverse1 == Reverse2)) {
                return false;
            }
            if (Reverse1) {
                op1b = DupOutPt(op1, false);
                op2b = DupOutPt(op2, true);
                op1.prev = op2;
                op2.next = op1;
                op1b.next = op2b;
                op2b.prev = op1b;
                j.outPt1 = op1;
                j.outPt2 = op1b;
                return true;
            }
            else {
                op1b = DupOutPt(op1, true);
                op2b = DupOutPt(op2, false);
                op1.next = op2;
                op2.prev = op1;
                op1b.prev = op2b;
                op2b.next = op1b;
                j.outPt1 = op1;
                j.outPt2 = op1b;
                return true;
            }
        }
    };
    Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec) {
        for (var _i = 0, _a = this.m_PolyOuts; _i < _a.length; _i++) {
            var outRec = _a[_i];
            var firstLeft = ParseFirstLeft(outRec.firstLeft);
            if (outRec.pts != null && firstLeft == OldOutRec) {
                if (Poly2ContainsPoly1(outRec.pts, NewOutRec.pts)) {
                    outRec.firstLeft = NewOutRec;
                }
            }
        }
    };
    Clipper.prototype.FixupFirstLefts2 = function (innerOutRec, outerOutRec) {
        //A polygon has split into two such that one is now the inner of the other.
        //It's possible that these polygons now wrap around other polygons, so check
        //every polygon that's also contained by OuterOutRec's FirstLeft container
        //(including nil) to see if they've become inner to the new inner polygon ...
        var orfl = outerOutRec.firstLeft;
        for (var _i = 0, _a = this.m_PolyOuts; _i < _a.length; _i++) {
            var outRec = _a[_i];
            if (outRec.pts == null || outRec == outerOutRec || outRec == innerOutRec) {
                continue;
            }
            var firstLeft = ParseFirstLeft(outRec.firstLeft);
            if (firstLeft != orfl && firstLeft != innerOutRec && firstLeft != outerOutRec) {
                continue;
            }
            if (Poly2ContainsPoly1(outRec.pts, innerOutRec.pts)) {
                outRec.firstLeft = innerOutRec;
            }
            else if (Poly2ContainsPoly1(outRec.pts, outerOutRec.pts)) {
                outRec.firstLeft = outerOutRec;
            }
            else if (outRec.firstLeft == innerOutRec || outRec.firstLeft == outerOutRec) {
                outRec.firstLeft = orfl;
            }
        }
    };
    Clipper.prototype.FixupFirstLefts3 = function (OldOutRec, NewOutRec) {
        //same as FixupFirstLefts1 but doesn't call Poly2ContainsPoly1()
        for (var _i = 0, _a = this.m_PolyOuts; _i < _a.length; _i++) {
            var outRec = _a[_i];
            var firstLeft = ParseFirstLeft(outRec.firstLeft);
            if (outRec.pts != null && firstLeft == OldOutRec) {
                outRec.firstLeft = NewOutRec;
            }
        }
    };
    Clipper.prototype.JoinCommonEdges = function () {
        for (var _i = 0, _a = this.m_Joins; _i < _a.length; _i++) {
            var join = _a[_i];
            var outRec1 = this.GetOutRec(join.outPt1.idx);
            var outRec2 = this.GetOutRec(join.outPt2.idx);
            if (outRec1.pts == null || outRec2.pts == null) {
                continue;
            }
            if (outRec1.isOpen || outRec2.isOpen) {
                continue;
            }
            //get the polygon fragment with the correct hole state (FirstLeft)
            //before calling JoinPoints() ...
            var holeStateRec = void 0;
            if (outRec1 == outRec2) {
                holeStateRec = outRec1;
            }
            else if (OutRec1RightOfOutRec2(outRec1, outRec2)) {
                holeStateRec = outRec2;
            }
            else if (OutRec1RightOfOutRec2(outRec2, outRec1)) {
                holeStateRec = outRec1;
            }
            else {
                holeStateRec = GetLowermostRec(outRec1, outRec2);
            }
            if (!this.JoinPoints(join, outRec1, outRec2)) {
                continue;
            }
            if (outRec1 == outRec2) {
                //instead of joining two polygons, we've just created a new one by
                //splitting one polygon into two.
                outRec1.pts = join.outPt1;
                outRec1.bottomPt = null;
                outRec2 = this.CreateOutRec();
                outRec2.pts = join.outPt2;
                //update all OutRec2.Pts Idx's ...
                UpdateOutPtIdxs(outRec2);
                if (Poly2ContainsPoly1(outRec2.pts, outRec1.pts)) {
                    //outRec1 contains outRec2 ...
                    outRec2.isHole = !outRec1.isHole;
                    outRec2.firstLeft = outRec1;
                    if (this.m_UsingPolyTree) {
                        this.FixupFirstLefts2(outRec2, outRec1);
                    }
                    if (XOR(outRec2.isHole, this.ReverseSolution) == (Area(outRec2) > 0)) {
                        ReversePolyPtLinks(outRec2.pts);
                    }
                }
                else if (Poly2ContainsPoly1(outRec1.pts, outRec2.pts)) {
                    //outRec2 contains outRec1 ...
                    outRec2.isHole = outRec1.isHole;
                    outRec1.isHole = !outRec2.isHole;
                    outRec2.firstLeft = outRec1.firstLeft;
                    outRec1.firstLeft = outRec2;
                    if (this.m_UsingPolyTree) {
                        this.FixupFirstLefts2(outRec1, outRec2);
                    }
                    if (XOR(outRec1.isHole, this.ReverseSolution) == (Area(outRec1) > 0)) {
                        ReversePolyPtLinks(outRec1.pts);
                    }
                }
                else {
                    //the 2 polygons are completely separate ...
                    outRec2.isHole = outRec1.isHole;
                    outRec2.firstLeft = outRec1.firstLeft;
                    //fixup FirstLeft pointers that may need reassigning to OutRec2
                    if (this.m_UsingPolyTree) {
                        this.FixupFirstLefts1(outRec1, outRec2);
                    }
                }
            }
            else {
                //joined 2 polygons together ...
                outRec2.pts = null;
                outRec2.bottomPt = null;
                outRec2.idx = outRec1.idx;
                outRec1.isHole = holeStateRec.isHole;
                if (holeStateRec == outRec2) {
                    outRec1.firstLeft = outRec2.firstLeft;
                }
                outRec2.firstLeft = outRec1;
                //fixup FirstLeft pointers that may need reassigning to OutRec1
                if (this.m_UsingPolyTree) {
                    this.FixupFirstLefts3(outRec2, outRec1);
                }
            }
        }
    };
    Clipper.prototype.DoSimplePolygons = function () {
        var i = 0;
        while (i < this.m_PolyOuts.length) {
            var outrec = this.m_PolyOuts[i++];
            var op = outrec.pts;
            if (op == null || outrec.isOpen) {
                continue;
            }
            do { //for each Pt in Polygon until duplicate found do ...
                var op2 = op.next;
                while (op2 != outrec.pts) {
                    if (op.pt.equals(op2.pt) && op2.next != op && op2.prev != op) {
                        //split the polygon into two ...
                        var op3 = op.prev;
                        var op4 = op2.prev;
                        op.prev = op4;
                        op4.next = op;
                        op2.prev = op3;
                        op3.next = op2;
                        outrec.pts = op;
                        var outrec2 = this.CreateOutRec();
                        outrec2.pts = op2;
                        UpdateOutPtIdxs(outrec2);
                        if (Poly2ContainsPoly1(outrec2.pts, outrec.pts)) {
                            //OutRec2 is contained by OutRec1 ...
                            outrec2.isHole = !outrec.isHole;
                            outrec2.firstLeft = outrec;
                            if (this.m_UsingPolyTree) {
                                this.FixupFirstLefts2(outrec2, outrec);
                            }
                        }
                        else if (Poly2ContainsPoly1(outrec.pts, outrec2.pts)) {
                            //OutRec1 is contained by OutRec2 ...
                            outrec2.isHole = outrec.isHole;
                            outrec.isHole = !outrec2.isHole;
                            outrec2.firstLeft = outrec.firstLeft;
                            outrec.firstLeft = outrec2;
                            if (this.m_UsingPolyTree) {
                                this.FixupFirstLefts2(outrec, outrec2);
                            }
                        }
                        else {
                            //the 2 polygons are separate ...
                            outrec2.isHole = outrec.isHole;
                            outrec2.firstLeft = outrec.firstLeft;
                            if (this.m_UsingPolyTree) {
                                this.FixupFirstLefts1(outrec, outrec2);
                            }
                        }
                        op2 = op; //ie get ready for the next iteration
                    }
                    op2 = op2.next;
                }
                op = op.next;
            } while (op != outrec.pts);
        }
    };
    // SimplifyPolygon functions ...
    // Convert self-intersecting polygons into simple polygons
    Clipper.SimplifyPolygon = function (poly, fillType) {
        if (fillType === void 0) { fillType = PolyFillType.pftEvenOdd; }
        var result = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
        var c = new Clipper();
        c.StrictlySimple = true;
        c.AddPath(poly, PolyType.ptSubject, true);
        c.ExecutePaths(ClipType.ctUnion, result, fillType, fillType);
        return result;
    };
    Clipper.SimplifyPolygons = function (polys, fillType) {
        if (fillType === void 0) { fillType = PolyFillType.pftEvenOdd; }
        var result = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
        var c = new Clipper();
        c.StrictlySimple = true;
        c.AddPaths(polys, PolyType.ptSubject, true);
        c.ExecutePaths(ClipType.ctUnion, result, fillType, fillType);
        return result;
    };
    Clipper.CleanPolygon = function (path, distance) {
        //distance = proximity in units/pixels below which vertices will be stripped.
        //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have
        //both x & y coords within 1 unit, then the second vertex will be stripped.
        if (distance === void 0) { distance = 1.415; }
        var cnt = path.Count;
        var result = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
        if (cnt === 0) {
            return result;
        }
        var outPts = new Array(cnt);
        for (var i = 0; i < cnt; ++i) {
            outPts[i] = new OutPt();
        }
        for (var i = 0; i < cnt; ++i) {
            outPts[i].pt = new ClipPoint(path[i].x, path[i].y);
            outPts[i].next = outPts[(i + 1) % cnt];
            outPts[i].next.prev = outPts[i];
            outPts[i].idx = 0;
        }
        var distSqrd = distance * distance;
        var op = outPts[0];
        while (op.idx == 0 && op.next != op.prev) {
            if (PointsAreClose(op.pt, op.prev.pt, distSqrd)) {
                op = ExcludeOp(op);
                cnt--;
            }
            else if (PointsAreClose(op.prev.pt, op.next.pt, distSqrd)) {
                ExcludeOp(op.next);
                op = ExcludeOp(op);
                cnt -= 2;
            }
            else if (SlopesNearCollinear(op.prev.pt, op.pt, op.next.pt, distSqrd)) {
                op = ExcludeOp(op);
                cnt--;
            }
            else {
                op.idx = 1;
                op = op.next;
            }
        }
        if (cnt < 3) {
            cnt = 0;
        }
        for (var i = 0; i < cnt; ++i) {
            result.Add(op.pt);
            op = op.next;
        }
        outPts = null;
        return result;
    };
    Clipper.CleanPolygons = function (polys, distance) {
        if (distance === void 0) { distance = 1.415; }
        var result = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.foreach)(polys, function (poly) {
            result.Add(Clipper.CleanPolygon(poly, distance));
        });
        return result;
    };
    Clipper.Minkowski = function (pattern, path, IsSum, IsClosed) {
        var delta = (IsClosed ? 1 : 0);
        var polyCnt = pattern.Count;
        var pathCnt = path.Count;
        var result = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List(); //(pathCnt);
        if (IsSum) {
            var _loop_1 = function (i) {
                var p = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
                (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.foreach)(pattern, function (ip) {
                    p.Add(new ClipPoint(path[i].x + ip.x, path[i].y + ip.y));
                });
                result.Add(p);
            };
            for (var i = 0; i < pathCnt; i++) {
                _loop_1(i);
            }
        }
        else {
            var _loop_2 = function (i) {
                var p = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List(); //(polyCnt);
                (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.foreach)(pattern, function (ip) {
                    p.Add(new ClipPoint(path[i].x - ip.x, path[i].y - ip.y));
                });
                result.Add(p);
            };
            for (var i = 0; i < pathCnt; i++) {
                _loop_2(i);
            }
        }
        var quads = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List(); //((pathCnt + delta) * (polyCnt + 1));
        for (var i = 0; i < pathCnt - 1 + delta; i++) {
            for (var j = 0; j < polyCnt; j++) {
                var quad = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List(4);
                quad[0] = result[i % pathCnt][j % polyCnt];
                quad[1] = result[(i + 1) % pathCnt][j % polyCnt];
                quad[2] = result[(i + 1) % pathCnt][(j + 1) % polyCnt];
                quad[3] = result[i % pathCnt][(j + 1) % polyCnt];
                if (!Orientation(quad)) {
                    quad.Reverse();
                }
                quads.Add(quad);
            }
        }
        return quads;
    };
    Clipper.MinkowskiSumPath = function (pattern, path, pathIsClosed) {
        var paths = Clipper.Minkowski(pattern, path, true, pathIsClosed);
        var c = new Clipper();
        c.AddPaths(paths, PolyType.ptSubject, true);
        c.ExecutePaths(ClipType.ctUnion, paths, PolyFillType.pftNonZero, PolyFillType.pftNonZero);
        return paths;
    };
    Clipper.TranslatePath = function (path, delta) {
        var outPath = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List(path.Count);
        for (var i = 0; i < path.Count; i++) {
            outPath[i] = new ClipPoint(path[i].x + delta.x, path[i].y + delta.y);
        }
        return outPath;
    };
    Clipper.MinkowskiSumPaths = function (pattern, paths, pathIsClosed) {
        var solution = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
        var c = new Clipper();
        for (var i = 0; i < paths.Count; ++i) {
            var tmp = Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);
            c.AddPaths(tmp, PolyType.ptSubject, true);
            if (pathIsClosed) {
                var path = Clipper.TranslatePath(paths[i], pattern[0]);
                c.AddPath(path, PolyType.ptClip, true);
            }
        }
        c.ExecutePaths(ClipType.ctUnion, solution, PolyFillType.pftNonZero, PolyFillType.pftNonZero);
        return solution;
    };
    Clipper.MinkowskiDiff = function (poly1, poly2) {
        var paths = Clipper.Minkowski(poly1, poly2, false, true);
        var c = new Clipper();
        c.AddPaths(paths, PolyType.ptSubject, true);
        c.ExecutePaths(ClipType.ctUnion, paths, PolyFillType.pftNonZero, PolyFillType.pftNonZero);
        return paths;
    };
    Clipper.PolyTreeToPaths = function (polytree) {
        var result = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
        //result.Capacity = polytree.Total;
        Clipper.AddPolyNodeToPaths(polytree, NodeType.ntAny, result);
        return result;
    };
    Clipper.AddPolyNodeToPaths = function (polynode, nt, paths) {
        var match = true;
        switch (nt) {
            case NodeType.ntOpen:
                return;
            case NodeType.ntClosed:
                match = !polynode.isOpen;
                break;
            default:
                break;
        }
        if (polynode.polygon.Count > 0 && match) {
            paths.Add(polynode.polygon);
        }
        for (var _i = 0, _a = polynode.children; _i < _a.length; _i++) {
            var pn = _a[_i];
            Clipper.AddPolyNodeToPaths(pn, nt, paths);
        }
    };
    Clipper.OpenPathsFromPolyTree = function (polytree) {
        var result = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
        //result.Capacity = polytree.ChildCount;
        for (var _i = 0, _a = polytree.children; _i < _a.length; _i++) {
            var pn = _a[_i];
            if (pn.isOpen) {
                result.Add(pn.polygon);
            }
        }
        return result;
    };
    Clipper.ClosedPathsFromPolyTree = function (polytree) {
        var result = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
        //result.Capacity = polytree.Total;
        Clipper.AddPolyNodeToPaths(polytree, NodeType.ntClosed, result);
        return result;
    };
    return Clipper;
}(ClipperBase)); //end Clipper

var ClipperOffset = /** @class */ (function () {
    function ClipperOffset(miterLimit, arcTolerance) {
        if (miterLimit === void 0) { miterLimit = 2.0; }
        if (arcTolerance === void 0) { arcTolerance = DefArcTolerance; }
        this.m_destPolys = undefined;
        this.m_srcPoly = undefined;
        this.m_destPoly = undefined;
        this.m_normals = new Array();
        this.m_delta = 0;
        this.m_sinA = 0;
        this.m_sin = 0;
        this.m_cos = 0;
        this.m_miterLim = 0;
        this.m_StepsPerRad = 0;
        this.m_lowest = undefined;
        this.m_polyNodes = new PolyNode();
        this.MiterLimit = miterLimit;
        this.ArcTolerance = arcTolerance;
        this.m_lowest.x = -1;
    }
    ClipperOffset.prototype.clear = function () {
        this.m_polyNodes.children.length = 0;
        this.m_lowest.x = -1;
    };
    ClipperOffset.prototype.AddPath = function (path, joinType, endType) {
        var highI = path.Count - 1;
        if (highI < 0) {
            return;
        }
        var newNode = new PolyNode();
        newNode.joinType = joinType;
        newNode.endType = endType;
        //strip duplicate points from path and also get index to the lowest point ...
        if (endType == EndType.etClosedLine || endType == EndType.etClosedPolygon) {
            while (highI > 0 && path[0] == path[highI]) {
                highI--;
            }
        }
        //newNode.polygon.Capacity = highI + 1;
        newNode.polygon.Add(path[0]);
        var j = 0, k = 0;
        for (var i = 1; i <= highI; i++) {
            if (newNode.polygon[j] != path[i]) {
                j++;
                newNode.polygon.Add(path[i]);
                if (path[i].y > newNode.polygon[k].y
                    || (fltEquals(path[i].y, newNode.polygon[k].y)
                        && path[i].x < newNode.polygon[k].x)) {
                    k = j;
                }
            }
        }
        if (endType === EndType.etClosedPolygon && j < 2) {
            return;
        }
        this.m_polyNodes.addChild(newNode);
        //if this path's lowest pt is lower than all the others then update m_lowest
        if (endType !== EndType.etClosedPolygon) {
            return;
        }
        if (this.m_lowest.x < 0) {
            this.m_lowest = { x: this.m_polyNodes.childCount - 1, y: k };
        }
        else {
            var ip = this.m_polyNodes.children[this.m_lowest.x].polygon[this.m_lowest.y];
            if (newNode.polygon[k].y > ip.y
                || (fltEquals(newNode.polygon[k].y, ip.y)
                    && newNode.polygon[k].x < ip.x)) {
                this.m_lowest = { x: this.m_polyNodes.childCount - 1, y: k };
            }
        }
    };
    ClipperOffset.prototype.AddPaths = function (paths, joinType, endType) {
        var _this = this;
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.foreach)(paths, function (p) {
            _this.AddPath(p, joinType, endType);
        });
    };
    ClipperOffset.prototype.FixOrientations = function () {
        //fixup orientations of all closed paths if the orientation of the
        //closed path with the lowermost vertex is wrong ...
        if (this.m_lowest.x >= 0 &&
            !Orientation(this.m_polyNodes.children[this.m_lowest.x].polygon)) {
            for (var i = 0; i < this.m_polyNodes.childCount; i++) {
                var node = this.m_polyNodes.children[i];
                if (node.endType === EndType.etClosedPolygon ||
                    (node.endType === EndType.etClosedLine && Orientation(node.polygon))) {
                    node.polygon.Reverse();
                }
            }
        }
        else {
            for (var i = 0; i < this.m_polyNodes.childCount; i++) {
                var node = this.m_polyNodes.children[i];
                if (node.endType === EndType.etClosedLine
                    && !Orientation(node.polygon)) {
                    node.polygon.Reverse();
                }
            }
        }
    };
    ClipperOffset.prototype.DoOffset = function (delta) {
        this.m_destPolys = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
        this.m_delta = delta;
        //if Zero offset, just copy any CLOSED polygons to m_p and return ...
        if (NearZero(delta)) {
            //this.m_destPolys.Capacity = m_polyNodes.ChildCount;
            for (var i = 0; i < this.m_polyNodes.childCount; i++) {
                var node = this.m_polyNodes.children[i];
                if (node.endType === EndType.etClosedPolygon) {
                    this.m_destPolys.Add(node.polygon);
                }
            }
            return;
        }
        //see offset_triginometry3.svg in the documentation folder ...
        if (this.MiterLimit > 2) {
            this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);
        }
        else {
            this.m_miterLim = 0.5;
        }
        var y;
        if (this.ArcTolerance <= 0.0) {
            y = DefArcTolerance;
        }
        else if (this.ArcTolerance > Math.abs(delta) * DefArcTolerance) {
            y = Math.abs(delta) * DefArcTolerance;
        }
        else {
            y = this.ArcTolerance;
        }
        //see offset_triginometry2.svg in the documentation folder ...
        var steps = Math.PI / Math.acos(1 - y / Math.abs(delta));
        this.m_sin = Math.sin(TwoPI / steps);
        this.m_cos = Math.cos(TwoPI / steps);
        this.m_StepsPerRad = steps / TwoPI;
        if (delta < 0.0) {
            this.m_sin = -this.m_sin;
        }
        //m_destPolys.Capacity = m_polyNodes.ChildCount * 2;
        for (var i = 0; i < this.m_polyNodes.childCount; i++) {
            var node = this.m_polyNodes.children[i];
            this.m_srcPoly = node.polygon;
            var len = this.m_srcPoly.Count;
            if (len === 0
                || (delta <= 0 && (len < 3 || node.endType !== EndType.etClosedPolygon))) {
                continue;
            }
            this.m_destPoly = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
            if (len === 1) {
                if (node.joinType === JoinType.jtRound) {
                    var X = 1.0, Y = 0.0;
                    for (var j = 1; j <= steps; j++) {
                        this.m_destPoly.Add(new ClipPoint(this.m_srcPoly[0].x + X * delta, this.m_srcPoly[0].y + Y * delta));
                        var X2 = X;
                        X = X * this.m_cos - this.m_sin * Y;
                        Y = X2 * this.m_sin + Y * this.m_cos;
                    }
                }
                else {
                    var X = -1.0, Y = -1.0;
                    for (var j = 0; j < 4; ++j) {
                        this.m_destPoly.Add(new ClipPoint(this.m_srcPoly[0].x + X * delta, this.m_srcPoly[0].y + Y * delta));
                        if (X < 0) {
                            X = 1;
                        }
                        else if (Y < 0) {
                            Y = 1;
                        }
                        else {
                            X = -1;
                        }
                    }
                }
                this.m_destPolys.Add(this.m_destPoly);
                continue;
            }
            //build m_normals ...
            this.m_normals.length = 0;
            //m_normals.Capacity = len;
            for (var j = 0; j < len - 1; j++) {
                this.m_normals.push(GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));
            }
            if (node.endType === EndType.etClosedLine
                || node.endType === EndType.etClosedPolygon) {
                this.m_normals.push(GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));
            }
            else {
                this.m_normals.push(new ClipPoint(this.m_normals[len - 2].x, this.m_normals[len - 2].y));
            }
            if (node.endType === EndType.etClosedPolygon) {
                var k = len - 1;
                for (var j = 0; j < len; j++) {
                    k = this.OffsetPoint(j, k, node.joinType);
                }
                this.m_destPolys.Add(this.m_destPoly);
            }
            else if (node.endType === EndType.etClosedLine) {
                var k = len - 1;
                for (var j = 0; j < len; j++) {
                    k = this.OffsetPoint(j, k, node.joinType);
                }
                this.m_destPolys.Add(this.m_destPoly);
                this.m_destPoly = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List();
                //re-build m_normals ...
                var n = this.m_normals[len - 1];
                for (var j = len - 1; j > 0; j--) {
                    this.m_normals[j] = new ClipPoint(-this.m_normals[j - 1].x, -this.m_normals[j - 1].y);
                }
                this.m_normals[0] = new ClipPoint(-n.x, -n.y);
                k = 0;
                for (var j = len - 1; j >= 0; j--) {
                    k = this.OffsetPoint(j, k, node.joinType);
                }
                this.m_destPolys.Add(this.m_destPoly);
            }
            else {
                var k = 0;
                for (var j = 1; j < len - 1; ++j) {
                    k = this.OffsetPoint(j, k, node.joinType);
                }
                var pt1 = void 0;
                if (node.endType === EndType.etOpenButt) {
                    var j = len - 1;
                    pt1 = new ClipPoint(this.m_srcPoly[j].x + this.m_normals[j].x * delta, this.m_srcPoly[j].y + this.m_normals[j].y * delta);
                    this.m_destPoly.Add(pt1);
                    pt1 = new ClipPoint(this.m_srcPoly[j].x - this.m_normals[j].x * delta, this.m_srcPoly[j].y - this.m_normals[j].y * delta);
                    this.m_destPoly.Add(pt1);
                }
                else {
                    var j = len - 1;
                    k = len - 2;
                    this.m_sinA = 0;
                    this.m_normals[j] = new ClipPoint(-this.m_normals[j].x, -this.m_normals[j].y);
                    if (node.endType === EndType.etOpenSquare) {
                        this.DoSquare(j, k);
                    }
                    else {
                        this.DoRound(j, k);
                    }
                }
                //re-build m_normals ...
                for (var j = len - 1; j > 0; j--) {
                    this.m_normals[j] = new ClipPoint(-this.m_normals[j - 1].x, -this.m_normals[j - 1].y);
                }
                this.m_normals[0] = new ClipPoint(-this.m_normals[1].x, -this.m_normals[1].y);
                k = len - 1;
                for (var j = k - 1; j > 0; --j) {
                    k = this.OffsetPoint(j, k, node.joinType);
                }
                if (node.endType == EndType.etOpenButt) {
                    pt1 = new ClipPoint(this.m_srcPoly[0].x - this.m_normals[0].x * delta, this.m_srcPoly[0].y - this.m_normals[0].y * delta);
                    this.m_destPoly.Add(pt1);
                    pt1 = new ClipPoint(this.m_srcPoly[0].x + this.m_normals[0].x * delta, this.m_srcPoly[0].y + this.m_normals[0].y * delta);
                    this.m_destPoly.Add(pt1);
                }
                else {
                    k = 1;
                    this.m_sinA = 0;
                    if (node.endType === EndType.etOpenSquare) {
                        this.DoSquare(0, 1);
                    }
                    else {
                        this.DoRound(0, 1);
                    }
                }
                this.m_destPolys.Add(this.m_destPoly);
            }
        }
    };
    ClipperOffset.prototype.Execute = function (solution, delta) {
        if (_tuval_core__WEBPACK_IMPORTED_MODULE_0__.is["typeof"](solution, _tuval_core__WEBPACK_IMPORTED_MODULE_0__.System.Types.Collections.Generics.List)) {
            return this.ExecutePaths(solution, delta);
        }
        return this.ExecutePolyTree(solution, delta);
    };
    ClipperOffset.prototype.ExecutePaths = function (solution, delta) {
        solution.Clear();
        this.FixOrientations();
        this.DoOffset(delta);
        //now clean up 'corners' ...
        var clpr = new Clipper();
        clpr.AddPaths(this.m_destPolys, PolyType.ptSubject, true);
        if (delta > 0) {
            clpr.ExecutePaths(ClipType.ctUnion, solution, PolyFillType.pftPositive, PolyFillType.pftPositive);
        }
        else {
            var r = Clipper.GetBounds(this.m_destPolys);
            var outer = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List(4);
            outer[0] = new ClipPoint(r.left - 10, r.bottom + 10);
            outer[1] = new ClipPoint(r.right + 10, r.bottom + 10);
            outer[2] = new ClipPoint(r.right + 10, r.top - 10);
            outer[3] = new ClipPoint(r.left - 10, r.top - 10);
            clpr.AddPath(outer, PolyType.ptSubject, true);
            clpr.ReverseSolution = true;
            clpr.ExecutePaths(ClipType.ctUnion, solution, PolyFillType.pftNegative, PolyFillType.pftNegative);
            if (solution.Count > 0) {
                solution.RemoveAt(0);
            }
        }
    };
    ClipperOffset.prototype.ExecutePolyTree = function (solution, delta) {
        solution.clear();
        this.FixOrientations();
        this.DoOffset(delta);
        //now clean up 'corners' ...
        var clpr = new Clipper();
        clpr.AddPaths(this.m_destPolys, PolyType.ptSubject, true);
        if (delta > 0) {
            clpr.ExecutePolyTree(ClipType.ctUnion, solution, PolyFillType.pftPositive, PolyFillType.pftPositive);
        }
        else {
            var r = Clipper.GetBounds(this.m_destPolys);
            var outer = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.List(4);
            outer[0] = new ClipPoint(r.left - 10, r.bottom + 10);
            outer[1] = new ClipPoint(r.right + 10, r.bottom + 10);
            outer[2] = new ClipPoint(r.right + 10, r.top - 10);
            outer[3] = new ClipPoint(r.left - 10, r.top - 10);
            clpr.AddPath(outer, PolyType.ptSubject, true);
            clpr.ReverseSolution = true;
            clpr.ExecutePolyTree(ClipType.ctUnion, solution, PolyFillType.pftNegative, PolyFillType.pftNegative);
            //remove the outer PolyNode rectangle ...
            if (solution.childCount == 1 && solution.children[0].childCount > 0) {
                var outerNode = solution.children[0];
                //solution.children.Capacity = outerNode.ChildCount;
                solution.children[0] = outerNode.children[0];
                solution.children[0].parent = solution;
                for (var i = 1; i < outerNode.childCount; i++) {
                    solution.addChild(outerNode.children[i]);
                }
            }
            else {
                solution.clear();
            }
        }
    };
    ClipperOffset.prototype.OffsetPoint = function (j, k, jointype) {
        //cross product ...
        this.m_sinA = this.m_normals[k].x * this.m_normals[j].y - this.m_normals[j].x * this.m_normals[k].y;
        if (Math.abs(this.m_sinA * this.m_delta) < 1.0) {
            //dot product ...
            var cosA = this.m_normals[k].x * this.m_normals[j].x + this.m_normals[j].y * this.m_normals[k].y;
            if (cosA > 0) { // angle ==> 0 degrees
                this.m_destPoly.Add(new ClipPoint(this.m_srcPoly[j].x + this.m_normals[k].x * this.m_delta, this.m_srcPoly[j].y + this.m_normals[k].y * this.m_delta));
                return k;
            }
            //else angle ==> 180 degrees
        }
        else if (this.m_sinA > 1.0) {
            this.m_sinA = 1.0;
        }
        else if (this.m_sinA < -1.0) {
            this.m_sinA = -1.0;
        }
        if (this.m_sinA * this.m_delta < 0) {
            this.m_destPoly.Add(new ClipPoint(this.m_srcPoly[j].x + this.m_normals[k].x * this.m_delta, this.m_srcPoly[j].y + this.m_normals[k].y * this.m_delta));
            this.m_destPoly.Add(this.m_srcPoly[j]);
            this.m_destPoly.Add(new ClipPoint(this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta, this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta));
        }
        else {
            switch (jointype) {
                case JoinType.jtMiter:
                    var r = 1 + (this.m_normals[j].x * this.m_normals[k].x + this.m_normals[j].y * this.m_normals[k].y);
                    if (r >= this.m_miterLim) {
                        this.DoMiter(j, k, r);
                    }
                    else {
                        this.DoSquare(j, k);
                    }
                    break;
                case JoinType.jtSquare:
                    this.DoSquare(j, k);
                    break;
                case JoinType.jtRound:
                    this.DoRound(j, k);
                    break;
            }
        }
        k = j;
        return k;
    };
    ClipperOffset.prototype.DoSquare = function (j, k) {
        var dx = Math.tan(Math.atan2(this.m_sinA, this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y)
            / 4);
        this.m_destPoly.Add(new ClipPoint(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[k].x - this.m_normals[k].y * dx), this.m_srcPoly[j].y + this.m_delta * (this.m_normals[k].y - this.m_normals[k].x * dx)));
        this.m_destPoly.Add(new ClipPoint(this.m_srcPoly[j].x + this.m_delta * (this.m_normals[j].x - this.m_normals[j].y * dx), this.m_srcPoly[j].y + this.m_delta * (this.m_normals[j].y - this.m_normals[j].x * dx)));
    };
    ClipperOffset.prototype.DoMiter = function (j, k, r) {
        var q = this.m_delta / r;
        this.m_destPoly.Add(new ClipPoint(this.m_srcPoly[j].x + (this.m_normals[k].x + this.m_normals[j].x) * q, this.m_srcPoly[j].y + (this.m_normals[k].y + this.m_normals[j].y) * q));
    };
    ClipperOffset.prototype.DoRound = function (j, k) {
        var a = Math.atan2(this.m_sinA, this.m_normals[k].x * this.m_normals[j].x + this.m_normals[k].y * this.m_normals[j].y);
        var steps = Math.max(Math.round(this.m_StepsPerRad * Math.abs(a)), 1);
        var X = this.m_normals[k].x;
        var Y = this.m_normals[k].y;
        var X2;
        for (var i = 0; i < steps; ++i) {
            this.m_destPoly.Add(new ClipPoint(this.m_srcPoly[j].x + X * this.m_delta, this.m_srcPoly[j].y + Y * this.m_delta));
            X2 = X;
            X = X * this.m_cos - this.m_sin * Y;
            Y = X2 * this.m_sin + Y * this.m_cos;
        }
        this.m_destPoly.Add(new ClipPoint(this.m_srcPoly[j].x + this.m_normals[j].x * this.m_delta, this.m_srcPoly[j].y + this.m_normals[j].y * this.m_delta));
    };
    return ClipperOffset;
}()); // end ClipperOffset



/***/ }),

/***/ "./src/drawing/ColorMatrix.ts":
/*!************************************!*\
  !*** ./src/drawing/ColorMatrix.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorMatrix": () => (/* binding */ ColorMatrix)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GDITypes */ "./src/GDITypes.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var ColorMatrix = /** @class */ (function () {
    function ColorMatrix() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._matrix00 = 0;
        this._matrix01 = 0;
        this._matrix02 = 0;
        this._matrix03 = 0;
        this._matrix04 = 0;
        this._matrix10 = 0;
        this._matrix11 = 0;
        this._matrix12 = 0;
        this._matrix13 = 0;
        this._matrix14 = 0;
        this._matrix20 = 0;
        this._matrix21 = 0;
        this._matrix22 = 0;
        this._matrix23 = 0;
        this._matrix24 = 0;
        this._matrix30 = 0;
        this._matrix31 = 0;
        this._matrix32 = 0;
        this._matrix33 = 0;
        this._matrix34 = 0;
        this._matrix40 = 0;
        this._matrix41 = 0;
        this._matrix42 = 0;
        this._matrix43 = 0;
        this._matrix44 = 0;
        if (args.length == 0) {
            /*
             * Setup identity matrix by default
             */
            this._matrix00 = 1.0;
            //matrix01 = 0.0f;
            //matrix02 = 0.0f;
            //matrix03 = 0.0f;
            //matrix04 = 0.0f;
            //matrix10 = 0.0f;
            this._matrix11 = 1.0;
            //matrix12 = 0.0f;
            //matrix13 = 0.0f;
            //matrix14 = 0.0f;
            //matrix20 = 0.0f;
            //matrix21 = 0.0f;
            this._matrix22 = 1.0;
            // matrix23 = 0.0f;
            // matrix24 = 0.0f;
            // matrix30 = 0.0f;
            //matrix31 = 0.0f;
            // matrix32 = 0.0f;
            this._matrix33 = 1.0;
            // matrix34 = 0.0f;
            // matrix40 = 0.0f;
            // matrix41 = 0.0f;
            // matrix42 = 0.0f;
            // matrix43 = 0.0f;
            this._matrix44 = 1.0;
        }
        else if (Array.isArray(args[0])) {
            this.setMatrix(args[0]);
        }
        else {
            var config = args[0];
            this.Matrix00 = config.matrix00;
            this.Matrix01 = config.matrix01;
            this.Matrix02 = config.matrix02;
            this.Matrix03 = config.matrix03;
            this.Matrix04 = config.matrix04;
            this.Matrix10 = config.matrix10;
            this.Matrix11 = config.matrix11;
            this.Matrix12 = config.matrix12;
            this.Matrix13 = config.matrix13;
            this.Matrix14 = config.matrix14;
            this.Matrix20 = config.matrix20;
            this.Matrix21 = config.matrix21;
            this.Matrix22 = config.matrix22;
            this.Matrix23 = config.matrix23;
            this.Matrix24 = config.matrix24;
            this.Matrix30 = config.matrix30;
            this.Matrix31 = config.matrix31;
            this.Matrix32 = config.matrix32;
            this.Matrix33 = config.matrix33;
            this.Matrix34 = config.matrix34;
            this.Matrix40 = config.matrix40;
            this.Matrix41 = config.matrix41;
            this.Matrix42 = config.matrix42;
            this.Matrix43 = config.matrix43;
            this.Matrix44 = config.matrix44;
        }
    }
    Object.defineProperty(ColorMatrix.prototype, "Matrix00", {
        get: function () {
            return this._matrix00;
        },
        set: function (value) {
            this._matrix00 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix01", {
        get: function () {
            return this._matrix01;
        },
        set: function (value) {
            this._matrix01 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix02", {
        get: function () {
            return this._matrix02;
        },
        set: function (value) {
            this._matrix02 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix03", {
        get: function () {
            return this._matrix03;
        },
        set: function (value) {
            this._matrix03 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix04", {
        get: function () {
            return this._matrix04;
        },
        set: function (value) {
            this._matrix04 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix10", {
        get: function () {
            return this._matrix10;
        },
        set: function (value) {
            this._matrix10 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix11", {
        get: function () {
            return this._matrix11;
        },
        set: function (value) {
            this._matrix11 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix12", {
        get: function () {
            return this._matrix12;
        },
        set: function (value) {
            this._matrix12 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix13", {
        get: function () {
            return this._matrix13;
        },
        set: function (value) {
            this._matrix13 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix14", {
        get: function () {
            return this._matrix14;
        },
        set: function (value) {
            this._matrix14 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix20", {
        get: function () {
            return this._matrix20;
        },
        set: function (value) {
            this._matrix20 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix21", {
        get: function () {
            return this._matrix21;
        },
        set: function (value) {
            this._matrix21 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix22", {
        get: function () {
            return this._matrix22;
        },
        set: function (value) {
            this._matrix22 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix23", {
        get: function () {
            return this._matrix23;
        },
        set: function (value) {
            this._matrix23 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix24", {
        get: function () {
            return this._matrix24;
        },
        set: function (value) {
            this._matrix24 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix30", {
        get: function () {
            return this._matrix30;
        },
        set: function (value) {
            this._matrix30 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix31", {
        get: function () {
            return this._matrix31;
        },
        set: function (value) {
            this._matrix31 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix32", {
        get: function () {
            return this._matrix32;
        },
        set: function (value) {
            this._matrix32 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix33", {
        get: function () {
            return this._matrix33;
        },
        set: function (value) {
            this._matrix33 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix34", {
        get: function () {
            return this._matrix34;
        },
        set: function (value) {
            this._matrix34 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix40", {
        get: function () {
            return this._matrix40;
        },
        set: function (value) {
            this._matrix40 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix41", {
        get: function () {
            return this._matrix41;
        },
        set: function (value) {
            this._matrix41 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix42", {
        get: function () {
            return this._matrix42;
        },
        set: function (value) {
            this._matrix42 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix43", {
        get: function () {
            return this._matrix43;
        },
        set: function (value) {
            this._matrix43 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorMatrix.prototype, "Matrix44", {
        get: function () {
            return this._matrix44;
        },
        set: function (value) {
            this._matrix44 = value;
        },
        enumerable: false,
        configurable: true
    });
    ColorMatrix.prototype.setMatrix = function (newColorMatrix) {
        this._matrix00 = newColorMatrix[0][0];
        this._matrix01 = newColorMatrix[0][1];
        this._matrix02 = newColorMatrix[0][2];
        this._matrix03 = newColorMatrix[0][3];
        this._matrix04 = newColorMatrix[0][4];
        this._matrix10 = newColorMatrix[1][0];
        this._matrix11 = newColorMatrix[1][1];
        this._matrix12 = newColorMatrix[1][2];
        this._matrix13 = newColorMatrix[1][3];
        this._matrix14 = newColorMatrix[1][4];
        this._matrix20 = newColorMatrix[2][0];
        this._matrix21 = newColorMatrix[2][1];
        this._matrix22 = newColorMatrix[2][2];
        this._matrix23 = newColorMatrix[2][3];
        this._matrix24 = newColorMatrix[2][4];
        this._matrix30 = newColorMatrix[3][0];
        this._matrix31 = newColorMatrix[3][1];
        this._matrix32 = newColorMatrix[3][2];
        this._matrix33 = newColorMatrix[3][3];
        this._matrix34 = newColorMatrix[3][4];
        this._matrix40 = newColorMatrix[4][0];
        this._matrix41 = newColorMatrix[4][1];
        this._matrix42 = newColorMatrix[4][2];
        this._matrix43 = newColorMatrix[4][3];
        this._matrix44 = newColorMatrix[4][4];
    };
    ColorMatrix.prototype.getMatrix = function () {
        var returnMatrix = new Array(5);
        for (var i = 0; i < 5; i++)
            returnMatrix[i] = new Array(5);
        returnMatrix[0][0] = this._matrix00;
        returnMatrix[0][1] = this._matrix01;
        returnMatrix[0][2] = this._matrix02;
        returnMatrix[0][3] = this._matrix03;
        returnMatrix[0][4] = this._matrix04;
        returnMatrix[1][0] = this._matrix10;
        returnMatrix[1][1] = this._matrix11;
        returnMatrix[1][2] = this._matrix12;
        returnMatrix[1][3] = this._matrix13;
        returnMatrix[1][4] = this._matrix14;
        returnMatrix[2][0] = this._matrix20;
        returnMatrix[2][1] = this._matrix21;
        returnMatrix[2][2] = this._matrix22;
        returnMatrix[2][3] = this._matrix23;
        returnMatrix[2][4] = this._matrix24;
        returnMatrix[3][0] = this._matrix30;
        returnMatrix[3][1] = this._matrix31;
        returnMatrix[3][2] = this._matrix32;
        returnMatrix[3][3] = this._matrix33;
        returnMatrix[3][4] = this._matrix34;
        returnMatrix[4][0] = this._matrix40;
        returnMatrix[4][1] = this._matrix41;
        returnMatrix[4][2] = this._matrix42;
        returnMatrix[4][3] = this._matrix43;
        returnMatrix[4][4] = this._matrix44;
        return returnMatrix;
    };
    ColorMatrix.prototype.get = function (row, column) {
        return this.getMatrix()[row][column];
    };
    ColorMatrix.prototype.set = function (row, column, value) {
        var tempMatrix = this.getMatrix();
        tempMatrix[row][column] = value;
        this.setMatrix(tempMatrix);
    };
    ColorMatrix = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_1__.GraphicTypes.ColorMatrix,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_1__.GraphicTypes.ColorMatrix
            ]
        }),
        __metadata("design:paramtypes", [Object])
    ], ColorMatrix);
    return ColorMatrix;
}());



/***/ }),

/***/ "./src/drawing/ContentAlignment.ts":
/*!*****************************************!*\
  !*** ./src/drawing/ContentAlignment.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContentAlignment": () => (/* binding */ ContentAlignment)
/* harmony export */ });
var ContentAlignment;
(function (ContentAlignment) {
    /// <summary>Content is vertically aligned at the top, and horizontally aligned on the left.</summary>
    ContentAlignment[ContentAlignment["TopLeft"] = 1] = "TopLeft";
    /// <summary>Content is vertically aligned at the top, and horizontally aligned at the center.</summary>
    ContentAlignment[ContentAlignment["TopCenter"] = 2] = "TopCenter";
    /// <summary>Content is vertically aligned at the top, and horizontally aligned on the right.</summary>
    ContentAlignment[ContentAlignment["TopRight"] = 4] = "TopRight";
    /// <summary>Content is vertically aligned in the middle, and horizontally aligned on the left.</summary>
    ContentAlignment[ContentAlignment["MiddleLeft"] = 16] = "MiddleLeft";
    /// <summary>Content is vertically aligned in the middle, and horizontally aligned at the center.</summary>
    ContentAlignment[ContentAlignment["MiddleCenter"] = 32] = "MiddleCenter";
    /// <summary>Content is vertically aligned in the middle, and horizontally aligned on the right.</summary>
    ContentAlignment[ContentAlignment["MiddleRight"] = 64] = "MiddleRight";
    /// <summary>Content is vertically aligned at the bottom, and horizontally aligned on the left.</summary>
    ContentAlignment[ContentAlignment["BottomLeft"] = 256] = "BottomLeft";
    /// <summary>Content is vertically aligned at the bottom, and horizontally aligned at the center.</summary>
    ContentAlignment[ContentAlignment["BottomCenter"] = 512] = "BottomCenter";
    /// <summary>Content is vertically aligned at the bottom, and horizontally aligned on the right.</summary>
    ContentAlignment[ContentAlignment["BottomRight"] = 1024] = "BottomRight";
})(ContentAlignment || (ContentAlignment = {}));


/***/ }),

/***/ "./src/drawing/ConversionHelpers.ts":
/*!******************************************!*\
  !*** ./src/drawing/ConversionHelpers.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConversionHelpers": () => (/* binding */ ConversionHelpers)
/* harmony export */ });
/* harmony import */ var _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GraphicsUnit */ "./src/drawing/GraphicsUnit.ts");
/* harmony import */ var _drawing2D_CoordinateSpace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawing2D/CoordinateSpace */ "./src/drawing/drawing2D/CoordinateSpace.ts");
/* harmony import */ var _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawing2D/Matrix */ "./src/drawing/drawing2D/Matrix.ts");



var ConversionHelpers = /** @class */ (function () {
    function ConversionHelpers() {
    }
    ConversionHelpers.GraphicsUnitConversion = function (from, to, dpiX, dpiY, srcRect) {
        srcRect.value.X = ConversionHelpers.GraphicsUnitConversion1(from, to, dpiX, srcRect.value.X);
        srcRect.value.Y = ConversionHelpers.GraphicsUnitConversion1(from, to, dpiY, srcRect.value.Y);
        srcRect.value.Width = ConversionHelpers.GraphicsUnitConversion1(from, to, dpiX, srcRect.value.Width);
        srcRect.value.Height = ConversionHelpers.GraphicsUnitConversion1(from, to, dpiY, srcRect.value.Height);
    };
    ConversionHelpers.GraphicsUnitConversion1 = function (from, to, dpi, nSrc) {
        var inchs = 0;
        switch (from) {
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Document:
                inchs = nSrc / 300.0;
                break;
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Inch:
                inchs = nSrc;
                break;
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Millimeter:
                inchs = nSrc / 25.4;
                break;
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Display:
                //if (type == gtPostScript) { /* Uses 1/100th on printers */
                //	inchs = nSrc / 100;
                //} else { /* Pixel for video display */
                inchs = nSrc / dpi;
                //}
                break;
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Pixel:
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.World:
                inchs = nSrc / dpi;
                break;
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Point:
                inchs = nSrc / 72.0;
                break;
            //			case GraphicsUnit.Display:
            //				if (type == gtPostScript) { /* Uses 1/100th on printers */
            //					inchs = nSrc / 72.0f;
            //				} else { /* Pixel for video display */
            //					inchs = nSrc / dpi;
            //				}
            //				break;
            default:
                return nSrc;
        }
        switch (to) {
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Document:
                return inchs * 300.0;
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Inch:
                return inchs;
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Millimeter:
                return inchs * 25.4;
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Display:
                //if (type == gtPostScript) { /* Uses 1/100th on printers */
                //	return inchs * 100;
                //} else { /* Pixel for video display */
                return inchs * dpi;
            //}
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Pixel:
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.World:
                return inchs * dpi;
            case _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Point:
                return inchs * 72.0;
            //			case GraphicsUnit.Display:
            //				if (type == gtPostScript) { /* Uses 1/100th on printers */
            //					return inchs * 72.0f;
            //				} else { /* Pixel for video display */
            //					return inchs * dpi;
            //				}
            default:
                return nSrc;
        }
    };
    ConversionHelpers.GetGraphicsTransform = function (graphics, destinationSpace, sourceSpace, matrix) {
        var scale_x = 0;
        var scale_y = 0;
        matrix.value.reset();
        if (destinationSpace !== sourceSpace) {
            scale_x = ConversionHelpers.GraphicsUnitConversion1(graphics.PageUnit, _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Pixel, graphics.DpiX, 1);
            scale_y = ConversionHelpers.GraphicsUnitConversion1(graphics.PageUnit, _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Pixel, graphics.DpiY, 1);
            if (graphics.PageUnit !== _GraphicsUnit__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit.Display) {
                scale_x *= graphics.PageScale;
                scale_y *= graphics.PageScale;
            }
            // Transform from sourceSpace to CoordinateSpace.Page
            switch (sourceSpace) {
                case _drawing2D_CoordinateSpace__WEBPACK_IMPORTED_MODULE_1__.CoordinateSpace.World:
                    matrix.value.multiply(graphics.modelMatrix, _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_2__.MatrixOrder.Append);
                    break;
                case _drawing2D_CoordinateSpace__WEBPACK_IMPORTED_MODULE_1__.CoordinateSpace.Page:
                    break;
                case _drawing2D_CoordinateSpace__WEBPACK_IMPORTED_MODULE_1__.CoordinateSpace.Device:
                    matrix.value.scale(1.0 / scale_x, 1.0 / scale_y, _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_2__.MatrixOrder.Append);
                    break;
            }
            // Transform from CoordinateSpace.Page to destinationSpace
            switch (destinationSpace) {
                case _drawing2D_CoordinateSpace__WEBPACK_IMPORTED_MODULE_1__.CoordinateSpace.World:
                    var destWorld = graphics.Transform;
                    if (destWorld.IsInvertible) {
                        destWorld.invert();
                        matrix.value.multiply(destWorld, _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_2__.MatrixOrder.Append);
                    }
                    break;
                case _drawing2D_CoordinateSpace__WEBPACK_IMPORTED_MODULE_1__.CoordinateSpace.Page:
                    break;
                case _drawing2D_CoordinateSpace__WEBPACK_IMPORTED_MODULE_1__.CoordinateSpace.Device:
                    matrix.value.scale(scale_x, scale_y, _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_2__.MatrixOrder.Append);
                    break;
            }
        }
    };
    return ConversionHelpers;
}());



/***/ }),

/***/ "./src/drawing/DashCap.ts":
/*!********************************!*\
  !*** ./src/drawing/DashCap.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DashCap": () => (/* binding */ DashCap)
/* harmony export */ });
var DashCap;
(function (DashCap) {
    DashCap[DashCap["Flat"] = 0] = "Flat";
    DashCap[DashCap["Round"] = 2] = "Round";
    DashCap[DashCap["Triangle"] = 3] = "Triangle";
})(DashCap || (DashCap = {}));


/***/ }),

/***/ "./src/drawing/DrawStringCache.ts":
/*!****************************************!*\
  !*** ./src/drawing/DrawStringCache.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DrawStringCache": () => (/* binding */ DrawStringCache)
/* harmony export */ });
var DrawStringCache = /** @class */ (function () {
    function DrawStringCache(name) {
    }
    return DrawStringCache;
}());



/***/ }),

/***/ "./src/drawing/Font.ts":
/*!*****************************!*\
  !*** ./src/drawing/Font.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Font": () => (/* binding */ Font)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _FontStyle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FontStyle */ "./src/drawing/FontStyle.ts");
/* harmony import */ var _StringAlignment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StringAlignment */ "./src/drawing/StringAlignment.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _scene_utils_Canvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scene/utils/Canvas */ "./src/drawing/scene/utils/Canvas.ts");
/* harmony import */ var _fontMeasure__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fontMeasure */ "./src/drawing/fontMeasure.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// import * as opentype from 'opentype.js'




var pxToEmArray = [];
pxToEmArray[4] = 0.250;
pxToEmArray[5] = 0.3125;
pxToEmArray[6] = 0.375;
pxToEmArray[7] = 0.4375;
pxToEmArray[8] = 0.500;
pxToEmArray[9] = 0.5625;
pxToEmArray[10] = 0.625;
pxToEmArray[11] = 0.6875;
pxToEmArray[12] = 0.750;
pxToEmArray[13] = 0.8125;
pxToEmArray[14] = 0.875;
pxToEmArray[15] = 0.9375;
pxToEmArray[16] = 1.000;
pxToEmArray[17] = 1.0625;
pxToEmArray[18] = 1.125;
pxToEmArray[19] = 1.1875;
pxToEmArray[20] = 1.250;
pxToEmArray[21] = 1.3125;
pxToEmArray[22] = 1.375;
pxToEmArray[23] = 1.4375;
pxToEmArray[24] = 1.500;
pxToEmArray[25] = 1.5625;
pxToEmArray[26] = 1.625;
pxToEmArray[27] = 1.6875;
pxToEmArray[28] = 1.75;
pxToEmArray[29] = 1.8125;
pxToEmArray[30] = 1.875;
pxToEmArray[31] = 1.9375;
pxToEmArray[32] = 2.00;
/*
4 PX	0.250 EM	25%
5 PX	0.3125 EM	31.25%
6 PX	0.375 EM	37.5%
7 PX	0.4375 EM	43.75%
8 PX	0.500 EM	50.0%
9 PX	0.5625 EM	56.25%
10 PX	0.625 EM	62.5%
11 PX	0.6875 EM	68.75%
12 PX	0.750 EM	75.0%
13 PX	0.8125 EM	81.25%
14 PX	0.875 EM	87.5%
15 PX	0.9375 EM	93.75%
16 PX	1.000 EM	100.0%
17 PX	1.0625 EM	106.25%
18 PX	1.125 EM	112.5%
19 PX	1.1875 EM	118.75%
20 PX	1.250 EM	125.0%
21 PX	1.3125 EM	131.25%
22 PX	1.375 EM	137.5%
23 PX	1.4375 EM	143.75%
24 PX	1.500 EM	150.0%
25 PX	1.5625 EM	156.25%
26 PX	1.625 EM	162.5%
27 PX	1.6875 EM	168.75%
28 PX	1.75 EM	175.0%
29 PX	1.8125 EM	181.25%
30 PX	1.875 EM	187.5%
31 PX	1.9375 EM	193.75%
32 PX	2.00 EM	200.0% */
var Font = /** @class */ (function (_super) {
    __extends(Font, _super);
    function Font(fontFamily, size) {
        return _super.call(this, fontFamily, size) || this;
    }
    Font_1 = Font;
    Object.defineProperty(Font.prototype, "Height", {
        get: function () {
            return this.Size;
        },
        enumerable: false,
        configurable: true
    });
    Font.prototype.setup = function (graphics) {
        var a = 'sdasd';
        //if (graphics instanceof GraphicsBase) {
        graphics.setFont(this);
        //}
    };
    Font.prototype._prepContext = function (ctx) {
        ctx.font = this.Size + "px " + this.Name;
        switch (this.HorizAlign) {
            case _StringAlignment__WEBPACK_IMPORTED_MODULE_2__.StringAlignment.Near:
                ctx.textAlign = "left";
                break;
            case _StringAlignment__WEBPACK_IMPORTED_MODULE_2__.StringAlignment.Center:
                ctx.textAlign = "center";
                break;
            case _StringAlignment__WEBPACK_IMPORTED_MODULE_2__.StringAlignment.Far:
                ctx.textAlign = "right";
                break;
        }
        switch (this.VertAlign) {
            case _StringAlignment__WEBPACK_IMPORTED_MODULE_2__.StringAlignment.Near:
                ctx.textBaseline = "top";
                break;
            case _StringAlignment__WEBPACK_IMPORTED_MODULE_2__.StringAlignment.Center:
                ctx.textBaseline = "middle";
                break;
            case _StringAlignment__WEBPACK_IMPORTED_MODULE_2__.StringAlignment.Far:
                ctx.textBaseline = "bottom";
                break;
        }
        ctx.lineJoin = "miter";
        ctx.miterLimit = 2.5;
        return ctx;
    };
    Font.prototype.getHeight = function () {
        // TODO: fix this
        //console.error('font.getHeight not implemented.');
        return this.textSize;
    };
    Font.prototype.getTextWidth = function (text) {
        var ctx = Font_1._ctx;
        ctx.save();
        var w = this._prepContext(ctx).measureText(text).width;
        ctx.restore();
        return w;
    };
    Font.prototype.equals = function (font) {
        return false;
    };
    Font.prototype.GetCellAscent = function () {
        var metics = (0,_fontMeasure__WEBPACK_IMPORTED_MODULE_6__.measureFont)(this.Name, {
            'fontSize': this.Height, 'fontWeight': this.Style === _FontStyle__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Bold ? 400 : 100,
            'fontStyle': this.Style === _FontStyle__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Italic ? 'italic' : 'normal'
        });
        return metics.ascent;
    };
    Font.prototype.GetHeight = function () {
        var metics = (0,_fontMeasure__WEBPACK_IMPORTED_MODULE_6__.measureFont)(this.Name, {
            'fontSize': this.Height, 'fontWeight': this.Style === _FontStyle__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Bold ? 400 : 100,
            'fontStyle': this.Style === _FontStyle__WEBPACK_IMPORTED_MODULE_1__.FontStyle.Italic ? 'italic' : 'normal'
        });
        return metics.lineHeight;
    };
    var Font_1;
    Font._ctx = (0,_scene_utils_Canvas__WEBPACK_IMPORTED_MODULE_5__.createCanvas)().getContext("2d");
    Font = Font_1 = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_3__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.Font,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.Font
            ]
        }),
        __metadata("design:paramtypes", [Object, Number])
    ], Font);
    return Font;
}(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGFont));



/***/ }),

/***/ "./src/drawing/FontFamily.ts":
/*!***********************************!*\
  !*** ./src/drawing/FontFamily.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FontFamily": () => (/* binding */ FontFamily)
/* harmony export */ });
var FontFamily = /** @class */ (function () {
    function FontFamily(name) {
        this.familyName = name;
    }
    Object.defineProperty(FontFamily.prototype, "Name", {
        get: function () {
            return this.familyName;
        },
        enumerable: false,
        configurable: true
    });
    FontFamily.prototype.getLineSpacing = function (style) {
        console.error('FontFamily.getLineSpacing not implemented.');
        return undefined;
    };
    FontFamily.prototype.getEmHeight = function (style) {
        console.error('font.getEmHeight not implemented.');
        return undefined;
    };
    FontFamily.prototype.toString = function () {
        return "FontFamily: Name=" + this.Name;
    };
    return FontFamily;
}());



/***/ }),

/***/ "./src/drawing/FontStyle.ts":
/*!**********************************!*\
  !*** ./src/drawing/FontStyle.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FontStyle": () => (/* binding */ FontStyle)
/* harmony export */ });
var FontStyle;
(function (FontStyle) {
    FontStyle[FontStyle["Regular"] = 0] = "Regular";
    FontStyle[FontStyle["Bold"] = 1] = "Bold";
    FontStyle[FontStyle["Italic"] = 2] = "Italic";
    FontStyle[FontStyle["Underline"] = 4] = "Underline";
    FontStyle[FontStyle["Strikeout"] = 8] = "Strikeout";
})(FontStyle || (FontStyle = {}));


/***/ }),

/***/ "./src/drawing/GDIPlus.ts":
/*!********************************!*\
  !*** ./src/drawing/GDIPlus.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DrawImageAbort": () => (/* binding */ DrawImageAbort),
/* harmony export */   "ImageHandleTable": () => (/* binding */ ImageHandleTable),
/* harmony export */   "GraphicsHandleTable": () => (/* binding */ GraphicsHandleTable),
/* harmony export */   "GDIPlus": () => (/* binding */ GDIPlus),
/* harmony export */   "StreamGetHeaderDelegate": () => (/* binding */ StreamGetHeaderDelegate),
/* harmony export */   "StreamGetBytesDelegate": () => (/* binding */ StreamGetBytesDelegate),
/* harmony export */   "StreamSeekDelegate": () => (/* binding */ StreamSeekDelegate),
/* harmony export */   "StreamPutBytesDelegate": () => (/* binding */ StreamPutBytesDelegate),
/* harmony export */   "StreamCloseDelegate": () => (/* binding */ StreamCloseDelegate),
/* harmony export */   "StreamSizeDelegate": () => (/* binding */ StreamSizeDelegate),
/* harmony export */   "GdiPlusStreamHelper": () => (/* binding */ GdiPlusStreamHelper)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _gdipEnums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gdipEnums */ "./src/drawing/gdipEnums.ts");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _gdipStructs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gdipStructs */ "./src/drawing/gdipStructs.ts");
/* harmony import */ var _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./imaging/PixelFormat */ "./src/drawing/imaging/PixelFormat.ts");
/* harmony import */ var _Utilities_ColorThief__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Utilities/ColorThief */ "./src/Utilities/ColorThief.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var DrawImageAbort = /** @class */ (function (_super) {
    __extends(DrawImageAbort, _super);
    function DrawImageAbort() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DrawImageAbort;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Delegate));

;
var ImageHandleTable = /** @class */ (function (_super) {
    __extends(ImageHandleTable, _super);
    function ImageHandleTable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageHandleTable.prototype.CreateHandle = function (image) {
        var handle = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(ImageHandleTable.handleCount++);
        this.Add(handle, image);
        return handle;
    };
    ImageHandleTable.prototype.GetImage = function (handle) {
        if (this.ContainsKey(handle)) {
            return this.Get(handle);
        }
        return null;
    };
    ImageHandleTable.handleCount = 0;
    return ImageHandleTable;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Dictionary));

var GraphicsHandleTable = /** @class */ (function (_super) {
    __extends(GraphicsHandleTable, _super);
    function GraphicsHandleTable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GraphicsHandleTable.prototype.CreateHandle = function (context) {
        var handle = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(GraphicsHandleTable.handleCount++);
        this.Add(handle, context);
        return handle;
    };
    GraphicsHandleTable.prototype.GetGraphics = function (handle) {
        if (this.ContainsKey(handle)) {
            return this.Get(handle);
        }
        return null;
    };
    GraphicsHandleTable.prototype.SetGraphics = function (handle, renderingContext) {
        //if (this.ContainsKey(handle)) {
        this.Set(handle, renderingContext);
        //}
        //return null as any;
    };
    GraphicsHandleTable.Default = new GraphicsHandleTable();
    GraphicsHandleTable.handleCount = 0;
    return GraphicsHandleTable;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Dictionary));

var GDIPlus = /** @class */ (function () {
    function GDIPlus() {
    }
    /*  public static CreateImageHandle: (image: CGImage) => IntPtr = (function () {
         let imageHandleCount = 0;
         let imageTable: Dictionary<IntPtr, CGImage> = null as any;
         return (image: CGImage): IntPtr => {
             if (imageTable == null) {
                 imageTable = new Dictionary();
             }
             const handle = new IntPtr(imageHandleCount++);
             imageTable.Add(handle, image);
             return
         }
     })(); */
    GDIPlus.GdiplusStartup = function (token, input, output) {
        //throw new NotImplementedException('');
        // do nothing
        return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
    };
    GDIPlus.GdiplusShutdown = function (token) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.ProcessExit = function (sender, e) {
        // Called all pending objects and claim any pending handle before
        // shutting down
        GC.Collect();
        GC.WaitForPendingFinalizers();
    };
    GDIPlus.StaticConstructor = function () {
        GDIPlus.GdiPlusToken = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
        var platform = 4; // Environment.OSVersion.Platform;
        /* if ((platform == 4) || (platform == 6) || (platform == 128)) {
            if (Environment.GetEnvironmentVariable("not_supported_MONO_MWF_USE_NEW_X11_BACKEND") != null || Environment.GetEnvironmentVariable("MONO_MWF_MAC_FORCE_X11") != null) {
                UseX11Drawable = true;
            } else {
                IntPtr buf = Marshal.AllocHGlobal(8192);
                // This is kind of a hack but gets us sysname from uname (struct utsname *name) on
                // linux and darwin
                if (uname(buf) != 0) {
                    // WTH: We couldn't detect the OS; lets default to X11
                    UseX11Drawable = true;
                } else {
                    string os = Marshal.PtrToStringAnsi(buf);
                    if (os == "Darwin")
                        UseCarbonDrawable = true;
                    else
                        UseX11Drawable = true;
                }
                Marshal.FreeHGlobal(buf);
            }
        }*/
        var input = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(_gdipStructs__WEBPACK_IMPORTED_MODULE_3__.GdiplusStartupInput.MakeGdiplusStartupInput());
        var output = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(_gdipStructs__WEBPACK_IMPORTED_MODULE_3__.GdiplusStartupOutput.MakeGdiplusStartupOutput());
        try {
            GDIPlus.GdiplusStartup(GDIPlus.GdiPlusToken, input, output);
        }
        catch (TypeInitializationException) {
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Console.Error.WriteLine("* ERROR: Can not initialize GDI+ library{0}{0}" +
                "Please check http://www.mono-project.com/Problem:GDIPlusInit for details", _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Environment.NewLine);
        }
        // under MS 1.x this event is raised only for the default application domain
        // TODO: AppDomain.CurrentDomain.ProcessExit.add(new EventHandler(GDIPlus.ProcessExit));
    };
    GDIPlus.RunningOnWindows = function () {
        return true; /* !UseX11Drawable && !UseCarbonDrawable && !UseCocoaDrawable */
        ;
    };
    GDIPlus.RunningOnUnix = function () {
        return false; /* UseX11Drawable || UseCarbonDrawable || UseCocoaDrawable; */
    };
    // Copies a Ptr to an array of Points and releases the memory
    GDIPlus.FromUnManagedMemoryToPointI = function (prt, pts) {
        var nPointSize = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.SizeOf(pts[0]);
        var pos = prt;
        for (var i = 0; i < pts.length; i++, pos = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(pos.ToInt64() + nPointSize))
            pts[i] = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStructure(pos, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CoreGraphicTypes.CGPoint));
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(prt);
    };
    // Copies a Ptr to an array of Points and releases the memory
    GDIPlus.FromUnManagedMemoryToPoint = function (prt, pts) {
        var nPointSize = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.SizeOf(pts[0]);
        var pos = prt;
        for (var i = 0; i < pts.length; i++, pos = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(pos.ToInt64() + nPointSize))
            pts[i] = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStructure(pos, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CoreGraphicTypes.CGPoint));
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(prt);
    };
    // Copies an array of Points to unmanaged memory
    GDIPlus.FromPointToUnManagedMemoryI = function (pts) {
        var nPointSize = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.SizeOf(pts[0]);
        var dest = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.AllocHGlobal(nPointSize * pts.length);
        var pos = dest;
        for (var i = 0; i < pts.length; i++, pos = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(pos.ToInt64() + nPointSize))
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.StructureToPtr(pts[i], pos, false);
        return dest;
    };
    // Copies a Ptr to an array of v and releases the memory
    GDIPlus.FromUnManagedMemoryToRectangles = function (prt, pts) {
        var nPointSize = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.SizeOf(pts[0]);
        var pos = prt;
        for (var i = 0; i < pts.length; i++, pos = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(pos.ToInt64() + nPointSize))
            pts[i] = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStructure(pos, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CoreGraphicTypes.CGRectangle));
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(prt);
    };
    // Copies an array of Points to unmanaged memory
    GDIPlus.FromPointToUnManagedMemory = function (pts) {
        var nPointSize = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.SizeOf(pts[0]);
        var dest = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.AllocHGlobal(nPointSize * pts.length);
        var pos = dest;
        for (var i = 0; i < pts.length; i++, pos = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(pos.ToInt64() + nPointSize))
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.StructureToPtr(pts[i], pos, false);
        return dest;
    };
    // Converts a status into exception
    // TODO: Add more status code mappings here
    GDIPlus.CheckStatus = function (status) {
        var msg;
        switch (status) {
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok:
                return;
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.GenericError:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Generic Error [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Exception(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.InvalidParameter:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("A null reference or invalid value was found [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.OutOfMemory:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Not enough memory to complete operation [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.OutOfMemoryException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.ObjectBusy:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Object is busy and cannot state allow this operation [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.MemberAccessException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.InsufficientBuffer:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Insufficient buffer provided to complete operation [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.InternalBufferOverflowException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.PropertyNotSupported:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Property not supported [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotSupportedException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.FileNotFound:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Requested file was not found [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.FileNotFoundException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.AccessDenied:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Access to resource was denied [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.UnauthorizedAccessException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.UnknownImageFormat:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Either the image format is unknown or you don't have the required libraries to decode this format [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotSupportedException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.NotImplemented:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("The requested feature is not implemented [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.WrongState:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Object is not in a state that can allow this operation [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.FontFamilyNotFound:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("The requested FontFamily could not be found [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.ValueOverflow:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Argument is out of range [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.OverflowException(msg);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Win32Error:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("The operation is invalid [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.InvalidOperationException(msg);
            default:
                msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Unknown Error [GDI+ status: {0}]", status);
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Exception(msg);
        }
    };
    // Memory functions
    GDIPlus.GdipAlloc = function (size) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipFree = function (ptr) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    // Brush functions
    GDIPlus.GdipCloneBrush = function (brush, clonedBrush) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDeleteBrush = function (brush) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetBrushType = function (brush, type) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    // Region functions
    GDIPlus.GdipCreateRegion = function (region) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateRegionRgnData = function (data, size, region) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDeleteRegion = function (region) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCloneRegion = function (region, cloned) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateRegionRect = function (rect, region) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateRegionRectI = function (rect, region) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateRegionPath = function (path, region) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipTranslateRegion = function (region, dx, dy) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipTranslateRegionI = function (region, dx, dy) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipIsVisibleRegionPoint = function (region, x, y, graphics, result) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipIsVisibleRegionPointI = function (region, x, y, graphics, result) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipIsVisibleRegionRect = function (region, x, y, width, height, graphics, result) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipIsVisibleRegionRectI = function (region, x, y, width, height, graphics, result) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCombineRegionRect = function (region, rect, combineMode) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCombineRegionRectI = function (region, rect, combineMode) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCombineRegionPath = function (region, path, combineMode) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetRegionBounds = function (region, graphics, rect) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipSetInfinite = function (region) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipSetEmpty = function (region) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipIsEmptyRegion = function (region, graphics, result) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipIsInfiniteRegion = function (region, graphics, result) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCombineRegionRegion = function (region, region2, combineMode) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipIsEqualRegion = function (region, region2, graphics, result) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCloneBitmapArea = function (x, y, width, height, format, original, bitmap) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    // Image functions
    GDIPlus.GdipLoadImageFromFile = function (filename, image) {
        //throw new NotImplementedException('');
        var img = new _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGImage(filename);
        image.value = GDIPlus.ImageHandleTable.CreateHandle(img);
        if (image.value != null) {
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
        }
        else {
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.GenericError;
        }
    };
    // Stream functions for Win32 (original Win32 ones)
    GDIPlus.GdipLoadImageFromStream = function (stream, image) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipSaveImageToStream = function (image, stream, clsidEncoder, encoderParams) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCloneImage = function (image, imageclone) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipLoadImageFromFileICM = function (filename, image) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateBitmapFromHBITMAP = function (hBitMap, gdiPalette, image) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDisposeImage = function (image) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageFlags = function (image, flag) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageType = function (image, type) {
        // throw new NotImplementedException('');
        type.value = _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.ImageType.Bitmap;
        return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
    };
    GDIPlus.GdipImageGetFrameDimensionsCount = function (image, count) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipImageGetFrameDimensionsList = function (image, dimensionIDs, count) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageHeight = function (image, height) {
        //throw new NotImplementedException('');
        var img = GDIPlus.ImageHandleTable.GetImage(image);
        if (img != null) {
            height.value = img.Height;
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
        }
        else {
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.NativeImageNotFound;
        }
    };
    GDIPlus.GdipGetImageHorizontalResolution = function (image, resolution) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImagePaletteSize = function (image, size) {
        //throw new NotImplementedException('');
        var img = GDIPlus.ImageHandleTable.GetImage(image);
        if (img != null) {
            var colorThief = new _Utilities_ColorThief__WEBPACK_IMPORTED_MODULE_5__.ColorThief();
            size.value = colorThief.GetPalette(img).length;
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
        }
        else {
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.NativeImageNotFound;
        }
    };
    GDIPlus.GdipGetImagePalette = function (image, palette, size) {
        var img = GDIPlus.ImageHandleTable.GetImage(image);
        if (img != null) {
            var colorThief = new _Utilities_ColorThief__WEBPACK_IMPORTED_MODULE_5__.ColorThief();
            var buffer = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.GetBufferFromPointer(palette);
            buffer.writeInt32(1); // flag
            buffer.writeInt32(size); // sieof palette
            var imagePalette = colorThief.GetPalette(img);
            for (var i = 0; i < imagePalette.length; i++) {
                for (var j = 0; j < imagePalette[i].length; j++) {
                    buffer.writeUint8(imagePalette[i][j]);
                }
            }
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
        }
        else {
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.NativeImageNotFound;
        }
    };
    GDIPlus.GdipSetImagePalette = function (image, palette) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageDimension = function (image, width, height) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImagePixelFormat = function (image, format) {
        //throw new NotImplementedException('');
        format.value = _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_4__.PixelFormat.Format32bppArgb;
        return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
    };
    GDIPlus.GdipGetPropertyCount = function (image, propNumbers) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetPropertyIdList = function (image, propNumbers, list) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetPropertySize = function (image, bufferSize, propNumbers) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetAllPropertyItems = function (image, bufferSize, propNumbers, items) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageRawFormat = function (image, format) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageVerticalResolution = function (image, resolution) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageWidth = function (image, width) {
        //throw new NotImplementedException('');
        var img = GDIPlus.ImageHandleTable.GetImage(image);
        if (img != null) {
            width.value = img.Width;
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
        }
        else {
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.NativeImageNotFound;
        }
    };
    GDIPlus.GdipGetImageBounds = function (image, source, unit) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetEncoderParameterListSize = function (image, encoder, size) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetEncoderParameterList = function (image, encoder, size, buffer) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipImageGetFrameCount = function (image, guidDimension, count) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipImageSelectActiveFrame = function (image, guidDimension, frameIndex) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetPropertyItemSize = function (image, propertyID, propertySize) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetPropertyItem = function (image, propertyID, propertySize, buffer) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipRemovePropertyItem = function (image, propertyId) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipSetPropertyItem = function (image, propertyItem) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageThumbnail = function (image, width, height, thumbImage, callback, callBackData) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipImageRotateFlip = function (image, rotateFlipType) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipSaveImageToFile = function (image, filename, encoderClsID, encoderParameters) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipSaveAdd = function (image, encoderParameters) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipSaveAddImage = function (image, imagenew, encoderParameters) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDrawImageI = function (graphics, image, x, y) {
        // throw new NotImplementedException('');
        var context = GraphicsHandleTable.Default.GetGraphics(graphics);
        if (context != null) {
            var img = GDIPlus.ImageHandleTable.GetImage(image);
            if (img != null) {
                context.drawImage(img.canvas, 0, 0, img.Width, img.Height, x, y, img.Width, img.Height);
                return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
            }
            else {
                return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.NativeImageNotFound;
            }
        }
        else {
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.NativeContext2DNotFound;
        }
        return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.NotImplemented;
    };
    GDIPlus.GdipGetImageGraphicsContext = function (image, graphics) {
        //throw new NotImplementedException('');
        var img = GDIPlus.ImageHandleTable.GetImage(image);
        if (img != null) {
            var rendererContext = new _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGContext2D(img.getContext());
            graphics.value = GraphicsHandleTable.Default.CreateHandle(rendererContext);
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
        }
        return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.GenericError;
    };
    GDIPlus.GdipDrawImage = function (graphics, image, x, y) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipBeginContainer = function (graphics, dstrect, srcrect, unit, state) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipBeginContainerI = function (graphics, dstrect, srcrect, unit, state) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipBeginContainer2 = function (graphics, state) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDrawImagePoints = function (graphics, image, destPoints, count) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDrawImagePointsI = function (graphics, image, destPoints, count) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDrawImageRectRectI = function (graphics, image, dstx, dsty, dstwidth, dstheight, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDrawImageRectRect = function (graphics, image, dstx, dsty, dstwidth, dstheight, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDrawImagePointsRectI = function (graphics, image, destPoints, count, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDrawImagePointsRect = function (graphics, image, destPoints, count, srcx, srcy, srcwidth, srcheight, srcUnit, imageattr, callback, callbackData) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDrawImageRect = function (graphics, image, x, y, width, height) {
        // throw new NotImplementedException('');
        var context = GraphicsHandleTable.Default.GetGraphics(graphics);
        if (context != null) {
            var img = GDIPlus.ImageHandleTable.GetImage(image);
            if (img != null) {
                context.drawImage(img.canvas, 0, 0, img.Width, img.Height, x, y, width, height);
                return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
            }
            else {
                return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.NativeImageNotFound;
            }
        }
        else {
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.NativeContext2DNotFound;
        }
        return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.NotImplemented;
    };
    GDIPlus.GdipDrawImagePointRect = function (graphics, image, x, y, srcx, srcy, srcwidth, srcheight, srcUnit) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipDrawImagePointRectI = function (graphics, image, x, y, srcx, srcy, srcwidth, srcheight, srcUnit) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateStringFormat = function (formatAttributes, language, native) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateHBITMAPFromBitmap = function (bmp, HandleBmp, clrbackground) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateBitmapFromFile = function (filename, bitmap) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateBitmapFromFileICM = function (filename, bitmap) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateHICONFromBitmap = function (bmp, HandleIcon) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateBitmapFromHICON = function (hicon, bitmap) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipCreateBitmapFromResource = function (hInstance, lpBitmapName, bitmap) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageDecodersSize = function (decoderNums, arraySize) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageDecoders = function (decoderNums, arraySize, decoders) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageEncodersSize = function (encoderNums, arraySize) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipGetImageEncoders = function (encoderNums, arraySize, encoders) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    // Bitmap functions
    GDIPlus.GdipCreateBitmapFromScan0 = function (width, height, stride, format, scan0, bmp) {
        // throw new NotImplementedException('');
        var img = new _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGImage(width, height);
        bmp.value = GDIPlus.ImageHandleTable.CreateHandle(img);
        if (bmp.value != null) {
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
        }
        else {
            return _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.GenericError;
        }
    };
    GDIPlus.GdipCreateBitmapFromGraphics = function (width, height, target, bitmap) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipBitmapLockBits = function (bmp, rc, flags, format, bmpData) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipBitmapSetResolution = function (bmp, xdpi, ydpi) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipBitmapUnlockBits = function (bmp, bmpData) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipBitmapGetPixel = function (bmp, x, y, argb) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.GdipBitmapSetPixel = function (bmp, x, y, argb) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
    };
    GDIPlus.ImageHandleTable = new ImageHandleTable();
    GDIPlus.FACESIZE = 32;
    GDIPlus.LANG_NEUTRAL = 0;
    GDIPlus.Display = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
    GDIPlus.UseX11Drawable = false;
    GDIPlus.UseCarbonDrawable = false;
    GDIPlus.UseCocoaDrawable = false;
    return GDIPlus;
}());

//
// These are stuff that is unix-only
//
var StreamGetHeaderDelegate = /** @class */ (function (_super) {
    __extends(StreamGetHeaderDelegate, _super);
    function StreamGetHeaderDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StreamGetHeaderDelegate;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Delegate));

;
var StreamGetBytesDelegate = /** @class */ (function (_super) {
    __extends(StreamGetBytesDelegate, _super);
    function StreamGetBytesDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StreamGetBytesDelegate;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Delegate));

var StreamSeekDelegate = /** @class */ (function (_super) {
    __extends(StreamSeekDelegate, _super);
    function StreamSeekDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StreamSeekDelegate;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Delegate));

;
var StreamPutBytesDelegate = /** @class */ (function (_super) {
    __extends(StreamPutBytesDelegate, _super);
    function StreamPutBytesDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StreamPutBytesDelegate;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Delegate));

;
var StreamCloseDelegate = /** @class */ (function (_super) {
    __extends(StreamCloseDelegate, _super);
    function StreamCloseDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StreamCloseDelegate;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Delegate));

;
var StreamSizeDelegate = /** @class */ (function (_super) {
    __extends(StreamSizeDelegate, _super);
    function StreamSizeDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StreamSizeDelegate;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Delegate));

;
var GdiPlusStreamHelper = /** @class */ (function () {
    function GdiPlusStreamHelper(s, seekToOrigin) {
        this.stream = null;
        this.sghd = null;
        this.sgbd = null;
        this.skd = null;
        this.spbd = null;
        this.scd = null;
        this.ssd = null;
        this.start_buf = null;
        this.start_buf_pos = 0;
        this.start_buf_len = 0;
        this.managedBuf = null;
        this.managedBuf = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(GdiPlusStreamHelper.default_bufsize);
        this.stream = s;
        if (this.stream != null && this.stream.CanSeek && seekToOrigin) {
            this.stream.Seek(0, _tuval_core__WEBPACK_IMPORTED_MODULE_0__.SeekOrigin.Begin);
        }
    }
    GdiPlusStreamHelper.prototype.StreamGetHeaderImpl = function (buf, bufsz) {
        var bytesRead;
        this.start_buf = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(bufsz);
        try {
            bytesRead = this.stream.Read(this.start_buf, 0, bufsz);
        }
        catch (e) {
            return -1;
        }
        if (bytesRead > 0 && buf != _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero) {
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.Copy(this.start_buf, 0, new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(buf.ToInt64()), bytesRead);
        }
        this.start_buf_pos = 0;
        this.start_buf_len = bytesRead;
        return bytesRead;
    };
    Object.defineProperty(GdiPlusStreamHelper.prototype, "GetHeaderDelegate", {
        get: function () {
            if (this.stream != null && this.stream.CanRead) {
                if (this.sghd == null) {
                    this.sghd = new StreamGetHeaderDelegate(this.StreamGetHeaderImpl);
                }
                return this.sghd;
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    GdiPlusStreamHelper.prototype.StreamGetBytesImpl = function (buf, bufsz, peek) {
        if (buf === _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero && peek) {
            return -1;
        }
        if (bufsz > this.managedBuf.length)
            this.managedBuf = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(bufsz);
        var bytesRead = 0;
        var streamPosition = 0;
        if (bufsz > 0) {
            if (this.stream.CanSeek) {
                streamPosition = this.stream.Position;
            }
            if (this.start_buf_len > 0) {
                if (this.start_buf_len > bufsz) {
                    _tuval_core__WEBPACK_IMPORTED_MODULE_0__.TArray.Copy(this.start_buf, this.start_buf_pos, this.managedBuf, 0, bufsz);
                    this.start_buf_pos += bufsz;
                    this.start_buf_len -= bufsz;
                    bytesRead = bufsz;
                    bufsz = 0;
                }
                else {
                    // this is easy
                    _tuval_core__WEBPACK_IMPORTED_MODULE_0__.TArray.Copy(this.start_buf, this.start_buf_pos, this.managedBuf, 0, this.start_buf_len);
                    bufsz -= this.start_buf_len;
                    bytesRead = this.start_buf_len;
                    this.start_buf_len = 0;
                }
            }
            if (bufsz > 0) {
                try {
                    bytesRead += this.stream.Read(this.managedBuf, bytesRead, bufsz);
                }
                catch (IOException) {
                    return -1;
                }
            }
            if (bytesRead > 0 && buf != _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero) {
                _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.Copy(this.managedBuf, 0, new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(buf.ToInt64()), bytesRead);
            }
            if (!this.stream.CanSeek && (bufsz === 10) && peek) {
                // Special 'hack' to support peeking of the type for gdi+ on non-seekable streams
            }
            if (peek) {
                if (this.stream.CanSeek) {
                    // If we are peeking bytes, then go back to original position before peeking
                    this.stream.Seek(streamPosition, _tuval_core__WEBPACK_IMPORTED_MODULE_0__.SeekOrigin.Begin);
                }
                else {
                    throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotSupportedException('');
                }
            }
        }
        return bytesRead;
    };
    Object.defineProperty(GdiPlusStreamHelper.prototype, "GetBytesDelegate", {
        get: function () {
            if (this.stream != null && this.stream.CanRead) {
                if (this.sgbd == null) {
                    this.sgbd = new StreamGetBytesDelegate(this.StreamGetBytesImpl);
                }
                return this.sgbd;
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    GdiPlusStreamHelper.prototype.StreamSeekImpl = function (offset, whence) {
        // Make sure we have a valid 'whence'.
        if ((whence < 0) || (whence > 2))
            return -1;
        // Invalidate the start_buf if we're actually going to call a Seek method.
        this.start_buf_pos += this.start_buf_len;
        this.start_buf_len = 0;
        var origin;
        // Translate 'whence' into a SeekOrigin enum member.
        switch (whence) {
            case 0:
                origin = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.SeekOrigin.Begin;
                break;
            case 1:
                origin = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.SeekOrigin.Current;
                break;
            case 2:
                origin = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.SeekOrigin.End;
                break;
            // The following line is redundant but necessary to avoid a
            // "Use of unassigned local variable" error without actually
            // initializing 'origin' to a dummy value.
            default: return -1;
        }
        // Do the actual seek operation and return its result.
        return this.stream.Seek(offset, origin);
    };
    Object.defineProperty(GdiPlusStreamHelper.prototype, "SeekDelegate", {
        get: function () {
            if (this.stream != null && this.stream.CanSeek) {
                if (this.skd == null) {
                    this.skd = new StreamSeekDelegate(this.StreamSeekImpl);
                }
                return this.skd;
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    GdiPlusStreamHelper.prototype.StreamPutBytesImpl = function (buf, bufsz) {
        if (bufsz > this.managedBuf.length)
            this.managedBuf = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(bufsz);
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.Copy(buf, this.managedBuf, 0, bufsz);
        this.stream.Write(this.managedBuf, 0, bufsz);
        return bufsz;
    };
    Object.defineProperty(GdiPlusStreamHelper.prototype, "PutBytesDelegate", {
        get: function () {
            if (this.stream != null && this.stream.CanWrite) {
                if (this.spbd == null) {
                    this.spbd = new StreamPutBytesDelegate(this.StreamPutBytesImpl);
                }
                return this.spbd;
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    GdiPlusStreamHelper.prototype.StreamCloseImpl = function () {
        this.stream.Close();
    };
    Object.defineProperty(GdiPlusStreamHelper.prototype, "CloseDelegate", {
        get: function () {
            if (this.stream != null) {
                if (this.scd == null) {
                    this.scd = new StreamCloseDelegate(this.StreamCloseImpl);
                }
                return this.scd;
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    GdiPlusStreamHelper.prototype.StreamSizeImpl = function () {
        try {
            return this.stream.Length;
        }
        catch (_a) {
            return -1;
        }
    };
    Object.defineProperty(GdiPlusStreamHelper.prototype, "SizeDelegate", {
        get: function () {
            if (this.stream != null) {
                if (this.ssd == null) {
                    this.ssd = new StreamSizeDelegate(this.StreamSizeImpl);
                }
                return this.ssd;
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    GdiPlusStreamHelper.default_bufsize = 4096;
    return GdiPlusStreamHelper;
}());

GDIPlus.StaticConstructor();


/***/ }),

/***/ "./src/drawing/GeomUtilities.ts":
/*!**************************************!*\
  !*** ./src/drawing/GeomUtilities.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GeomUtilities": () => (/* binding */ GeomUtilities)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _drawing2D_Blend__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawing2D/Blend */ "./src/drawing/drawing2D/Blend.ts");
/* harmony import */ var _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawing2D/GraphicsPath */ "./src/drawing/drawing2D/GraphicsPath.ts");




var GeomUtilities = /** @class */ (function () {
    function GeomUtilities() {
    }
    /*
           * The angle of the orientation line determines which corners the starting and ending lines pass through.
           * For example, if the angle is between 0 and 90 degrees, the starting line passes through the upper-left corner,
           * and the ending line passes through the lower-right corner.
           *
           * Mac NSGradient drawInRect angle Documentation:
           *
           * https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/NSGradient_class/Reference/Reference.html
           *
           * Linear gradient starting points.
           *   Mac osx coordinates
           * 	Rotation angle		Start corner
           * 	0-89 degrees		Lower-left
           * 	90-179 degrees		Lower-right
           * 	180-269 degrees		Upper-right
           * 	270-359 degrees		Upper-left
           *
           *  Think of a rectangle within a circle.  start from one of the quadrants above and find the point on the
           *  circumference of the circle
           *
           * http://msdn.microsoft.com/en-us/library/ms142563.aspx
           * All points along any line perpendicular to the orientation line are the same color.
           * The starting line is perpendicular to the orientation line and passes through one of the corners of
           * the rectangle. All points on the starting line are the starting color. Then ending line is perpendicular
           * to the orientation line and passes through one of the corners of the rectangle. All points on the
           * ending line are the ending color.
           *
           */
    GeomUtilities.ComputeOrientationLine = function (rect, angle, start, end) {
        start.value = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        end.value = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        var tanSize = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize.Empty;
        // Clamp to 360 degrees
        angle = angle % 360;
        // We start by breaking the angle up into quadrants
        // as per table in comments
        if (angle < 90) {
            start.value.X = rect.Location.X;
            start.value.Y = rect.Location.Y;
            tanSize.Width = rect.Size.Width;
            tanSize.Height = rect.Size.Height;
        }
        else if (angle < 180) {
            start.value.X = rect.Location.X + rect.Size.Width;
            start.value.Y = rect.Location.Y;
            tanSize.Width = -rect.Size.Width;
            tanSize.Height = rect.Size.Height;
        }
        else if (angle < 270) {
            start.value.X = rect.Location.X + rect.Size.Width;
            start.value.Y = rect.Location.Y + rect.Size.Height;
            tanSize.Width = -rect.Size.Width;
            tanSize.Height = -rect.Size.Height;
        }
        else {
            start.value.X = rect.Location.X;
            start.value.Y = rect.Location.Y + rect.Size.Height;
            tanSize.Width = rect.Size.Width;
            tanSize.Height = -rect.Size.Height;
        }
        var radAngle = GeomUtilities.ToRadians(angle);
        // Distance formula to get the circle radius - http://en.wikipedia.org/wiki/Distance
        var radius = Math.sqrt(rect.Size.Width * rect.Size.Width + rect.Size.Height * rect.Size.Height);
        // get the slope angle
        var slopeAngle = Math.atan2(tanSize.Height, tanSize.Width);
        //  Compute the distance
        var distance = Math.cos(slopeAngle - radAngle) * radius;
        // Parametric Equation for a circle
        // a = angle in radians
        // ( cos(a) * d + x, sin(a) * d + y)
        end.value.X = Math.cos(radAngle) * distance + start.value.X;
        end.value.Y = Math.sin(radAngle) * distance + start.value.Y;
    };
    GeomUtilities.ToRadians = function (degrees) {
        return (degrees * Math.PI) / 180;
    };
    /*
           * Linear Interpoloation helper function
           */
    GeomUtilities.Lerp = function (value1, value2, amount) {
        return value1 + (value2 - value1) * amount;
    };
    /*
           * Based on libgdiplus lineargradientbrush.c implementation with a couple of small modifications
           * for calculating the Normal Distribution.  The reason for this change comes
           * from The Art of Scientific Computing by Press et al
           * 
           * We assume that you know enough never to evaluate a polynomial this way:
           * p=c[0]+c[1]*x+c[2]*x*x+c[3]*x*x*x+c[4]*x*x*x*x;
           * or (even worse!),
           * p=c[0]+c[1]*x+c[2]*pow(x,2.0)+c[3]*pow(x,3.0)+c[4]*pow(x,4.0);
           *
           * Come the (computer) revolution, all persons found guilty of such criminal behavior will be
           * summarily executed, and their programs wont be! It is a matter of taste, however, whether to write
           * p=c[0]+x*(c[1]+x*(c[2]+x*(c[3]+x*c[4])));
           * or
           * p=(((c[4]*x+c[3])*x+c[2])*x+c[1])*x+c[0];
           * If the number of coefficients c[0..n-1] is large, one writes
           * p=c[n-1];
           * for(j=n-2;j>=0;j) p=p*x+c[j];
           * or
           * p=c[j=n-1];
           * while (j>0) p=p*x+c[--j];
           *
           * where the original routine was using Math.Pow to evaluate the polinomials so with the Phi function
           * we should have a little speed increase.  Not verified though so revert this implementaion if need be.
           * It is just a funtion that I have used before for CDF.
           * .
           */
    GeomUtilities.SigmaBellShape = function (focus, scale) {
        var blend = new _drawing2D_Blend__WEBPACK_IMPORTED_MODULE_2__.Blend();
        var pos = 0.0;
        var count = 511; /* total no of samples */
        var index;
        var sigma;
        var mean;
        var fall_off_len = 2.0; /* curve fall off length in terms of SIGMA */
        var delta; /* distance between two samples */
        var phi; /* variable to hold the value of Phi - Normal Distribution - CFD etc... */
        /* we get a curve not starting from 0 and not ending at 1.
                 * so we subtract the starting value and divide by the curve
                 * height to make it fit in the 0 to scale range
                 */
        var curve_bottom;
        var curve_top;
        var curve_height;
        if (focus === 0 || focus === 1) {
            count = 256;
        }
        if (blend.Positions.length !== count) {
            blend = new _drawing2D_Blend__WEBPACK_IMPORTED_MODULE_2__.Blend();
        }
        /* Set the blend colors. We use integral of the Normal Distribution,
                 * i.e. Cumulative Distribution Function (CDF).
                 *
                 * Normal distribution:
                 *
                 * y (x) = (1 / sqrt (2 * PI * sq (sigma))) * exp (-sq (x - mu)/ (2 * sq (sigma)))
                 *
                 * where, y = height of normal curve,
                 *        sigma = standard deviation
                 *        mu = mean
                 * OR
                 * y (x) = peak * exp ( - z * z / 2)
                 * where, z = (x - mu) / sigma
                 *
                 * In this curve, peak would occur at mean i.e. for x = mu. This results in
                 * a peak value of peak = (1 / sqrt (2 * PI * sq (sigma))).
                 *
                 * Cumulative distribution function:
                 * Ref: http://mathworld.wolfram.com/NormalDistribution.html
                 * see function Phi(x) below - (x)
                 *
                 * D (x) = Phi(z)
                 * where, z = (x - mu) / sigma
                 *
                 */
        if (focus === 0) {
            /* right part of the curve with a complete fall in fall_off_len * SIGMAs */
            sigma = 1.0 / fall_off_len;
            mean = 0.5;
            delta = 1.0 / 255.0;
            curve_bottom = GeomUtilities.Phi((1.0 - mean) / sigma);
            curve_top = GeomUtilities.Phi((focus - mean) / sigma);
            curve_height = curve_top - curve_bottom;
            /* set the start */
            blend.Positions[0] = focus;
            blend.Factors[0] = scale;
            for (index = 1, pos = delta; index < 255; index++, pos += delta) {
                blend.Positions[index] = pos;
                phi = GeomUtilities.Phi((pos - mean) / sigma);
                blend.Factors[index] = (scale / curve_height) * (phi - curve_bottom);
            }
            /* set the end */
            blend.Positions[count - 1] = 1.0;
            blend.Factors[count - 1] = 0.0;
        }
        else if (focus === 1) {
            /* left part of the curve with a complete rise in fall_off_len * SIGMAs */
            sigma = 1.0 / fall_off_len;
            mean = 0.5;
            delta = 1.0 / 255.0;
            curve_bottom = GeomUtilities.Phi((0.0 - mean) / sigma);
            curve_top = GeomUtilities.Phi((focus - mean) / sigma);
            curve_height = curve_top - curve_bottom;
            /* set the start */
            blend.Positions[0] = 0.0;
            blend.Factors[0] = 0.0;
            for (index = 1, pos = delta; index < 255; index++, pos += delta) {
                blend.Positions[index] = pos;
                phi = GeomUtilities.Phi((pos - mean) / sigma);
                blend.Factors[index] = (scale / curve_height) * (pos - curve_bottom);
            }
            /* set the end */
            blend.Positions[count - 1] = focus;
            blend.Factors[count - 1] = scale;
        }
        else {
            /* left part of the curve with a complete fall in fall_off_len * SIGMAs */
            sigma = focus / (2 * fall_off_len);
            mean = focus / 2.0;
            delta = focus / 255.0;
            /* set the start */
            blend.Positions[0] = 0.0;
            blend.Factors[0] = 0.0;
            curve_bottom = GeomUtilities.Phi((0.0 - mean) / sigma);
            curve_top = GeomUtilities.Phi((focus - mean) / sigma);
            curve_height = curve_top - curve_bottom;
            for (index = 1, pos = delta; index < 255; index++, pos += delta) {
                blend.Positions[index] = pos;
                phi = GeomUtilities.Phi((pos - mean) / sigma);
                blend.Factors[index] = (scale / curve_height) * (phi - curve_bottom);
            }
            blend.Positions[index] = focus;
            blend.Factors[index] = scale;
            /* right part of the curve with a complete fall in fall_off_len * SIGMAs */
            sigma = (1.0 - focus) / (2 * fall_off_len);
            mean = (1.0 + focus) / 2.0;
            delta = (1.0 - focus) / 255.0;
            curve_bottom = GeomUtilities.Phi((1.0 - mean) / sigma);
            curve_top = GeomUtilities.Phi((focus - mean) / sigma);
            curve_height = curve_top - curve_bottom;
            index++;
            pos = focus + delta;
            for (; index < 510; index++, pos += delta) {
                blend.Positions[index] = pos;
                phi = GeomUtilities.Phi((pos - mean) / sigma);
                blend.Factors[index] = (scale / curve_height) * (phi - curve_bottom);
            }
            /* set the end */
            blend.Positions[count - 1] = 1.0;
            blend.Factors[count - 1] = 0.0;
        }
        return blend;
    };
    /*
           * The function (x) is the cumulative density function (CDF) of a standard normal
           * (Gaussian) random variable. It is closely related to the error function erf(x).
           *
           * http://www.johndcook.com/csharp_phi.html
           *
           * http://www.johndcook.com/erf_and_normal_cdf.pdf
           *
           * This function is used by gradient brushes
           *
           * This routine is self contained with the Erf code included in the funtion.
           * This could also be implemented by 0.5 * (1.0 + Erf(x))
           *
           * I left this double instead of implementing a float version as the Math.XXX api's are also double
           */
    GeomUtilities.Phi = function (x) {
        // constants
        var a1 = 0.254829592;
        var a2 = -0.284496736;
        var a3 = 1.421413741;
        var a4 = -1.453152027;
        var a5 = 1.061405429;
        var p = 0.3275911;
        // Save the sign of x
        var sign = 1;
        if (x < 0)
            sign = -1;
        x = Math.abs(x) / Math.sqrt(2.0);
        // A&S refers to Handbook of Mathematical Functions by Abramowitz and Stegun.
        // See Stand-alone error function for details of the algorithm.
        // http://www.johndcook.com/blog/2009/01/19/stand-alone-error-function-erf/
        // A&S formula 7.1.26
        var t = 1.0 / (1.0 + p * x);
        var y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
        return 0.5 * (1.0 + sign * y);
    };
    /*
           * Not used right now but left here just in case so it does not have to be looked up again
           *
           * http://www.johndcook.com/csharp_erf.html
           * http://www.johndcook.com/blog/2009/01/19/stand-alone-error-function-erf/
           * http://www.johndcook.com/erf_and_normal_cdf.pdf
           */
    GeomUtilities.Erf = function (x) {
        // constants
        var a1 = 0.254829592;
        var a2 = -0.284496736;
        var a3 = 1.421413741;
        var a4 = -1.453152027;
        var a5 = 1.061405429;
        var p = 0.3275911;
        // Save the sign of x
        var sign = 1;
        if (x < 0)
            sign = -1;
        x = Math.abs(x);
        // A&S refers to Handbook of Mathematical Functions by Abramowitz and Stegun.
        // http://www.johndcook.com/blog/2009/01/19/stand-alone-error-function-erf/
        //
        // A&S formula 7.1.26
        var t = 1.0 / (1.0 + p * x);
        var y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
        return sign * y;
    };
    /// <summary>
    /// This method initializes the new CGAffineTransform such that it represents the geometric transform that maps the rectangle
    /// specified by the rect parameter to the parallelogram defined by the three points in the plgpts parameter.
    ///
    /// The upper-left corner of the rectangle is mapped to the first point in the plgpts array, the upper-right corner
    /// is mapped to the second point, and the lower-left corner is mapped to the third point. The lower-right point of
    /// the parallelogram is implied by the first three.
    /// </summary>
    /// <returns>The affine transform.</returns>
    /// <param name="rect">Rectangle.</param>
    /// <param name="points">Points.</param>
    GeomUtilities.CreateGeometricTransform = function (rect, points) {
        var p0 = points[0];
        var p1 = points[1];
        var p2 = points[2];
        var width = rect.Width;
        var height = rect.Height;
        var m11 = (p1.X - p0.X) / width;
        var m12 = (p1.Y - p0.Y) / width;
        var m21 = (p2.X - p0.X) / height;
        var m22 = (p2.Y - p0.Y) / height;
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform(m11, m12, m21, m22, p0.X, p0.Y);
    };
    /// <summary>
    /// Creates the rotate flip transform given the input parameters
    /// </summary>
    /// <returns>The rotate flip transform.</returns>
    /// <param name="width">Width.</param>
    /// <param name="height">Height.</param>
    /// <param name="angle">Angle.</param>
    /// <param name="flipX">If set to <c>true</c> flip x.</param>
    /// <param name="flipY">If set to <c>true</c> flip y.</param>
    GeomUtilities.CreateRotateFlipTransform = function (width, height, angle, flipX, flipY) {
        var rotateX = Math.abs(Math.cos(GeomUtilities.ToRadians(angle)));
        var rotateY = Math.abs(Math.sin(GeomUtilities.ToRadians(angle)));
        var deltaWidth = width.value * rotateX + height.value * rotateY;
        var deltaHeight = width.value * rotateY + height.value * rotateX;
        var rotateFlipTransform = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeTranslation(flipX ? -deltaWidth : 0.0, flipY ? -deltaHeight : 0.0);
        rotateFlipTransform.multiply(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeScale(flipX ? -1.0 : 1.0, flipY ? -1.0 : 1.0));
        if (0.0 !== angle) {
            var rot = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeTranslation(-deltaHeight * 0.5, -deltaWidth * 0.5);
            rot.rotate(GeomUtilities.ToRadians(angle));
            rot.translate(deltaWidth * 0.5, deltaHeight * 0.5);
            rotateFlipTransform = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.Multiply(rot, rotateFlipTransform);
        }
        width.value = deltaWidth;
        height.value = deltaHeight;
        return rotateFlipTransform;
    };
    GeomUtilities.TransformRectangle = function (rectangle, matrix) {
        var transform = matrix.transform;
        var x = rectangle.value.X;
        var y = rectangle.value.Y;
        rectangle.value.X = transform.m[0] * x + transform.m[1] * y + transform.m[4];
        rectangle.value.Y = transform.m[1] * x + transform.m[3] * y + transform.m[5];
        x = rectangle.value.Width;
        y = rectangle.value.Height;
        rectangle.value.Width = transform.m[0] * x + transform.m[2] * y + transform.m[4];
        rectangle.value.Height = transform.m[1] * x + transform.m[3] * y + transform.m[5];
    };
    /// <summary>
    /// Transform the specified Rectangle by the matrix that is passed.
    /// </summary>
    /// <param name="matrix">Matrix.</param>
    GeomUtilities.GetCurveTangents = function (terms, points, count, tension, type) {
        var coefficient = tension / 3;
        var tangents = new Array(count);
        for (var i = 0; i < count; i++) {
            tangents[i] = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        }
        if (count <= 2)
            return tangents;
        for (var i = 0; i < count; i++) {
            var r = i + 1;
            var s = i - 1;
            if (r >= count)
                r = count - 1;
            if (type === _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_3__.CurveType.Open) {
                if (s < 0)
                    s = 0;
            }
            else {
                if (s < 0)
                    s += count;
            }
            tangents[i].X += coefficient * (points[r].X - points[s].X);
            tangents[i].Y += coefficient * (points[r].Y - points[s].Y);
        }
        return tangents;
    };
    // from http://fontforge.org/bezier.html
    //  Formula for converting qudratic to cubic
    //
    // Any quadratic spline can be expressed as a cubic (where the cubic term is zero).
    // The end points of the cubic will be the same as the quadratic's.
    //
    // CP0 = QP0
    // CP3 = QP2
    // The two control points for the cubic are:
    //
    // CP1 = QP0 + 2/3 *(QP1-QP0)
    // CP2 = QP2 + 2/3 *(QP1-QP2)
    GeomUtilities.QuadraticToCubic = function (start, controlPoint, end, controlPoint1, controlPoint2) {
        controlPoint1.value = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        controlPoint2.value = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        controlPoint1.value.X = start.X + GeomUtilities.quadCubeCoeff * (controlPoint.X - start.X);
        controlPoint2.value.X = end.X + GeomUtilities.quadCubeCoeff * (controlPoint.X - end.X);
        controlPoint1.value.Y = start.Y + GeomUtilities.quadCubeCoeff * (controlPoint.Y - start.Y);
        controlPoint2.value.Y = end.Y + GeomUtilities.quadCubeCoeff * (controlPoint.Y - end.Y);
    };
    //#region PathGradientBrush
    GeomUtilities.DotProduct = function (u, v) {
        return u.X * v.X + u.Y * v.Y; // + (u).z * (v).z)
    };
    GeomUtilities.Normal = function (v) {
        return Math.sqrt(GeomUtilities.DotProduct(v, v)); // normal = length of  vector
    };
    /*
           * Calculates crossProduct of two 2D vectors / points.
           * @param p1 first point used as vector
           * @param p2 second point used as vector
           * @return crossProduct of vectors
           */
    GeomUtilities.CrossProduct = function (v1, v2) {
        return v1.X * v2.Y - v1.Y * v2.X;
    };
    // Basic bounding box implementation getting min X, min Y, max X and max Y
    // from the array of PointF's only the first three will be used.
    GeomUtilities.TriangleBoundingBox = function (points) {
        /* get the bounding box of the triangle */
        var maxX = Math.max(points[0].X, Math.max(points[1].X, points[2].X));
        var minX = Math.min(points[0].X, Math.min(points[1].X, points[2].X));
        var maxY = Math.max(points[0].Y, Math.max(points[1].Y, points[2].Y));
        var minY = Math.min(points[0].Y, Math.min(points[1].Y, points[2].Y));
        var bb = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(minX, minY, maxX - minX, maxY - minY);
        return bb;
    };
    // Basic bounding box implementation getting min X, min Y, max X and max Y
    // from the array of PointF's
    GeomUtilities.PolygonBoundingBox = function (points) {
        var minX = Number.MAX_VALUE;
        var minY = Number.MAX_VALUE;
        var maxX = Number.MIN_VALUE;
        var maxY = Number.MIN_VALUE;
        /* get the bounding box of the polygon */
        for (var m = 0; m < points.length; m++) {
            minX = Math.min(points[m].X, minX);
            minY = Math.min(points[m].Y, minY);
            maxX = Math.max(points[m].X, maxX);
            maxY = Math.max(points[m].Y, maxY);
        }
        var bb = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(minX, minY, maxX - minX, maxY - minY);
        return bb;
    };
    // http://en.wikipedia.org/wiki/Centroid
    //
    // NOTE: this algorithm doesn`t apply to complex polygons. If this is causing problems
    // we may have to change this.
    GeomUtilities.PolygonCentroid = function (points) {
        var C = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        var area = 0;
        //var A6 = 6.0f * (float)PolygonArea(points);
        var first = points[0];
        var last = points[points.length - 1];
        // make sure we have a closed path
        if (last !== first)
            last = first;
        last = first;
        var dotProd = 0;
        for (var i = 1; i < points.length; i++) {
            var next = points[i];
            dotProd = last.X * next.Y - next.X * last.Y;
            area += dotProd;
            C.X += (last.X + next.X) * dotProd;
            C.Y += (last.Y + next.Y) * dotProd;
            last = next;
        }
        dotProd = last.X * first.Y - first.X * last.Y;
        area += dotProd;
        C.X += (last.X + first.X) * dotProd;
        C.Y += (last.Y + first.Y) * dotProd;
        var aaa = GeomUtilities.PolygonArea(points);
        // Note: The result is positive if the polygon is clockwise for our coordinate system in
        // which increasing Y goes downward.
        // Positive - clockwise
        // Negative - counterclockwise
        //
        // We want to keep the area positive so we do not get negative numbers
        // depending on the polygon winding. This may not be right though.
        //
        var A6 = 6.0 * (area / 2);
        var reciprocal = 1.0 / A6;
        // We need make sure we are positive here.
        C.X = C.X * reciprocal;
        C.Y = C.Y * reciprocal;
        return C;
    };
    // Note: The result is positive if the polygon is clockwise for our coordinate system in
    // which increasing Y goes downward.
    // Positive - clockwise
    // Negative - counterclockwise
    GeomUtilities.PolygonArea = function (points) {
        var first = points[0];
        var last = points[points.length - 1];
        // make sure we have a closed path
        if (last != first)
            last = first;
        var area = 0;
        for (var p = 1; p < points.length; p++) {
            var next = points[p];
            area += last.X * next.Y - next.X * last.Y;
            last = next;
        }
        area += last.X * first.Y - first.X * last.Y;
        return area / 2;
    };
    //#endregion
    GeomUtilities.InflateRect = function (a, w, h) {
        a.value.X = a.value.X - w;
        a.value.Width = a.value.Width + w * 2;
        a.value.Y = a.value.Y - h;
        a.value.Height = a.value.Height + h * 2;
    };
    GeomUtilities.IntersectionRect = function (a, b) {
        var single = Math.max(a.X, b.X);
        var single1 = Math.max(a.Y, b.Y);
        var single2 = Math.min(a.X + a.Width, b.X + b.Width);
        var single3 = Math.min(a.Y + a.Height, b.Y + b.Height);
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(single, single1, Math.max(0, single2 - single), Math.max(0, single3 - single1));
    };
    GeomUtilities.ContainsRect = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 2 && args[1] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint) {
            var a = args[0];
            var b = args[1];
            if (a.X > b.X || b.X > a.X + a.Width || a.Y > b.Y) {
                return false;
            }
            return b.Y <= a.Y + a.Height;
        }
        else if (args.length === 2 && args[1] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle) {
            var a = args[0];
            var b = args[1];
            if (a.X > b.X || b.X + b.Width > a.X + a.Width || a.Y > b.Y || b.Y + b.Height > a.Y + a.Height || a.Width < 0) {
                return false;
            }
            return a.Height >= 0;
        }
        return false;
    };
    GeomUtilities.IntersectsLineSegment = function (rect, p1, p2) {
        if (p1.X === p2.X) {
            if (rect.Left > p1.X || p1.X > rect.Right || Math.min(p1.Y, p2.Y) > rect.Bottom) {
                return false;
            }
            return Math.max(p1.Y, p2.Y) >= rect.Top;
        }
        if (p1.Y == p2.Y) {
            if (rect.Top > p1.Y || p1.Y > rect.Bottom || Math.min(p1.X, p2.X) > rect.Right) {
                return false;
            }
            return Math.max(p1.X, p2.X) >= rect.Left;
        }
        if (GeomUtilities.ContainsRect(rect, p1)) {
            return true;
        }
        if (GeomUtilities.ContainsRect(rect, p2)) {
            return true;
        }
        if (GeomUtilities.IntersectingLines(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left, rect.Top), new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Right, rect.Top), p1, p2)) {
            return true;
        }
        if (GeomUtilities.IntersectingLines(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Right, rect.Top), new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Right, rect.Bottom), p1, p2)) {
            return true;
        }
        if (GeomUtilities.IntersectingLines(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Right, rect.Bottom), new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left, rect.Bottom), p1, p2)) {
            return true;
        }
        if (GeomUtilities.IntersectingLines(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left, rect.Bottom), new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left, rect.Top), p1, p2)) {
            return true;
        }
        return false;
    };
    GeomUtilities.IntersectsRect = function (a, b) {
        var width = a.Width;
        if (width < 0) {
            return false;
        }
        var height = a.Height;
        if (height < 0) {
            return false;
        }
        var single = b.Width;
        if (single < 0) {
            return false;
        }
        var height1 = b.Height;
        if (height1 < 0) {
            return false;
        }
        var x = a.X;
        var x1 = b.X;
        width = width + x;
        single = single + x1;
        if (x > single || x1 > width) {
            return false;
        }
        var y = a.Y;
        var y1 = b.Y;
        height = height + y;
        height1 = height1 + y1;
        if (y <= height1 && y1 <= height) {
            return true;
        }
        return false;
    };
    GeomUtilities.ComparePointWithLine = function (a1, a2, p) {
        var x = a2.X - a1.X;
        var y = a2.Y - a1.Y;
        var single = p.X - a1.X;
        var y1 = p.Y - a1.Y;
        var single1 = single * y - y1 * x;
        if (single1 === 0) {
            single1 = single * x + y1 * y;
            if (single1 > 0) {
                single = single - x;
                y1 = y1 - y;
                single1 = single * x + y1 * y;
                if (single1 < 0) {
                    single1 = 0;
                }
            }
        }
        if (single1 < 0) {
            return -1;
        }
        if (single1 <= 0) {
            return 0;
        }
        return 1;
    };
    GeomUtilities.IntersectingLines = function (a1, a2, b1, b2) {
        if ((GeomUtilities.ComparePointWithLine(a1, a2, b1) * GeomUtilities.ComparePointWithLine(a1, a2, b2)) > 0) {
            return false;
        }
        return (GeomUtilities.ComparePointWithLine(b1, b2, a1) * GeomUtilities.ComparePointWithLine(b1, b2, a2)) <= 0;
    };
    GeomUtilities.LineBounds = function (a, b) {
        var single = Math.min(a.X, b.X);
        var single1 = Math.min(a.Y, b.Y);
        var single2 = Math.max(a.X, b.X);
        var single3 = Math.max(a.Y, b.Y);
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(single, single1, single2 - single, single3 - single1);
    };
    GeomUtilities.LineContainsPoint = function (a, b, fuzz, p) {
        var x;
        var single;
        var y;
        var y1;
        if (a.X >= b.X) {
            single = b.X;
            x = a.X;
        }
        else {
            single = a.X;
            x = b.X;
        }
        if (a.Y >= b.Y) {
            y1 = b.Y;
            y = a.Y;
        }
        else {
            y1 = a.Y;
            y = b.Y;
        }
        if (a.X == b.X) {
            if (y1 > p.Y || p.Y > y || a.X - fuzz > p.X) {
                return false;
            }
            return p.X <= a.X + fuzz;
        }
        if (a.Y == b.Y) {
            if (single > p.X || p.X > x || a.Y - fuzz > p.Y) {
                return false;
            }
            return p.Y <= a.Y + fuzz;
        }
        var single1 = x + fuzz;
        var single2 = single - fuzz;
        if (single2 <= p.X && p.X <= single1) {
            var single3 = y + fuzz;
            var single4 = y1 - fuzz;
            if (single4 <= p.Y && p.Y <= single3) {
                if (single1 - single2 <= single3 - single4) {
                    if (a.Y - b.Y <= fuzz && b.Y - a.Y <= fuzz) {
                        return true;
                    }
                    var x1 = (b.X - a.X) / (b.Y - a.Y) * (p.Y - a.Y) + a.X;
                    if (x1 - fuzz <= p.X && p.X <= x1 + fuzz) {
                        return true;
                    }
                }
                else {
                    if (a.X - b.X <= fuzz && b.X - a.X <= fuzz) {
                        return true;
                    }
                    var y2 = (b.Y - a.Y) / (b.X - a.X) * (p.X - a.X) + a.Y;
                    if (y2 - fuzz <= p.Y && p.Y <= y2 + fuzz) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    GeomUtilities.NearestIntersectionOnLine = function (a, b, p, q, result) {
        var x = a.X;
        var y = a.Y;
        var single = b.X;
        var y1 = b.Y;
        var x1 = p.X;
        var single1 = p.Y;
        var x2 = q.X;
        var y2 = q.Y;
        if (x1 == x2) {
            if (x == single) {
                GeomUtilities.NearestPointOnLine(a, b, p, result);
                return false;
            }
            var single2 = (y1 - y) / (single - x) * (x1 - x) + y;
            return GeomUtilities.NearestPointOnLine(a, b, new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(x1, single2), result);
        }
        var single3 = (y2 - single1) / (x2 - x1);
        if (x == single) {
            var single4 = single3 * (x - x1) + single1;
            if (single4 < Math.min(y, y1)) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(x, Math.min(y, y1));
                return false;
            }
            if (single4 <= Math.max(y, y1)) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(x, single4);
                return true;
            }
            result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(x, Math.max(y, y1));
            return false;
        }
        var single5 = (y1 - y) / (single - x);
        if (single3 == single5) {
            GeomUtilities.NearestPointOnLine(a, b, p, result);
            return false;
        }
        var single6 = (single5 * x - single3 * x1 + single1 - y) / (single5 - single3);
        if (single5 !== 0) {
            var single7 = single5 * (single6 - x) + y;
            return GeomUtilities.NearestPointOnLine(a, b, new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single6, single7), result);
        }
        if (single6 < Math.min(x, single)) {
            result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(Math.min(x, single), y);
            return false;
        }
        if (single6 <= Math.max(x, single)) {
            result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single6, y);
            return true;
        }
        result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(Math.max(x, single), y);
        return false;
    };
    GeomUtilities.RectFromLine = function (a, b, w) {
        if (a.X === b.X) {
            var y = a.Y;
            var single = b.Y;
            if (y > single) {
                y = b.Y;
                single = a.Y;
            }
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(a.X - w / 2, y, w, single - y);
        }
        if (a.Y == b.Y) {
            var x = a.X;
            var x1 = b.X;
            if (x > x1) {
                x = b.X;
                x1 = a.X;
            }
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(x, a.Y - w / 2, x1 - x, w);
        }
        var y1 = a.Y;
        var single1 = b.Y;
        if (y1 > single1) {
            y1 = b.Y;
            single1 = a.Y;
        }
        var x2 = a.X;
        var single2 = b.X;
        if (x2 > single2) {
            x2 = b.X;
            single2 = a.X;
        }
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(x2, y1, single2 - x2, single1 - y1);
    };
    GeomUtilities.NearestPointOnLine = function (a, b, p, result) {
        var single;
        var single1;
        var single2;
        var single3;
        var x = a.X;
        var y = a.Y;
        var x1 = b.X;
        var y1 = b.Y;
        var x2 = p.X;
        var y2 = p.Y;
        if (x === x1) {
            if (y >= y1) {
                single = y1;
                single1 = y;
            }
            else {
                single = y;
                single1 = y1;
            }
            var single4 = y2;
            if (single4 < single) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(x, single);
                return false;
            }
            if (single4 > single1) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(x, single1);
                return false;
            }
            result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(x, single4);
            return true;
        }
        if (y === y1) {
            if (x >= x1) {
                single2 = x1;
                single3 = x;
            }
            else {
                single2 = x;
                single3 = x1;
            }
            var single5 = x2;
            if (single5 < single2) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single2, y);
                return false;
            }
            if (single5 > single3) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single3, y);
                return false;
            }
            result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single5, y);
            return true;
        }
        var single6 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);
        var single7 = ((x - x2) * (x - x1) + (y - y2) * (y - y1)) / single6;
        if (single7 < 0) {
            result.value = a;
            return false;
        }
        if (single7 > 1) {
            result.value = b;
            return false;
        }
        var single8 = x + single7 * (x1 - x);
        var single9 = y + single7 * (y1 - y);
        result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single8, single9);
        return true;
    };
    GeomUtilities.GetNearestIntersectionPoint = function (rect, p1, p2, result) {
        var pointF = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.newOutEmpty)();
        var pointF1 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.X, rect.Y);
        var pointF2 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.X + rect.Width, rect.Y);
        var pointF3 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.X, rect.Y + rect.Height);
        var pointF4 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.X + rect.Width, rect.Y + rect.Height);
        var x = p1.X;
        var y = p1.Y;
        var single = 1E+21;
        var pointF5 = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.newOutEmpty)();
        if (GeomUtilities.NearestIntersectionOnLine(pointF1, pointF2, p1, p2, pointF)) {
            var x1 = (pointF.value.X - x) * (pointF.value.X - x) + (pointF.value.Y - y) * (pointF.value.Y - y);
            if (x1 < single) {
                single = x1;
                pointF5.value = pointF.value;
            }
        }
        if (GeomUtilities.NearestIntersectionOnLine(pointF2, pointF4, p1, p2, pointF)) {
            var single1 = (pointF.value.X - x) * (pointF.value.X - x) + (pointF.value.Y - y) * (pointF.value.Y - y);
            if (single1 < single) {
                single = single1;
                pointF5 = pointF;
            }
        }
        if (GeomUtilities.NearestIntersectionOnLine(pointF4, pointF3, p1, p2, pointF)) {
            var x2 = (pointF.value.X - x) * (pointF.value.X - x) + (pointF.value.Y - y) * (pointF.value.Y - y);
            if (x2 < single) {
                single = x2;
                pointF5 = pointF;
            }
        }
        if (GeomUtilities.NearestIntersectionOnLine(pointF3, pointF1, p1, p2, pointF)) {
            var single2 = (pointF.value.X - x) * (pointF.value.X - x) + (pointF.value.Y - y) * (pointF.value.Y - y);
            if (single2 < single) {
                single = single2;
                pointF5 = pointF;
            }
        }
        result.value = pointF5.value;
        return single < 1E+21;
    };
    GeomUtilities.LargestSizeKeepingAspectRatio = function (target, aspect) {
        var single = Math.max(0, aspect.Width);
        var single1 = Math.max(0, aspect.Height);
        if (single === 0 && single1 === 0) {
            single = 1;
            single1 = 1;
        }
        var single2 = Math.max(0, target.Width);
        var single3 = Math.max(0, target.Height);
        if (single === 0) {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize(0, single3);
        }
        if (single1 === 0) {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize(single2, 0);
        }
        if (single2 === 0 || single3 === 0) {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize(single2, single3);
        }
        var single4 = single1 / single;
        if (single4 < single3 / single2) {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize(single2, single4 * single2);
        }
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize(single3 / single4, single3);
    };
    GeomUtilities.MakeRect = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (typeof args[0] === 'number') {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(args[0], 0, 0, 0);
        }
        else if (args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint) {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(args[0].X, args[0].Y, 0, 0);
        }
        else if (args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize) {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, args[0].Width, args[0].Height);
        }
        return _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty;
    };
    GeomUtilities.UnionRect = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 2 && args[1] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle) {
            var a = args[0];
            var b = args[1];
            var single = Math.min(a.X, b.X);
            var single1 = Math.min(a.Y, b.Y);
            var single2 = Math.max(a.X + a.Width, b.X + b.Width);
            var single3 = Math.max(a.Y + a.Height, b.Y + b.Height);
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(single, single1, single2 - single, single3 - single1);
        }
        else {
            var r = args[0];
            var p = args[1];
            if (p.X < r.X) {
                r.Width = r.X + r.Width - p.X;
                r.X = p.X;
            }
            else if (p.X > r.X + r.Width) {
                r.Width = p.X - r.X;
            }
            if (p.Y < r.Y) {
                r.Height = r.Y + r.Height - p.Y;
                r.Y = p.Y;
            }
            else if (p.Y > r.Y + r.Height) {
                r.Height = p.Y - r.Y;
            }
            return r;
        }
    };
    GeomUtilities.lineBounds = function (a, b) {
        var single = Math.min(a.X, b.X);
        var single1 = Math.min(a.Y, b.Y);
        var single2 = Math.max(a.X, b.X);
        var single3 = Math.max(a.Y, b.Y);
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle({ x: single, y: single1, width: single2 - single, height: single3 - single1 });
    };
    GeomUtilities.BezierBounds = function (s, c1, c2, e, epsilon) {
        if (GeomUtilities.LineContainsPoint(s, e, epsilon, c1) && GeomUtilities.LineContainsPoint(s, e, epsilon, c2)) {
            return GeomUtilities.lineBounds(s, e);
        }
        var pointF = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (s.X + c1.X) / 2, y: (s.Y + c1.Y) / 2 });
        var pointF1 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (c1.X + c2.X) / 2, y: (c1.Y + c2.Y) / 2 });
        var pointF2 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (c2.X + e.X) / 2, y: (c2.Y + e.Y) / 2 });
        var pointF3 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (pointF.X + pointF1.X) / 2, y: (pointF.Y + pointF1.Y) / 2 });
        var pointF4 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (pointF1.X + pointF2.X) / 2, y: (pointF1.Y + pointF2.Y) / 2 });
        var pointF5 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (pointF3.X + pointF4.X) / 2, y: (pointF3.Y + pointF4.Y) / 2 });
        return GeomUtilities.UnionRect(GeomUtilities.BezierBounds(s, pointF, pointF3, pointF5, epsilon), GeomUtilities.BezierBounds(pointF5, pointF4, pointF2, e, epsilon));
    };
    GeomUtilities.BezierContainsPoint = function (s, c1, c2, e, epsilon, p) {
        if (GeomUtilities.LineContainsPoint(s, e, epsilon, c1) && GeomUtilities.LineContainsPoint(s, e, epsilon, c2)) {
            return GeomUtilities.LineContainsPoint(s, e, epsilon, p);
        }
        var pointF = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (s.X + c1.X) / 2, y: (s.Y + c1.Y) / 2 });
        var pointF1 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (c1.X + c2.X) / 2, y: (c1.Y + c2.Y) / 2 });
        var pointF2 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (c2.X + e.X) / 2, y: (c2.Y + e.Y) / 2 });
        var pointF3 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (pointF.X + pointF1.X) / 2, y: (pointF.Y + pointF1.Y) / 2 });
        var pointF4 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (pointF1.X + pointF2.X) / 2, y: (pointF1.Y + pointF2.Y) / 2 });
        var pointF5 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (pointF3.X + pointF4.X) / 2, y: (pointF3.Y + pointF4.Y) / 2 });
        if (GeomUtilities.BezierContainsPoint(s, pointF, pointF3, pointF5, epsilon, p)) {
            return true;
        }
        return GeomUtilities.BezierContainsPoint(pointF5, pointF4, pointF2, e, epsilon, p);
    };
    GeomUtilities.BezierMidPoint = function (b0, b1, b2, b3, v, w) {
        v = v || (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.newOutEmpty)();
        w = w || (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.newOutEmpty)();
        var pointF = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint((b0.X + b1.X) / 2, (b0.Y + b1.Y) / 2);
        var pointF1 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint((b1.X + b2.X) / 2, (b1.Y + b2.Y) / 2);
        var pointF2 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint((b2.X + b3.X) / 2, (b2.Y + b3.Y) / 2);
        v.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint((pointF.X + pointF1.X) / 2, (pointF.Y + pointF1.Y) / 2);
        w.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint((pointF1.X + pointF2.X) / 2, (pointF1.Y + pointF2.Y) / 2);
    };
    GeomUtilities.BezierNearestIntersectionOnLine = function (s, c1, c2, e, p1, p2, epsilon, /*out*/ result) {
        result = result || (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.newOutEmpty)();
        var pointF = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.newOutEmpty)();
        var single = 1E+21;
        var pointF1 = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        if (!GeomUtilities.LineContainsPoint(s, e, epsilon, c1) || !GeomUtilities.LineContainsPoint(s, e, epsilon, c2)) {
            var pointF2 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (s.X + c1.X) / 2, y: (s.Y + c1.Y) / 2 });
            var pointF3 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (c1.X + c2.X) / 2, y: (c1.Y + c2.Y) / 2 });
            var pointF4 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (c2.X + e.X) / 2, y: (c2.Y + e.Y) / 2 });
            var pointF5 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (pointF2.X + pointF3.X) / 2, y: (pointF2.Y + pointF3.Y) / 2 });
            var pointF6 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (pointF3.X + pointF4.X) / 2, y: (pointF3.Y + pointF4.Y) / 2 });
            var pointF7 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: (pointF5.X + pointF6.X) / 2, y: (pointF5.Y + pointF6.Y) / 2 });
            if (GeomUtilities.BezierNearestIntersectionOnLine(s, pointF2, pointF5, pointF7, p1, p2, epsilon, pointF)) {
                var x = (pointF.value.X - p1.X) * (pointF.value.X - p1.X) + (pointF.value.Y - p1.Y) * (pointF.value.Y - p1.Y);
                if (x < single) {
                    single = x;
                    pointF1 = pointF.value;
                }
            }
            if (GeomUtilities.BezierNearestIntersectionOnLine(pointF7, pointF6, pointF4, e, p1, p2, epsilon, pointF)) {
                var x1 = (pointF.value.X - p1.X) * (pointF.value.X - p1.X) + (pointF.value.Y - p1.Y) * (pointF.value.Y - p1.Y);
                if (x1 < single) {
                    single = x1;
                    pointF1 = pointF.value;
                }
            }
        }
        if (GeomUtilities.NearestIntersectionOnLine(s, e, p1, p2, pointF)) {
            var single1 = (pointF.value.X - p1.X) * (pointF.value.X - p1.X) + (pointF.value.Y - p1.Y) * (pointF.value.Y - p1.Y);
            if (single1 < single) {
                single = single1;
                pointF1 = pointF.value;
            }
        }
        result.value = pointF1;
        return single < 1E+21;
    };
    GeomUtilities.RescalePoints = function (v, oldr, newr) {
        var width = 1;
        if (oldr.Width !== 0) {
            width = newr.Width / oldr.Width;
        }
        var height = 1;
        if (oldr.Height !== 0) {
            height = newr.Height / oldr.Height;
        }
        for (var i = 0; i < v.length; i++) {
            var pointF = v[i];
            var x = newr.X + (pointF.X - oldr.X) * width;
            var y = newr.Y + (pointF.Y - oldr.Y) * height;
            v[i] = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint({ x: x, y: y });
        }
    };
    GeomUtilities.ExpandPointOnEdge = function (p, rect, shift) {
        if (p.X <= rect.X) {
            p.X = p.X - shift;
        }
        else if (p.X >= rect.X + rect.Width) {
            p.X = p.X + shift;
        }
        if (p.Y <= rect.Y) {
            p.Y = p.Y - shift;
        }
        else if (p.Y >= rect.Y + rect.Height) {
            p.Y = p.Y + shift;
        }
        return p;
    };
    GeomUtilities.TranslatePoints = function (v, dx, dy) {
        for (var i = 0; i < v.length; i++) {
            if (v[i] !== undefined) {
                var x = v[i];
                x.X = x.X + dx;
                x.Y = x.Y + dy;
                v[i] = x;
            }
        }
    };
    GeomUtilities.GetAngle = function (x, y) {
        var single;
        if (x === 0) {
            single = (y <= 0 ? 270 : 90);
        }
        else if (y != 0) {
            single = Math.atan(Math.abs(y / x)) * 180 / 3.14159265358979;
            if (x < 0) {
                single = (y >= 0 ? 180 - single : single + 180);
            }
            else if (y < 0) {
                single = 360 - single;
            }
        }
        else {
            single = (x <= 0 ? 180 : 0);
        }
        return single;
    };
    GeomUtilities.NearestIntersectionOnArc = function (rect, p1, p2, result, startAngle, sweepAngle) {
        var single;
        var single1;
        var single2;
        var width = rect.Width / 2;
        var height = rect.Height / 2;
        var x = rect.X + width;
        var y = rect.Y + height;
        if (sweepAngle >= 0) {
            single = startAngle;
            single1 = sweepAngle;
        }
        else {
            single = startAngle + sweepAngle;
            single1 = -sweepAngle;
        }
        if (p1.X == p2.X) {
            var single3 = height;
            var single4 = height;
            var single5 = width;
            var single6 = Math.sqrt((single3 * single3 - single4 * single4 / (single5 * single5) * ((p1.X - x) * (p1.X - x))));
            var single7 = y + single6;
            var single8 = y - single6;
            var angle = GeomUtilities.GetAngle(p1.X - x, single7 - y);
            var angle1 = GeomUtilities.GetAngle(p1.X - x, single8 - y);
            if (angle < single) {
                angle += 360;
            }
            if (angle1 < single) {
                angle1 += 360;
            }
            if (angle > single + single1) {
                angle -= 360;
            }
            if (angle1 > single + single1) {
                angle1 -= 360;
            }
            var flag = (angle < single ? false : angle <= single + single1);
            var flag1 = (angle1 < single ? false : angle1 <= single + single1);
            if (flag && flag1) {
                if (Math.abs(single7 - p1.Y) >= Math.abs(single8 - p1.Y)) {
                    result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(p1.X, single8);
                }
                else {
                    result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(p1.X, single7);
                }
                return true;
            }
            if (flag && !flag1) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(p1.X, single7);
                return true;
            }
            if (!(!flag && flag1)) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint();
                return false;
            }
            result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(p1.X, single8);
            return true;
        }
        single2 = (p1.X <= p2.X ? (p2.Y - p1.Y) / (p2.X - p1.X) : (p1.Y - p2.Y) / (p1.X - p2.X));
        var y1 = p1.Y - y - single2 * (p1.X - x);
        var single9 = width;
        var single10 = single2;
        var single11 = height;
        var single12 = y1;
        var single13 = Math.sqrt((single9 * single9 * (single10 * single10) + single11 * single11 - single12 * single12));
        var single14 = width;
        var single15 = height;
        var single16 = width;
        var single17 = single2;
        var single18 = (-(single14 * single14 * single2 * y1) + width * height * single13) / (single15 * single15 + single16 * single16 * (single17 * single17)) + x;
        var single19 = width;
        var single20 = height;
        var single21 = width;
        var single22 = single2;
        var single23 = (-(single19 * single19 * single2 * y1) - width * height * single13) / (single20 * single20 + single21 * single21 * (single22 * single22)) + x;
        var single24 = single2 * (single18 - x) + y1 + y;
        var single25 = single2 * (single23 - x) + y1 + y;
        var angle2 = GeomUtilities.GetAngle(single18 - x, single24 - y);
        var angle3 = GeomUtilities.GetAngle(single23 - x, single25 - y);
        if (angle2 < single) {
            angle2 += 360;
        }
        if (angle3 < single) {
            angle3 += 360;
        }
        if (angle2 > single + single1) {
            angle2 -= 360;
        }
        if (angle3 > single + single1) {
            angle3 -= 360;
        }
        var flag2 = (angle2 < single ? false : angle2 <= single + single1);
        var flag3 = (angle3 < single ? false : angle3 <= single + single1);
        if (!(flag2 && flag3)) {
            if (flag2 && !flag3) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single18, single24);
                return true;
            }
            if (!(!flag2 && flag3)) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint();
                return false;
            }
            result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single23, single25);
            return true;
        }
        if (Math.abs((p1.X - single18) * (p1.X - single18)) + Math.abs((p1.Y - single24) * (p1.Y - single24)) >= Math.abs((p1.X - single23) * (p1.X - single23)) + Math.abs((p1.Y - single25) * (p1.Y - single25))) {
            result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single23, single25);
        }
        else {
            result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single18, single24);
        }
        return true;
    };
    GeomUtilities.NearestIntersectionOnEllipse = function (rect, p1, p2, result) {
        if (rect.Width === 0) {
            return GeomUtilities.NearestIntersectionOnLine(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.X, rect.Y), new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.X, rect.Y + rect.Height), p1, p2, result);
        }
        if (rect.Height === 0) {
            return GeomUtilities.NearestIntersectionOnLine(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.X, rect.Y), new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.X + rect.Width, rect.Y), p1, p2, result);
        }
        var width = rect.Width / 2;
        var height = rect.Height / 2;
        var x = rect.X + width;
        var y = rect.Y + height;
        var single = 9999;
        if (p1.X > p2.X) {
            single = (p1.Y - p2.Y) / (p1.X - p2.X);
        }
        else if (p1.X < p2.X) {
            single = (p2.Y - p1.Y) / (p2.X - p1.X);
        }
        if (Math.abs(single) >= 9999) {
            var single1 = height;
            var single2 = single1 * single1;
            var single3 = width;
            var single4 = single3 * single3;
            var x1 = p1.X - x;
            var single5 = single2 - single2 / single4 * (x1 * x1);
            if (single5 < 0) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint();
                return false;
            }
            var single6 = Math.sqrt(single5);
            var single7 = y + single6;
            var single8 = y - single6;
            if (Math.abs(single7 - p1.Y) >= Math.abs(single8 - p1.Y)) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(p1.X, single8);
            }
            else {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(p1.X, single7);
            }
        }
        else {
            var y1 = p1.Y - y - single * (p1.X - x);
            var single9 = width;
            var single10 = single;
            var single11 = height;
            var single12 = y1;
            if (single9 * single9 * (single10 * single10) + single11 * single11 - single12 * single12 < 0) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint();
                return false;
            }
            var single13 = width;
            var single14 = single;
            var single15 = height;
            var single16 = y1;
            var single17 = Math.sqrt((single13 * single13 * (single14 * single14) + single15 * single15 - single16 * single16));
            var single18 = width;
            var single19 = height;
            var single20 = width;
            var single21 = single;
            var single22 = (-(single18 * single18 * single * y1) + width * height * single17) / (single19 * single19 + single20 * single20 * (single21 * single21)) + x;
            var single23 = width;
            var single24 = height;
            var single25 = width;
            var single26 = single;
            var single27 = (-(single23 * single23 * single * y1) - width * height * single17) / (single24 * single24 + single25 * single25 * (single26 * single26)) + x;
            var single28 = single * (single22 - x) + y1 + y;
            var single29 = single * (single27 - x) + y1 + y;
            if (Math.abs((p1.X - single22) * (p1.X - single22)) + Math.abs((p1.Y - single28) * (p1.Y - single28)) >= Math.abs((p1.X - single27) * (p1.X - single27)) + Math.abs((p1.Y - single29) * (p1.Y - single29))) {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single27, single29);
            }
            else {
                result.value = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(single22, single28);
            }
        }
        return true;
    };
    /**
     * Get surrounding rectangle of  given rect with angle.
     * @param angleInDeg
     * @param rect
     */
    GeomUtilities.GetSurroundingRectangle = function (angleInDeg, rect) {
        var alpha = (angleInDeg % 90) * Math.PI / 180;
        var tetha = (90 - (angleInDeg % 90)) * Math.PI / 180;
        var w = rect.Width;
        var h = rect.Height;
        var x1 = Math.cos(tetha) * Math.sin(alpha) * w;
        var y1 = Math.sin(tetha) * Math.sin(alpha) * w;
        var x2 = Math.sin(alpha) * Math.sin(tetha) * h;
        var y2 = Math.cos(alpha) * Math.sin(tetha) * h;
        var x3 = Math.cos(alpha) * Math.sin(tetha) * w;
        var y3 = Math.sin(alpha) * Math.sin(tetha) * w;
        var x4 = Math.sin(alpha) * Math.cos(alpha) * h;
        var y4 = Math.cos(alpha) * Math.cos(alpha) * h;
        var point1 = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        var point2 = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        var point3 = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        var point4 = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        if (angleInDeg <= 90) {
            point1 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left + x1, rect.Top - y1);
            point2 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left - x2, rect.Top + y2);
            point3 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left + x3, rect.Bottom + y3);
            point4 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Right + x4, rect.Bottom - y4);
        }
        else if (angleInDeg > 90 && angleInDeg <= 180) {
            point2 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left + x1, rect.Top - y1);
            point3 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left - x2, rect.Top + y2);
            point4 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left + x3, rect.Bottom + y3);
            point1 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Right + x4, rect.Bottom - y4);
        }
        else if (angleInDeg > 180 && angleInDeg <= 270) {
            point3 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left + x1, rect.Top - y1);
            point4 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left - x2, rect.Top + y2);
            point1 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left + x3, rect.Bottom + y3);
            point2 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Right + x4, rect.Bottom - y4);
        }
        else if (angleInDeg <= 360) {
            point4 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left + x1, rect.Top - y1);
            point1 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left - x2, rect.Top + y2);
            point2 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left + x3, rect.Bottom + y3);
            point3 = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Right + x4, rect.Bottom - y4);
        }
        return [point1, point2, point3, point4];
    };
    GeomUtilities.CheckLineIntersection = function (line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
        // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
        var denominator, a, b, numerator1, numerator2, result = {
            x: null,
            y: null,
            onLine1: false,
            onLine2: false
        };
        denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
        if (denominator == 0) {
            return result;
        }
        a = line1StartY - line2StartY;
        b = line1StartX - line2StartX;
        numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
        numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
        a = numerator1 / denominator;
        b = numerator2 / denominator;
        // if we cast these lines infinitely in both directions, they intersect here:
        result.x = line1StartX + (a * (line1EndX - line1StartX));
        result.y = line1StartY + (a * (line1EndY - line1StartY));
        /*
                // it is worth noting that this should be the same as:
                x = line2StartX + (b * (line2EndX - line2StartX));
                y = line2StartX + (b * (line2EndY - line2StartY));
                */
        // if line1 is a segment and line2 is infinite, they intersect if:
        if (a > 0 && a < 1) {
            result.onLine1 = true;
        }
        // if line2 is a segment and line1 is infinite, they intersect if:
        if (b > 0 && b < 1) {
            result.onLine2 = true;
        }
        // if line1 and line2 are segments, they intersect if both of the above are true
        return result;
    };
    GeomUtilities.quadCubeCoeff = 2.0 / 3.0;
    return GeomUtilities;
}());



/***/ }),

/***/ "./src/drawing/Graphics.ts":
/*!*********************************!*\
  !*** ./src/drawing/Graphics.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AngleModes": () => (/* binding */ AngleModes),
/* harmony export */   "EllipseModes": () => (/* binding */ EllipseModes),
/* harmony export */   "RectangleModes": () => (/* binding */ RectangleModes),
/* harmony export */   "ArcModes": () => (/* binding */ ArcModes),
/* harmony export */   "CompositingMode": () => (/* binding */ CompositingMode),
/* harmony export */   "PI": () => (/* binding */ PI),
/* harmony export */   "DEG_TO_RAD": () => (/* binding */ DEG_TO_RAD),
/* harmony export */   "RAD_TO_DEG": () => (/* binding */ RAD_TO_DEG),
/* harmony export */   "TWO_PI": () => (/* binding */ TWO_PI),
/* harmony export */   "HALF_PI": () => (/* binding */ HALF_PI),
/* harmony export */   "QUARTER_PI": () => (/* binding */ QUARTER_PI),
/* harmony export */   "CORNER": () => (/* binding */ CORNER),
/* harmony export */   "CORNERS": () => (/* binding */ CORNERS),
/* harmony export */   "GraphicsBase": () => (/* binding */ GraphicsBase),
/* harmony export */   "CanvasGraphics": () => (/* binding */ CanvasGraphics),
/* harmony export */   "Graphics": () => (/* binding */ Graphics),
/* harmony export */   "CommandGraphics": () => (/* binding */ CommandGraphics),
/* harmony export */   "OffScreenGraphics": () => (/* binding */ OffScreenGraphics)
/* harmony export */ });
/* harmony import */ var _scene_tween_Tween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scene/tween/Tween */ "./src/drawing/scene/tween/Tween.ts");
/* harmony import */ var _Pen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pen */ "./src/drawing/Pen.ts");
/* harmony import */ var _Text_TextMetrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Text/TextMetrics */ "./src/Text/TextMetrics.ts");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _GraphicsUnit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GraphicsUnit */ "./src/drawing/GraphicsUnit.ts");
/* harmony import */ var _InterpolationMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./InterpolationMode */ "./src/drawing/InterpolationMode.ts");
/* harmony import */ var _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SmoothingMode */ "./src/drawing/SmoothingMode.ts");
/* harmony import */ var _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./drawing2D/Matrix */ "./src/drawing/drawing2D/Matrix.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _Region__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Region */ "./src/drawing/Region.ts");
/* harmony import */ var _MeasureStringCache__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./MeasureStringCache */ "./src/drawing/MeasureStringCache.ts");
/* harmony import */ var _ConversionHelpers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ConversionHelpers */ "./src/drawing/ConversionHelpers.ts");
/* harmony import */ var _drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./drawing2D/FillMode */ "./src/drawing/drawing2D/FillMode.ts");
/* harmony import */ var _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./drawing2D/GraphicsPath */ "./src/drawing/drawing2D/GraphicsPath.ts");
/* harmony import */ var _GeomUtilities__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./GeomUtilities */ "./src/drawing/GeomUtilities.ts");
/* harmony import */ var _PathPointType__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./PathPointType */ "./src/drawing/PathPointType.ts");
/* harmony import */ var _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./drawing2D/CombineMode */ "./src/drawing/drawing2D/CombineMode.ts");
/* harmony import */ var _drawing2D_PixelOffsetMode__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./drawing2D/PixelOffsetMode */ "./src/drawing/drawing2D/PixelOffsetMode.ts");
/* harmony import */ var _drawing2D_CompositingQuality__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./drawing2D/CompositingQuality */ "./src/drawing/drawing2D/CompositingQuality.ts");
/* harmony import */ var _drawing2D_GraphicsState__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./drawing2D/GraphicsState */ "./src/drawing/drawing2D/GraphicsState.ts");
/* harmony import */ var _drawing2D_FlushIntention__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./drawing2D/FlushIntention */ "./src/drawing/drawing2D/FlushIntention.ts");
/* harmony import */ var _Font__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Font */ "./src/drawing/Font.ts");
/* harmony import */ var _createCanvasElement__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./createCanvasElement */ "./src/drawing/createCanvasElement.ts");
/* harmony import */ var _DrawStringCache__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./DrawStringCache */ "./src/drawing/DrawStringCache.ts");
/* harmony import */ var _StringFormatFlags__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./StringFormatFlags */ "./src/drawing/StringFormatFlags.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _StringAlignment__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./StringAlignment */ "./src/drawing/StringAlignment.ts");
/* harmony import */ var _SolidBrush__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./imaging/PixelFormat */ "./src/drawing/imaging/PixelFormat.ts");
/* harmony import */ var _GDIPlus__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./GDIPlus */ "./src/drawing/GDIPlus.ts");
/* harmony import */ var _FontStyle__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./FontStyle */ "./src/drawing/FontStyle.ts");
/* harmony import */ var _Text_TextStyle__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../Text/TextStyle */ "./src/Text/TextStyle.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





























// import { Sketch } from "./Sketch/Core/Sketch";





var leadDiv = document.createElement("div");
document.body.appendChild(leadDiv);
var __canvas = document.createElement("canvas");
var beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0;
var AngleModes;
(function (AngleModes) {
    AngleModes["Degrees"] = "degrees";
    AngleModes["Radians"] = "radians";
})(AngleModes || (AngleModes = {}));
var EllipseModes;
(function (EllipseModes) {
    EllipseModes["Radians"] = "radians";
    EllipseModes["Corner"] = "corner";
    EllipseModes["Corners"] = "corners";
    EllipseModes["Center"] = "center";
})(EllipseModes || (EllipseModes = {}));
var RectangleModes;
(function (RectangleModes) {
    RectangleModes["Radians"] = "radians";
    RectangleModes["Corner"] = "corner";
    RectangleModes["Corners"] = "corners";
    RectangleModes["Center"] = "center";
})(RectangleModes || (RectangleModes = {}));
var ArcModes;
(function (ArcModes) {
    ArcModes["Chord"] = "chord";
    ArcModes["Pie"] = "pie";
    ArcModes["Open"] = "open";
})(ArcModes || (ArcModes = {}));
var CompositingMode;
(function (CompositingMode) {
    CompositingMode[CompositingMode["SourceOver"] = 0] = "SourceOver";
    CompositingMode[CompositingMode["SourceCopy"] = 1] = "SourceCopy";
})(CompositingMode || (CompositingMode = {}));
var PI = Math.PI;
var DEG_TO_RAD = PI / 180.0;
var RAD_TO_DEG = 180.0 / PI;
var TWO_PI = PI * 2;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var CORNER = 'corner';
var CORNERS = 'corners';
var GraphicsBase = /** @class */ (function (_super) {
    __extends(GraphicsBase, _super);
    function GraphicsBase() {
        var _this = _super.call(this) || this;
        _this.nativeObject = null;
        _this.ticker = undefined;
        _this.renderer = undefined;
        _this.hasClientTransform = false;
        _this.LastPen = undefined;
        _this.LastBrush = undefined;
        _this.boundingBox = undefined;
        _this.quartzUnit = _GraphicsUnit__WEBPACK_IMPORTED_MODULE_4__.GraphicsUnit.Point;
        _this.isFlipped = false;
        _this.interpolationMode = _InterpolationMode__WEBPACK_IMPORTED_MODULE_5__.InterpolationMode.Default;
        _this.myAngleMode = AngleModes.Degrees;
        _this.myEllipseMode = EllipseModes.Corner;
        _this.x = 0;
        _this.y = 0;
        _this.width = 0;
        _this.height = 0;
        // Need to keep a transform around, since it is not possible to
        // set the transform on the context, merely to concatenate.
        // private transform: CGAffineTransform;
        _this.smoothingMode = _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__.SmoothingMode.Default;
        // Text Layout
        _this.LastBrushColor = undefined;
        // User Space variables
        _this.modelMatrix = undefined;
        _this.viewMatrix = undefined;
        _this.modelViewMatrix = undefined;
        _this.userspaceScaleX = 1;
        _this.userspaceScaleY = 1;
        _this.graphicsUnit = _GraphicsUnit__WEBPACK_IMPORTED_MODULE_4__.GraphicsUnit.Display;
        _this.pageScale = 1;
        _this.renderingOrigin = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGPoint.Empty;
        _this.subviewClipOffset = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle.Empty;
        _this.clip = undefined;
        _this.screenScale = 1;
        _this.compositing_mode = CompositingMode.SourceOver;
        _this.myCurrentPen = undefined;
        _this.myCurrentBrush = undefined;
        _this.DeltaTime = 0;
        _this.FPS = 0;
        _this.MemoryUsage = 0;
        _this.totalFPS = 0;
        _this.totalFPSCount = 0;
        _this.AvgFPS = 0;
        _this.FrameCount = 0;
        _this.prevFPS = 0;
        _this.ticker = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Ticker('TGI_Ticker');
        _this.ticker.timingMode = _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Ticker.RAF;
        return _this;
    }
    GraphicsBase_1 = GraphicsBase;
    Object.defineProperty(GraphicsBase.prototype, "CurrentPen", {
        get: function () {
            return this.getCurrentPen();
        },
        set: function (value) {
            this.setCurrentPen(value);
        },
        enumerable: false,
        configurable: true
    });
    GraphicsBase.prototype.getCurrentPen = function () {
        return this.myCurrentPen;
    };
    GraphicsBase.prototype.setCurrentPen = function (value) {
        this.myCurrentPen = value;
    };
    Object.defineProperty(GraphicsBase.prototype, "CurrentBrush", {
        get: function () {
            return this.getCurrentBrush();
        },
        set: function (value) {
            this.setCurrentBrush(value);
        },
        enumerable: false,
        configurable: true
    });
    GraphicsBase.prototype.getCurrentBrush = function () {
        return this.myCurrentBrush;
    };
    GraphicsBase.prototype.setCurrentBrush = function (value) {
        this.myCurrentBrush = value;
    };
    GraphicsBase.prototype.setSize = function (width, height) {
        this.width = width;
        this.height = height;
    };
    Object.defineProperty(GraphicsBase.prototype, "CompositingMode", {
        get: function () {
            return this.compositing_mode;
        },
        set: function (value) {
            this.compositing_mode = value;
            switch (this.compositing_mode) {
                case CompositingMode.SourceCopy:
                    this.renderer.setBlendMode(_tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGBlendMode.Copy);
                    break;
                case CompositingMode.SourceOver:
                    this.renderer.setBlendMode(_tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGBlendMode.Overlay);
                    break;
            }
        },
        enumerable: false,
        configurable: true
    });
    GraphicsBase.prototype.Graphics = function (context, flipped) {
        if (flipped === void 0) { flipped = true; }
        if (context == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(context));
        this.isFlipped = flipped;
        this.screenScale = 1;
        if (context instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGContext2D) {
            this.initializeContext(context);
        }
        else {
            this.initializeContext(new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGContext2D(context));
        }
    };
    GraphicsBase.prototype.begin = function () {
        beginTime = (performance || Date).now();
    };
    GraphicsBase.prototype.end = function () {
        frames++;
        var time = (performance || Date).now();
        this.DeltaTime = time - beginTime;
        if (time >= prevTime + 1000) {
            this.FPS = Math.round((frames * 1000) / (time - prevTime));
            prevTime = time;
            frames = 0;
            var memory = performance.memory;
            this.MemoryUsage = Math.round((memory === null || memory === void 0 ? void 0 : memory.usedJSHeapSize) / 1048576); /* , memory.jsHeapSizeLimit / 1048576 */
            ;
        }
        return time;
    };
    GraphicsBase.prototype.CreateTween = function (obj, props) {
        //Tween._ticker = this.ticker;
        var tween = _scene_tween_Tween__WEBPACK_IMPORTED_MODULE_0__.Tween.get(obj, props);
        return tween;
    };
    GraphicsBase.prototype.UpdateTween = function (event) {
        _scene_tween_Tween__WEBPACK_IMPORTED_MODULE_0__.Tween.handleEvent(event);
    };
    GraphicsBase.prototype.RequestAnimationFrame = function (func) {
        var _this = this;
        this.ticker.addEventListener('tick', function (event) {
            _this.begin();
            //Tween.handleEvent(event);
            // TWEEN.update(event.time);
            func(event.time);
            _this.end();
            _this.totalFPS += _this.FPS;
            _this.AvgFPS = Math.round(_this.totalFPS / _this.totalFPSCount);
            if (_this.totalFPSCount > 1000) {
                _this.totalFPS = _this.FPS;
                _this.totalFPSCount = 0;
            }
            _this.FrameCount++;
            _this.totalFPSCount++;
            _this.prevFPS = _this.FPS;
        });
    };
    GraphicsBase.prototype.modeAdjust = function (a, b, c, d, mode) {
        if (mode === EllipseModes.Corner) {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle({ x: a, y: b, width: c, height: d });
        }
        else if (mode === EllipseModes.Corners) {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle({ x: a, y: b, width: c - a, height: d - b });
        }
        else if (mode === EllipseModes.Radians) {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle({ x: a - c, y: b - d, width: 2 * c, height: 2 * d });
        }
        else if (mode === EllipseModes.Center) {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle({ x: a - c * 0.5, y: b - d * 0.5, width: c, height: d });
        }
        return _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle.Empty;
    };
    GraphicsBase.prototype.initializeContext = function (context) {
        this.renderer = context;
        context.saveState();
        this.modelMatrix = new _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_7__.Matrix();
        this.viewMatrix = new _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_7__.Matrix();
        this.modelViewMatrix = new _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_7__.Matrix();
        this.boundingBox = context.getClipBoundingBox();
        this.graphicsUnit = _GraphicsUnit__WEBPACK_IMPORTED_MODULE_4__.GraphicsUnit.Pixel;
        this.pageScale = 1;
        // Set anti-aliasing
        this.SmoothingMode = _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__.SmoothingMode.Default;
        this.setupgetView();
    };
    GraphicsBase.prototype.initializeMatrix = function (matrix, isFlipped) {
        if (!isFlipped) {
            //				matrix.Reset();
            //				matrix.Translate(0, boundingBox.Height, MatrixOrder.Append);
            //				matrix.Scale(1,-1, MatrixOrder.Append);
            matrix.value = new _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_7__.Matrix(1, 0, 0, -1, 0, this.boundingBox.Height);
        }
        else {
            matrix.value.reset();
        }
        // It looks like we really do not need to determin if it is flipped or not.
        // So far this following is working no matter which coordinate system is being used
        // on both Mac and iOS.
        // I will leave the previous commented out code there just in case.  When first implementing
        // DrawString the flipped coordinates were causing problems.  Now after implementing with
        // CoreText it seems to all be working.  Fingers Crossed.
        //matrix = new Matrix(
        //	1, 0, 0, -1, 0, boundingBox.Height);
    };
    GraphicsBase.prototype.graphicsUnitConvertX = function (x) {
        return _ConversionHelpers__WEBPACK_IMPORTED_MODULE_11__.ConversionHelpers.GraphicsUnitConversion1(this.PageUnit, _GraphicsUnit__WEBPACK_IMPORTED_MODULE_4__.GraphicsUnit.Pixel, this.DpiX, x);
    };
    GraphicsBase.prototype.graphicsUnitConvertY = function (y) {
        return _ConversionHelpers__WEBPACK_IMPORTED_MODULE_11__.ConversionHelpers.GraphicsUnitConversion1(this.PageUnit, _GraphicsUnit__WEBPACK_IMPORTED_MODULE_4__.GraphicsUnit.Pixel, this.DpiY, y);
    };
    GraphicsBase.prototype.dispose = function (disposing) {
        if (disposing) {
            if (this.renderer != null) {
                this.renderer.restoreState();
                if (this.hasClientTransform)
                    this.renderer.restoreState();
                this.renderer = undefined;
            }
            // PlatformDispose();
        }
    };
    GraphicsBase.prototype.transferToImageBitmap = function () {
        return this.renderer.transferToImageBitmap();
    };
    GraphicsBase.prototype.moveTo = function (x, y) {
        if (_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](x, _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint)) {
            this.moveTo(x.X, x.Y);
        }
        else {
            this.renderer.moveTo(x, y);
        }
    };
    GraphicsBase.prototype.lineTo = function (x, y) {
        if (_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](x, _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint)) {
            this.lineTo(x.X, x.Y);
        }
        else {
            this.renderer.addLineToPoint(x, y);
        }
    };
    GraphicsBase.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {
        this.renderer.addCurveToPoint(x1, y1, x2, y2, x3, y3);
    };
    GraphicsBase.prototype.preparePen = function (pen) {
        if (pen.Width <= 1) {
            this.renderer.translateCTM(-.5, -.5);
        }
    };
    GraphicsBase.prototype.strokePen = function (pen) {
        // FIXME: draw custom start/end caps
        // First we call the Pen with a fill of false so the brush can setup the stroke
        // For LinearGradientBrush this will setup a TransparentLayer so the gradient can
        // be filled at the end.  See comments.
        pen.setup(this, false);
        this.renderer.drawPath(_tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGPathDrawingMode.Stroke);
        // Next we call the Pen with a fill of true so the brush can draw the Gradient.
        // For LinearGradientBrush this will draw the Gradient and end the TransparentLayer.
        // See comments.
        pen.setup(this, true);
        if (pen.Width <= 1) {
            this.renderer.translateCTM(.5, .5);
        }
    };
    GraphicsBase.prototype.fillBrush = function (brush, fillMode) {
        if (fillMode === void 0) { fillMode = _drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__.FillMode.Alternate; }
        brush.setup(this, true);
        if (fillMode === _drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__.FillMode.Alternate)
            this.renderer.eOFillPath();
        else
            this.renderer.fillPath();
    };
    GraphicsBase.prototype.drawArc = function (pen, x, y, width, height, startAngle, sweepAngle) {
        if (pen instanceof _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen && x instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle && typeof y === 'number' && typeof width === 'number') {
            var rect = x;
            var startAngle_1 = y;
            var sweepAngle_1 = width;
            this.drawArc(pen, rect.X, rect.Y, rect.Width, rect.Height, startAngle_1, sweepAngle_1);
        }
        else if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {
            if (pen == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
            }
            this.renderer.beginPath();
            this.preparePen(pen);
            this.drawEllipticalArc(x, y, width, height, startAngle, sweepAngle, false);
            this.strokePen(pen);
        }
    };
    GraphicsBase.prototype.DrawLine = function (param1, param2, param3, param4, param5) {
        if (_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](param2, _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](param3, _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint)) {
            var pen = param1;
            var pt1 = param2;
            var pt2 = param3;
            if (pen == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
            // DrawLine is throwing an assertion error on MonoTouch
            // Assertion failed: (CGFloatIsValid(x) && CGFloatIsValid(y))
            // , function void CGPathAddLineToPoint(CGMutablePathRef, const CGAffineTransform *, CGFloat, CGFloat)
            // What we will do here is not draw the line at all if any of the points are Single.NaN
            if (!Number.isNaN(pt1.X) && !Number.isNaN(pt1.Y) &&
                !Number.isNaN(pt2.X) && !Number.isNaN(pt2.Y)) {
                this.preparePen(pen);
                this.renderer.beginPath();
                this.moveTo(pt1.X, pt1.Y);
                this.lineTo(pt2.X, pt2.Y);
                this.strokePen(pen);
            }
        }
        else if (typeof param2 === 'number' && typeof param3 === 'number') {
            var pen = param1;
            var x1 = param2;
            var y1 = param3;
            var x2 = param4;
            var y2 = param5;
            if (pen == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
            }
            this.preparePen(pen);
            this.renderer.beginPath();
            this.moveTo(x1, y1);
            this.lineTo(x2, y2);
            this.strokePen(pen);
        }
    };
    GraphicsBase.prototype.drawBezier = function (pen, param2, param3, param4, param5, param6, param7, param8, param9) {
        if (pen == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
        }
        this.preparePen(pen);
        this.renderer.beginPath();
        if (_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](param2, _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint) &&
            _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](param3, _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](param4, _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint) &&
            _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](param5, _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint)) {
            this.moveTo(param2.X, param2.Y);
            this.curveTo(param3.X, param3.Y, param4.X, param4.Y, param5.X, param5.Y);
        }
        else if (typeof param2 === 'number' && typeof param3 === 'number' && typeof param4 === 'number' && typeof param5 === 'number') {
            this.moveTo(param2, param3);
            this.curveTo(param4, param5, param6, param7, param8, param9);
        }
        this.strokePen(pen);
    };
    GraphicsBase.prototype.drawBeziers = function (pen, points) {
        if (pen == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
        if (points == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(points));
        var length = points.length;
        if (length < 4)
            return;
        for (var i = 0; i < length - 1; i += 3) {
            var p1 = points[i];
            var p2 = points[i + 1];
            var p3 = points[i + 2];
            var p4 = points[i + 3];
            this.drawBezier(pen, p1, p2, p3, p4);
        }
    };
    GraphicsBase.prototype.drawLines = function (pen, points) {
        if (pen == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
        if (points == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(points));
        var count = points.length;
        if (count < 2)
            return;
        this.preparePen(pen);
        this.renderer.beginPath();
        this.moveTo(points[0]);
        for (var i = 1; i < count; i++)
            this.lineTo(points[i]);
        this.strokePen(pen);
    };
    GraphicsBase.prototype.rectanglePath = function (x, y, w, h, tl, tr, br, bl) {
        this.renderer.beginPath();
        if (typeof tl === 'undefined') {
            // No rounded corners
            this.renderer.addRect(new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle(x, y, w, h));
        }
        else {
            // At least one rounded corner
            // Set defaults when not specified
            if (typeof tr === 'undefined') {
                tr = tl;
            }
            if (typeof br === 'undefined') {
                br = tr;
            }
            if (typeof bl === 'undefined') {
                bl = br;
            }
            var hw = w / 2;
            var hh = h / 2;
            // Clip radii
            if (w < 2 * tl) {
                tl = hw;
            }
            if (h < 2 * tl) {
                tl = hh;
            }
            if (w < 2 * tr) {
                tr = hw;
            }
            if (h < 2 * tr) {
                tr = hh;
            }
            if (w < 2 * br) {
                br = hw;
            }
            if (h < 2 * br) {
                br = hh;
            }
            if (w < 2 * bl) {
                bl = hw;
            }
            if (h < 2 * bl) {
                bl = hh;
            }
            // Draw shape
            this.renderer.beginPath();
            this.renderer.moveTo(x + tl, y);
            this.renderer.addArcToPoint(x + w, y, x + w, y + h, tr);
            this.renderer.addArcToPoint(x + w, y + h, x, y + h, br);
            this.renderer.addArcToPoint(x, y + h, x, y, bl);
            this.renderer.addArcToPoint(x, y, x + w, y, tl);
            this.renderer.closePath();
            /*  this.context.beginPath();
             this.moveTo(x1, y1);
             this.lineTo(x1, y2);
             this.lineTo(x2, y2);
             this.lineTo(x2, y1);
             this.lineTo(x1, y1);
             this.context.closePath(); */
        }
    };
    GraphicsBase.prototype.DrawRectangle = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var pen = args[0];
        if (pen == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
        if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle)) {
            var rect = args[1];
            this.DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle) && typeof args[2] === 'string') {
            var rect = args[1];
            var mode = args[2];
            this.DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height, mode);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle) && typeof args[2] === 'string') {
            var rect = args[1];
            var mode = args[2];
            this.DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height, mode);
        }
        else if (args.length >= 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle) && typeof args[2] === 'number') {
            var rect = args[1];
            var tl = args[2];
            var tr = args[3];
            var br = args[4];
            var bl = args[5];
            var mode = args[6] || RectangleModes.Corner;
            if (typeof tr === 'undefined') {
                tr = tl;
            }
            if (typeof br === 'undefined') {
                br = tr;
            }
            if (typeof bl === 'undefined') {
                bl = br;
            }
            this.DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height, tl, tr, br, bl, mode);
        }
        else if (args.length === 5) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var mode = RectangleModes.Corner;
            this.DrawRectangle(pen, x, y, w, h, mode);
        }
        else if (args.length === 6 && typeof args[5] === 'string') {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var mode = args[5];
            this.DrawRectangle(pen, x, y, w, h, 0, 0, 0, 0, mode);
        }
        else if (args.length >= 6 && args.length < 10) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var tl = args[5];
            var tr = args[6];
            var br = args[7];
            var bl = args[8];
            var mode = args[9] || RectangleModes.Corner;
            if (typeof tr === 'undefined') {
                tr = tl;
            }
            if (typeof br === 'undefined') {
                br = tr;
            }
            if (typeof bl === 'undefined') {
                bl = br;
            }
            this.DrawRectangle(pen, x, y, w, h, tl, tr, br, bl, mode);
        }
        else if (args.length === 10) {
            this.preparePen(pen);
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var tl = args[5];
            var tr = args[6];
            var br = args[7];
            var bl = args[8];
            var mode = args[9] || RectangleModes.Corner;
            var adjustedRect = this.modeAdjust(x, y, w, h, mode);
            this.rectanglePath(adjustedRect.X, adjustedRect.Y, adjustedRect.Width, adjustedRect.Height, tl, tr, br, bl);
            this.strokePen(pen);
        }
    };
    GraphicsBase.prototype.FillRectangle = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var brush = args[0];
        if (brush == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(brush));
        if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle)) {
            var rect = args[1];
            this.FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle) && typeof args[2] === 'string') {
            var rect = args[1];
            var mode = args[2];
            this.FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height, mode);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle) && typeof args[2] === 'string') {
            var rect = args[1];
            var mode = args[2];
            this.FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height, mode);
        }
        else if (args.length >= 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle) && typeof args[2] === 'number') {
            var rect = args[1];
            var tl = args[2];
            var tr = args[3];
            var br = args[4];
            var bl = args[5];
            var mode = args[6] || RectangleModes.Corner;
            if (typeof tr === 'undefined') {
                tr = tl;
            }
            if (typeof br === 'undefined') {
                br = tr;
            }
            if (typeof bl === 'undefined') {
                bl = br;
            }
            this.FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height, tl, tr, br, bl, mode);
        }
        else if (args.length === 5) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var mode = RectangleModes.Corner;
            this.FillRectangle(brush, x, y, w, h, mode);
        }
        else if (args.length === 6 && typeof args[5] === 'string') {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var mode = args[5];
            this.FillRectangle(brush, x, y, w, h, 0, 0, 0, 0, mode);
        }
        else if (args.length >= 6 && args.length < 10) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var tl = args[5];
            var tr = args[6];
            var br = args[7];
            var bl = args[8];
            var mode = args[9] || RectangleModes.Corner;
            if (typeof tr === 'undefined') {
                tr = tl;
            }
            if (typeof br === 'undefined') {
                br = tr;
            }
            if (typeof bl === 'undefined') {
                bl = br;
            }
            this.FillRectangle(brush, x, y, w, h, tl, tr, br, bl, mode);
        }
        else if (args.length === 10) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var tl = args[5];
            var tr = args[6];
            var br = args[7];
            var bl = args[8];
            var mode = args[9] || RectangleModes.Corner;
            var adjustedRect = this.modeAdjust(x, y, w, h, mode);
            this.translateTransform(adjustedRect.X, adjustedRect.Y);
            this.rectanglePath(0, 0, adjustedRect.Width, adjustedRect.Height, tl, tr, br, bl);
            this.fillBrush(brush);
            this.translateTransform(-adjustedRect.X, -adjustedRect.Y);
        }
    };
    GraphicsBase.prototype.fillRegion = function (brush, region) {
        if (brush == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("brush");
        if (region == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("region");
        // We will clear the rectangle of our clipping bounds for Empty
        if (region.regionPath == null) {
            // This may set the rectangle to Black depending on the context
            // passed.  On a NSView set WantsLayers and the Layer Background color.
            this.renderer.clearRect(this.renderer.getClipBoundingBox());
            return;
        }
        this.renderer.addPath(region.regionPath);
        this.fillBrush(brush);
    };
    GraphicsBase.prototype.makeEllipse = function (x, y, width, height, ellipseMode) {
        if (width < 0) {
            width = Math.abs(width);
        }
        if (height < 0) {
            height = Math.abs(height);
        }
        var vals = this.modeAdjust(x, y, width, height, ellipseMode);
        x = vals.X,
            y = vals.Y,
            width = vals.Width,
            height = vals.Height;
        var kappa = 0.5522847498, ox = width / 2 * kappa, // control point offset horizontal
        oy = height / 2 * kappa, // control point offset vertical
        xe = x + width, // x-end
        ye = y + height, // y-end
        xm = x + width / 2, // x-middle
        ym = y + height / 2; // y-middle
        this.renderer.beginPath();
        this.renderer.moveTo(x, ym);
        this.renderer.addCurveToPoint(x, ym - oy, xm - ox, y, xm, y);
        this.renderer.addCurveToPoint(xm + ox, y, xe, ym - oy, xe, ym);
        this.renderer.addCurveToPoint(xe, ym + oy, xm + ox, ye, xm, ye);
        this.renderer.addCurveToPoint(xm - ox, ye, x, ym + oy, x, ym);
        this.renderer.closePath();
    };
    GraphicsBase.prototype.drawPoint = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var pen = args[0];
        var x, y;
        if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint)) {
            x = Math.round(args[1].X);
            y = Math.round(args[1].Y);
        }
        else {
            x = Math.round(args[1]);
            y = Math.round(args[2]);
        }
        // swapping fill color to stroke and back after for correct point rendering
        var newBrush = new _SolidBrush__WEBPACK_IMPORTED_MODULE_27__.SolidBrush(pen.Color);
        if (pen.Width > 1) {
            this.renderer.beginPath();
            this.renderer.addArc(x, y, pen.Width / 2, 0, Math.PI * 2, false);
            this.fillBrush(newBrush);
        }
        else {
            this.renderer.beginPath();
            this.renderer.addRect(new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle(x, y, 1, 1));
            this.fillBrush(newBrush);
        }
    };
    GraphicsBase.prototype.DrawEllipse = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var pen = args[0];
        if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle)) {
            var rect = args[1];
            this.DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height, EllipseModes.Corner);
        }
        else if (args.length === 4 &&
            (_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Pen) && typeof args[1] === 'number' && typeof args[2] === 'number' && typeof args[3] === 'number')) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = w;
            var mode = EllipseModes.Corner;
            this.DrawEllipse(pen, x, y, w, h, mode);
        }
        else if (args.length === 5 &&
            (_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Pen) && typeof args[1] === 'number' &&
                typeof args[2] === 'number' && typeof args[3] === 'number' && typeof args[4] === 'string')) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = w;
            var mode = args[4];
            this.DrawEllipse(pen, x, y, w, h, mode);
        }
        else if (args.length === 5 &&
            (_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Pen) && typeof args[1] === 'number' &&
                typeof args[2] === 'number' && typeof args[3] === 'number' && typeof args[4] === 'number')) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var mode = EllipseModes.Corner;
            this.DrawEllipse(pen, x, y, w, h, mode);
        }
        else if (args.length === 6) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var mode = args[5];
            this.preparePen(pen);
            this.makeEllipse(x, y, w, h, mode);
            this.strokePen(pen);
        }
        /* const pen: Pen = args[0];
        let rect: RectangleF;

        if (pen == null) {
            throw new ArgumentNullException(nameof(pen));
        }

        if (args.length === 2) {
            rect = args[1];
        } else if (args.length === 5) {
            rect = new RectangleF(args[1], args[2], args[3], args[4]);
        }
        this.preparePen(pen);
        this.context.beginPath();
        this.context.addEllipseInRect(rect);
        this.context.closePath();
        this.strokePen(pen); */
    };
    GraphicsBase.prototype.FillEllipse = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var brush = args[0];
        if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle)) {
            var rect = args[1];
            this.FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height, EllipseModes.Corner);
        }
        else if (args.length === 4 &&
            (_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Brush) && typeof args[1] === 'number' && typeof args[2] === 'number' && typeof args[3] === 'number')) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = w;
            var mode = EllipseModes.Corner;
            this.FillEllipse(brush, x, y, w, h, mode);
        }
        else if (args.length === 5 &&
            (_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Brush) && typeof args[1] === 'number' &&
                typeof args[2] === 'number' && typeof args[3] === 'number' && typeof args[4] === 'string')) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = w;
            var mode = args[4];
            this.FillEllipse(brush, x, y, w, h, mode);
        }
        else if (args.length === 5 &&
            (_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Brush) && typeof args[1] === 'number' &&
                typeof args[2] === 'number' && typeof args[3] === 'number' && typeof args[4] === 'number')) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var mode = EllipseModes.Corner;
            this.FillEllipse(brush, x, y, w, h, mode);
        }
        else if (args.length === 6) {
            var x = args[1];
            var y = args[2];
            var w = args[3];
            var h = args[4];
            var mode = args[5];
            this.translateTransform(x, y);
            this.makeEllipse(0, 0, w, h, mode);
            this.fillBrush(brush);
            this.translateTransform(-x, -y);
        }
        /*  const brush: Brush = args[0];
         let rect: RectangleF;

         if (brush == null) {
             throw new ArgumentNullException("brush");
         }

         if (args.length === 2) {
             rect = args[1];
         } else if (args.length === 5) {
             rect = new RectangleF(args[1], args[2], args[3], args[4]);
         }

         this.context.beginPath();
         this.context.addEllipseInRect(rect);
         this.context.closePath();
         this.fillBrush(brush); */
    };
    GraphicsBase.prototype.applyModelgetView = function () {
        // Since there is no context.SetCTM, only ConcatCTM
        // get the current transform, invert it, and concat this to
        // obtain the identity.   Then we concatenate the value passed
        this.renderer.concatCTM(this.modelViewMatrix.transform.invert());
        this.modelViewMatrix = this.viewMatrix.clone();
        this.modelViewMatrix.multiply(this.modelMatrix);
        //			Console.WriteLine("------------ apply Model View ------");
        //			Console.WriteLine("Model: " + modelMatrix.transform);
        //			Console.WriteLine("View: " + viewMatrix.transform);
        //			Console.WriteLine("ModelView: " + modelViewMatrix.transform);
        //			Console.WriteLine("------------ end apply Model View ------\n\n");
        // we apply the Model View matrix passed to the context
        this.renderer.concatCTM(this.modelViewMatrix.transform);
    };
    GraphicsBase.prototype.resetTransform = function () {
        this.modelMatrix.reset();
        this.applyModelgetView();
    };
    Object.defineProperty(GraphicsBase.prototype, "Transform", {
        get: function () {
            return this.modelMatrix;
        },
        set: function (value) {
            this.modelMatrix = value;
            this.applyModelgetView();
        },
        enumerable: false,
        configurable: true
    });
    GraphicsBase.prototype.rotateTransform = function (angle, order) {
        if (order === void 0) { order = _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_7__.MatrixOrder.Prepend; }
        /* this.modelMatrix.rotate(angle, order);
        this.applyModelgetView(); */
        this.renderer.rotateCTM(angle);
    };
    GraphicsBase.prototype.translateTransform = function (tx, ty, order) {
        if (order === void 0) { order = _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_7__.MatrixOrder.Prepend; }
        //Console.WriteLine ("Currently does not support anything but prepend mode");
        /*  this.modelMatrix.translate(tx, ty, order);
         this.applyModelgetView(); */
        this.renderer.translateCTM(tx, ty);
    };
    GraphicsBase.prototype.ScaleTransform = function (sx, sy, order) {
        if (order === void 0) { order = _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_7__.MatrixOrder.Prepend; }
        // TODO scale de problem kard iin commentlendi.
        //this.modelMatrix.scale(sx, sy, order);
        //this.applyModelgetView();
        this.renderer.scaleCTM(sx, sy);
    };
    GraphicsBase.prototype.makeCurve = function (points, tangents, offset, length, type) {
        this.moveTo(points[offset].X, points[offset].Y);
        var i = offset;
        for (; i < offset + length; i++) {
            var j = i + 1;
            var x1 = points[i].X + tangents[i].X;
            var y1 = points[i].Y + tangents[i].Y;
            var x2 = points[j].X - tangents[j].X;
            var y2 = points[j].Y - tangents[j].Y;
            var x3 = points[j].X;
            var y3 = points[j].Y;
            this.renderer.addCurveToPoint(x1, y1, x2, y2, x3, y3);
        }
        if (type === _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_13__.CurveType.Close) {
            /* complete (close) the curve using the first point */
            var x1 = points[i].X + tangents[i].X;
            var y1 = points[i].Y + tangents[i].Y;
            var x2 = points[0].X - tangents[0].X;
            var y2 = points[0].Y - tangents[0].Y;
            var x3 = points[0].X;
            var y3 = points[0].Y;
            this.renderer.addCurveToPoint(x1, y1, x2, y2, x3, y3);
            this.renderer.closePath();
        }
    };
    GraphicsBase.prototype.drawCurve = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 2) {
            var pen = args[0];
            var points = args[1];
            var tension = 0.5;
            if (points == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(points));
            }
            var count = points.length;
            if (count == 2)
                this.drawLines(pen, points);
            else {
                var segments = (count > 3) ? (count - 1) : (count - 2);
                this.drawCurve(pen, points, 0, segments, tension);
            }
        }
        else if (args.length === 3) {
            var pen = args[0];
            var points = args[1];
            var tension = args[2];
            if (points == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(points));
            }
            var count = points.length;
            if (count == 2)
                this.drawLines(pen, points);
            else {
                var segments = (count > 3) ? (count - 1) : (count - 2);
                this.drawCurve(pen, points, 0, segments, tension);
            }
        }
        else if (arguments.length === 5) {
            var pen = args[0];
            var points = args[1];
            var offset = args[2];
            var numberOfSegments = args[3];
            var tension = 0.5;
            if (args[4] != null) {
                tension = args[4];
            }
            if (points == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(points));
            }
            if (pen == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
            }
            if (numberOfSegments < 1) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(numberOfSegments));
            }
            var count = points.length;
            // we need 3 points for the first curve, 2 more for each curves
            // and it's possible to use a point prior to the offset (to calculate)
            if (offset === 0 && numberOfSegments === 1 && count < 3)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException("invalid parameters");
            if (numberOfSegments >= points.length - offset)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException("offset");
            var tangents = _GeomUtilities__WEBPACK_IMPORTED_MODULE_14__.GeomUtilities.GetCurveTangents(_drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_13__.CURVE_MIN_TERMS, points, count, tension, _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_13__.CurveType.Open);
            this.preparePen(pen);
            this.renderer.beginPath();
            this.makeCurve(points, tangents, offset, numberOfSegments, _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_13__.CurveType.Open);
            this.strokePen(pen);
        }
    };
    GraphicsBase.prototype.plotPath = function (path) {
        var x1 = 0, y1 = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0;
        var points = path.PathPoints;
        var types = path.PathTypes;
        var bidx = 0;
        this.renderer.beginPath();
        for (var i = 0; i < points.length; i++) {
            var point = points[i];
            var type = types[i];
            switch (type & _PathPointType__WEBPACK_IMPORTED_MODULE_15__.PathPointType.PathTypeMask) {
                case _PathPointType__WEBPACK_IMPORTED_MODULE_15__.PathPointType.Start:
                    this.moveTo(point.X, point.Y);
                    break;
                case _PathPointType__WEBPACK_IMPORTED_MODULE_15__.PathPointType.Line:
                    this.lineTo(point.X, point.Y);
                    break;
                case _PathPointType__WEBPACK_IMPORTED_MODULE_15__.PathPointType.Bezier3:
                    // collect 3 points
                    switch (bidx++) {
                        case 0:
                            x1 = point.X;
                            y1 = point.Y;
                            break;
                        case 1:
                            x2 = point.X;
                            y2 = point.Y;
                            break;
                        case 2:
                            x3 = point.X;
                            y3 = point.Y;
                            break;
                    }
                    if (bidx === 3) {
                        this.renderer.addCurveToPoint(x1, y1, x2, y2, x3, y3);
                        bidx = 0;
                    }
                    break;
                default:
                    throw new Error("Inconsistent internal state, path type=" + type);
            }
            if ((type & _PathPointType__WEBPACK_IMPORTED_MODULE_15__.PathPointType.CloseSubpath) !== 0)
                this.renderer.closePath();
        }
    };
    GraphicsBase.prototype.drawContextPath = function (pen) {
        this.strokePen(pen);
    };
    GraphicsBase.prototype.drawPath = function (pen, path) {
        if (pen == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
        }
        if (path == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(path));
        }
        this.preparePen(pen);
        this.plotPath(path);
        this.strokePen(pen);
    };
    GraphicsBase.prototype.fillContextPath = function (brush) {
        if (brush == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(brush));
        }
        this.fillBrush(brush);
    };
    GraphicsBase.prototype.fillPath = function (brush, path) {
        if (brush == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(brush));
        }
        if (path == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(path));
        }
        this.plotPath(path);
        var fillMode = path.FillMode;
        if (path.isReverseWindingOnFill)
            fillMode = (fillMode === _drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__.FillMode.Alternate) ? _drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__.FillMode.Winding : _drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__.FillMode.Alternate;
        this.fillBrush(brush, fillMode);
    };
    GraphicsBase.prototype.getNearestColor = function (color) {
        // this uses a color pallette which we really do not implement
        // so just return back the color passed for now.
        return _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGColor.FromRgba(color.R, color.G, color.B);
    };
    GraphicsBase.prototype.setupgetView = function () {
        var outParam = { value: this.viewMatrix };
        this.initializeMatrix(outParam, this.isFlipped);
        // Take into account retina diplays
        this.viewMatrix.scale(this.screenScale, this.screenScale);
        this.userspaceScaleX = this.graphicsUnitConvertX(1) * this.pageScale;
        this.userspaceScaleY = this.graphicsUnitConvertY(1) * this.pageScale;
        this.viewMatrix.scale(this.userspaceScaleX, this.userspaceScaleY);
        this.viewMatrix.translate(this.renderingOrigin.X * this.userspaceScaleX, -this.renderingOrigin.Y * this.userspaceScaleY, _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_7__.MatrixOrder.Append);
        this.applyModelgetView();
    };
    Object.defineProperty(GraphicsBase.prototype, "PageUnit", {
        get: function () {
            return this.graphicsUnit;
        },
        set: function (value) {
            this.graphicsUnit = value;
            this.setupgetView();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "PageScale", {
        get: function () {
            return this.pageScale;
        },
        set: function (value) {
            // TODO: put some validation in here maybe?  Need to
            this.pageScale = value;
            this.setupgetView();
        },
        enumerable: false,
        configurable: true
    });
    GraphicsBase.prototype.setClip = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle)) {
            this.setClip(args[0], _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Replace);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.GraphicsPath)) {
            this.setClip(args[0], _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Replace);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Graphics)) {
            this.setClip(args[0], _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Replace);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle)) {
            if (args[1] === _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Intersect) {
                // TODO: aadaki kod yavalk ve kullanlmad iin kapatld.
                /* if (this.clip == null || this.clip.isInfinite(this)) {
                    this.clip = new Region(args[0]);
                } else {
                    this.clip.intersect(args[0]);
                } */
                this.renderer.clipToRect(args[0]);
            }
            else if (args[1] === _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Replace) {
                if (args[1] === _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Replace && this.clip != null && !this.clip.isInfinite(this)) {
                    this.resetNativeClip();
                }
                this.clip = new _Region__WEBPACK_IMPORTED_MODULE_9__.Region(args[0]);
                this.renderer.clipToRect(args[0]);
            }
            else {
                this.setClip(new _Region__WEBPACK_IMPORTED_MODULE_9__.Region(args[0]), args[1]);
            }
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.GraphicsPath)) {
            this.setClip(new _Region__WEBPACK_IMPORTED_MODULE_9__.Region(args[0]), args[1]);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Graphics)) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.NotImplementedException('Graphics.setClip');
        }
        else if (args.length === 2 && args[0] instanceof _Region__WEBPACK_IMPORTED_MODULE_9__.Region) {
            var region = args[0];
            // We need to reset the clip that is active now so that the graphic
            // states are correct when we set them.
            this.resetNativeClip();
            switch (args[1]) {
                case _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Replace:
                    // Set our clip region by cloning the region that is passed for now
                    this.clip = region.clone();
                    break;
                case _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Intersect:
                    if (this.clip == null) {
                        this.clip = region.clone();
                    }
                    else {
                        this.clip.intersect(region);
                    }
                    break;
                case _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Union:
                    if (this.clip != null) {
                        this.clip.union(region);
                    }
                    break;
                case _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Exclude:
                    if (this.clip == null) {
                        this.clip = new _Region__WEBPACK_IMPORTED_MODULE_9__.Region();
                    }
                    this.clip.exclude(region);
                    break;
                case _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Xor:
                    if (this.clip == null) {
                        this.clip = new _Region__WEBPACK_IMPORTED_MODULE_9__.Region();
                    }
                    this.clip.xor(region);
                    break;
                default:
                    throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.NotImplementedException("SetClip for CombineMode " + args[1] + " not implemented");
            }
            //Unlike the current path, the current clipping path is part of the graphics state.
            //Therefore, to re-enlarge the paintable area by restoring the clipping path to a
            //prior state, you must save the graphics state before you clip and restore the graphics
            //state after youve completed any clipped drawing.
            if (this.Clip.isEmpty(this)) {
                this.renderer.clipToRect(_tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle.Empty);
            }
            else {
                this.renderer.addPath(this.Clip.regionPath); // FIXME:
                this.renderer.closePath();
                this.renderer.clip();
            }
        }
    };
    GraphicsBase.prototype.beginContainer = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.NotImplementedException('beginContainer');
    };
    GraphicsBase.prototype.endContainer = function (container) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.NotImplementedException('endContainer');
    };
    Object.defineProperty(GraphicsBase.prototype, "SmoothingMode", {
        get: function () {
            return this.smoothingMode;
        },
        set: function (value) {
            if (this.smoothingMode !== value) {
                // Quartz performs antialiasing for a graphics context if both the allowsAntialiasing parameter
                // and the graphics state parameter shouldAntialias are true.
                switch (value) {
                    case _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__.SmoothingMode.AntiAlias:
                    case _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__.SmoothingMode.HighQuality:
                    case _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__.SmoothingMode.Default:
                        if (this.smoothingMode !== _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__.SmoothingMode.AntiAlias &&
                            this.smoothingMode !== _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__.SmoothingMode.HighQuality &&
                            this.smoothingMode !== _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__.SmoothingMode.Default) {
                            //context.SetAllowsAntialiasing(true);  // This parameter is not part of the graphics state.
                            this.renderer.setShouldAntialias(true);
                        }
                        break;
                    default:
                        if (this.smoothingMode === _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__.SmoothingMode.AntiAlias &&
                            this.smoothingMode === _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__.SmoothingMode.HighQuality &&
                            this.smoothingMode === _SmoothingMode__WEBPACK_IMPORTED_MODULE_6__.SmoothingMode.Default) {
                            //context.SetAllowsAntialiasing(false); // This parameter is not part of the graphics state.
                            this.renderer.setShouldAntialias(false);
                        }
                        break;
                }
                this.smoothingMode = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "IsClipEmpty", {
        get: function () {
            return this.Clip.isEmpty(this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "PixelOffsetMode", {
        get: function () {
            //throw new NotImplementedException ();
            return _drawing2D_PixelOffsetMode__WEBPACK_IMPORTED_MODULE_17__.PixelOffsetMode.None;
        },
        set: function (value) {
            //throw new NotImplementedException('set PixelOffsetMode');
            //console.error('set PixelOffsetMode not implemented.')
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "Clip", {
        get: function () {
            return this.clip == null ? Graphics.infiniteRegion : this.clip;
        },
        set: function (value) {
            //this.setClip(value, CombineMode.Replace);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "ClipBounds", {
        get: function () {
            return this.Clip.getBounds();
            //return context.GetClipBoundingBox ();
        },
        set: function (value) {
            this.setClip(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "VisibleClipBounds", {
        get: function () {
            // FIXME
            return this.Clip.getBounds();
            //throw new NotImplementedException ();
        },
        set: function (value) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.NotImplementedException('set VisibleClipBounds');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "InterpolationMode", {
        get: function () {
            return this.interpolationMode;
        },
        set: function (value) {
            this.interpolationMode = value;
            switch (value) {
                case _InterpolationMode__WEBPACK_IMPORTED_MODULE_5__.InterpolationMode.Low:
                    this.renderer.InterpolationQuality = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGInterpolationQuality.Low;
                    break;
                case _InterpolationMode__WEBPACK_IMPORTED_MODULE_5__.InterpolationMode.High:
                case _InterpolationMode__WEBPACK_IMPORTED_MODULE_5__.InterpolationMode.HighQualityBicubic:
                case _InterpolationMode__WEBPACK_IMPORTED_MODULE_5__.InterpolationMode.HighQualityBilinear:
                    this.renderer.InterpolationQuality = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGInterpolationQuality.High;
                    break;
                case _InterpolationMode__WEBPACK_IMPORTED_MODULE_5__.InterpolationMode.NearestNeighbor:
                case _InterpolationMode__WEBPACK_IMPORTED_MODULE_5__.InterpolationMode.Bicubic:
                case _InterpolationMode__WEBPACK_IMPORTED_MODULE_5__.InterpolationMode.Bilinear:
                    this.renderer.InterpolationQuality = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGInterpolationQuality.Medium;
                    break;
                case _InterpolationMode__WEBPACK_IMPORTED_MODULE_5__.InterpolationMode.Invalid:
                    this.renderer.InterpolationQuality = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGInterpolationQuality.None;
                    break;
                default:
                    this.renderer.InterpolationQuality = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGInterpolationQuality.Default;
                    break;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "RenderingOrigin", {
        get: function () {
            return this.renderingOrigin;
        },
        set: function (value) {
            this.renderingOrigin = value;
            this.setupgetView();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "TextContrast", {
        get: function () {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.NotImplementedException('get TextContrast');
        },
        set: function (value) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.NotImplementedException('set TextContrast');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "DpiX", {
        get: function () {
            // We should probably read the NSScreen attributes and get the resolution
            //    but there are problems getting the value from NSValue to a Rectangle
            // We will set this to a fixed value for now
            return 96.0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "DpiY", {
        get: function () {
            // We should probably read the NSScreen attributes and get the resolution
            //    but there are problems getting the value from NSValue to a Rectangle
            // We will set this to a fixed value for now
            return 96.0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "CompositingQuality", {
        get: function () {
            // There is no support for CompositingQuality in CoreGraphics.
            // Instead of throwing a NotImplementedException we will just let
            // things fall through when setting and return Default always.
            return _drawing2D_CompositingQuality__WEBPACK_IMPORTED_MODULE_18__.CompositingQuality.Default;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsBase.prototype, "isVisibleClipEmpty", {
        get: function () {
            return this.Clip.isEmpty(this);
        },
        enumerable: false,
        configurable: true
    });
    GraphicsBase.prototype.translateClip = function (dx, dy) {
        if (this.clip != null) {
            this.Clip.translate(dx, dy);
            this.setClip(this.Clip, _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Replace);
        }
    };
    GraphicsBase.prototype.resetClip = function () {
        this.resetNativeClip();
        this.clip = undefined;
    };
    GraphicsBase.prototype.resetNativeClip = function () {
        this.LastPen = undefined;
        this.LastBrush = undefined;
        //Unlike the current path, the current clipping path is part of the graphics state.
        //Therefore, to re-enlarge the paintable area by restoring the clipping path to a
        //prior state, you must save the graphics state before you clip and restore the graphics
        //state after youve completed any clipped drawing.
        this.renderer.restoreState();
        this.renderer.saveState();
        this.modelViewMatrix.reset();
        this.applyModelgetView();
    };
    GraphicsBase.prototype.excludeClip = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.setClip(args[0], _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Exclude);
    };
    GraphicsBase.prototype.intersectClip = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.setClip(args[0], _drawing2D_CombineMode__WEBPACK_IMPORTED_MODULE_16__.CombineMode.Intersect);
    };
    GraphicsBase.prototype.clear = function (color) {
        if (color == null) {
            this.renderer.clearRect(this.renderer.getClipBoundingBox());
        }
        else {
            this.renderer.saveState();
            //context.SetFillColorWithColor(new CGColor(color.R / 255f, color.G / 255f, color.B / 255f, color.A / 255f));
            this.renderer.setFillColor(color);
            this.renderer.fillRect(this.renderer.getClipBoundingBox());
            this.renderer.restoreState();
        }
    };
    GraphicsBase.prototype.restore = function (gstate) {
        //LastPen = gstate.lastPen;
        //LastBrush = gstate.lastBrush;
        if (gstate) {
            this.modelMatrix = gstate.model;
            this.viewMatrix = gstate.view;
            this.renderingOrigin = gstate.renderingOrigin;
            this.graphicsUnit = gstate.pageUnit;
            this.pageScale = gstate.pageScale;
            this.SmoothingMode = gstate.smoothingMode;
            this.clip = gstate.clipRegion;
            this.applyModelgetView();
        }
        this.renderer.restoreState();
    };
    GraphicsBase.prototype.save = function () {
        var currentState = new _drawing2D_GraphicsState__WEBPACK_IMPORTED_MODULE_19__.GraphicsState();
        //currentState.lastPen = LastPen;
        //currentState.lastBrush = LastBrush;
        // Make sure we clone the Matrices or we will still modify
        // them after the save as they are the same objects.  Woops!!
        currentState.model = this.modelMatrix.clone();
        currentState.view = this.viewMatrix.clone();
        currentState.renderingOrigin = this.renderingOrigin;
        currentState.pageUnit = this.graphicsUnit;
        currentState.pageScale = this.pageScale;
        currentState.smoothingMode = this.smoothingMode;
        currentState.clipRegion = (this.clip == null ? undefined : this.clip.clone());
        this.renderer.saveState();
        return currentState;
    };
    GraphicsBase.prototype.drawClosedCurve = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 2) {
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(args[0]));
            }
            if (args[1] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(args[1]));
            }
            this.drawClosedCurve(args[0], args[1], 0.5, _drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__.FillMode.Winding);
        }
        else if (args.length === 4) {
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(args[0]));
            }
            if (args[1] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(args[1]));
            }
            var count = args[1].length;
            if (count === 2) {
                this.drawPolygon(args[0], args[1]);
            }
            else {
                var segments = (count > 3) ? (count - 1) : (count - 2);
                var tangents = _GeomUtilities__WEBPACK_IMPORTED_MODULE_14__.GeomUtilities.GetCurveTangents(_drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_13__.CURVE_MIN_TERMS, args[1], count, args[2], _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_13__.CurveType.Close);
                this.preparePen(args[0]);
                this.makeCurve(args[1], tangents, 0, segments, _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_13__.CurveType.Close);
                this.strokePen(args[0]);
            }
        }
    };
    GraphicsBase.prototype.fillClosedCurve = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 2) {
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(args[0]));
            }
            if (args[1] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(args[1]));
            }
            this.fillClosedCurve(args[0], args[1], _drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__.FillMode.Alternate, 0.5);
        }
        else if (args.length === 4) {
            args[3] = args[3] == null ? 0.5 : args[3];
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(args[0]));
            }
            if (args[1] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(args[1]));
            }
            var count = args[1].length;
            if (count === 2)
                this.fillPolygon(args[0], args[1], _drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__.FillMode.Alternate);
            else {
                var segments = (count > 3) ? (count - 1) : (count - 2);
                var tangents = _GeomUtilities__WEBPACK_IMPORTED_MODULE_14__.GeomUtilities.GetCurveTangents(_drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_13__.CURVE_MIN_TERMS, args[1], count, args[3], _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_13__.CurveType.Close);
                this.makeCurve(args[1], tangents, 0, segments, _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_13__.CurveType.Close);
                this.fillBrush(args[0]);
            }
        }
    };
    GraphicsBase.prototype.drawPie = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var pen = args[0];
        if (pen == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
        }
        if (args.length === 4) {
            this.drawPie(pen, args[1].X, args[1].Y, args[1].Width, args[1].Height, args[2], args[3]);
        }
        else if (args.length === 7) {
            this.preparePen(pen);
            this.renderer.beginPath();
            this.drawEllipticalArc(args[1], args[2], args[3], args[4], args[5], args[6], true);
            this.strokePen(pen);
        }
    };
    GraphicsBase.radians = function (degrees) {
        return degrees * Math.PI / 180;
    };
    GraphicsBase.prototype.fillPie = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var brush = args[0];
        if (brush == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(brush));
        }
        if (args.length === 4) {
            this.renderer.beginPath();
            this.drawEllipticalArc(args[1], args[2], args[3], true);
            this.fillBrush(brush);
        }
        else if (args.length === 7) {
            this.renderer.beginPath();
            this.drawEllipticalArc(args[1], args[2], args[3], args[4], args[5], args[6], true);
            this.fillBrush(brush);
        }
    };
    GraphicsBase.prototype.polygonSetup = function (points) {
        if (points == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(points));
        }
        if (points.length < 2) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException("Needs at least two points");
        }
        this.renderer.beginPath();
        this.moveTo(points[0]);
        for (var i = 0; i < points.length - 0; i++) {
            this.lineTo(points[i]);
        }
        this.renderer.closePath();
    };
    GraphicsBase.prototype.drawPolygon = function (pen, points) {
        if (pen == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
        }
        this.preparePen(pen);
        this.polygonSetup(points);
        this.renderer.closePath();
        this.strokePen(pen);
    };
    GraphicsBase.prototype.fillPolygon = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var brush = args[0];
        var points = args[1];
        if (brush == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(brush));
        }
        if (points == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(points));
        }
        if (args.length === 2) {
            this.fillPolygon(brush, points, _drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__.FillMode.Alternate);
        }
        else if (args.length === 3) {
            this.polygonSetup(points);
            this.fillBrush(brush, args[2]);
        }
    };
    GraphicsBase.prototype.drawRectangles = function (pen, rects) {
        var _this = this;
        if (pen == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pen));
        }
        if (rects == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(rects));
        }
        this.preparePen(pen);
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.foreach)(rects, function (rect) {
            _this.rectanglePath(rect.X, rect.Y, rect.Right, rect.Bottom);
        });
        this.strokePen(pen);
    };
    GraphicsBase.prototype.fillRectangles = function (brush, rects) {
        var _this = this;
        if (brush == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(brush));
        }
        if (rects == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(rects));
        }
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.foreach)(rects, function (rect) {
            _this.rectanglePath(rect.X, rect.Y, rect.Right, rect.Bottom);
        });
        this.fillBrush(brush);
    };
    GraphicsBase.prototype.flush = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 0) {
            this.flush(_drawing2D_FlushIntention__WEBPACK_IMPORTED_MODULE_20__.FlushIntention.Flush);
        }
        else if (args.length === 1) {
            if (this.renderer == null) {
                return;
            }
            this.renderer.synchronize();
        }
    };
    GraphicsBase.prototype.isVisible = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle)) {
            return this.Clip.isVisible(args[0]);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint)) {
            return this.Clip.isVisible(args[0]);
        }
        else if (args.length === 2) {
            return this.Clip.isVisible(args[0], args[1]);
        }
        else if (args.length === 4) {
            return this.isVisible(new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle(args[0], args[1], args[2], args[3]));
        }
        return false;
    };
    GraphicsBase.prototype.multiplyTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.multiplyTransform(args[0], _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_7__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(args[0]));
            }
            //if (args[1] === MatrixOrder.Prepend) {
            this.renderer.concatCTM(args[0].transform);
            //}
            //else {
            //   this.context.concatCTM(args[0].transform);
            //}
        }
    };
    GraphicsBase.prototype.transformPoints = function (destSpace, srcSpace, pts) {
        if (pts == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.nameof)(pts));
        }
        var transform = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.newOutEmpty)();
        transform.value = new _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_7__.Matrix();
        _ConversionHelpers__WEBPACK_IMPORTED_MODULE_11__.ConversionHelpers.GetGraphicsTransform(this, destSpace, srcSpace, transform);
        transform.value.transformPoints(pts);
    };
    GraphicsBase.prototype.drawEllipticalArc = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 4) {
            GraphicsBase_1.make_arcs(this.renderer, args[0].X, args[0].Y, args[0].Width, args[0].Height, args[1], args[2], false, true, args[3]);
        }
        else if (args.length === 7) {
            GraphicsBase_1.make_arcs(this.renderer, args[0], args[1], args[2], args[3], args[4], args[5], false, true, args[6]);
        }
    };
    GraphicsBase.make_arc = function (graphics, start, x, y, width, height, startAngle, endAngle, antialiasing, isPieSlice) {
        var delta, bcp;
        var sin_alpha, sin_beta, cos_alpha, cos_beta;
        var PI = Math.PI;
        var rx = width / 2;
        var ry = height / 2;
        /* center */
        var cx = x + rx;
        var cy = y + ry;
        /* angles in radians */
        var alpha = startAngle * PI / 180;
        var beta = endAngle * PI / 180;
        /* adjust angles for ellipses */
        alpha = Math.atan2(rx * Math.sin(alpha), ry * Math.cos(alpha));
        beta = Math.atan2(rx * Math.sin(beta), ry * Math.cos(beta));
        if (Math.abs(beta - alpha) > PI) {
            if (beta > alpha)
                beta -= 2 * PI;
            else
                alpha -= 2 * PI;
        }
        delta = beta - alpha;
        bcp = (4.0 / 3.0 * (1 - Math.cos(delta / 2)) / Math.sin(delta / 2));
        sin_alpha = Math.sin(alpha);
        sin_beta = Math.sin(beta);
        cos_alpha = Math.cos(alpha);
        cos_beta = Math.cos(beta);
        /* don't move to starting point if we're continuing an existing curve */
        if (start) {
            /* starting point */
            var sx = cx + rx * cos_alpha;
            var sy = cy + ry * sin_alpha;
            if (isPieSlice)
                graphics.addLineToPoint(sx, sy);
            else
                graphics.moveTo(sx, sy);
        }
        graphics.addCurveToPoint(cx + rx * (cos_alpha - bcp * sin_alpha), cy + ry * (sin_alpha + bcp * cos_alpha), cx + rx * (cos_beta + bcp * sin_beta), cy + ry * (sin_beta - bcp * cos_beta), cx + rx * cos_beta, cy + ry * sin_beta);
    };
    GraphicsBase.make_arcs = function (graphics, x, y, width, height, startAngle, sweepAngle, convert_units, antialiasing, isPieSlice) {
        var i;
        var drawn = 0;
        var endAngle;
        var enough = false;
        // I do not think we need to convert the units so commented this out.
        /* if required deal, once and for all, with unit conversions */
        //if (convert_units && !OPTIMIZE_CONVERSION(graphics))
        //{
        //    x = gdip_unitx_convgr(graphics, x);
        //    y = gdip_unity_convgr(graphics, y);
        //    width = gdip_unitx_convgr(graphics, width);
        //    height = gdip_unity_convgr(graphics, height);
        //}
        if (Math.abs(sweepAngle) >= 360) {
            graphics.addEllipseInRect(new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle(x, y, width, height));
            return;
        }
        endAngle = startAngle + sweepAngle;
        /* if we end before the start then reverse positions (to keep increment positive) */
        if (endAngle < startAngle) {
            var temp = endAngle;
            endAngle = startAngle;
            startAngle = temp;
        }
        if (isPieSlice) {
            graphics.moveTo(x + (width / 2), y + (height / 2));
        }
        /* i is the number of sub-arcs drawn, each sub-arc can be at most 90 degrees.*/
        /* there can be no more then 4 subarcs, ie. 90 + 90 + 90 + (something less than 90) */
        for (i = 0; i < 4; i++) {
            var current = startAngle + drawn;
            var additional = void 0;
            if (enough) {
                if (isPieSlice) {
                    graphics.closePath();
                }
                return;
            }
            additional = endAngle - current; /* otherwise, add the remainder */
            if (additional > 90) {
                additional = 90.0;
            }
            else {
                /* a near zero value will introduce bad artefact in the drawing (#78999) */
                if ((additional >= -0.0001) && (additional <= 0.0001)) {
                    return;
                }
                enough = true;
            }
            this.make_arc(graphics, (i === 0), /* only move to the starting pt in the 1st iteration */ x, y, width, height, /* bounding rectangle */ current, current + additional, antialiasing, isPieSlice);
            drawn += additional;
        }
        if (isPieSlice) {
            graphics.closePath();
        }
    };
    GraphicsBase.prototype.measureCharacterRanges = function (text, font, layoutRect, stringFormat) {
        if ((text == null) || (text.length === 0))
            return new Array(0);
        if (font == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("font");
        }
        if (stringFormat == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException("stringFormat");
        }
        // TODO:
        // FIXME TODO:
        var n = stringFormat.measurableCharacterRanges != null ? stringFormat.measurableCharacterRanges.length : 0;
        var regions = new Array(n);
        for (var i = 0; i < n; ++i)
            regions[i] = new _Region__WEBPACK_IMPORTED_MODULE_9__.Region(); //layoutRect);
        return regions;
    };
    GraphicsBase.prototype.MeasureString = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 2) {
            var textMetrics = this.measureStringEx(args[0], args[1]);
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGSize(textMetrics.width, textMetrics.height);
        }
        else if (args.length === 4) {
            var textMetrics = this.measureStringEx(args[0], args[1]);
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGSize(textMetrics.width, textMetrics.height);
        }
        else if (args.length === 6) {
            var text = args[0];
            var font = args[1];
            var area = args[2];
            var format = args[3];
            var charactersFitted = args[4];
            var linesFilled = args[5];
            var defaultStyle = {
                breakWords: false,
                fontFamily: font.Name,
                fontSize: font.Size,
                fontStyle: font.Style === _FontStyle__WEBPACK_IMPORTED_MODULE_30__.FontStyle.Italic ? 'italic' : '',
                fontVariant: 'normal',
                fontWeight: 900,
                wordWrap: true,
                wordWrapWidth: area.Width,
                letterSpacing: 4,
            };
            var textMetrics = _Text_TextMetrics__WEBPACK_IMPORTED_MODULE_2__.TextMetrics.measureText(text, new _Text_TextStyle__WEBPACK_IMPORTED_MODULE_31__.TextStyle(defaultStyle));
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGSize(textMetrics.width, textMetrics.height);
        }
        else {
            //console.warn("NotImplementedException('Graphics.measureString not implemented.')");
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.NotImplementedException('Graphics.measureString not implemented.');
        }
        // return new CGSize(1, 1);
    };
    GraphicsBase.prototype.drawString = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 5 && typeof args[3] === 'number' && typeof args[4] === 'number') {
            var s = args[0];
            var font = args[1];
            var brush = args[2];
            var x = args[3];
            var y = args[4];
            font.setup(this.renderer);
            brush.setup(this, true);
            this.renderer.showText(s, x, y);
            return;
        }
        else if (args.length === 6 && typeof args[3] === 'number' && typeof args[4] === 'number' && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[5], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.StringFormat)) {
            var s = args[0];
            var font = args[1];
            var brush = args[2];
            var x = args[3];
            var y = args[4];
            var format = args[5];
            font.setup(this.renderer);
            brush.setup(this, true);
            if (format.FormatFlags & _StringFormatFlags__WEBPACK_IMPORTED_MODULE_24__.StringFormatFlags.DirectionVertical) {
                this.translateTransform(x + font.Size, y);
                this.rotateTransform(90 * Math.PI / 180);
            }
            else {
                this.translateTransform(x, y);
            }
            if (format.Alignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Near) {
                this.renderer.setTextAlign('start');
            }
            else if (format.Alignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Center) {
                this.renderer.setTextAlign('center');
            }
            else if (format.Alignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Far) {
                this.renderer.setTextAlign('right');
            }
            if (format.LineAlignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Near) {
                this.renderer.setTextBaseline('top');
            }
            else if (format.LineAlignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Center) {
                this.renderer.setTextBaseline('middle');
            }
            else if (format.LineAlignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Far) {
                this.renderer.setTextBaseline('bottom');
            }
            this.renderer.showText(s, 0, 0);
            if (format.FormatFlags & _StringFormatFlags__WEBPACK_IMPORTED_MODULE_24__.StringFormatFlags.DirectionVertical) {
                this.rotateTransform(-90 * Math.PI / 180);
                this.translateTransform(-(x + font.Size), -y);
            }
            else {
                this.translateTransform(-x, -y);
            }
        }
        else if (args.length === 5 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[3], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint)) {
            var s = args[0];
            var font = args[1];
            var brush = args[2];
            var point = args[3];
            var format = args[4];
        }
        if (args.length === 5 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[3], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle)) {
            var s = args[0];
            var font = args[1];
            var brush = args[2];
            var rect = args[3];
            var format = args[4];
            var x = 0, y = 0;
            font.setup(this.renderer);
            brush.setup(this, true);
            if (format.Alignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Near) {
                this.renderer.setTextAlign('start');
                x = rect.X1;
            }
            else if (format.Alignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Center) {
                this.renderer.setTextAlign('center');
                x = rect.X1 + rect.Width / 2;
            }
            else if (format.Alignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Far) {
                this.renderer.setTextAlign('right');
                x = rect.X2;
            }
            if (format.LineAlignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Near) {
                this.renderer.setTextBaseline('top');
                y = rect.Y1;
            }
            else if (format.LineAlignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Center) {
                this.renderer.setTextBaseline('middle');
                y = rect.Y1 + rect.Height / 2;
            }
            else if (format.LineAlignment === _StringAlignment__WEBPACK_IMPORTED_MODULE_26__.StringAlignment.Far) {
                this.renderer.setTextBaseline('bottom');
                y = rect.Y2;
            }
            this.renderer.showText(s, x, y);
        }
        else if (args.length === 6) {
        }
        else {
            var s = args[0];
            var font = args[1];
            var brush = args[2];
            var rect = args[3];
            font.setup(this.renderer);
            brush.setup(this, true);
            this.renderer.showText(s, rect.X, rect.Y);
        }
    };
    GraphicsBase.prototype.DrawImage = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Image) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle)) {
            var image = args[0];
            var rect = args[1];
            if (image == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("image");
            var status_1 = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.GdipDrawImageRect(this.nativeObject, image.NativeObject, rect.X, rect.Y, rect.Width, rect.Height);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.CheckStatus(status_1);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Image) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGPoint)) {
            var image = args[0];
            var point = args[1];
            if (image == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("image");
            var status_2 = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.GdipDrawImage(this.nativeObject, image.NativeObject, point.X, point.Y);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.CheckStatus(status_2);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Image) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.array(args[1])) {
            var image = args[0];
            var destPoints = args[1];
            if (image == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("image");
            if (destPoints == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("destPoints");
            var status_3 = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.GdipDrawImagePoints(this.nativeObject, image.NativeObject, destPoints, destPoints.length);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.CheckStatus(status_3);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Image) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.int(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.int(args[2])) {
            var image = args[0];
            var x = args[1];
            var y = args[2];
            if (image == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("image");
            var status_4 = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.GdipDrawImageI(this.nativeObject, image.NativeObject, x, y);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.CheckStatus(status_4);
        }
        else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Image) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[2], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.int(args[3])) {
            var image = args[0];
            var destRect = args[1];
            var srcRect = args[2];
            var srcUnit = args[3];
            if (image == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("image");
            var status_5 = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.GdipDrawImageRectRect(this.nativeObject, image.NativeObject, destRect.X, destRect.Y, destRect.Width, destRect.Height, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, _tuval_core__WEBPACK_IMPORTED_MODULE_8__.IntPtr.Zero, null, _tuval_core__WEBPACK_IMPORTED_MODULE_8__.IntPtr.Zero);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.CheckStatus(status_5);
        }
        else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Image) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.array(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[2], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.int(args[3])) {
            var image = args[0];
            var destPoints = args[1];
            var srcRect = args[2];
            var srcUnit = args[3];
            if (image == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("image");
            if (destPoints == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("destPoints");
            var status_6 = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.GdipDrawImagePointsRect(this.nativeObject, image.NativeObject, destPoints, destPoints.length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, _tuval_core__WEBPACK_IMPORTED_MODULE_8__.IntPtr.Zero, null, _tuval_core__WEBPACK_IMPORTED_MODULE_8__.IntPtr.Zero);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.CheckStatus(status_6);
        }
        else if (args.length === 5 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Image) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.array(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[2], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGRectangle) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.int(args[3]) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[4], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Imaging.ImageAttributes)) {
            var image = args[0];
            var destPoints = args[1];
            var srcRect = args[2];
            var srcUnit = args[3];
            var imageAttr = args[4];
            if (image == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("image");
            if (destPoints == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("destPoints");
            var status_7 = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.GdipDrawImagePointsRect(this.nativeObject, image.NativeObject, destPoints, destPoints.length, srcRect.X, srcRect.Y, srcRect.Width, srcRect.Height, srcUnit, imageAttr != null ? imageAttr.NativeObject : _tuval_core__WEBPACK_IMPORTED_MODULE_8__.IntPtr.Zero, null, _tuval_core__WEBPACK_IMPORTED_MODULE_8__.IntPtr.Zero);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.CheckStatus(status_7);
        }
        else if (args.length === 5 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Image) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.int(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.int(args[2])) {
            var image = args[0];
            var x = args[1];
            var y = args[2];
            var width = args[3];
            var height = args[4];
            if (image == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("image");
            var status_8 = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.GdipDrawImageRect(this.nativeObject, image.NativeObject, x, y, width, height);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.CheckStatus(status_8);
        }
    };
    /*  public drawSketch(sketchShape: (...args: any[]) => any, x: float, y: float, width: float, height: float): void {
         if ((<any>sketchShape).pIns == null) {

             if (sketchShape.prototype.setup == null && (<any>sketchShape).setup == null) {
                 sketchShape.prototype.setup = function () {
                     this.createCanvas(width, height);
                 }
             }

             sketchShape.prototype.x = x;
             sketchShape.prototype.y = y;
             sketchShape.prototype.width = width;
             sketchShape.prototype.height = height;
             sketchShape.prototype.mouseX = 0;
             sketchShape.prototype.mouseY = 0;

             var sketchInstance = new (<any>sketchShape)();

             window.addEventListener('mousemove', function (evt: MouseEvent) {
                 if (evt.offsetX < sketchShape.prototype.x) {
                     sketchShape.prototype.mouseX = 0;
                 } else if (evt.offsetX > x && evt.offsetX < x + width) {
                     sketchShape.prototype.mouseX = evt.offsetX - x;
                 }

                 if (evt.offsetY < sketchShape.prototype.y) {
                     sketchShape.prototype.mouseY = 0;
                 } else if (evt.offsetY > y && evt.offsetY < y + height) {
                     sketchShape.prototype.mouseY = evt.offsetY - y;
                 }


             });

             window.addEventListener('mousedown', function (evt: MouseEvent) {
                 if ((evt.offsetX > x && evt.offsetX < x + width) && (evt.offsetY > y && evt.offsetY < y + height)) {
                     if (sketchInstance.mousePressed != null) {
                         sketchInstance.mousePressed();
                     }
                 }

             });

              var ss = new Sketch(sketchInstance);
             (<any>sketchShape).pIns = ss;
         }
         var image = new Tuval.Image((<any>sketchShape).pIns.drawingContext);
         this.drawImage(image, x, y);
     } */
    /*  public background(color: number): void;
     public background(r: number, g: number, b: number): void;
     public background(color: string): void;
     public background(color: Color): void;
     public background(brush: Brush): void;
     public background(...args: any[]): void { }

     public fill(color: number): void;
     public fill(r: number, g: number, b: number): void;
     public fill(color: string): void;
     public fill(color: Color): void;
     public fill(brush: Brush): void;
     public fill(...args: any[]): void { }

     public stroke(color: number): void;
     public stroke(r: number, g: number, b: number): void;
     public stroke(color: string): void;
     public stroke(color: Color): void;
     public stroke(pen: Pen): void;
     public stroke(...args: any[]): void { }
     public noStroke(): void { }
     public strokeWeight(weight: number): void { }

     public line(x: number, y: number, x1: number, y1: number): void;
     public line(p1: PointF, p2: PointF): void;
     public line(...args: any[]): void { }

     public rect(x: number, y: number, w: number, h: number): void;
     public rect(x: number, y: number, w: number, h: number, tl?: number, tr?: number, br?: number, bl?: number): void;
     public rect(x: number, y: number, w: number, h: number, detailX?: number, detailY?: number): void;
     public rect(...args: any[]): void { }

     public ellipse(x: number, y: number, w: number, h: number): void;
     public ellipse(...args: any[]): void { }
     public lerpColor(c1: Color, c2: Color, amt: float): Color { return undefined; }

     public animate(animFunc: Function) { }


     public toRadians(angle: number): number { return undefined; } */
    GraphicsBase.prototype.drawImageBitmap = function (image, x, y) {
        this.renderer.drawImageBitmap(image, x, y);
    };
    GraphicsBase.prototype.createRectangle = function (x, y, width, height) {
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle(x, y, width, height);
    };
    GraphicsBase.prototype.createColor = function (r, g, b) {
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGColor(_tuval_core__WEBPACK_IMPORTED_MODULE_8__.Convert.ToByte(r), _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Convert.ToByte(g), _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Convert.ToByte(b));
    };
    GraphicsBase.prototype.createSolidBrush = function (r, g, b) {
        return new _SolidBrush__WEBPACK_IMPORTED_MODULE_27__.SolidBrush(new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGColor(_tuval_core__WEBPACK_IMPORTED_MODULE_8__.Convert.ToByte(r), _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Convert.ToByte(g), _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Convert.ToByte(b)));
    };
    GraphicsBase.prototype.createPen = function (r, g, b, size) {
        if (size === void 0) { size = 1; }
        return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGColor(_tuval_core__WEBPACK_IMPORTED_MODULE_8__.Convert.ToByte(r), _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Convert.ToByte(g), _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Convert.ToByte(b)), size);
    };
    var GraphicsBase_1;
    GraphicsBase.infiniteRegion = new _Region__WEBPACK_IMPORTED_MODULE_9__.Region();
    GraphicsBase.maxSize = new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGSize(Number.MAX_VALUE, Number.MAX_VALUE);
    GraphicsBase.DrawStringCacheCapacity = 2000;
    GraphicsBase.DrawStringCache = new _DrawStringCache__WEBPACK_IMPORTED_MODULE_23__.DrawStringCache(GraphicsBase_1.DrawStringCacheCapacity);
    GraphicsBase.MeasureStringCache = new _MeasureStringCache__WEBPACK_IMPORTED_MODULE_10__.MeasureStringCache(GraphicsBase_1.DrawStringCacheCapacity);
    GraphicsBase = GraphicsBase_1 = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.GraphicsBase,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.GraphicsBase
            ]
        }),
        __metadata("design:paramtypes", [])
    ], GraphicsBase);
    return GraphicsBase;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_8__.TObject));

var CanvasGraphics = /** @class */ (function (_super) {
    __extends(CanvasGraphics, _super);
    function CanvasGraphics() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this.m_canvasElement = undefined;
        _this.isFlipped = true;
        _this.screenScale = 1;
        function setupCanvas(canvasElement, left, top, width, height, pixelSize) {
            if (pixelSize === void 0) { pixelSize = 1; }
            if (!_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.workerContext()) {
                canvasElement.style.width = width * pixelSize + "px";
                canvasElement.style.height = height * pixelSize + "px";
                canvasElement.style.padding = '0';
                //canvasElement.style.margin = 'auto';
                canvasElement.style.border = '0';
                canvasElement.style.background = 'transparent';
                canvasElement.style.position = 'absolute';
                canvasElement.style.top = top + "px";
                canvasElement.style.left = left + "px";
                canvasElement.style.bottom = "0px";
                canvasElement.style.right = "0px";
            }
            canvasElement.width = width;
            canvasElement.height = height;
        }
        if (args.length === 0) { //Auto Size
            var eventBus = _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Context.Current.get('eventBus');
            var env = _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Context.Current.get('envoriment');
            _this.m_canvasElement = (0,_createCanvasElement__WEBPACK_IMPORTED_MODULE_22__.createCanvasElement)();
            setupCanvas(_this.m_canvasElement, 0, 0, env.WindowWidth, env.WindowHeight, 1);
            if (!_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.workerContext() && document && document.body) {
                document.body.appendChild(_this.m_canvasElement);
            }
            var context = (0,_createCanvasElement__WEBPACK_IMPORTED_MODULE_22__.get2DCanvasContext)(_this.m_canvasElement);
            var rendererContext = _this.provideRenderer2D(context);
            _this.nativeObject = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GraphicsHandleTable.Default.CreateHandle(rendererContext);
            _this.initializeContext(rendererContext);
            _this.width = env.WindowWidth;
            _this.height = env.WindowHeight;
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is["typeof"](args[0], _tuval_core__WEBPACK_IMPORTED_MODULE_8__.System.Types.IntPtr)) {
            if (_GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GraphicsHandleTable.Default.ContainsKey(args[0])) {
                _this.nativeObject = args[0];
                var rendererContexty = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GraphicsHandleTable.Default.GetGraphics(_this.nativeObject);
                _this.initializeContext(rendererContexty);
            }
        }
        else if (args.length === 1) {
            if (args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGContext2D) {
                _this.m_canvasElement = args[0].drawingContext.canvas;
                _this.initializeContext(args[0]);
            }
            else {
                _this.m_canvasElement = args[0].canvas;
                _this.width = _this.m_canvasElement.width;
                _this.height = _this.m_canvasElement.height;
                var rendererContext = _this.provideRenderer2D(args[0]);
                _this.nativeObject = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GraphicsHandleTable.Default.CreateHandle(rendererContext);
                _this.initializeContext(rendererContext);
            }
        }
        else if (args.length === 2 && typeof args[0] === 'number' && typeof args[1] === 'number') {
            _this.m_canvasElement = (0,_createCanvasElement__WEBPACK_IMPORTED_MODULE_22__.createCanvasElement)();
            setupCanvas(_this.m_canvasElement, 0, 0, args[0], args[1], 1);
            if (!_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.workerContext() && document && document.body) {
                document.body.appendChild(_this.m_canvasElement);
            }
            var context = (0,_createCanvasElement__WEBPACK_IMPORTED_MODULE_22__.get2DCanvasContext)(_this.m_canvasElement);
            var rendererContext = _this.provideRenderer2D(context);
            _this.nativeObject = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GraphicsHandleTable.Default.CreateHandle(rendererContext);
            _this.initializeContext(rendererContext);
            _this.width = args[0];
            _this.height = args[1];
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.number(args[2])) {
            var width = args[0];
            var height = args[1];
            var pixelSize = args[2];
            _this.m_canvasElement = (0,_createCanvasElement__WEBPACK_IMPORTED_MODULE_22__.createCanvasElement)();
            setupCanvas(_this.m_canvasElement, 0, 0, width, height, pixelSize);
            if (!_tuval_core__WEBPACK_IMPORTED_MODULE_8__.is.workerContext() && document && document.body) {
                document.body.appendChild(_this.m_canvasElement);
            }
            var context = (0,_createCanvasElement__WEBPACK_IMPORTED_MODULE_22__.get2DCanvasContext)(_this.m_canvasElement);
            var rendererContext = _this.provideRenderer2D(context);
            _this.nativeObject = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GraphicsHandleTable.Default.CreateHandle(rendererContext);
            _this.initializeContext(rendererContext);
            _this.width = args[0];
            _this.height = args[1];
        }
        else if (args.length === 2 && typeof args[1] === 'boolean') {
            _this.isFlipped = args[1];
            if (args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGContext2D) {
                _this.initializeContext(args[0]);
            }
            else {
                _this.initializeContext(_this.provideRenderer2D(args[0]));
            }
        }
        else if (args.length === 4) {
            _this.m_canvasElement = (0,_createCanvasElement__WEBPACK_IMPORTED_MODULE_22__.createCanvasElement)();
            setupCanvas(_this.m_canvasElement, args[0], args[1], args[2], args[3], 1);
            if (document && document.body) {
                document.body.appendChild(_this.m_canvasElement);
            }
            var context = (0,_createCanvasElement__WEBPACK_IMPORTED_MODULE_22__.get2DCanvasContext)(_this.m_canvasElement);
            var rendererContext = _this.provideRenderer2D(context);
            _this.nativeObject = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GraphicsHandleTable.Default.CreateHandle(rendererContext);
            _this.initializeContext(rendererContext);
            _this.x = args[0];
            _this.y = args[1];
            _this.width = args[2];
            _this.height = args[3];
        }
        _this.init();
        return _this;
    }
    CanvasGraphics.prototype.setSize = function (width, height) {
        this.m_canvasElement.width = width;
        this.m_canvasElement.height = height;
        _super.prototype.setSize.call(this, width, height);
    };
    CanvasGraphics.prototype.init = function () {
    };
    CanvasGraphics.prototype.getContext = function () {
        return this.m_canvasElement.getContext('2d');
    };
    CanvasGraphics.prototype.getCanvas = function () {
        return this.m_canvasElement;
    };
    CanvasGraphics.prototype.getCSSValue = function (element, property) {
        return document.defaultView.getComputedStyle(element, null).getPropertyValue(property);
    };
    CanvasGraphics.prototype.measureStringEx = function (textstring, font) {
        var metrics = {};
        var self = this;
        var fontFamily;
        var fontSize;
        if (font == null) {
            fontFamily = this.getCSSValue(self.getCanvas(), "font-family");
            fontSize = parseFloat(this.getCSSValue(self.getCanvas(), "font-size").replace("pt", ""));
            metrics.width = self.renderer.measureText(textstring, new _Font__WEBPACK_IMPORTED_MODULE_21__.Font(fontFamily, fontSize)).Width;
        }
        else {
            metrics.width = self.renderer.measureText(textstring, font).Width;
            fontFamily = font.Name;
            fontSize = font.Size;
        }
        var isSpace = !(/\S/.test(textstring));
        metrics.fontSize = fontSize;
        // for text lead values, we meaure a multiline text container.
        leadDiv.style.position = "absolute";
        leadDiv.style.opacity = '0';
        leadDiv.style.font = fontSize + "pt " + fontFamily;
        leadDiv.innerHTML = textstring + "<br/>" + textstring;
        // make some initial guess at the text leading (using the standard TeX ratio)
        metrics.leading = 1.2 * metrics.fontSize;
        // then we try to get the real value from the browser
        var leadDivHeight = parseFloat(this.getCSSValue(leadDiv, "height").replace("pt", ""));
        if (leadDivHeight >= metrics.fontSize * 2) {
            metrics.leading = (leadDivHeight / 2) | 0;
        }
        // document.body.removeChild(leadDiv);
        // if we're not dealing with white space, we can compute metrics
        if (!isSpace) {
            // Have characters, so measure the text
            var padding = 100;
            __canvas.width = metrics.width + padding;
            __canvas.height = 3 * metrics.fontSize;
            __canvas.style.opacity = '1';
            __canvas.style.fontFamily = fontFamily;
            __canvas.style.fontSize = fontSize + 'pt';
            var ctx = __canvas.getContext("2d");
            ctx.font = fontSize + "pt " + fontFamily;
            var w = __canvas.width, h = __canvas.height, baseline = h / 2;
            // Set all canvas pixeldata values to 255, with all the content
            // data being 0. This lets us scan for data[i] != 255.
            ctx.fillStyle = "white";
            ctx.fillRect(-1, -1, w + 2, h + 2);
            ctx.fillStyle = "black";
            ctx.fillText(textstring, padding / 2, baseline);
            var pixelData = ctx.getImageData(0, 0, w, h).data;
            // canvas pixel data is w*4 by h*4, because R, G, B and A are separate,
            // consecutive values in the array, rather than stored as 32 bit ints.
            var i = 0, w4 = w * 4, len = pixelData.length;
            // Finding the ascent uses a normal, forward scanline
            while (++i < len && pixelData[i] === 255) { }
            var ascent = (i / w4) | 0;
            // Finding the descent uses a reverse scanline
            i = len - 1;
            while (--i > 0 && pixelData[i] === 255) { }
            var descent = (i / w4) | 0;
            // find the min-x coordinate
            for (i = 0; i < len && pixelData[i] === 255;) {
                i += w4;
                if (i >= len) {
                    i = (i - len) + 4;
                }
            }
            var minx = ((i % w4) / 4) | 0;
            // find the max-x coordinate
            var step = 1;
            for (i = len - 3; i >= 0 && pixelData[i] === 255;) {
                i -= w4;
                if (i < 0) {
                    i = (len - 3) - (step++) * 4;
                }
            }
            var maxx = ((i % w4) / 4) + 1 | 0;
            // set font metrics
            metrics.ascent = (baseline - ascent);
            metrics.descent = (descent - baseline);
            metrics.bounds = {
                minx: minx - (padding / 2),
                maxx: maxx - (padding / 2),
                miny: 0,
                maxy: descent - ascent
            };
            metrics.height = 1 + (descent - ascent);
        }
        // if we ARE dealing with whitespace, most values will just be zero.
        else {
            // Only whitespace, so we can't measure the text
            metrics.ascent = 0;
            metrics.descent = 0;
            metrics.bounds = {
                minx: 0,
                maxx: metrics.width,
                miny: 0,
                maxy: 0
            };
            metrics.height = 0;
        }
        return metrics;
    };
    CanvasGraphics.fromCurrentContext = function () {
        return new Graphics(undefined);
    };
    CanvasGraphics = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Graphics,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_25__.GraphicTypes.Graphics
            ]
        }),
        __metadata("design:paramtypes", [Object])
    ], CanvasGraphics);
    return CanvasGraphics;
}(GraphicsBase));

var Graphics = /** @class */ (function (_super) {
    __extends(Graphics, _super);
    function Graphics() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Graphics.FromImage = function (image) {
        var graphics = _tuval_core__WEBPACK_IMPORTED_MODULE_8__.New.Out();
        if (image == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException("image");
        if ((image.PixelFormat & _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_28__.PixelFormat.Indexed) != 0)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Exception(_tuval_core__WEBPACK_IMPORTED_MODULE_8__.Locale.GetText("Cannot create Graphics from an indexed bitmap."));
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.GdipGetImageGraphicsContext(image.nativeObject, graphics);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_29__.GDIPlus.CheckStatus(status);
        var result = new Graphics(graphics.value);
        /* if (GDIPlus.RunningOnUnix ()) {
            Rectangle rect  = new Rectangle (0,0, image.Width, image.Height);
            GDIPlus.GdipSetVisibleClip_linux (result.NativeObject, ref rect);
        } */
        return result;
    };
    Graphics.prototype.GetHdc = function () {
        return this.nativeObject;
    };
    Graphics.FromHwnd = function (handle) {
        if (handle == null) {
            throw 'Kernel object handle is null.';
        }
        var kernelObject = _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Runtime.GetKernelObject(handle);
        if (kernelObject != null && kernelObject.type === 'window') {
            if (kernelObject.hDC instanceof _tuval_core__WEBPACK_IMPORTED_MODULE_8__.IntPtr) {
                var contextObject = _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Runtime.GetKernelObject(kernelObject.hDC);
                if (contextObject != null && contextObject.context instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGContext2D) {
                    return new Graphics(contextObject.context);
                }
            }
            else {
                var canvasContext = _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Browser.CreateRenderingContext(kernelObject.nWidth, kernelObject.nHeight);
                kernelObject.GraphicsContext = new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGContext2D(canvasContext);
                return new Graphics(kernelObject.GraphicsContext);
            }
        }
        else if (kernelObject == null) {
            throw 'Kernel object not found for given handle.';
        }
        else {
            throw 'Kernel object not window for graphics context.';
        }
        throw 'Graphics object can not created.';
    };
    Graphics.prototype.ReleaseHdc = function () {
        throw new Error('Method not implemented.');
    };
    Graphics.prototype.init = function () {
    };
    Graphics.prototype.provideRenderer2D = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var canvasContext = args[0];
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGContext2D(canvasContext);
        }
        else {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('');
        }
    };
    Graphics.fromCurrentContext = function () {
        return new Graphics(undefined);
    };
    return Graphics;
}(CanvasGraphics));

var CommandGraphics = /** @class */ (function (_super) {
    __extends(CommandGraphics, _super);
    function CommandGraphics() {
        var _this = _super.call(this) || this;
        _this.renderer = _this.provideRenderer2D();
        _this.init();
        return _this;
    }
    CommandGraphics.prototype.measureStringEx = function (textstring, font) {
        throw new Error('Method not implemented.');
    };
    CommandGraphics.prototype.provideRenderer2D = function () {
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGCommandContext2D(null);
    };
    CommandGraphics.prototype.init = function () {
    };
    return CommandGraphics;
}(GraphicsBase));

var OffScreenGraphics = /** @class */ (function (_super) {
    __extends(OffScreenGraphics, _super);
    function OffScreenGraphics(width, height) {
        var _this = _super.call(this) || this;
        _this.m_OffScreenCanvas = null;
        _this.m_Context = null;
        _this.m_OffScreenCanvas = new OffscreenCanvas(width, height);
        _this.renderer = _this.provideRenderer2D(_this.m_OffScreenCanvas.getContext('2d'));
        return _this;
    }
    OffScreenGraphics.prototype.measureStringEx = function (textstring, font) {
        throw new Error('Method not implemented.');
    };
    OffScreenGraphics.prototype.provideRenderer2D = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var canvasContext = args[0];
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGContext2D(canvasContext);
        }
        else {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('');
        }
    };
    OffScreenGraphics.prototype.init = function () {
    };
    OffScreenGraphics.prototype.TrasferToImageBitmap = function () {
        return this.m_OffScreenCanvas.transferToImageBitmap();
    };
    return OffScreenGraphics;
}(GraphicsBase));

/*  (<any>document).getElementById = function (canvas: any) {
     let _canvas: HTMLCanvasElement
     if (typeof canvas === 'string') {
         _canvas = <HTMLCanvasElement>document.getElementById(canvas);
     } else {
         _canvas = canvas;
     }
     if (_canvas != null) {
         const context: CanvasRenderingContext2D = _canvas.getContext('2d');
         if (context != null) {
             return new Graphics(context);
         }
     }

 } */
/* console.log('registering createGraphics');
(<any>document).originalFunc = document.getElementById;
(<any>document).getElementById = function (elementId: string): HTMLElement {
    const element: HTMLElement = (<any>document).originalFunc(elementId);
    if (element && element.tagName === 'DIV') {
        (<any>element).createGraphics = function (): Graphics {
            const canvas = createCanvasElement();
            if (element && element.clientWidth && element.clientHeight) {
                canvas.setAttribute('width', element.clientWidth + 'px');
                canvas.setAttribute('height', element.clientHeight + 'px');
            } else {
                canvas.setAttribute('width', '200px');
                canvas.setAttribute('height', '200px');
            }

            element.appendChild(canvas);
            return new Graphics(get2DCanvasContext(canvas));
        }
    }
    return element;

}; */
/* (<any>document).originalCreateElementFunc = document.createElement;
(<any>document).createElement = function (tagName: string): HTMLElement {
    const element: HTMLElement = (<any>document).originalCreateElementFunc(tagName);
    if (element && element.tagName === 'DIV' || element.tagName === 'div') {
        (<any>element).createGraphics = function (): Graphics {
            const canvas = createCanvasElement();
            if (element && element.clientWidth && element.clientHeight) {
                canvas.setAttribute('width', element.clientWidth + 'px');
                canvas.setAttribute('height', element.clientHeight + 'px');
            } else {
                canvas.setAttribute('width', '200px');
                canvas.setAttribute('height', '200px');
            }
            element.appendChild(canvas);
            return new Graphics(get2DCanvasContext(canvas));
        }
    }
    return element;
} */
_tuval_core__WEBPACK_IMPORTED_MODULE_8__.EventBus.Default.on('KSM_OBJECT_CREATED', function (eventInfo) {
    console.log(eventInfo.KernelObject);
    var kernelObject = eventInfo.KernelObject;
    if (kernelObject != null && kernelObject.type === 'window') {
        var htmlCanvasContext = _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Browser.CreateRenderingContext(kernelObject.nWidth, kernelObject.nHeight);
        var cgContext = new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGContext2D(htmlCanvasContext);
        var hDC = _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Runtime.CreateKernelHandle();
        _tuval_core__WEBPACK_IMPORTED_MODULE_8__.Runtime.AddKernelObject(hDC, {
            type: 'dc',
            context: cgContext
        });
        kernelObject.hDC = hDC;
    }
});


/***/ }),

/***/ "./src/drawing/GraphicsUnit.ts":
/*!*************************************!*\
  !*** ./src/drawing/GraphicsUnit.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphicsUnit": () => (/* binding */ GraphicsUnit)
/* harmony export */ });
var GraphicsUnit;
(function (GraphicsUnit) {
    GraphicsUnit[GraphicsUnit["World"] = 0] = "World";
    GraphicsUnit[GraphicsUnit["Display"] = 1] = "Display";
    GraphicsUnit[GraphicsUnit["Pixel"] = 2] = "Pixel";
    GraphicsUnit[GraphicsUnit["Point"] = 3] = "Point";
    GraphicsUnit[GraphicsUnit["Inch"] = 4] = "Inch";
    GraphicsUnit[GraphicsUnit["Document"] = 5] = "Document";
    GraphicsUnit[GraphicsUnit["Millimeter"] = 6] = "Millimeter";
})(GraphicsUnit || (GraphicsUnit = {}));


/***/ }),

/***/ "./src/drawing/HotkeyPrefix.ts":
/*!*************************************!*\
  !*** ./src/drawing/HotkeyPrefix.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HotkeyPrefix": () => (/* binding */ HotkeyPrefix)
/* harmony export */ });
var HotkeyPrefix;
(function (HotkeyPrefix) {
    HotkeyPrefix[HotkeyPrefix["None"] = 0] = "None";
    HotkeyPrefix[HotkeyPrefix["Show"] = 1] = "Show";
    HotkeyPrefix[HotkeyPrefix["Hide"] = 2] = "Hide";
})(HotkeyPrefix || (HotkeyPrefix = {}));


/***/ }),

/***/ "./src/drawing/Icon.ts":
/*!*****************************!*\
  !*** ./src/drawing/Icon.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Icon": () => (/* binding */ Icon)
/* harmony export */ });
var Icon = /** @class */ (function () {
    function Icon() {
    }
    Icon.prototype.toBitmap = function () {
        return undefined;
    };
    return Icon;
}());



/***/ }),

/***/ "./src/drawing/Image.ts":
/*!******************************!*\
  !*** ./src/drawing/Image.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GetThumbnailImageAbort": () => (/* binding */ GetThumbnailImageAbort),
/* harmony export */   "Image": () => (/* binding */ Image)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _gdipEnums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gdipEnums */ "./src/drawing/gdipEnums.ts");
/* harmony import */ var _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./imaging/PixelFormat */ "./src/drawing/imaging/PixelFormat.ts");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _GraphicsUnit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GraphicsUnit */ "./src/drawing/GraphicsUnit.ts");
/* harmony import */ var _GDIPlus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GDIPlus */ "./src/drawing/GDIPlus.ts");
/* harmony import */ var _imaging_EncoderParameters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./imaging/EncoderParameters */ "./src/drawing/imaging/EncoderParameters.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Graphics */ "./src/drawing/Graphics.ts");
/* harmony import */ var _imaging_PropertyItem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./imaging/PropertyItem */ "./src/drawing/imaging/PropertyItem.ts");
/* harmony import */ var _gdipStructs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./gdipStructs */ "./src/drawing/gdipStructs.ts");
/* harmony import */ var _imaging_ImageFormat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./imaging/ImageFormat */ "./src/drawing/imaging/ImageFormat.ts");
/* harmony import */ var _imaging_ImageCodecInfo__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./imaging/ImageCodecInfo */ "./src/drawing/imaging/ImageCodecInfo.ts");
/* harmony import */ var _imaging_ColorPalette__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./imaging/ColorPalette */ "./src/drawing/imaging/ColorPalette.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../GDITypes */ "./src/GDITypes.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};















var GetThumbnailImageAbort = /** @class */ (function (_super) {
    __extends(GetThumbnailImageAbort, _super);
    function GetThumbnailImageAbort() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return GetThumbnailImageAbort;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Delegate));

;
var Image = /** @class */ (function () {
    function Image() {
        this.nativeObject = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
        this.stream = null;
    }
    Image_1 = Image;
    Image.FromFile = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var filename = args[0];
            return Image_1.FromFile(filename, false);
        }
        else if (args.length === 2) {
            var filename = args[0];
            var useEmbeddedColorManagement = args[1];
            var imagePtr = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(null);
            var st = void 0;
            if (!_tuval_core__WEBPACK_IMPORTED_MODULE_0__.File.Exists(filename))
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.FileNotFoundException(filename);
            if (useEmbeddedColorManagement)
                st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipLoadImageFromFileICM(filename, imagePtr.value);
            else
                st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipLoadImageFromFile(filename, imagePtr);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(st);
            return Image_1.CreateFromHandle(imagePtr.value);
        }
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentOutOfRangeException('');
    };
    Image.FromHbitmap = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var hbitmap = args[0];
            return Image_1.FromHbitmap(hbitmap, _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero);
        }
        else if (args.length === 2) {
            var hbitmap = args[0];
            var hpalette = args[1];
            var imagePtr = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(null);
            ;
            var st = void 0;
            st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipCreateBitmapFromHBITMAP(hbitmap, hpalette, imagePtr);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(st);
            var bitmap = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Context.Current.get('Bitmap');
            return new bitmap(imagePtr.value);
        }
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentOutOfRangeException('');
    };
    Image.FromStream = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var stream = args[0];
            return Image_1.LoadFromStream(stream, false);
        }
        else if (args.length === 2) {
            var stream = args[0];
            var useEmbeddedColorManagement = args[1];
            return Image_1.LoadFromStream(stream, false);
        }
        else if (args.length === 3) {
            var stream = args[0];
            var useEmbeddedColorManagement = args[1];
            var validateImageData = args[2];
            return Image_1.LoadFromStream(stream, false);
        }
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentOutOfRangeException('');
    };
    Image.LoadFromStream = function (stream, keepAlive) {
        if (stream == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentNullException("stream");
        var img = Image_1.CreateFromHandle(Image_1.InitFromStream(stream));
        // Under Windows, we may need to keep a reference on the stream as long as the image is alive
        // (GDI+ seems to use a lazy loader)
        if (keepAlive && _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.RunningOnWindows())
            img.stream = stream;
        return img;
    };
    Image.CreateFromHandle = function (handle) {
        var type = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(_gdipEnums__WEBPACK_IMPORTED_MODULE_1__.ImageType.Unknown);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(_GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImageType(handle, type));
        switch (type.value) {
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.ImageType.Bitmap:
                var bitmap = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Context.Current.get('Bitmap');
                return new bitmap(handle);
            case _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.ImageType.Metafile:
                return new Metafile(handle);
            default:
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotSupportedException(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("Unknown image type."));
        }
    };
    Image.GetPixelFormatSize = function (pixfmt) {
        var result = 0;
        switch (pixfmt) {
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format16bppArgb1555:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format16bppGrayScale:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format16bppRgb555:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format16bppRgb565:
                result = 16;
                break;
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format1bppIndexed:
                result = 1;
                break;
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format24bppRgb:
                result = 24;
                break;
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format32bppArgb:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format32bppPArgb:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format32bppRgb:
                result = 32;
                break;
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format48bppRgb:
                result = 48;
                break;
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format4bppIndexed:
                result = 4;
                break;
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format64bppArgb:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format64bppPArgb:
                result = 64;
                break;
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format8bppIndexed:
                result = 8;
                break;
        }
        return result;
    };
    Image.IsAlphaPixelFormat = function (pixfmt) {
        var result = false;
        switch (pixfmt) {
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format16bppArgb1555:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format32bppArgb:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format32bppPArgb:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format64bppArgb:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format64bppPArgb:
                result = true;
                break;
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format16bppGrayScale:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format16bppRgb555:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format16bppRgb565:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format1bppIndexed:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format24bppRgb:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format32bppRgb:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format48bppRgb:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format4bppIndexed:
            case _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Format8bppIndexed:
                result = false;
                break;
        }
        return result;
    };
    Image.IsCanonicalPixelFormat = function (pixfmt) {
        return ((pixfmt & _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Canonical) !== 0);
    };
    Image.IsExtendedPixelFormat = function (pixfmt) {
        return ((pixfmt & _imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_2__.PixelFormat.Extended) != 0);
    };
    Image.InitFromStream = function (stream) {
        if (stream == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentException("stream");
        var imagePtr = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out();
        var st = _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
        // Seeking required
        if (!stream.CanSeek) {
            var buffer = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(256);
            var index = 0;
            var count = void 0;
            do {
                if (buffer.length < index + 256) {
                    var newBuffer = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(buffer.length * 2);
                    _tuval_core__WEBPACK_IMPORTED_MODULE_0__.TArray.Copy(buffer, newBuffer, buffer.length);
                    buffer = newBuffer;
                }
                count = stream.Read(buffer, index, 256);
                index += count;
            } while (count !== 0);
            stream = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.MemoryStream(buffer, 0, index);
        }
        if (_GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.RunningOnUnix()) {
            // Unix, with libgdiplus
            // We use a custom API for this, because there's no easy way
            // to get the Stream down to libgdiplus.  So, we wrap the stream
            // with a set of delegates.
            /*   const sh:GdiPlusStreamHelper = new GdiPlusStreamHelper(stream, true);

              st = GdipLoadImageFromDelegate_linux(sh.GetHeaderDelegate, sh.GetBytesDelegate,
                  sh.PutBytesDelegate, sh.SeekDelegate, sh.CloseDelegate, sh.SizeDelegate, out imagePtr); */
        }
        else {
            st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipLoadImageFromStream(/* new ComIStreamWrapper( */ stream, imagePtr);
        }
        return st === _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok ? imagePtr.value : _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
    };
    // non-static
    Image.prototype.GetBounds = function (pageUnit) {
        var source = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(_tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGRectangle.Empty);
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImageBounds(this.nativeObject, source, pageUnit);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
        return source.value;
    };
    Image.prototype.GetEncoderParameterList = function (encoder) {
        var status;
        var sz = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
        status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetEncoderParameterListSize(this.nativeObject, _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(encoder), sz);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
        var rawEPList = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.AllocHGlobal(sz.value);
        var eps;
        try {
            status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetEncoderParameterList(this.nativeObject, _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(encoder), sz.value, rawEPList);
            eps = _imaging_EncoderParameters__WEBPACK_IMPORTED_MODULE_6__.EncoderParameters.FromNativePtr(rawEPList);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
        }
        finally {
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(rawEPList);
        }
        return eps;
    };
    Image.prototype.GetFrameCount = function (dimension) {
        var count = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
        var guid = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(dimension.Guid);
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipImageGetFrameCount(this.nativeObject, guid, count);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
        return count.value;
    };
    Image.prototype.GetPropertyItem = function (propid) {
        var propSize = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
        var property;
        var item = new _imaging_PropertyItem__WEBPACK_IMPORTED_MODULE_8__.PropertyItem();
        var gdipProperty = new _gdipStructs__WEBPACK_IMPORTED_MODULE_9__.GdipPropertyItem();
        var status;
        status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetPropertyItemSize(this.nativeObject, propid, propSize);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
        /* Get PropertyItem */
        property = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.AllocHGlobal(propSize.value);
        try {
            status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetPropertyItem(this.nativeObject, propid, propSize.value, property);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            gdipProperty = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStructure(property, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_gdipStructs__WEBPACK_IMPORTED_MODULE_9__.GdipPropertyItem));
            _gdipStructs__WEBPACK_IMPORTED_MODULE_9__.GdipPropertyItem.MarshalTo(gdipProperty, item);
        }
        finally {
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(property);
        }
        return item;
    };
    Image.prototype.GetThumbnailImage = function (thumbWidth, thumbHeight, callback, callbackData) {
        var _this = this;
        if ((thumbWidth <= 0) || (thumbHeight <= 0))
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.OutOfMemoryException("Invalid thumbnail size");
        var bitmap = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Context.Current.get('Bitmap');
        var ThumbNail = new bitmap(thumbWidth, thumbHeight);
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.using)(_Graphics__WEBPACK_IMPORTED_MODULE_7__.Graphics.FromImage(ThumbNail), function (g) {
            var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipDrawImageRectRectI(g.nativeObject, _this.nativeObject, 0, 0, thumbWidth, thumbHeight, 0, 0, _this.Width, _this.Height, _GraphicsUnit__WEBPACK_IMPORTED_MODULE_4__.GraphicsUnit.Pixel, _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero, null, _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
        });
        return ThumbNail;
    };
    Image.prototype.RemovePropertyItem = function (propid) {
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipRemovePropertyItem(this.nativeObject, propid);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
    };
    Image.prototype.RotateFlip = function (rotateFlipType) {
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipImageRotateFlip(this.nativeObject, rotateFlipType);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
    };
    Image.prototype.findEncoderForFormat = function (format) {
        var encoders = _imaging_ImageCodecInfo__WEBPACK_IMPORTED_MODULE_11__.ImageCodecInfo.GetImageEncoders();
        var encoder = null;
        if (format.Guid.Equals(_imaging_ImageFormat__WEBPACK_IMPORTED_MODULE_10__.ImageFormat.MemoryBmp.Guid))
            format = _imaging_ImageFormat__WEBPACK_IMPORTED_MODULE_10__.ImageFormat.Png;
        /* Look for the right encoder for our format*/
        for (var i = 0; i < encoders.length; i++) {
            if (encoders[i].FormatID.Equals(format.Guid)) {
                encoder = encoders[i];
                break;
            }
        }
        return encoder;
    };
    Image.prototype.Save = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 0 && _tuval_core__WEBPACK_IMPORTED_MODULE_0__.is.string(args[0])) {
            var filename = args[0];
            this.Save(filename, this.RawFormat);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_0__.is.string(args[0])) {
            var filename = args[0];
            var format = args[1];
            var encoder = this.findEncoderForFormat(format);
            if (encoder == null) {
                // second chance
                encoder = this.findEncoderForFormat(this.RawFormat);
                if (encoder == null) {
                    var msg = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Locale.GetText("No codec available for saving format '{0}'.", format.Guid);
                    throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentException(msg, "format");
                }
            }
            this.Save(filename, encoder, null);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_0__.is.string(args[0])) {
            var filename = args[0];
            var encoder = args[1];
            var encoderParams = args[2];
            var st = void 0;
            var guid = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(encoder.Clsid);
            if (encoderParams == null) {
                st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipSaveImageToFile(this.nativeObject, filename, guid, _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero);
            }
            else {
                var nativeEncoderParams = encoderParams.ToNativePtr();
                st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipSaveImageToFile(this.nativeObject, filename, guid, nativeEncoderParams);
                _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(nativeEncoderParams);
            }
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(st);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_0__.is["typeof"](args[0], _tuval_core__WEBPACK_IMPORTED_MODULE_0__.System.Types.IO.Stream)) {
            var stream = args[0];
            var format = args[1];
            var encoder = this.findEncoderForFormat(format);
            if (encoder == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentException("No codec available for format:" + format.Guid);
            this.Save(stream, encoder, null);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_0__.is["typeof"](args[0], _tuval_core__WEBPACK_IMPORTED_MODULE_0__.System.Types.IO.Stream)) {
            var stream = args[0];
            var encoder = args[1];
            var encoderParams = args[2];
            var st = _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
            var nativeEncoderParams = void 0;
            var guid = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(encoder.Clsid);
            if (encoderParams == null)
                nativeEncoderParams = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
            else
                nativeEncoderParams = encoderParams.ToNativePtr();
            try {
                if (_GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.RunningOnUnix()) {
                    /*  GdiPlusStreamHelper sh = new GDIPlus.GdiPlusStreamHelper(stream, false);
                     st = GDIPlus.GdipSaveImageToDelegate_linux(nativeObject, sh.GetBytesDelegate, sh.PutBytesDelegate,
                         sh.SeekDelegate, sh.CloseDelegate, sh.SizeDelegate, ref guid, nativeEncoderParams); */
                }
                else {
                    st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipSaveImageToStream(this.nativeObject, stream, guid, new HandleRef(encoderParams, nativeEncoderParams));
                }
            }
            finally {
                if (nativeEncoderParams != _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero)
                    _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(nativeEncoderParams);
            }
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(st);
        }
    };
    Image.prototype.SaveAdd = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var encoderParams = args[0];
            var st = _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
            var nativeEncoderParams = encoderParams.ToNativePtr();
            st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipSaveAdd(this.nativeObject, nativeEncoderParams);
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(nativeEncoderParams);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(st);
        }
        else if (args.length === 2) {
            var image = args[0];
            var encoderParams = args[1];
            var st = _gdipEnums__WEBPACK_IMPORTED_MODULE_1__.Status.Ok;
            var nativeEncoderParams = encoderParams.ToNativePtr();
            st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipSaveAddImage(this.nativeObject, image.NativeObject, nativeEncoderParams);
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(nativeEncoderParams);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(st);
        }
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentOutOfRangeException('');
    };
    Image.prototype.SelectActiveFrame = function (dimension, frameIndex) {
        var guid = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(dimension.Guid);
        var st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipImageSelectActiveFrame(this.nativeObject, guid, frameIndex);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(st);
        return frameIndex;
    };
    Image.prototype.SetPropertyItem = function (propitem) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.NotImplementedException('');
        /*
                GdipPropertyItem pi = new GdipPropertyItem ();
                GdipPropertyItem.MarshalTo (pi, propitem);
                unsafe {
                    Status status = GDIPlus.GdipSetPropertyItem (nativeObject, &pi);

                    GDIPlus.CheckStatus (status);
                }
        */
    };
    Object.defineProperty(Image.prototype, "Flags", {
        // properties
        get: function () {
            var flags = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
            var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImageFlags(this.nativeObject, flags);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            return flags.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "FrameDimensionsList", {
        get: function () {
            var found = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
            var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipImageGetFrameDimensionsCount(this.nativeObject, found);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            var guid = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Array(found.value);
            status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipImageGetFrameDimensionsList(this.nativeObject, guid, found.value);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            return guid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "Height", {
        get: function () {
            var height = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
            var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImageHeight(this.nativeObject, height);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            return height.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "HorizontalResolution", {
        get: function () {
            var resolution = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
            var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImageHorizontalResolution(this.nativeObject, resolution);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            return resolution.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "Palette", {
        get: function () {
            return this.retrieveGDIPalette();
        },
        set: function (value) {
            this.storeGDIPalette(value);
        },
        enumerable: false,
        configurable: true
    });
    Image.prototype.retrieveGDIPalette = function () {
        var bytes = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
        var ret = new _imaging_ColorPalette__WEBPACK_IMPORTED_MODULE_12__.ColorPalette();
        var st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImagePaletteSize(this.nativeObject, bytes);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(st);
        var palette_data = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.AllocHGlobal(bytes.value + 4 /* flag */ + 4 /* count */);
        try {
            st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImagePalette(this.nativeObject, palette_data, bytes.value);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(st);
            ret.setFromGDIPalette(palette_data);
            return ret;
        }
        finally {
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(palette_data);
        }
    };
    Image.prototype.storeGDIPalette = function (palette) {
        if (palette == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.ArgumentNullException("palette");
        }
        var palette_data = palette.getGDIPalette();
        if (palette_data === _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero) {
            return;
        }
        try {
            var st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipSetImagePalette(this.nativeObject, palette_data);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(st);
        }
        finally {
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(palette_data);
        }
    };
    Object.defineProperty(Image.prototype, "PhysicalDimension", {
        get: function () {
            var width = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0), height = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
            var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImageDimension(this.nativeObject, width, height);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGSize(width.value, height.value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "PixelFormat", {
        get: function () {
            var pixFormat = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out();
            var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImagePixelFormat(this.nativeObject, pixFormat);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            return pixFormat.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "PropertyIdList", {
        get: function () {
            var propNumbers = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
            var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetPropertyCount(this.nativeObject, propNumbers);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            var idList = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.IntArray(propNumbers.value);
            status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetPropertyIdList(this.nativeObject, propNumbers.value, idList);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            return idList;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "PropertyItems", {
        get: function () {
            var propNums = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
            var propsSize = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
            var propSize = 0;
            var properties = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out();
            var propPtr = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out();
            var items;
            var gdipProperty = new _gdipStructs__WEBPACK_IMPORTED_MODULE_9__.GdipPropertyItem();
            var status;
            status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetPropertySize(this.nativeObject, propsSize, propNums);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            items = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Array(propNums.value);
            if (propNums.value === 0)
                return items;
            /* Get PropertyItem list*/
            properties.value = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.AllocHGlobal(propsSize.value * propNums.value);
            try {
                status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetAllPropertyItems(this.nativeObject, propsSize.value, propNums.value, properties.value);
                _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
                propSize = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.SizeOf(gdipProperty);
                propPtr = properties;
                for (var i = 0; i < propNums.value; i++, propPtr.value = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(propPtr.value.ToInt64() + propSize)) {
                    gdipProperty = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStructure(propPtr.value, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_gdipStructs__WEBPACK_IMPORTED_MODULE_9__.GdipPropertyItem));
                    items[i] = new _imaging_PropertyItem__WEBPACK_IMPORTED_MODULE_8__.PropertyItem();
                    _gdipStructs__WEBPACK_IMPORTED_MODULE_9__.GdipPropertyItem.MarshalTo(gdipProperty, items[i]);
                }
            }
            finally {
                _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(properties.value);
            }
            return items;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "RawFormat", {
        get: function () {
            var guid = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out();
            var st = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImageRawFormat(this.nativeObject, guid);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(st);
            return new _imaging_ImageFormat__WEBPACK_IMPORTED_MODULE_10__.ImageFormat(guid.value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "Size", {
        get: function () {
            return new _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGSize(this.Width, this.Height);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "VerticalResolution", {
        get: function () {
            var resolution = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out();
            var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImageVerticalResolution(this.nativeObject, resolution);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            return resolution.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "Width", {
        get: function () {
            var width = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
            var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipGetImageWidth(this.nativeObject, width);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
            return width.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "NativeObject", {
        get: function () {
            return this.nativeObject;
        },
        set: function (value) {
            this.nativeObject = value;
        },
        enumerable: false,
        configurable: true
    });
    Image.prototype.Dispose = function () {
        this.dispose(true);
        //GC.SuppressFinalize(this);
    };
    /* ~Image()
    {
        Dispose(false);
    } */
    Image.prototype.dispose = function (disposing) {
        if (_GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdiPlusToken.value !== 0 && this.nativeObject !== _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero) {
            var status_1 = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipDisposeImage(this.nativeObject);
            // dispose the stream (set under Win32 only if SD owns the stream) and ...
            if (this.stream != null) {
                this.stream.Close();
                this.stream = null;
            }
            // ... set nativeObject to null before (possibly) throwing an exception
            this.nativeObject = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
            _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status_1);
        }
    };
    Image.prototype.Clone = function () {
        if (_GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.RunningOnWindows() && this.stream != null)
            return this.CloneFromStream();
        var newimage = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero);
        var status = _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.GdipCloneImage(this.NativeObject, newimage);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_5__.GDIPlus.CheckStatus(status);
        if (_tuval_core__WEBPACK_IMPORTED_MODULE_0__.is["typeof"](this, _GDITypes__WEBPACK_IMPORTED_MODULE_13__.GraphicTypes.Bitmap)) {
            var bitmap = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Context.Current.get('Bitmap');
            return new bitmap(newimage.value);
        }
        else
            return new Metafile(newimage);
    };
    // On win32, when cloning images that were originally created from a stream, we need to
    // clone both the image and the stream to make sure the gc doesn't kill it
    // (when using MS GDI+ and IStream we must ensure the stream stays alive for all the life of the Image)
    Image.prototype.CloneFromStream = function () {
        var bytes = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(this.stream.Length);
        var ms = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.MemoryStream(bytes);
        var count = (this.stream.Length < 4096 ? this.stream.Length : 4096);
        var buffer = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(count);
        this.stream.Position = 0;
        do {
            count = this.stream.Read(buffer, 0, count);
            ms.Write(buffer, 0, count);
        } while (count == 4096);
        var newimage = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
        newimage = Image_1.InitFromStream(ms);
        if (_tuval_core__WEBPACK_IMPORTED_MODULE_0__.is["typeof"](this, _GDITypes__WEBPACK_IMPORTED_MODULE_13__.GraphicTypes.Bitmap)) {
            var bitmap = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Context.Current.get('Bitmap');
            return new bitmap(newimage, ms);
        }
        else {
            return new Metafile(newimage, ms);
        }
    };
    var Image_1;
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Virtual,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Boolean]),
        __metadata("design:returntype", void 0)
    ], Image.prototype, "dispose", null);
    Image = Image_1 = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_13__.GraphicTypes.Image,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_13__.GraphicTypes.Image
            ]
        })
    ], Image);
    return Image;
}());



/***/ }),

/***/ "./src/drawing/ImageList.ts":
/*!**********************************!*\
  !*** ./src/drawing/ImageList.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageList": () => (/* binding */ ImageList)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ImageList = /** @class */ (function (_super) {
    __extends(ImageList, _super);
    function ImageList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ImageList;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.List));



/***/ }),

/***/ "./src/drawing/InterpolationMode.ts":
/*!******************************************!*\
  !*** ./src/drawing/InterpolationMode.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InterpolationMode": () => (/* binding */ InterpolationMode)
/* harmony export */ });
var InterpolationMode;
(function (InterpolationMode) {
    InterpolationMode[InterpolationMode["Invalid"] = -1] = "Invalid";
    InterpolationMode[InterpolationMode["Default"] = 0] = "Default";
    InterpolationMode[InterpolationMode["Low"] = 1] = "Low";
    InterpolationMode[InterpolationMode["High"] = 2] = "High";
    InterpolationMode[InterpolationMode["Bilinear"] = 3] = "Bilinear";
    InterpolationMode[InterpolationMode["Bicubic"] = 4] = "Bicubic";
    InterpolationMode[InterpolationMode["NearestNeighbor"] = 5] = "NearestNeighbor";
    InterpolationMode[InterpolationMode["HighQualityBilinear"] = 6] = "HighQualityBilinear";
    InterpolationMode[InterpolationMode["HighQualityBicubic"] = 7] = "HighQualityBicubic";
})(InterpolationMode || (InterpolationMode = {}));


/***/ }),

/***/ "./src/drawing/KnownColor.ts":
/*!***********************************!*\
  !*** ./src/drawing/KnownColor.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KnownColor": () => (/* binding */ KnownColor)
/* harmony export */ });
var KnownColor;
(function (KnownColor) {
    /// <summary>The system-defined color of the active window's border.</summary>
    KnownColor[KnownColor["ActiveBorder"] = 1] = "ActiveBorder";
    /// <summary>The system-defined color of the background of the active window's title bar.</summary>
    KnownColor[KnownColor["ActiveCaption"] = 2] = "ActiveCaption";
    /// <summary>The system-defined color of the text in the active window's title bar.</summary>
    KnownColor[KnownColor["ActiveCaptionText"] = 3] = "ActiveCaptionText";
    /// <summary>The system-defined color of the application workspace. The application workspace is the area in a multiple-document view that is not being occupied by documents.</summary>
    KnownColor[KnownColor["AppWorkspace"] = 4] = "AppWorkspace";
    /// <summary>The system-defined face color of a 3-D element.</summary>
    KnownColor[KnownColor["Control"] = 5] = "Control";
    /// <summary>The system-defined shadow color of a 3-D element. The shadow color is applied to parts of a 3-D element that face away from the light source.</summary>
    KnownColor[KnownColor["ControlDark"] = 6] = "ControlDark";
    /// <summary>The system-defined color that is the dark shadow color of a 3-D element. The dark shadow color is applied to the parts of a 3-D element that are the darkest color.</summary>
    KnownColor[KnownColor["ControlDarkDark"] = 7] = "ControlDarkDark";
    /// <summary>The system-defined color that is the light color of a 3-D element. The light color is applied to parts of a 3-D element that face the light source.</summary>
    KnownColor[KnownColor["ControlLight"] = 8] = "ControlLight";
    /// <summary>The system-defined highlight color of a 3-D element. The highlight color is applied to the parts of a 3-D element that are the lightest color.</summary>
    KnownColor[KnownColor["ControlLightLight"] = 9] = "ControlLightLight";
    /// <summary>The system-defined color of text in a 3-D element.</summary>
    KnownColor[KnownColor["ControlText"] = 10] = "ControlText";
    /// <summary>The system-defined color of the desktop.</summary>
    KnownColor[KnownColor["Desktop"] = 11] = "Desktop";
    /// <summary>The system-defined color of dimmed text. Items in a list that are disabled are displayed in dimmed text.</summary>
    KnownColor[KnownColor["GrayText"] = 12] = "GrayText";
    /// <summary>The system-defined color of the background of selected items. This includes selected menu items as well as selected text. </summary>
    KnownColor[KnownColor["Highlight"] = 13] = "Highlight";
    /// <summary>The system-defined color of the text of selected items.</summary>
    KnownColor[KnownColor["HighlightText"] = 14] = "HighlightText";
    /// <summary>The system-defined color used to designate a hot-tracked item. Single-clicking a hot-tracked item executes the item.</summary>
    KnownColor[KnownColor["HotTrack"] = 15] = "HotTrack";
    /// <summary>The system-defined color of an inactive window's border.</summary>
    KnownColor[KnownColor["InactiveBorder"] = 16] = "InactiveBorder";
    /// <summary>The system-defined color of the background of an inactive window's title bar.</summary>
    KnownColor[KnownColor["InactiveCaption"] = 17] = "InactiveCaption";
    /// <summary>The system-defined color of the text in an inactive window's title bar.</summary>
    KnownColor[KnownColor["InactiveCaptionText"] = 18] = "InactiveCaptionText";
    /// <summary>The system-defined color of the background of a ToolTip.</summary>
    KnownColor[KnownColor["Info"] = 19] = "Info";
    /// <summary>The system-defined color of the text of a ToolTip.</summary>
    KnownColor[KnownColor["InfoText"] = 20] = "InfoText";
    /// <summary>The system-defined color of a menu's background.</summary>
    KnownColor[KnownColor["Menu"] = 21] = "Menu";
    /// <summary>The system-defined color of a menu's text.</summary>
    KnownColor[KnownColor["MenuText"] = 22] = "MenuText";
    /// <summary>The system-defined color of the background of a scroll bar.</summary>
    KnownColor[KnownColor["ScrollBar"] = 23] = "ScrollBar";
    /// <summary>The system-defined color of the background in the client area of a window.</summary>
    KnownColor[KnownColor["Window"] = 24] = "Window";
    /// <summary>The system-defined color of a window frame.</summary>
    KnownColor[KnownColor["WindowFrame"] = 25] = "WindowFrame";
    /// <summary>The system-defined color of the text in the client area of a window.</summary>
    KnownColor[KnownColor["WindowText"] = 26] = "WindowText";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Transparent"] = 27] = "Transparent";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["AliceBlue"] = 28] = "AliceBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["AntiqueWhite"] = 29] = "AntiqueWhite";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Aqua"] = 30] = "Aqua";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Aquamarine"] = 31] = "Aquamarine";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Azure"] = 32] = "Azure";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Beige"] = 33] = "Beige";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Bisque"] = 34] = "Bisque";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Black"] = 35] = "Black";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["BlanchedAlmond"] = 36] = "BlanchedAlmond";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Blue"] = 37] = "Blue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["BlueViolet"] = 38] = "BlueViolet";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Brown"] = 39] = "Brown";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["BurlyWood"] = 40] = "BurlyWood";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["CadetBlue"] = 41] = "CadetBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Chartreuse"] = 42] = "Chartreuse";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Chocolate"] = 43] = "Chocolate";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Coral"] = 44] = "Coral";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["CornflowerBlue"] = 45] = "CornflowerBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Cornsilk"] = 46] = "Cornsilk";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Crimson"] = 47] = "Crimson";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Cyan"] = 48] = "Cyan";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkBlue"] = 49] = "DarkBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkCyan"] = 50] = "DarkCyan";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkGoldenrod"] = 51] = "DarkGoldenrod";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkGray"] = 52] = "DarkGray";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkGreen"] = 53] = "DarkGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkKhaki"] = 54] = "DarkKhaki";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkMagenta"] = 55] = "DarkMagenta";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkOliveGreen"] = 56] = "DarkOliveGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkOrange"] = 57] = "DarkOrange";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkOrchid"] = 58] = "DarkOrchid";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkRed"] = 59] = "DarkRed";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkSalmon"] = 60] = "DarkSalmon";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkSeaGreen"] = 61] = "DarkSeaGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkSlateBlue"] = 62] = "DarkSlateBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkSlateGray"] = 63] = "DarkSlateGray";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkTurquoise"] = 64] = "DarkTurquoise";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DarkViolet"] = 65] = "DarkViolet";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DeepPink"] = 66] = "DeepPink";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DeepSkyBlue"] = 67] = "DeepSkyBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DimGray"] = 68] = "DimGray";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["DodgerBlue"] = 69] = "DodgerBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Firebrick"] = 70] = "Firebrick";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["FloralWhite"] = 71] = "FloralWhite";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["ForestGreen"] = 72] = "ForestGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Fuchsia"] = 73] = "Fuchsia";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Gainsboro"] = 74] = "Gainsboro";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["GhostWhite"] = 75] = "GhostWhite";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Gold"] = 76] = "Gold";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Goldenrod"] = 77] = "Goldenrod";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Gray"] = 78] = "Gray";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Green"] = 79] = "Green";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["GreenYellow"] = 80] = "GreenYellow";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Honeydew"] = 81] = "Honeydew";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["HotPink"] = 82] = "HotPink";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["IndianRed"] = 83] = "IndianRed";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Indigo"] = 84] = "Indigo";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Ivory"] = 85] = "Ivory";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Khaki"] = 86] = "Khaki";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Lavender"] = 87] = "Lavender";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LavenderBlush"] = 88] = "LavenderBlush";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LawnGreen"] = 89] = "LawnGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LemonChiffon"] = 90] = "LemonChiffon";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightBlue"] = 91] = "LightBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightCoral"] = 92] = "LightCoral";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightCyan"] = 93] = "LightCyan";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightGoldenrodYellow"] = 94] = "LightGoldenrodYellow";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightGray"] = 95] = "LightGray";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightGreen"] = 96] = "LightGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightPink"] = 97] = "LightPink";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightSalmon"] = 98] = "LightSalmon";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightSeaGreen"] = 99] = "LightSeaGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightSkyBlue"] = 100] = "LightSkyBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightSlateGray"] = 101] = "LightSlateGray";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightSteelBlue"] = 102] = "LightSteelBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LightYellow"] = 103] = "LightYellow";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Lime"] = 104] = "Lime";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["LimeGreen"] = 105] = "LimeGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Linen"] = 106] = "Linen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Magenta"] = 107] = "Magenta";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Maroon"] = 108] = "Maroon";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MediumAquamarine"] = 109] = "MediumAquamarine";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MediumBlue"] = 110] = "MediumBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MediumOrchid"] = 111] = "MediumOrchid";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MediumPurple"] = 112] = "MediumPurple";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MediumSeaGreen"] = 113] = "MediumSeaGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MediumSlateBlue"] = 114] = "MediumSlateBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MediumSpringGreen"] = 115] = "MediumSpringGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MediumTurquoise"] = 116] = "MediumTurquoise";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MediumVioletRed"] = 117] = "MediumVioletRed";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MidnightBlue"] = 118] = "MidnightBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MintCream"] = 119] = "MintCream";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["MistyRose"] = 120] = "MistyRose";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Moccasin"] = 121] = "Moccasin";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["NavajoWhite"] = 122] = "NavajoWhite";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Navy"] = 123] = "Navy";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["OldLace"] = 124] = "OldLace";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Olive"] = 125] = "Olive";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["OliveDrab"] = 126] = "OliveDrab";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Orange"] = 127] = "Orange";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["OrangeRed"] = 128] = "OrangeRed";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Orchid"] = 129] = "Orchid";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["PaleGoldenrod"] = 130] = "PaleGoldenrod";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["PaleGreen"] = 131] = "PaleGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["PaleTurquoise"] = 132] = "PaleTurquoise";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["PaleVioletRed"] = 133] = "PaleVioletRed";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["PapayaWhip"] = 134] = "PapayaWhip";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["PeachPuff"] = 135] = "PeachPuff";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Peru"] = 136] = "Peru";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Pink"] = 137] = "Pink";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Plum"] = 138] = "Plum";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["PowderBlue"] = 139] = "PowderBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Purple"] = 140] = "Purple";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Red"] = 141] = "Red";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["RosyBrown"] = 142] = "RosyBrown";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["RoyalBlue"] = 143] = "RoyalBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["SaddleBrown"] = 144] = "SaddleBrown";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Salmon"] = 145] = "Salmon";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["SandyBrown"] = 146] = "SandyBrown";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["SeaGreen"] = 147] = "SeaGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["SeaShell"] = 148] = "SeaShell";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Sienna"] = 149] = "Sienna";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Silver"] = 150] = "Silver";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["SkyBlue"] = 151] = "SkyBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["SlateBlue"] = 152] = "SlateBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["SlateGray"] = 153] = "SlateGray";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Snow"] = 154] = "Snow";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["SpringGreen"] = 155] = "SpringGreen";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["SteelBlue"] = 156] = "SteelBlue";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Tan"] = 157] = "Tan";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Teal"] = 158] = "Teal";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Thistle"] = 159] = "Thistle";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Tomato"] = 160] = "Tomato";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Turquoise"] = 161] = "Turquoise";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Violet"] = 162] = "Violet";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Wheat"] = 163] = "Wheat";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["White"] = 164] = "White";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["WhiteSmoke"] = 165] = "WhiteSmoke";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["Yellow"] = 166] = "Yellow";
    /// <summary>A system-defined color.</summary>
    KnownColor[KnownColor["YellowGreen"] = 167] = "YellowGreen";
    /// <summary>The system-defined face color of a 3-D element.</summary>
    KnownColor[KnownColor["ButtonFace"] = 168] = "ButtonFace";
    /// <summary>The system-defined color that is the highlight color of a 3-D element. This color is applied to parts of a 3-D element that face the light source.</summary>
    KnownColor[KnownColor["ButtonHighlight"] = 169] = "ButtonHighlight";
    /// <summary>The system-defined color that is the shadow color of a 3-D element. This color is applied to parts of a 3-D element that face away from the light source.</summary>
    KnownColor[KnownColor["ButtonShadow"] = 170] = "ButtonShadow";
    /// <summary>The system-defined color of the lightest color in the color gradient of an active window's title bar.</summary>
    KnownColor[KnownColor["GradientActiveCaption"] = 171] = "GradientActiveCaption";
    /// <summary>The system-defined color of the lightest color in the color gradient of an inactive window's title bar. </summary>
    KnownColor[KnownColor["GradientInactiveCaption"] = 172] = "GradientInactiveCaption";
    /// <summary>The system-defined color of the background of a menu bar.</summary>
    KnownColor[KnownColor["MenuBar"] = 173] = "MenuBar";
    /// <summary>The system-defined color used to highlight menu items when the menu appears as a flat menu.</summary>
    KnownColor[KnownColor["MenuHighlight"] = 174] = "MenuHighlight";
})(KnownColor || (KnownColor = {}));


/***/ }),

/***/ "./src/drawing/MeasureStringCache.ts":
/*!*******************************************!*\
  !*** ./src/drawing/MeasureStringCache.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Entry": () => (/* binding */ Entry),
/* harmony export */   "MeasureStringCache": () => (/* binding */ MeasureStringCache)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);



var Entry = /** @class */ (function () {
    function Entry(text, font, layoutArea, format) {
        // Outputs
        this.charactersFitted = 0;
        this.linesFilled = 0;
        this.measure = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize.Empty;
        this.text = text;
        this.font = font;
        this.layoutArea = layoutArea;
        this.format = format;
    }
    Entry.prototype.conformsTo = function (text, font, layoutArea, format) {
        return this.text === text && this.font.equals(font)
            && this.layoutArea.Equals(layoutArea)
            && this.format.equals(format);
    };
    return Entry;
}());

var MeasureStringCache = /** @class */ (function () {
    function MeasureStringCache(capacity, enabled) {
        if (enabled === void 0) { enabled = true; }
        this.enabled = enabled;
        this.lurch = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.SimpleDictionary();
        this.myCreateEntryDelegate = null; //new Event<any/* CreateEntryDelegateType */>(this);
    }
    Object.defineProperty(MeasureStringCache.prototype, "CreateEntryDelegate", {
        get: function () {
            return this.myCreateEntryDelegate;
        },
        set: function (value) {
            this.myCreateEntryDelegate = value;
        },
        enumerable: false,
        configurable: true
    });
    MeasureStringCache.prototype.MeasureStringCache = function (capacity, enabled) {
        if (enabled === void 0) { enabled = true; }
    };
    MeasureStringCache.prototype.getKey = function (s, font, layoutArea, format) {
        // const fnt: string = `{font.Name }|{font.Size}|{(font.Italic ? '1' : '0')}{(font.Underline ? '1' : '0')}{(font.Strikeout ? '1' : '0')}`;
        // const fmt: string = `{format.FormatFlags}|{format.HotkeyPrefix}|{format.Alignment}|{format.LineAlignment}|{format.Trimming}`;
        return "{s}|{layoutArea.Width},{layoutArea.Height}|{fnt}|{fmt}";
    };
    MeasureStringCache.prototype.getOrCreate = function (text, font, layoutArea, format, createEntryDelegate) {
        if (!this.enabled) {
            return createEntryDelegate(text, font, layoutArea, format);
        }
        var key = this.getKey(text, font, layoutArea, format);
        var c = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.newOutEmpty)();
        if (this.lurch.tryGetValue(key, c))
            if (c.value.conformsTo(text, font, layoutArea, format))
                return c.value;
        var entry = createEntryDelegate(text, font, layoutArea, format);
        this.lurch.set(key, entry);
        return entry;
    };
    return MeasureStringCache;
}());



/***/ }),

/***/ "./src/drawing/PathPointType.ts":
/*!**************************************!*\
  !*** ./src/drawing/PathPointType.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathPointType": () => (/* binding */ PathPointType)
/* harmony export */ });
var PathPointType;
(function (PathPointType) {
    PathPointType[PathPointType["Start"] = 0] = "Start";
    PathPointType[PathPointType["Line"] = 1] = "Line";
    PathPointType[PathPointType["Bezier"] = 3] = "Bezier";
    PathPointType[PathPointType["PathTypeMask"] = 7] = "PathTypeMask";
    PathPointType[PathPointType["DashMode"] = 16] = "DashMode";
    PathPointType[PathPointType["PathMarker"] = 32] = "PathMarker";
    PathPointType[PathPointType["CloseSubpath"] = 128] = "CloseSubpath";
    // Path types used for advanced path.
    PathPointType[PathPointType["Bezier3"] = 3] = "Bezier3";
})(PathPointType || (PathPointType = {}));


/***/ }),

/***/ "./src/drawing/Pen.ts":
/*!****************************!*\
  !*** ./src/drawing/Pen.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Pen": () => (/* binding */ Pen)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _drawing2D_LineCap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawing2D/LineCap */ "./src/drawing/drawing2D/LineCap.ts");
/* harmony import */ var _drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawing2D/DashStyle */ "./src/drawing/drawing2D/DashStyle.ts");
/* harmony import */ var _drawing2D_LineJoin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawing2D/LineJoin */ "./src/drawing/drawing2D/LineJoin.ts");
/* harmony import */ var _SolidBrush__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _DashCap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DashCap */ "./src/drawing/DashCap.ts");
/* harmony import */ var _Shadow__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Shadow */ "./src/drawing/Shadow.ts");
/* harmony import */ var _PenTypes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PenTypes */ "./src/drawing/PenTypes.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./../GDITypes */ "./src/GDITypes.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};












var Pen = /** @class */ (function () {
    function Pen() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.brush = undefined;
        this.color = undefined;
        this.changed = true;
        this.isModifiable = false;
        this.width = 1;
        this.transform = undefined;
        this.startCap = _drawing2D_LineCap__WEBPACK_IMPORTED_MODULE_2__.LineCap.Flat;
        this.endCap = _drawing2D_LineCap__WEBPACK_IMPORTED_MODULE_2__.LineCap.Flat;
        this.dashStyle = _drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__.DashStyle.Solid;
        this.dashOffset = 0;
        this.dashPattern = undefined;
        this.lineJoin = _drawing2D_LineJoin__WEBPACK_IMPORTED_MODULE_4__.LineJoin.Miter;
        this.miterLimit = 10;
        this.alignment = undefined;
        this.penType = _PenTypes__WEBPACK_IMPORTED_MODULE_8__.PenTypes.SolidColor;
        this.myDashCap = _DashCap__WEBPACK_IMPORTED_MODULE_6__.DashCap.Flat;
        this.Shadow = _Shadow__WEBPACK_IMPORTED_MODULE_7__.Shadow.identity.clone();
        if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.Brush)) {
            var brush = args[0];
            if (brush == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException("brush");
            }
            this.brush = brush.Clone();
            var sb = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.as)(brush, _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.SolidBrush);
            if (sb != null) {
                this.color = sb.Color;
            }
            else {
                this.color = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Black;
            }
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CoreGraphicTypes.CGColor)) {
            var color = args[0];
            this.brush = new _SolidBrush__WEBPACK_IMPORTED_MODULE_5__.SolidBrush(color);
            this.color = color;
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.Brush) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.number(args[1])) {
            var brush = args[0];
            var width = args[1];
            if (brush == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException("brush");
            }
            this.brush = brush.Clone();
            var sb = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.as)(brush, _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.SolidBrush);
            if (sb != null) {
                this.color = sb.Color;
            }
            else {
                this.color = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Black;
            }
            this.width = width;
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CoreGraphicTypes.CGColor) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.number(args[1])) {
            var color = args[0];
            var width = args[1];
            this.brush = new _SolidBrush__WEBPACK_IMPORTED_MODULE_5__.SolidBrush(color);
            this.color = color;
            this.width = width;
        }
        else {
            console.log('Can not create pen correctly.');
        }
    }
    Pen_1 = Pen;
    Object.defineProperty(Pen.prototype, "DashCap", {
        get: function () {
            return this.myDashCap;
        },
        set: function (value) {
            this.myDashCap = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pen.prototype, "Brush", {
        get: function () {
            return this.brush;
        },
        set: function (value) {
            this.brush = value.Clone();
            var sb = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.as)(this.brush, _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.SolidBrush);
            if (sb != null)
                this.color = sb.Color;
            else
                this.color = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Black;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pen.prototype, "Color", {
        get: function () {
            return this.color;
        },
        set: function (value) {
            if (value !== this.color) {
                this.color = value;
                this.brush = new _SolidBrush__WEBPACK_IMPORTED_MODULE_5__.SolidBrush(this.color);
                this.changed = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Pen.prototype.Dispose = function (disposing) {
        if (disposing === void 0) { disposing = true; }
    };
    Pen.prototype.Clone = function () {
        if (this.brush != null)
            return new Pen_1(this.brush, this.width);
        else
            return new Pen_1(this.color, this.width);
    };
    Object.defineProperty(Pen.prototype, "Width", {
        get: function () {
            return this.width;
        },
        set: function (value) {
            this.width = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pen.prototype, "Transform", {
        get: function () {
            return this.transform;
        },
        set: function (value) {
            this.transform = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pen.prototype, "StartCap", {
        get: function () {
            return this.startCap;
        },
        set: function (value) {
            if (_tuval_core__WEBPACK_IMPORTED_MODULE_1__.Enum.IsDefined(_drawing2D_LineCap__WEBPACK_IMPORTED_MODULE_2__.LineCap, value)) {
                this.startCap = value;
                this.changed = true;
            }
            else {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentException("Pen StartCap Argument Error.");
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pen.prototype, "EndCap", {
        get: function () {
            return this.endCap;
        },
        set: function (value) {
            if (_tuval_core__WEBPACK_IMPORTED_MODULE_1__.Enum.IsDefined(_drawing2D_LineCap__WEBPACK_IMPORTED_MODULE_2__.LineCap, value)) {
                this.endCap = value;
                this.changed = true;
            }
            else {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentException("Pen EndCap Argument Error.");
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pen.prototype, "DashStyle", {
        get: function () {
            return this.dashStyle;
        },
        set: function (value) {
            if (_tuval_core__WEBPACK_IMPORTED_MODULE_1__.Enum.IsDefined(_drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__.DashStyle, value)) {
                this.dashStyle = value;
                this.changed = true;
                if (this.dashStyle !== _drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__.DashStyle.Custom)
                    this.dashPattern = undefined;
            }
            else {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentException("Pen DashStyle Argument Error.");
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pen.prototype, "DashOffset", {
        get: function () {
            return this.dashOffset;
        },
        set: function (value) {
            // fixme for error checking and range
            this.dashOffset = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pen.prototype, "DashPattern", {
        get: function () {
            return this.dashPattern;
        },
        set: function (value) {
            if (value != null) {
                this.dashStyle = _drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__.DashStyle.Custom;
                this.dashPattern = value;
                this.changed = true;
            }
            else {
                this.dashStyle = _drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__.DashStyle.Solid;
                this.dashPattern = undefined;
                this.changed = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Pen.prototype.setLineCap = function (startCap, endCap, dashCap) {
        this.StartCap = startCap;
    };
    Object.defineProperty(Pen.prototype, "LineJoin", {
        get: function () {
            return this.lineJoin;
        },
        set: function (value) {
            this.lineJoin = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pen.prototype, "MiterLimit", {
        get: function () {
            return this.miterLimit;
        },
        set: function (value) {
            this.miterLimit = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pen.prototype, "Alignment", {
        get: function () {
            return this.alignment;
        },
        set: function (value) {
            this.alignment = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pen.prototype, "PenType", {
        get: function () {
            var penType = _PenTypes__WEBPACK_IMPORTED_MODULE_8__.PenTypes.Custom;
            if (_tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](this.brush, _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.SolidBrush)) {
                penType = _PenTypes__WEBPACK_IMPORTED_MODULE_8__.PenTypes.SolidColor;
            }
            else if (_tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](this.brush, _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.HatchBrush)) {
                penType = _PenTypes__WEBPACK_IMPORTED_MODULE_8__.PenTypes.HatchFill;
            }
            else if (_tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](this.brush, _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.LinearGradientBrush)) {
                penType = _PenTypes__WEBPACK_IMPORTED_MODULE_8__.PenTypes.LinearGradient;
            }
            else if (_tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](this.brush, _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.PathGradientBrush)) {
                penType = _PenTypes__WEBPACK_IMPORTED_MODULE_8__.PenTypes.PathGradient;
            }
            else if (_tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](this.brush, _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.TextureBrush)) {
                penType = _PenTypes__WEBPACK_IMPORTED_MODULE_8__.PenTypes.TextureFill;
            }
            else if (_tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](this.brush, _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.RadialGradientBrush)) {
                penType = _PenTypes__WEBPACK_IMPORTED_MODULE_8__.PenTypes.RadialGradient;
            }
            return penType;
        },
        enumerable: false,
        configurable: true
    });
    Pen.prototype.setup = function (graphics, fill) {
        this.brush.setup(graphics, fill);
        // TODO: apply matrix
        if (graphics.LastPen === this && !this.changed)
            return;
        graphics.renderer.setShadowWithColor(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize(this.Shadow.offsetX, this.Shadow.offsetY), this.Shadow.blur, this.Shadow.color);
        //  A Width of 0 will result in the Pen drawing as if the Width were 1.
        this.width = this.width === 0 ? 1 : this.width;
        //width = graphics.GraphicsUnitConvertFloat (width);
        graphics.renderer.setLineWidth(this.width);
        switch (this.startCap) {
            case _drawing2D_LineCap__WEBPACK_IMPORTED_MODULE_2__.LineCap.Flat:
                graphics.renderer.setLineCap(this.width > 1 || this.dashStyle !== _drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__.DashStyle.Solid ? _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Butt : _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
                break;
            case _drawing2D_LineCap__WEBPACK_IMPORTED_MODULE_2__.LineCap.Square:
                graphics.renderer.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
                break;
            case _drawing2D_LineCap__WEBPACK_IMPORTED_MODULE_2__.LineCap.Round:
                graphics.renderer.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Round);
                break;
            //			case LineCap.Triangle:
            //			case LineCap.NoAnchor:
            //			case LineCap.SquareAnchor:
            //			case LineCap.RoundAnchor:
            //			case LineCap.DiamondAnchor:
            //			case LineCap.ArrowAnchor:
            //			case LineCap.AnchorMask:
            //			case LineCap.Custom:
            default:
                graphics.renderer.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Butt);
                break;
        }
        switch (this.dashStyle) {
            case _drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__.DashStyle.Custom:
                graphics.renderer.setLineDash(this.dashOffset, this.setupMorseCode(this.dashPattern));
                break;
            case _drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__.DashStyle.Dash:
                graphics.renderer.setLineDash(this.dashOffset, this.setupMorseCode(Pen_1.Dash));
                break;
            case _drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__.DashStyle.Dot:
                graphics.renderer.setLineDash(this.dashOffset, this.setupMorseCode(Pen_1.Dot));
                break;
            case _drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__.DashStyle.DashDot:
                graphics.renderer.setLineDash(this.dashOffset, this.setupMorseCode(Pen_1.DashDot));
                break;
            case _drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_3__.DashStyle.DashDotDot:
                graphics.renderer.setLineDash(this.dashOffset, this.setupMorseCode(Pen_1.DashDotDot));
                break;
            default:
                graphics.renderer.setLineDash(0, []);
                break;
        }
        // miter limit
        // join
        // cap
        // dashes
        this.changed = false;
        graphics.LastPen = this;
    };
    Pen.prototype.setupMorseCode = function (morse) {
        var dashdots = new Array(morse.length);
        for (var x = 0; x < dashdots.length; x++) {
            dashdots[x] = morse[x] * this.width;
        }
        return dashdots;
    };
    var Pen_1;
    Pen.Dot = [1, 1];
    Pen.Dash = [3, 1];
    Pen.DashDot = [3, 1, 1, 1];
    Pen.DashDotDot = [3, 1, 1, 1, 1, 1];
    Pen = Pen_1 = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.Pen,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.Pen
            ]
        }),
        __metadata("design:paramtypes", [Object])
    ], Pen);
    return Pen;
}());



/***/ }),

/***/ "./src/drawing/PenAlignment.ts":
/*!*************************************!*\
  !*** ./src/drawing/PenAlignment.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PenAlignment": () => (/* binding */ PenAlignment)
/* harmony export */ });
var PenAlignment;
(function (PenAlignment) {
    PenAlignment[PenAlignment["Center"] = 0] = "Center";
    PenAlignment[PenAlignment["Inset"] = 1] = "Inset";
    PenAlignment[PenAlignment["Outset"] = 2] = "Outset";
    PenAlignment[PenAlignment["Left"] = 3] = "Left";
    PenAlignment[PenAlignment["Right"] = 4] = "Right";
})(PenAlignment || (PenAlignment = {}));


/***/ }),

/***/ "./src/drawing/PenTypes.ts":
/*!*********************************!*\
  !*** ./src/drawing/PenTypes.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PenTypes": () => (/* binding */ PenTypes)
/* harmony export */ });
var PenTypes;
(function (PenTypes) {
    PenTypes[PenTypes["HatchFill"] = 0] = "HatchFill";
    PenTypes[PenTypes["LinearGradient"] = 1] = "LinearGradient";
    PenTypes[PenTypes["PathGradient"] = 2] = "PathGradient";
    PenTypes[PenTypes["SolidColor"] = 3] = "SolidColor";
    PenTypes[PenTypes["TextureFill"] = 4] = "TextureFill";
    PenTypes[PenTypes["RadialGradient"] = 5] = "RadialGradient";
    PenTypes[PenTypes["Custom"] = 6] = "Custom";
})(PenTypes || (PenTypes = {}));


/***/ }),

/***/ "./src/drawing/Pens.ts":
/*!*****************************!*\
  !*** ./src/drawing/Pens.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Pens": () => (/* binding */ Pens)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Pen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pen */ "./src/drawing/Pen.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../GDITypes */ "./src/GDITypes.ts");




var Pens = /** @class */ (function () {
    function Pens() {
    }
    Object.defineProperty(Pens, "Transparent", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Transparent); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "AliceBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.AliceBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "AntiqueWhite", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.AntiqueWhite); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Aqua", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Aqua); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Aquamarine", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Aquamarine); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Azure", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Azure); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Beige", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Beige); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Bisque", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Bisque); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Black", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Black); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "BlanchedAlmond", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.BlanchedAlmond); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Blue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Blue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "BlueViolet", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.BlueViolet); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Brown", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Brown); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "BurlyWood", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.BurlyWood); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "CadetBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.CadetBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Chartreuse", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Chartreuse); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Chocolate", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Chocolate); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Coral", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Coral); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "CornflowerBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.CornflowerBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Cornsilk", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Cornsilk); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Crimson", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Crimson); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Cyan", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Cyan); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkCyan", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkCyan); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkGoldenrod", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkGoldenrod); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkGray", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkGray); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkKhaki", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkKhaki); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkMagenta", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkMagenta); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkOliveGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkOliveGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkOrange", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkOrange); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkOrchid", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkOrchid); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkRed", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkRed); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkSalmon", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkSalmon); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkSeaGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkSeaGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkSlateBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkSlateBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkSlateGray", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkSlateGray); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkTurquoise", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkTurquoise); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DarkViolet", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DarkViolet); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DeepPink", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DeepPink); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DeepSkyBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DeepSkyBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DimGray", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DimGray); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "DodgerBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.DodgerBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Firebrick", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Firebrick); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "FloralWhite", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FloralWhite); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "ForestGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.ForestGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Fuchsia", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Fuchsia); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Gainsboro", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Gainsboro); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "GhostWhite", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.GhostWhite); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Gold", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Gold); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Goldenrod", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Goldenrod); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Gray", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Gray); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Green", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Green); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "GreenYellow", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.GreenYellow); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Honeydew", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Honeydew); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "HotPink", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.HotPink); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "IndianRed", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.IndianRed); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Indigo", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Indigo); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Ivory", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Ivory); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Khaki", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Khaki); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Lavender", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Lavender); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LavenderBlush", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LavenderBlush); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LawnGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LawnGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LemonChiffon", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LemonChiffon); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightCoral", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightCoral); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightCyan", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightCyan); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightGoldenrodYellow", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightGoldenrodYellow); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightGray", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightGray); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightPink", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightPink); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightSalmon", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightSalmon); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightSeaGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightSeaGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightSkyBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightSkyBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightSlateGray", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightSlateGray); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightSteelBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightSteelBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LightYellow", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LightYellow); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Lime", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Lime); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "LimeGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.LimeGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Linen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Linen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Magenta", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Magenta); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Maroon", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Maroon); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MediumAquamarine", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumAquamarine); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MediumBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MediumOrchid", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumOrchid); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MediumPurple", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumPurple); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MediumSeaGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumSeaGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MediumSlateBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumSlateBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MediumSpringGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumSpringGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MediumTurquoise", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumTurquoise); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MediumVioletRed", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MediumVioletRed); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MidnightBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MidnightBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MintCream", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MintCream); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "MistyRose", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.MistyRose); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Moccasin", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Moccasin); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "NavajoWhite", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.NavajoWhite); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Navy", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Navy); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "OldLace", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.OldLace); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Olive", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Olive); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "OliveDrab", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.OliveDrab); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Orange", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Orange); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "OrangeRed", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.OrangeRed); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Orchid", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Orchid); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "PaleGoldenrod", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PaleGoldenrod); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "PaleGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PaleGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "PaleTurquoise", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PaleTurquoise); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "PaleVioletRed", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PaleVioletRed); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "PapayaWhip", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PapayaWhip); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "PeachPuff", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PeachPuff); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Peru", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Peru); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Pink", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Pink); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Plum", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Plum); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "PowderBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.PowderBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Purple", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Purple); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Red", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Red); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "RosyBrown", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.RosyBrown); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "RoyalBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.RoyalBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "SaddleBrown", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SaddleBrown); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Salmon", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Salmon); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "SandyBrown", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SandyBrown); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "SeaGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SeaGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "SeaShell", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SeaShell); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Sienna", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Sienna); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Silver", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Silver); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "SkyBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SkyBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "SlateBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SlateBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "SlateGray", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SlateGray); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Snow", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Snow); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "SpringGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SpringGreen); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "SteelBlue", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.SteelBlue); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Tan", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Tan); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Teal", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Teal); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Thistle", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Thistle); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Tomato", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Tomato); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Turquoise", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Turquoise); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Violet", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Violet); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Wheat", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Wheat); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "White", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.White); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "WhiteSmoke", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.WhiteSmoke); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "Yellow", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Yellow); },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Pens, "YellowGreen", {
        get: function () { return new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.YellowGreen); },
        enumerable: false,
        configurable: true
    });
    return Pens;
}());

for (var p in Pens) {
    var pen = Pens[p];
    if (_tuval_core__WEBPACK_IMPORTED_MODULE_2__.is["typeof"](pen, _GDITypes__WEBPACK_IMPORTED_MODULE_3__.GraphicTypes.Pen)) {
        for (var i = 2; i < 10; i++) {
            Pens[p.toString() + i.toString()] = new _Pen__WEBPACK_IMPORTED_MODULE_1__.Pen(pen.Color, i);
            var penName = p.toString() + i.toString() + 'x5';
            var newPen = Pens[p.toString() + i.toString()].Clone();
            newPen.Shadow.color = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Black;
            newPen.Shadow.blur = newPen.Width * 5;
            Pens[penName] = newPen;
        }
    }
}


/***/ }),

/***/ "./src/drawing/Region.ts":
/*!*******************************!*\
  !*** ./src/drawing/Region.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RegionType": () => (/* binding */ RegionType),
/* harmony export */   "RegionClipType": () => (/* binding */ RegionClipType),
/* harmony export */   "Region": () => (/* binding */ Region)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawing2D/GraphicsPath */ "./src/drawing/drawing2D/GraphicsPath.ts");
/* harmony import */ var _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawing2D/Matrix */ "./src/drawing/drawing2D/Matrix.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _Clipper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Clipper */ "./src/drawing/Clipper.ts");








var RegionType;
(function (RegionType) {
    RegionType[RegionType["Rectangle"] = 10000] = "Rectangle";
    RegionType[RegionType["Infinity"] = 10001] = "Infinity";
    RegionType[RegionType["Empty"] = 10002] = "Empty";
    RegionType[RegionType["Path"] = 10003] = "Path";
})(RegionType || (RegionType = {}));
var RegionClipType;
(function (RegionClipType) {
    RegionClipType[RegionClipType["Intersection"] = 0] = "Intersection";
    RegionClipType[RegionClipType["Union"] = 1] = "Union";
    RegionClipType[RegionClipType["Difference"] = 2] = "Difference";
    RegionClipType[RegionClipType["Xor"] = 3] = "Xor";
    RegionClipType[RegionClipType["None"] = -1] = "None";
})(RegionClipType || (RegionClipType = {}));
;
var RegionEntry = /** @class */ (function () {
    function RegionEntry() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _a, _b;
        this.regionType = undefined;
        this.regionPath = undefined;
        this.regionClipType = undefined;
        if (args.length === 0) {
        }
        else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[2], _tuval_core__WEBPACK_IMPORTED_MODULE_1__.System.Types.Collections.Generics.List) && !_tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"]((_a = args[2]) === null || _a === void 0 ? void 0 : _a[0], _tuval_core__WEBPACK_IMPORTED_MODULE_1__.System.Types.Collections.Generics.List)) {
            var type = args[0];
            var obj = args[1];
            var path = args[2];
            var clipType = args[3];
            this.regionType = type;
            this.regionObject = obj;
            this.regionPath = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List();
            this.regionPath.Add(path);
            this.regionClipType = clipType;
        }
        else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"](args[2], _tuval_core__WEBPACK_IMPORTED_MODULE_1__.System.Types.Collections.Generics.List) && _tuval_core__WEBPACK_IMPORTED_MODULE_1__.is["typeof"]((_b = args[2]) === null || _b === void 0 ? void 0 : _b[0], _tuval_core__WEBPACK_IMPORTED_MODULE_1__.System.Types.Collections.Generics.List)) {
            var type = args[0];
            var obj = args[1];
            var path = args[2];
            var clipType = args[3];
            this.regionType = type;
            this.regionObject = obj;
            this.regionPath = path;
            this.regionClipType = clipType;
        }
    }
    RegionEntry.prototype.constructor1 = function (type) {
        this.constructor(type, null, new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List(), RegionClipType.None);
    };
    RegionEntry.prototype.constructor2 = function (type, obj) {
        this.constructor(type, obj, new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List(), RegionClipType.None);
    };
    RegionEntry.prototype.constructor3 = function (type, obj, path) {
        this.constructor(type, obj, path, RegionClipType.None);
    };
    return RegionEntry;
}());
var Region = /** @class */ (function () {
    function Region() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.regionList = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List();
        this.regionPath = undefined;
        this.regionBounds = undefined;
        this.solution = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List();
        if (args.length === 0) {
            this.regionObject = Region.infinite;
            var path = Region.RectangleToPath(Region.infinite);
            this.solution.Add(path);
            this.regionList.Add(new RegionEntry(RegionType.Infinity, Region.infinite, path, RegionClipType.None));
            this.regionPath = new _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath();
            this.regionPath.addLines([
                new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(Region.infinite.Left, Region.infinite.Top),
                new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(Region.infinite.Right, Region.infinite.Top),
                new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(Region.infinite.Right, Region.infinite.Bottom),
                new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(Region.infinite.Left, Region.infinite.Bottom)
            ]);
            this.regionBounds = Region.infinite;
        }
        else if (args.length === 1 && args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle) {
            var rect = args[0];
            this.regionObject = rect;
            var path = Region.RectangleToPath(rect);
            this.solution.Add(path);
            this.regionList.Add(new RegionEntry(RegionType.Rectangle, rect, path, RegionClipType.None));
            this.regionPath = new _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath();
            this.regionPath.addLines([
                new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left, rect.Top),
                new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Right, rect.Top),
                new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Right, rect.Bottom),
                new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(rect.Left, rect.Bottom),
            ]);
            this.regionBounds = rect;
        }
        else if (args.length === 1 && args[0] instanceof _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath) {
            var clonePath = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.as)(args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.GraphicsPath).Clone();
            this.regionObject = clonePath;
            this.regionPath = new _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath();
            // this.plotPath(clonePath);
            clonePath.flatten();
            var flatPath = Region.PointFArrayToIntArray(clonePath.PathPoints, Region.scale);
            this.solution.Add(flatPath);
            this.regionList.Add(new RegionEntry(RegionType.Path, clonePath, flatPath, RegionClipType.None));
            this.regionBounds = this.regionPath.getBounds();
        }
        else if (args.length === 1 && args[0] instanceof Region) {
            var region = args[0];
            this.solution = Region.Copy(region.solution);
            this.regionPath = region.regionPath.Clone();
            this.regionList = Region.Copy1(region.regionList);
            this.regionBounds = region.regionBounds;
            this.regionObject = Region.CopyRegionObject(region.regionObject);
        }
    }
    Region.PointFArrayToIntArray = function (points, scale) {
        var result = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List();
        for (var i = 0; i < points.length; ++i) {
            result.Add(new _Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipPoint(Math.round(points[i].X) * scale, Math.round(points[i].Y) * scale));
        }
        return result;
    };
    Region.PathToPointFArray = function (pg, scale) {
        var result = [];
        for (var i = 0; i < pg.Count; ++i) {
            result[i].X = pg[i].X / scale;
            result[i].Y = pg[i].Y / scale;
        }
        return result;
    };
    /* private plotPath ( path:GraphicsPath): void
    {
        let x1: float = 0, y1: float = 0, x2: float = 0, y2: float = 0, x3: float = 0, y3: float = 0;
        const points: PointF[] = path.PathPoints;
        const types: numbers[] = path.PathTypes;
        const bidx: number = 0;

        for (let i = 0; i < points.Length; i++){
            const point: PointF = points[i];
            const type:PathPointType = types[i];

            switch (type & PathPointType.PathTypeMask){
            case PathPointType.Start:
                this.regionPath.moveToPoint (point.ToCGPoint ());
                break;

            case PathPointType.Line:
                regionPath.AddLineToPoint (point.ToCGPoint ());
                break;

            case PathPointType.Bezier3:
                // collect 3 points
                switch (bidx++){
                    case 0:
                    x1 = point.X;
                    y1 = point.Y;
                    break;
                    case 1:
                    x2 = point.X;
                    y2 = point.Y;
                    break;
                    case 2:
                    x3 = point.X;
                    y3 = point.Y;
                    break;
                }
                if (bidx == 3){
                    regionPath.AddCurveToPoint (x1, y1, x2, y2, x3, y3);
                    bidx = 0;
                }
                break;
                default:
                throw new Exception ("Inconsistent internal state, path type=" + type);
            }
            if ((type & PathPointType.CloseSubpath) != 0)
                regionPath.CloseSubpath ();
        }
    } */
    Region.prototype.equals = function (region, g) {
        if (region == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException("region");
        }
        if (g == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException("g");
        }
        // Region.NotImplemented (MethodBase.GetCurrentMethod ());
        return this === region; //ReferenceEquals (this, region);
    };
    Region.prototype.clone = function () {
        return new Region(this);
    };
    Region.Copy = function (src) {
        var dst = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List( /*src.Capacity*/);
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.foreach)(src, function (path) {
            dst.Add(new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List(path));
        });
        return dst;
    };
    Region.Copy1 = function (src) {
        var dst = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List( /*src.Capacity*/);
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.foreach)(src, function (r) {
            var re = new RegionEntry();
            re.regionType = r.regionType,
                re.regionClipType = r.regionClipType,
                re.regionPath = Region.Copy(r.regionPath),
                re.regionObject = Region.CopyRegionObject(r.regionObject);
            dst.Add(re);
        });
        return dst;
    };
    Region.CopyRegionObject = function (src) {
        if (src instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle)
            return src;
        if (src instanceof _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath)
            return src.Clone();
        console.log("Unexpected type of regionObject ({src.GetType().Name})");
        return src;
    };
    Region.prototype.getBounds = function (g) {
        if (arguments.length === 1) {
            if (g == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException('graphics is null');
            }
            Region.NotImplemented('getBounds');
            return this.getBounds();
        }
        else {
            return this.regionBounds;
        }
    };
    Region.prototype.makeInfinite = function () {
        this.regionObject = Region.infinite;
        var path = Region.RectangleToPath(Region.infinite);
        // clear out our containers.
        this.regionList.Clear();
        this.solution.Clear();
        this.solution.Add(path);
        this.regionList.Add(new RegionEntry(RegionType.Infinity, Region.infinite, path, RegionClipType.None));
        this.regionPath = new _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath();
        this.regionPath.addLines([
            new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(Region.infinite.Left, Region.infinite.Top),
            new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(Region.infinite.Right, Region.infinite.Top),
            new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(Region.infinite.Right, Region.infinite.Bottom),
            new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(Region.infinite.Left, Region.infinite.Bottom)
        ]);
        this.regionBounds = this.regionPath.getBounds();
    };
    Region.prototype.makeEmpty = function () {
        this.regionObject = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty;
        var path = Region.RectangleToPath(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty);
        // clear out our containers.
        this.regionList.Clear();
        this.solution.Clear();
        this.solution.Add(path);
        this.regionList.Add(new RegionEntry(RegionType.Empty, _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty, path, RegionClipType.None));
        this.regionPath = new _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath();
        this.regionBounds = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty;
    };
    Region.prototype.transform = function (matrix) {
        if (!this.regionPath.IsEmpty && !this.regionBounds.Equals(Region.infinite)) {
            (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.foreach)(this.solution, function (path) {
                for (var p = 0; p < path.Count; p++) {
                    var point = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.newOutEmpty)();
                    point.value = path[p];
                    Region.TransformIntPoint(point, matrix);
                    path[p] = point.value;
                }
            });
            this.pathsToInternalPath(this.solution);
        }
    };
    Region.TransformIntPoint = function (point, matrix) {
        var transform = matrix.transform;
        var x = point.value.X / Region.scale;
        var y = point.value.Y / Region.scale;
        point.value.X = Math.round(((transform.m[0] * x + transform.m[2] * y + transform.m[4]) * Region.scale));
        point.value.Y = Math.round(((transform.m[1] * x + transform.m[3] * y + transform.m[5]) * Region.scale));
    };
    Region.prototype.translate = function (dx, dy) {
        var translateMatrix = new _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_3__.Matrix(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeTranslation(dx, dy));
        this.transform(translateMatrix);
    };
    Region.prototype.intersect = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1 && args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle) {
            var rect = args[0];
            this.regionList.Add(new RegionEntry(RegionType.Rectangle, rect, Region.RectangleToPath(rect), RegionClipType.Intersection));
            this.calculateRegionPath(_Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipType.ctIntersection);
        }
        else if (args.length === 1 && args[0] instanceof Region) {
            var region = args[0];
            this.regionList.Add(new RegionEntry(RegionType.Rectangle, region.solution, region.solution, RegionClipType.Intersection));
            this.calculateRegionPath(_Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipType.ctIntersection);
        }
        else if (args.length === 1 && args[0] instanceof _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath) {
            var path = args[0];
            var region = new Region(path);
            this.intersect(region);
            region.dispose();
        }
    };
    Region.prototype.dispose = function () {
    };
    Region.prototype.union = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1 && args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle) {
            var rect = args[0];
            this.regionList.Add(new RegionEntry(RegionType.Rectangle, rect, Region.RectangleToPath(rect), RegionClipType.Union));
            this.calculateRegionPath(_Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipType.ctUnion);
        }
        else if (args.length === 1 && args[0] instanceof Region) {
            var region = args[0];
            this.regionList.Add(new RegionEntry(RegionType.Path, region.solution, region.solution, RegionClipType.Union));
            this.calculateRegionPath(_Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipType.ctUnion);
        }
        else if (args.length === 1 && args[0] instanceof _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath) {
            var path = args[0];
            var region = new Region(path);
            this.union(region);
            region.dispose();
        }
    };
    Region.prototype.xor = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1 && args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle) {
            var rect = args[0];
            this.regionList.Add(new RegionEntry(RegionType.Rectangle, rect, Region.RectangleToPath(rect), RegionClipType.Xor));
            this.calculateRegionPath(_Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipType.ctXor);
        }
        else if (args.length === 1 && args[0] instanceof Region) {
            var region = args[0];
            this.regionList.Add(new RegionEntry(RegionType.Path, region.solution, region.solution, RegionClipType.Xor));
            this.calculateRegionPath(_Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipType.ctXor);
        }
        else if (args.length === 1 && args[0] instanceof _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath) {
            var path = args[0];
            var region = new Region(path);
            this.union(region);
            region.dispose();
        }
    };
    Region.prototype.exclude = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1 && args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle) {
            var rect = args[0];
            this.regionList.Add(new RegionEntry(RegionType.Rectangle, rect, Region.RectangleToPath(rect), RegionClipType.Difference));
            this.calculateRegionPath(_Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipType.ctDifference);
        }
        else if (args.length === 1 && args[0] instanceof Region) {
            var region = args[0];
            this.regionList.Add(new RegionEntry(RegionType.Path, region.solution, region.solution, RegionClipType.Difference));
            this.calculateRegionPath(_Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipType.ctDifference);
        }
        else if (args.length === 1 && args[0] instanceof _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath) {
            var path = args[0];
            var region = new Region(path);
            this.union(region);
            region.dispose();
        }
    };
    Region.prototype.calculateRegionPath = function (clipType) {
        var c = new _Clipper__WEBPACK_IMPORTED_MODULE_5__.Clipper();
        var subjects = this.solution;
        //subjects.Add (solution);
        var clips = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List();
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.foreach)(this.regionList[this.regionList.Count - 1].regionPath, function (path) {
            clips.Add(path);
        });
        c.AddPolygons(subjects, _Clipper__WEBPACK_IMPORTED_MODULE_5__.PolyType.ptSubject);
        c.AddPolygons(clips, _Clipper__WEBPACK_IMPORTED_MODULE_5__.PolyType.ptClip);
        this.solution.Clear();
        var succeeded = c.Execute(clipType, this.solution, Region.SUBJ_FILL_TYPE, Region.CLIP_FILL_TYPE);
        if (succeeded) {
            this.pathsToInternalPath(this.solution);
            // Not sure what this is returning
            //				var bounds = c.GetBounds ();
            //				regionBounds.X = bounds.left / scale;
            //				regionBounds.Y = bounds.top / scale;
            //				regionBounds.Width = (bounds.right - bounds.left) / scale;
            //				regionBounds.Height = (bounds.bottom - bounds.top) / scale;
            if (this.regionPath.IsEmpty)
                this.regionBounds = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty;
            else
                this.regionBounds = this.regionPath.getBounds();
        }
    };
    Region.prototype.pathsToInternalPath = function (paths) {
        var _this = this;
        this.regionPath = new _drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_2__.GraphicsPath();
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.foreach)(this.solution, function (poly) {
            var points = [];
            for (var p = 0; p < poly.Count; p++) {
                points.push(Region.IntPointToPointF(poly[p]));
            }
            _this.regionPath.addLines(points);
        });
    };
    Region.prototype.isInfinite = function (g) {
        return this.regionBounds.Equals(Region.infinite);
    };
    Region.prototype.isVisible = function () {
        // TODO: implement pointInPolygon algoritm
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // eoFill - A Boolean value that, if true, specifies to use the even-odd fill rule to evaluate
        // the painted region of the path. If false, the winding fill rule is used.
        //return regionPath.ContainsPoint (point.ToCGPoint (), EVEN_ODD_FILL);
        return false;
    };
    Region.prototype.isEmpty = function (g) {
        // TODO :
        return this.regionPath.IsEmpty;
    };
    Region.RectangleToPath = function (rect) {
        var path = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.List();
        path.Add(new _Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipPoint(rect.Left * Region.scale, rect.Top * Region.scale));
        path.Add(new _Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipPoint(rect.Right * Region.scale, rect.Top * Region.scale));
        path.Add(new _Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipPoint(rect.Right * Region.scale, rect.Bottom * Region.scale));
        path.Add(new _Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipPoint(rect.Left * Region.scale, rect.Bottom * Region.scale));
        path.Add(new _Clipper__WEBPACK_IMPORTED_MODULE_5__.ClipPoint(rect.Left * Region.scale, rect.Top * Region.scale));
        return path;
    };
    Region.IntPointToPointF = function (point) {
        return new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(point.X / Region.scale, point.Y / Region.scale);
    };
    Region.prototype.getRegionScans = function (matrix) {
        if (matrix == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException((0,_tuval_core__WEBPACK_IMPORTED_MODULE_1__.nameof)(matrix));
        }
        Region.NotImplemented('getRegionScans');
        return [this.getBounds()];
    };
    Region.NotImplemented = function (methodBase) {
        console.log("Not implemented:" + methodBase);
    };
    Region.SUBJ_FILL_TYPE = _Clipper__WEBPACK_IMPORTED_MODULE_5__.PolyFillType.pftNonZero;
    Region.CLIP_FILL_TYPE = _Clipper__WEBPACK_IMPORTED_MODULE_5__.PolyFillType.pftNonZero;
    Region.infinite = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(-4194304, -4194304, 8388608, 8388608);
    Region.scale = 10000; //or 1 or 10 or 10000 etc for lesser or greater precision.
    return Region;
}());



/***/ }),

/***/ "./src/drawing/RotateFlipType.ts":
/*!***************************************!*\
  !*** ./src/drawing/RotateFlipType.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RotateFlipType": () => (/* binding */ RotateFlipType)
/* harmony export */ });
var RotateFlipType;
(function (RotateFlipType) {
    RotateFlipType[RotateFlipType["Rotate180FlipXY"] = 0] = "Rotate180FlipXY";
    RotateFlipType[RotateFlipType["RotateNoneFlipNone"] = 0] = "RotateNoneFlipNone";
    RotateFlipType[RotateFlipType["Rotate270FlipXY"] = 1] = "Rotate270FlipXY";
    RotateFlipType[RotateFlipType["Rotate90FlipNone"] = 1] = "Rotate90FlipNone";
    RotateFlipType[RotateFlipType["Rotate180FlipNone"] = 2] = "Rotate180FlipNone";
    RotateFlipType[RotateFlipType["RotateNoneFlipXY"] = 2] = "RotateNoneFlipXY";
    RotateFlipType[RotateFlipType["Rotate270FlipNone"] = 3] = "Rotate270FlipNone";
    RotateFlipType[RotateFlipType["Rotate90FlipXY"] = 3] = "Rotate90FlipXY";
    RotateFlipType[RotateFlipType["Rotate180FlipY"] = 4] = "Rotate180FlipY";
    RotateFlipType[RotateFlipType["RotateNoneFlipX"] = 4] = "RotateNoneFlipX";
    RotateFlipType[RotateFlipType["Rotate270FlipY"] = 5] = "Rotate270FlipY";
    RotateFlipType[RotateFlipType["Rotate90FlipX"] = 5] = "Rotate90FlipX";
    RotateFlipType[RotateFlipType["Rotate180FlipX"] = 6] = "Rotate180FlipX";
    RotateFlipType[RotateFlipType["RotateNoneFlipY"] = 6] = "RotateNoneFlipY";
    RotateFlipType[RotateFlipType["Rotate270FlipX"] = 7] = "Rotate270FlipX";
    RotateFlipType[RotateFlipType["Rotate90FlipY"] = 7] = "Rotate90FlipY";
})(RotateFlipType || (RotateFlipType = {}));


/***/ }),

/***/ "./src/drawing/Shadow.ts":
/*!*******************************!*\
  !*** ./src/drawing/Shadow.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Shadow": () => (/* binding */ Shadow)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);

/**
 * This class encapsulates the properties required to define a shadow to apply to a {@link DisplayObject}
 * via its `shadow` property.
 *
 * @memberof easeljs
 * @example
 * img.shadow = new Shadow("#000000", 5, 5, 10);
 *
 * @param {String} [color=black] The color of the shadow. This can be any valid CSS color value.
 * @param {Number} [offsetX=0] The x offset of the shadow in pixels.
 * @param {Number} [offsetY=0] The y offset of the shadow in pixels.
 * @param {Number} [blur=0] The size of the blurring effect.
 */
var Shadow = /** @class */ (function () {
    function Shadow(color, offsetX, offsetY, blur) {
        if (color === void 0) { color = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(0, 0, 0); }
        if (offsetX === void 0) { offsetX = 0; }
        if (offsetY === void 0) { offsetY = 0; }
        if (blur === void 0) { blur = 0; }
        this.color = color;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.blur = blur;
    }
    /**
     * Returns a string representation of this object.
     * @return {String}
     */
    Shadow.prototype.toString = function () {
        return "[" + this.constructor.name + "]";
    };
    /**
     * Returns a clone of this Shadow instance.
     * @return {Shadow} A clone of the current Shadow instance.
     */
    Shadow.prototype.clone = function () {
        return new Shadow(this.color, this.offsetX, this.offsetY, this.blur);
    };
    return Shadow;
}());

/**
 * An identity shadow object (all properties are set to 0).
 * @type {Shadow}
 * @static
 * @readonly
 */
Shadow.identity = new Shadow(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(0, 0, 0, 0));


/***/ }),

/***/ "./src/drawing/SmoothingMode.ts":
/*!**************************************!*\
  !*** ./src/drawing/SmoothingMode.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SmoothingMode": () => (/* binding */ SmoothingMode),
/* harmony export */   "TextRenderingHint": () => (/* binding */ TextRenderingHint)
/* harmony export */ });
var SmoothingMode;
(function (SmoothingMode) {
    SmoothingMode[SmoothingMode["Invalid"] = -1] = "Invalid";
    SmoothingMode[SmoothingMode["Default"] = 0] = "Default";
    SmoothingMode[SmoothingMode["HighSpeed"] = 1] = "HighSpeed";
    SmoothingMode[SmoothingMode["HighQuality"] = 2] = "HighQuality";
    SmoothingMode[SmoothingMode["None"] = 3] = "None";
    SmoothingMode[SmoothingMode["AntiAlias"] = 4] = "AntiAlias";
})(SmoothingMode || (SmoothingMode = {}));
var TextRenderingHint;
(function (TextRenderingHint) {
    TextRenderingHint[TextRenderingHint["SystemDefault"] = 0] = "SystemDefault";
    TextRenderingHint[TextRenderingHint["SingleBitPerPixelGridFit"] = 1] = "SingleBitPerPixelGridFit";
    TextRenderingHint[TextRenderingHint["SingleBitPerPixel"] = 2] = "SingleBitPerPixel";
    TextRenderingHint[TextRenderingHint["AntiAliasGridFit"] = 3] = "AntiAliasGridFit";
    TextRenderingHint[TextRenderingHint["AntiAlias"] = 4] = "AntiAlias";
    TextRenderingHint[TextRenderingHint["ClearTypeGridFit"] = 5] = "ClearTypeGridFit";
})(TextRenderingHint || (TextRenderingHint = {}));


/***/ }),

/***/ "./src/drawing/SolidBrush.ts":
/*!***********************************!*\
  !*** ./src/drawing/SolidBrush.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SolidBrush": () => (/* binding */ SolidBrush)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Brush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Brush */ "./src/drawing/Brush.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Graphics */ "./src/drawing/Graphics.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../GDITypes */ "./src/GDITypes.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





var SolidBrush = /** @class */ (function (_super) {
    __extends(SolidBrush, _super);
    function SolidBrush(color, isModifiable) {
        if (isModifiable === void 0) { isModifiable = true; }
        var _this = _super.call(this) || this;
        _this.isModifiable = false;
        _this.isModified = false;
        _this.color = color;
        _this.isModifiable = isModifiable;
        return _this;
    }
    SolidBrush_1 = SolidBrush;
    Object.defineProperty(SolidBrush.prototype, "Color", {
        get: function () {
            return this.color;
        },
        set: function (value) {
            if (value.Equals(this.color)) {
                this.color = value;
                this.isModified = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    SolidBrush.prototype.Dispose = function (disposing) {
    };
    SolidBrush.prototype.Clone = function () {
        return new SolidBrush_1(this.color);
    };
    SolidBrush.prototype.setup = function (graphics, fill) {
        // Aadaki mod sketch modda kullanrken problem yaratyor. nk bir nceki brush
        // ayn olsa dahi sketch mod ta arkaplanda fill style deiebiliyor.
        /* if (graphics.LastBrush === this && !this.isModified)
            return; */
        _super.prototype.setup.call(this, graphics, fill);
        var sourceCopy = graphics.CompositingMode === _Graphics__WEBPACK_IMPORTED_MODULE_2__.CompositingMode.SourceCopy;
        if (fill) {
            graphics.renderer.setFillColor(this.color.R, this.color.G, this.color.B, sourceCopy ? 1 : this.color.A);
        }
        else {
            graphics.renderer.setStrokeColor(this.color.R, this.color.G, this.color.B, sourceCopy ? 1 : this.color.A);
        }
        graphics.LastBrush = this;
        this.isModified = false;
        // I am setting this to be used for Text coloring in DrawString
        graphics.LastBrushColor = this.color;
    };
    SolidBrush.prototype.equals = function (sb) {
        return this.color.Equals(sb.Color);
    };
    SolidBrush.prototype.getHashCode = function () {
        return this.color.getHashCode();
    };
    var SolidBrush_1;
    SolidBrush = SolidBrush_1 = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_3__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.SolidBrush,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.SolidBrush
            ]
        }),
        __metadata("design:paramtypes", [_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor, Boolean])
    ], SolidBrush);
    return SolidBrush;
}(_Brush__WEBPACK_IMPORTED_MODULE_1__.Brush));



/***/ }),

/***/ "./src/drawing/StringAlignment.ts":
/*!****************************************!*\
  !*** ./src/drawing/StringAlignment.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringAlignment": () => (/* binding */ StringAlignment)
/* harmony export */ });
var StringAlignment;
(function (StringAlignment) {
    StringAlignment[StringAlignment["Near"] = 0] = "Near";
    StringAlignment[StringAlignment["Center"] = 1] = "Center";
    StringAlignment[StringAlignment["Far"] = 2] = "Far";
})(StringAlignment || (StringAlignment = {}));


/***/ }),

/***/ "./src/drawing/StringFormat.ts":
/*!*************************************!*\
  !*** ./src/drawing/StringFormat.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringFormat": () => (/* binding */ StringFormat)
/* harmony export */ });
/* harmony import */ var _HotkeyPrefix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HotkeyPrefix */ "./src/drawing/HotkeyPrefix.ts");
/* harmony import */ var _StringAlignment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StringAlignment */ "./src/drawing/StringAlignment.ts");
/* harmony import */ var _StringFormatFlags__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StringFormatFlags */ "./src/drawing/StringFormatFlags.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../GDITypes */ "./src/GDITypes.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







var StringFormat = /** @class */ (function () {
    function StringFormat() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.myHotkeyPrefix = _HotkeyPrefix__WEBPACK_IMPORTED_MODULE_0__.HotkeyPrefix.None;
        this.myAlignment = undefined;
        this.myLineAlignment = undefined;
        this.myTrimming = undefined;
        this.myFormatFlags = _StringFormatFlags__WEBPACK_IMPORTED_MODULE_2__.StringFormatFlags.NoWrap;
        this.measurableCharacterRanges = undefined;
        if (args.length === 0) {
            this.Alignment = _StringAlignment__WEBPACK_IMPORTED_MODULE_1__.StringAlignment.Near;
            this.LineAlignment = _StringAlignment__WEBPACK_IMPORTED_MODULE_1__.StringAlignment.Near;
        }
        else if (args.length === 1 && args[0] instanceof StringFormat_1) {
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_3__.ArgumentNullException("format");
            }
            var format = args[0];
            this.Alignment = format.Alignment;
            this.LineAlignment = format.LineAlignment;
            this.FormatFlags = format.FormatFlags;
            this.Trimming = format.Trimming;
            this.HotkeyPrefix = format.HotkeyPrefix;
        }
        else if (args.length === 1 && typeof args[0] === 'number') {
            this.myFormatFlags = args[0];
        }
    }
    StringFormat_1 = StringFormat;
    Object.defineProperty(StringFormat.prototype, "Alignment", {
        get: function () {
            return this.myAlignment;
        },
        set: function (value) {
            this.myAlignment = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StringFormat.prototype, "LineAlignment", {
        get: function () {
            return this.myLineAlignment;
        },
        set: function (value) {
            this.myLineAlignment = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StringFormat.prototype, "Trimming", {
        get: function () {
            return this.myTrimming;
        },
        set: function (value) {
            this.myTrimming = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StringFormat.prototype, "FormatFlags", {
        get: function () {
            return this.myFormatFlags;
        },
        set: function (value) {
            this.myFormatFlags = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StringFormat.prototype, "HotkeyPrefix", {
        get: function () {
            return this.myHotkeyPrefix;
        },
        set: function (value) {
            this.myHotkeyPrefix = value;
        },
        enumerable: false,
        configurable: true
    });
    StringFormat.prototype.clone = function () {
        return new StringFormat_1(this);
    };
    Object.defineProperty(StringFormat, "GenericDefault", {
        get: function () {
            var format = new StringFormat_1();
            format.FormatFlags = 0;
            return format;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StringFormat, "GenericTypographic", {
        get: function () {
            var format = new StringFormat_1();
            format.FormatFlags = _StringFormatFlags__WEBPACK_IMPORTED_MODULE_2__.StringFormatFlags.FitBlackBox | _StringFormatFlags__WEBPACK_IMPORTED_MODULE_2__.StringFormatFlags.LineLimit | _StringFormatFlags__WEBPACK_IMPORTED_MODULE_2__.StringFormatFlags.NoClip;
            return format;
        },
        enumerable: false,
        configurable: true
    });
    StringFormat.prototype.setMeasurableCharacterRanges = function (ranges) {
        this.measurableCharacterRanges = ranges;
    };
    StringFormat.prototype.setTabStops = function (firstTabOffset, tabStops) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_3__.NotImplementedException('StringFormat::setTabStops');
    };
    /*public void SetDigitSubstitution(int language,  StringDigitSubstitute substitute)
    {
        throw new NotImplementedException ();
    }*/
    StringFormat.prototype.getTabStops = function (firstTabOffset) {
        throw new _tuval_core__WEBPACK_IMPORTED_MODULE_3__.NotImplementedException('StringFormat::getTabStops');
    };
    StringFormat.prototype.equals = function (f) {
        return (_tuval_core__WEBPACK_IMPORTED_MODULE_3__.is["typeof"](f, _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.StringFormat))
            && this.FormatFlags === f.FormatFlags
            && this.HotkeyPrefix === f.HotkeyPrefix
            && this.measurableCharacterRanges === f.measurableCharacterRanges
            && this.Alignment === f.Alignment
            && this.LineAlignment === f.LineAlignment
            && this.Trimming === f.Trimming;
    };
    var StringFormat_1;
    StringFormat = StringFormat_1 = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_3__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.StringFormat,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.StringFormat
            ]
        }),
        __metadata("design:paramtypes", [Object])
    ], StringFormat);
    return StringFormat;
}());



/***/ }),

/***/ "./src/drawing/StringFormatFlags.ts":
/*!******************************************!*\
  !*** ./src/drawing/StringFormatFlags.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringFormatFlags": () => (/* binding */ StringFormatFlags)
/* harmony export */ });
var StringFormatFlags;
(function (StringFormatFlags) {
    StringFormatFlags[StringFormatFlags["DirectionRightToLeft"] = 1] = "DirectionRightToLeft";
    StringFormatFlags[StringFormatFlags["DirectionVertical"] = 2] = "DirectionVertical";
    StringFormatFlags[StringFormatFlags["FitBlackBox"] = 4] = "FitBlackBox";
    StringFormatFlags[StringFormatFlags["DisplayFormatControl"] = 32] = "DisplayFormatControl";
    StringFormatFlags[StringFormatFlags["NoFontFallback"] = 1024] = "NoFontFallback";
    StringFormatFlags[StringFormatFlags["MeasureTrailingSpaces"] = 2048] = "MeasureTrailingSpaces";
    StringFormatFlags[StringFormatFlags["NoWrap"] = 4096] = "NoWrap";
    StringFormatFlags[StringFormatFlags["LineLimit"] = 8192] = "LineLimit";
    StringFormatFlags[StringFormatFlags["NoClip"] = 16384] = "NoClip";
})(StringFormatFlags || (StringFormatFlags = {}));


/***/ }),

/***/ "./src/drawing/StringTrimming.ts":
/*!***************************************!*\
  !*** ./src/drawing/StringTrimming.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringTrimming": () => (/* binding */ StringTrimming)
/* harmony export */ });
var StringTrimming;
(function (StringTrimming) {
    StringTrimming[StringTrimming["None"] = 0] = "None";
    StringTrimming[StringTrimming["Character"] = 1] = "Character";
    StringTrimming[StringTrimming["Word"] = 2] = "Word";
    StringTrimming[StringTrimming["EllipsisCharacter"] = 3] = "EllipsisCharacter";
    StringTrimming[StringTrimming["EllipsisWord"] = 4] = "EllipsisWord";
    StringTrimming[StringTrimming["EllipsisPath"] = 5] = "EllipsisPath";
})(StringTrimming || (StringTrimming = {}));


/***/ }),

/***/ "./src/drawing/SystemBrushes.ts":
/*!**************************************!*\
  !*** ./src/drawing/SystemBrushes.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SystemBrushes": () => (/* binding */ SystemBrushes)
/* harmony export */ });
/* harmony import */ var _SolidBrush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _SystemColors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SystemColors */ "./src/drawing/SystemColors.ts");


var SystemBrushes = /** @class */ (function () {
    function SystemBrushes() {
    }
    SystemBrushes.ActiveBorder = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ActiveBorder);
    SystemBrushes.ActiveCaption = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ActiveCaption);
    SystemBrushes.ActiveCaptionText = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ActiveCaptionText);
    SystemBrushes.AppWorkspace = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.AppWorkspace);
    SystemBrushes.ButtonFace = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ButtonFace);
    SystemBrushes.ButtonHighlight = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ButtonHighlight);
    SystemBrushes.ButtonShadow = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ButtonShadow);
    SystemBrushes.Control = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Control);
    SystemBrushes.ControlLightLight = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ControlLightLight);
    SystemBrushes.ControlLight = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ControlLight);
    SystemBrushes.ControlDark = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ControlDark);
    SystemBrushes.ControlDarkDark = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ControlDarkDark);
    SystemBrushes.ControlText = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ControlText);
    SystemBrushes.Desktop = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Desktop);
    SystemBrushes.GradientActiveCaption = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.GradientActiveCaption);
    SystemBrushes.GradientInactiveCaption = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.GradientInactiveCaption);
    SystemBrushes.GrayText = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.GrayText);
    SystemBrushes.Highlight = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Highlight);
    SystemBrushes.HighlightText = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.HighlightText);
    SystemBrushes.HotTrack = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.HotTrack);
    SystemBrushes.InactiveCaption = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.InactiveCaption);
    SystemBrushes.InactiveBorder = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.InactiveBorder);
    SystemBrushes.InactiveCaptionText = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.InactiveCaptionText);
    SystemBrushes.Info = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Info);
    SystemBrushes.InfoText = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.InfoText);
    SystemBrushes.Menu = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Menu);
    SystemBrushes.MenuBar = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.MenuBar);
    SystemBrushes.MenuHighlight = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.MenuHighlight);
    SystemBrushes.MenuText = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.MenuText);
    SystemBrushes.ScrollBar = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ScrollBar);
    SystemBrushes.Window = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Window);
    SystemBrushes.WindowFrame = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.WindowFrame);
    SystemBrushes.WindowText = new _SolidBrush__WEBPACK_IMPORTED_MODULE_0__.SolidBrush(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.WindowText);
    return SystemBrushes;
}());



/***/ }),

/***/ "./src/drawing/SystemColors.ts":
/*!*************************************!*\
  !*** ./src/drawing/SystemColors.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SystemColors": () => (/* binding */ SystemColors)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);

var SystemColors = /** @class */ (function () {
    function SystemColors() {
    }
    SystemColors.ActiveBorder = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ActiveBorder);
    SystemColors.ActiveCaption = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ActiveCaption);
    SystemColors.ActiveCaptionText = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ActiveCaptionText);
    SystemColors.AppWorkspace = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.AppWorkspace);
    SystemColors.ButtonFace = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ButtonFace);
    SystemColors.ButtonHighlight = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ButtonHighlight);
    SystemColors.ButtonShadow = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ButtonShadow);
    SystemColors.Control = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.Control);
    SystemColors.ControlDark = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ControlDark);
    SystemColors.ControlDarkDark = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ControlDarkDark);
    SystemColors.ControlLight = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ControlLight);
    SystemColors.ControlLightLight = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ControlLightLight);
    SystemColors.ControlText = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ControlText);
    SystemColors.Desktop = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.Desktop);
    SystemColors.GradientActiveCaption = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.GradientActiveCaption);
    SystemColors.GradientInactiveCaption = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.GradientInactiveCaption);
    SystemColors.GrayText = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.GrayText);
    SystemColors.Highlight = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.Highlight);
    SystemColors.HighlightText = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.HighlightText);
    SystemColors.HotTrack = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.HotTrack);
    SystemColors.InactiveBorder = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.InactiveBorder);
    SystemColors.InactiveCaption = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.InactiveCaption);
    SystemColors.InactiveCaptionText = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.InactiveCaptionText);
    SystemColors.Info = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.Info);
    SystemColors.InfoText = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.InfoText);
    SystemColors.Menu = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.Menu);
    SystemColors.MenuBar = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.MenuBar);
    SystemColors.MenuHighlight = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.MenuHighlight);
    SystemColors.MenuText = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.MenuText);
    SystemColors.ScrollBar = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.ScrollBar);
    SystemColors.Window = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.Window);
    SystemColors.WindowFrame = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.WindowFrame);
    SystemColors.WindowText = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColors.FromKnownColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.KnownColor.WindowText);
    return SystemColors;
}());



/***/ }),

/***/ "./src/drawing/SystemFonts.ts":
/*!************************************!*\
  !*** ./src/drawing/SystemFonts.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SystemFonts": () => (/* binding */ SystemFonts)
/* harmony export */ });
/* harmony import */ var _Font__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Font */ "./src/drawing/Font.ts");

var SystemFonts = /** @class */ (function () {
    function SystemFonts() {
    }
    SystemFonts.StaticConstructor = function () {
        SystemFonts.CaptionFont = new _Font__WEBPACK_IMPORTED_MODULE_0__.Font('Tahoma', 8);
        SystemFonts.DefaultFont = new _Font__WEBPACK_IMPORTED_MODULE_0__.Font('Tahoma', 8);
        SystemFonts.DialogFont = new _Font__WEBPACK_IMPORTED_MODULE_0__.Font('Tahoma', 8);
        SystemFonts.IconTitleFont = new _Font__WEBPACK_IMPORTED_MODULE_0__.Font('Tahoma', 8);
        SystemFonts.MenuFont = new _Font__WEBPACK_IMPORTED_MODULE_0__.Font('Tahoma', 8);
        SystemFonts.MessageBoxFont = new _Font__WEBPACK_IMPORTED_MODULE_0__.Font('Tahoma', 8);
        SystemFonts.SmallCaptionFont = new _Font__WEBPACK_IMPORTED_MODULE_0__.Font('Tahoma', 8);
        SystemFonts.StatusFont = new _Font__WEBPACK_IMPORTED_MODULE_0__.Font('Tahoma', 8);
    };
    SystemFonts.GetFontByName = function (systemFontName) {
        if (systemFontName == "CaptionFont")
            return SystemFonts.CaptionFont;
        if (systemFontName == "DefaultFont")
            return SystemFonts.DefaultFont;
        if (systemFontName == "DialogFont")
            return SystemFonts.DialogFont;
        if (systemFontName == "IconTitleFont")
            return SystemFonts.IconTitleFont;
        if (systemFontName == "MenuFont")
            return SystemFonts.MenuFont;
        if (systemFontName == "MessageBoxFont")
            return SystemFonts.MessageBoxFont;
        if (systemFontName == "SmallCaptionFont")
            return SystemFonts.SmallCaptionFont;
        if (systemFontName == "StatusFont")
            return SystemFonts.StatusFont;
        return null;
    };
    SystemFonts.CaptionFont = null;
    SystemFonts.DefaultFont = null;
    SystemFonts.DialogFont = null;
    SystemFonts.IconTitleFont = null;
    SystemFonts.MenuFont = null;
    SystemFonts.MessageBoxFont = null;
    SystemFonts.SmallCaptionFont = null;
    SystemFonts.StatusFont = null;
    return SystemFonts;
}());

SystemFonts.StaticConstructor();


/***/ }),

/***/ "./src/drawing/SystemPens.ts":
/*!***********************************!*\
  !*** ./src/drawing/SystemPens.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SystemPens": () => (/* binding */ SystemPens)
/* harmony export */ });
/* harmony import */ var _Pen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pen */ "./src/drawing/Pen.ts");
/* harmony import */ var _SystemColors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SystemColors */ "./src/drawing/SystemColors.ts");


var SystemPens = /** @class */ (function () {
    function SystemPens() {
    }
    SystemPens.ActiveBorder = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ActiveBorder);
    SystemPens.ActiveCaption = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ActiveCaption);
    SystemPens.ActiveCaptionText = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ActiveCaptionText);
    SystemPens.AppWorkspace = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.AppWorkspace);
    SystemPens.ButtonFace = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ButtonFace);
    SystemPens.ButtonHighlight = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ButtonHighlight);
    SystemPens.ButtonShadow = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ButtonShadow);
    SystemPens.Control = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Control);
    SystemPens.ControlText = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ControlText);
    SystemPens.ControlDark = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ControlDark);
    SystemPens.ControlDarkDark = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ControlDarkDark);
    SystemPens.ControlLight = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ControlLight);
    SystemPens.ControlLightLight = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ControlLightLight);
    SystemPens.Desktop = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Desktop);
    SystemPens.GradientActiveCaption = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.GradientActiveCaption);
    SystemPens.GradientInactiveCaption = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.GradientInactiveCaption);
    SystemPens.GrayText = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.GrayText);
    SystemPens.Highlight = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Highlight);
    SystemPens.HighlightText = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.HighlightText);
    SystemPens.HotTrack = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.HotTrack);
    SystemPens.InactiveBorder = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.InactiveBorder);
    SystemPens.InactiveCaption = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.InactiveCaption);
    SystemPens.InactiveCaptionText = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.InactiveCaptionText);
    SystemPens.Info = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Info);
    SystemPens.InfoText = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.InfoText);
    SystemPens.Menu = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Menu);
    SystemPens.MenuBar = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.MenuBar);
    SystemPens.MenuHighlight = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.MenuHighlight);
    SystemPens.MenuText = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.MenuText);
    SystemPens.ScrollBar = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.ScrollBar);
    SystemPens.Window = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.Window);
    SystemPens.WindowFrame = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.WindowFrame);
    SystemPens.WindowText = new _Pen__WEBPACK_IMPORTED_MODULE_0__.Pen(_SystemColors__WEBPACK_IMPORTED_MODULE_1__.SystemColors.WindowText);
    return SystemPens;
}());



/***/ }),

/***/ "./src/drawing/TextureBrush.ts":
/*!*************************************!*\
  !*** ./src/drawing/TextureBrush.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureBrush": () => (/* binding */ TextureBrush)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Brush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Brush */ "./src/drawing/Brush.ts");
/* harmony import */ var _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawing2D/Matrix */ "./src/drawing/drawing2D/Matrix.ts");
/* harmony import */ var _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawing2D/WrapMode */ "./src/drawing/drawing2D/WrapMode.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../GDITypes */ "./src/GDITypes.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








var TextureBrush = /** @class */ (function (_super) {
    __extends(TextureBrush, _super);
    function TextureBrush(image, wrapMode) {
        if (wrapMode === void 0) { wrapMode = _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__.WrapMode.Tile; }
        var _this = _super.call(this) || this;
        _this.textureTransform = new _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix();
        _this.wrapMode = _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__.WrapMode.Tile;
        _this._changed = false;
        if (image == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_4__.ArgumentNullException("image");
        }
        _this.textureImage = image;
        _this.wrapMode = wrapMode;
        return _this;
    }
    Object.defineProperty(TextureBrush.prototype, "Image", {
        get: function () {
            return this.textureImage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextureBrush.prototype, "Transform", {
        get: function () {
            return this.textureTransform;
        },
        set: function (value) {
            if (value == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_4__.ArgumentNullException("value");
            }
            this.textureTransform = value.clone();
            this._changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextureBrush.prototype, "WrapMode", {
        get: function () {
            return this.wrapMode;
        },
        set: function (value) {
            if (this.wrapMode !== value) {
                this.wrapMode = value;
                this._changed = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    TextureBrush.prototype.multiplyTransform = function (matrix, order) {
        if (order === void 0) { order = _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_2__.MatrixOrder.Prepend; }
        if (matrix == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_4__.ArgumentNullException("matrix");
        }
        this.textureTransform.multiply(matrix, order);
        this._changed = true;
    };
    TextureBrush.prototype.resetTransform = function () {
        this.textureTransform.reset();
        this._changed = true;
    };
    TextureBrush.prototype.rotateTransform = function (angle, order) {
        if (order === void 0) { order = _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_2__.MatrixOrder.Prepend; }
        this.textureTransform.rotate(angle, order);
        this._changed = true;
    };
    TextureBrush.prototype.scaleTransform = function (sx, sy, order) {
        if (order === void 0) { order = _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_2__.MatrixOrder.Prepend; }
        this.textureTransform.scale(sx, sy, order);
        this._changed = true;
    };
    TextureBrush.prototype.translateTransform = function (dx, dy, order) {
        if (order === void 0) { order = _drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_2__.MatrixOrder.Prepend; }
        this.textureTransform.translate(dx, dy, order);
        this._changed = true;
    };
    TextureBrush.prototype.drawTexture = function (context) {
        var destRect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, this.textureImage.Width, this.textureImage.Height);
        context.concatCTM(this.textureImage.imageTransform);
        context.drawImage(this.textureImage.canvas, 0, 0);
        context.concatCTM(this.textureImage.imageTransform.invert());
        if (this.wrapMode === _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__.WrapMode.Tile) {
            context.drawImage(this.textureImage.canvas, 0, 0, destRect.Width, destRect.Height, destRect.X, destRect.Y, destRect.Width, destRect.Height);
        }
        if (this.wrapMode === _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__.WrapMode.TileFlipX || this.wrapMode === _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__.WrapMode.TileFlipXY) {
            context.concatCTM(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeScale(-1, 1));
            context.concatCTM(this.textureImage.imageTransform);
            context.drawImage(this.textureImage.canvas, 0, 0, destRect.Width, destRect.Height, destRect.X, destRect.Y, destRect.Width, destRect.Height);
            context.concatCTM(this.textureImage.imageTransform.invert());
        }
        if (this.wrapMode === _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__.WrapMode.TileFlipY || this.wrapMode === _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__.WrapMode.TileFlipXY) {
            var transformY = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform(1, 0, 0, -1, destRect.Width, destRect.Height);
            context.concatCTM(transformY);
            context.concatCTM(this.textureImage.imageTransform);
            context.drawImage(this.textureImage.canvas, 0, 0, destRect.Width, destRect.Height, destRect.X, destRect.Y, destRect.Width, destRect.Height);
            context.concatCTM(this.textureImage.imageTransform.invert());
        }
        if (this.wrapMode === _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__.WrapMode.TileFlipXY) {
            // draw the last one of the quadrant which is flipped by both the y and x axis
            var transform = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform(-1, 0, 0, -1, destRect.Width * 2, destRect.Height);
            context.concatCTM(transform);
            context.concatCTM(this.textureImage.imageTransform);
            context.drawImage(this.textureImage.canvas, 0, 0, destRect.Width, destRect.Height, destRect.X, destRect.Y, destRect.Width, destRect.Height);
            context.concatCTM(this.textureImage.imageTransform.invert());
        }
    };
    TextureBrush.prototype.setup = function (graphics, fill) {
        var HALF_PIXEL_X = 0.5;
        var HALF_PIXEL_Y = 0.5;
        // if this is the same as the last that was set then return and no changes have been made
        // then return.
        if (graphics.LastBrush == this && !this._changed) {
            return;
        }
        // obtain our width and height so we can set the pattern rectangle
        var textureWidth = this.textureImage.Width;
        var textureHeight = this.textureImage.Height;
        if (this.wrapMode === _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__.WrapMode.TileFlipX || this.wrapMode === _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__.WrapMode.TileFlipY)
            textureWidth *= 2;
        if (this.wrapMode === _drawing2D_WrapMode__WEBPACK_IMPORTED_MODULE_3__.WrapMode.TileFlipXY) {
            textureWidth *= 2;
            textureHeight *= 2;
        }
        //choose the pattern to be filled based on the currentPattern selected
        /* var patternSpace = CGColorSpace.CreatePattern(null);
        graphics.context.SetFillColorSpace(patternSpace);
        patternSpace.Dispose(); */
        // Pattern default work variables
        var patternRect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(HALF_PIXEL_X, HALF_PIXEL_Y, textureWidth + HALF_PIXEL_X, textureHeight + HALF_PIXEL_Y);
        //var patternTransform = graphics.context.getCTM();
        //patternTransform = CGAffineTransform.Multiply(this.textureTransform.transform, patternTransform);
        var patternTransform = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeIdentity();
        patternTransform.multiply(this.textureTransform.transform);
        // DrawPattern callback which will be set depending on hatch style
        var drawPattern;
        drawPattern = this.drawTexture;
        //set the pattern as the Current Contexts fill pattern
        var pattern = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPattern(patternRect, patternTransform, textureWidth, textureHeight, 
        //textureHeight,
        _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPatternTiling.NoDistortion, true, drawPattern.bind(this), this.wrapMode);
        //we dont need to set any color, as the pattern cell itself has chosen its own color
        var aone = [1];
        graphics.renderer.setFillPattern(pattern, aone);
        graphics.renderer.setStrokePattern(pattern, aone);
        this._changed = false;
        graphics.LastBrush = this;
        //graphics.lastBrushColor = foreColor;
    };
    TextureBrush = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_4__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_5__.GraphicTypes.TextureBrush,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_5__.GraphicTypes.TextureBrush
            ]
        }),
        __metadata("design:paramtypes", [_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGImage, Number])
    ], TextureBrush);
    return TextureBrush;
}(_Brush__WEBPACK_IMPORTED_MODULE_1__.Brush));



/***/ }),

/***/ "./src/drawing/createCanvasElement.ts":
/*!********************************************!*\
  !*** ./src/drawing/createCanvasElement.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCanvasElement": () => (/* binding */ createCanvasElement),
/* harmony export */   "get2DCanvasContext": () => (/* binding */ get2DCanvasContext)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);

function createCanvasElement() {
    if (_tuval_core__WEBPACK_IMPORTED_MODULE_0__.is.workerContext()) {
        return new OffscreenCanvas(1, 1);
    }
    else {
        var canvas = window.document.createElement('canvas');
        try {
            canvas.style = canvas.style || {};
        }
        catch (e) {
            return canvas;
        }
        return canvas;
    }
}
function get2DCanvasContext(canvas) {
    return canvas.getContext('2d');
}


/***/ }),

/***/ "./src/drawing/drawing2D/Blend.ts":
/*!****************************************!*\
  !*** ./src/drawing/drawing2D/Blend.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Blend": () => (/* binding */ Blend)
/* harmony export */ });
var Blend = /** @class */ (function () {
    function Blend(count) {
        if (count === void 0) { count = 1; }
        this.Factors = new Array(count);
        this.Positions = new Array(count);
    }
    return Blend;
}());



/***/ }),

/***/ "./src/drawing/drawing2D/ColorBlend.ts":
/*!*********************************************!*\
  !*** ./src/drawing/drawing2D/ColorBlend.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorBlend": () => (/* binding */ ColorBlend)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);

var ColorBlend = /** @class */ (function () {
    function ColorBlend(count) {
        if (count === void 0) { count = 1; }
        this.Colors = new Array(count);
        for (var i = 0; i < this.Colors.length; i++) {
            this.Colors[i] = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Black;
        }
        this.Positions = new Array(count);
        for (var i = 0; i < this.Positions.length; i++) {
            this.Positions[i] = 0;
        }
    }
    return ColorBlend;
}());



/***/ }),

/***/ "./src/drawing/drawing2D/CombineMode.ts":
/*!**********************************************!*\
  !*** ./src/drawing/drawing2D/CombineMode.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CombineMode": () => (/* binding */ CombineMode)
/* harmony export */ });
var CombineMode;
(function (CombineMode) {
    CombineMode[CombineMode["Replace"] = 0] = "Replace";
    CombineMode[CombineMode["Intersect"] = 1] = "Intersect";
    CombineMode[CombineMode["Union"] = 2] = "Union";
    CombineMode[CombineMode["Xor"] = 3] = "Xor";
    CombineMode[CombineMode["Exclude"] = 4] = "Exclude";
    CombineMode[CombineMode["Complement"] = 5] = "Complement";
})(CombineMode || (CombineMode = {}));


/***/ }),

/***/ "./src/drawing/drawing2D/CompositingQuality.ts":
/*!*****************************************************!*\
  !*** ./src/drawing/drawing2D/CompositingQuality.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CompositingQuality": () => (/* binding */ CompositingQuality)
/* harmony export */ });
var CompositingQuality;
(function (CompositingQuality) {
    CompositingQuality[CompositingQuality["Invalid"] = -1] = "Invalid";
    CompositingQuality[CompositingQuality["Default"] = 0] = "Default";
    CompositingQuality[CompositingQuality["HighSpeed"] = 1] = "HighSpeed";
    CompositingQuality[CompositingQuality["HighQuality"] = 2] = "HighQuality";
    CompositingQuality[CompositingQuality["GammaCorrected"] = 3] = "GammaCorrected";
    CompositingQuality[CompositingQuality["AssumeLinear"] = 4] = "AssumeLinear";
})(CompositingQuality || (CompositingQuality = {}));


/***/ }),

/***/ "./src/drawing/drawing2D/CoordinateSpace.ts":
/*!**************************************************!*\
  !*** ./src/drawing/drawing2D/CoordinateSpace.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CoordinateSpace": () => (/* binding */ CoordinateSpace)
/* harmony export */ });
var CoordinateSpace;
(function (CoordinateSpace) {
    CoordinateSpace[CoordinateSpace["World"] = 0] = "World";
    CoordinateSpace[CoordinateSpace["Page"] = 1] = "Page";
    CoordinateSpace[CoordinateSpace["Device"] = 2] = "Device";
})(CoordinateSpace || (CoordinateSpace = {}));


/***/ }),

/***/ "./src/drawing/drawing2D/DashStyle.ts":
/*!********************************************!*\
  !*** ./src/drawing/drawing2D/DashStyle.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DashStyle": () => (/* binding */ DashStyle)
/* harmony export */ });
var DashStyle;
(function (DashStyle) {
    DashStyle[DashStyle["Solid"] = 0] = "Solid";
    DashStyle[DashStyle["Dash"] = 1] = "Dash";
    DashStyle[DashStyle["Dot"] = 2] = "Dot";
    DashStyle[DashStyle["DashDot"] = 3] = "DashDot";
    DashStyle[DashStyle["DashDotDot"] = 4] = "DashDotDot";
    DashStyle[DashStyle["Custom"] = 5] = "Custom";
})(DashStyle || (DashStyle = {}));


/***/ }),

/***/ "./src/drawing/drawing2D/FillMode.ts":
/*!*******************************************!*\
  !*** ./src/drawing/drawing2D/FillMode.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FillMode": () => (/* binding */ FillMode)
/* harmony export */ });
var FillMode;
(function (FillMode) {
    FillMode[FillMode["Alternate"] = 0] = "Alternate";
    FillMode[FillMode["Winding"] = 1] = "Winding";
})(FillMode || (FillMode = {}));


/***/ }),

/***/ "./src/drawing/drawing2D/FlushIntention.ts":
/*!*************************************************!*\
  !*** ./src/drawing/drawing2D/FlushIntention.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FlushIntention": () => (/* binding */ FlushIntention)
/* harmony export */ });
// FlushIntentionFlush merely means that all the pending commands have been passed to
// the hardware, and that the final results will be shown as soon as the hardware finishes
// its rendering.  FlushIntentionSync means to wait for the hardware to actually finish its
// rendering before returning - this is important for animation and timing loops.
var FlushIntention;
(function (FlushIntention) {
    // Flush all batched rendering operations
    FlushIntention[FlushIntention["Flush"] = 0] = "Flush";
    // Flush all batched rendering operations and wait for them to complete
    FlushIntention[FlushIntention["Sync"] = 1] = "Sync";
})(FlushIntention || (FlushIntention = {}));


/***/ }),

/***/ "./src/drawing/drawing2D/GraphicsPath.ts":
/*!***********************************************!*\
  !*** ./src/drawing/drawing2D/GraphicsPath.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CurveType": () => (/* binding */ CurveType),
/* harmony export */   "CURVE_MIN_TERMS": () => (/* binding */ CURVE_MIN_TERMS),
/* harmony export */   "CURVE_MAX_TERMS": () => (/* binding */ CURVE_MAX_TERMS),
/* harmony export */   "GraphicsPath": () => (/* binding */ GraphicsPath)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _PathData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PathData */ "./src/drawing/drawing2D/PathData.ts");
/* harmony import */ var _FillMode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FillMode */ "./src/drawing/drawing2D/FillMode.ts");
/* harmony import */ var _PathPointType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PathPointType */ "./src/drawing/PathPointType.ts");
/* harmony import */ var _GeomUtilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../GeomUtilities */ "./src/drawing/GeomUtilities.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Graphics */ "./src/drawing/Graphics.ts");
/* harmony import */ var _Region__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Region */ "./src/drawing/Region.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_8__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










var CurveType;
(function (CurveType) {
    CurveType[CurveType["Open"] = 0] = "Open";
    CurveType[CurveType["Close"] = 1] = "Close";
})(CurveType || (CurveType = {}));
var CURVE_MIN_TERMS = 1;
var CURVE_MAX_TERMS = 7;
var FLATTEN_RECURSION_LIMIT = 10;
var scale = 10000;
var GraphicsPath = /** @class */ (function () {
    function GraphicsPath(pts, types, fillMode) {
        this.start_new_fig = true;
        this.isReverseWindingOnFill = false;
        if (pts == null) {
            this.fillMode = _FillMode__WEBPACK_IMPORTED_MODULE_2__.FillMode.Alternate;
            this.points = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List();
            this.types = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List();
        }
        else if (Array.isArray(pts)) {
            if (pts == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('pts');
            if (types == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('types');
            if (pts.length !== types.length) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('Invalid parameter passed. Number of points and types must be same.');
            }
            this.fillMode = fillMode;
            (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.foreach)(types, function (type) {
                if (type === 0 || type === 1 || type === 3 || type === 16 || type === 32 || type === 128 || type === 129 || type === 131)
                    return _tuval_core__WEBPACK_IMPORTED_MODULE_8__.CONTINUE;
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('The pts array contains an invalid value for PathPointType: ' + type);
            });
            this.points = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List(pts);
            this.types = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List(types);
        }
        else {
            this.fillMode = pts;
            this.points = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List();
            this.types = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List();
        }
    }
    GraphicsPath_1 = GraphicsPath;
    Object.defineProperty(GraphicsPath.prototype, "PathPoints", {
        get: function () {
            return this.points.ToArray();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsPath.prototype, "PathTypes", {
        get: function () {
            return this.types.ToArray();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsPath.prototype, "PointCount", {
        get: function () {
            return this.points.Count;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsPath.prototype, "PathData", {
        get: function () {
            return new _PathData__WEBPACK_IMPORTED_MODULE_1__.PathData(this.points.ToArray(), this.types.ToArray());
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsPath.prototype, "FillMode", {
        get: function () {
            return this.fillMode;
        },
        set: function (value) {
            this.fillMode = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphicsPath.prototype, "IsEmpty", {
        get: function () {
            return this.points.Count === 0;
        },
        enumerable: false,
        configurable: true
    });
    GraphicsPath.prototype.append = function (x, y, type, compress) {
        var t = type;
        var pt = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        /* in some case we're allowed to compress identical points */
        if (compress && this.points.Count > 0) {
            /* points (X, Y) must be identical */
            var lastPoint = this.points.Get(this.points.Count - 1);
            if (lastPoint.X === x && lastPoint.Y === y) {
                /* types need not be identical but must handle closed subpaths */
                var last_type = this.types.Get(this.types.Count - 1);
                if ((last_type & _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.CloseSubpath) !== _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.CloseSubpath)
                    return;
            }
        }
        if (this.start_new_fig)
            t = _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start;
        /* if we closed a subpath, then start new figure and append */ else if (this.points.Count > 0) {
            type = this.types.Get(this.types.Count - 1);
            if ((type & _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.CloseSubpath) !== 0)
                t = _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start;
        }
        pt.X = x;
        pt.Y = y;
        this.points.Add(pt);
        this.types.Add(t);
        this.start_new_fig = false;
    };
    GraphicsPath.prototype.appendBezier = function (x1, y1, x2, y2, x3, y3) {
        if (this.isReverseWindingOnFill) {
            this.append(y1, x1, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Bezier3, false);
            this.append(y2, x2, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Bezier3, false);
            this.append(y3, x3, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Bezier3, false);
        }
        else {
            this.append(x1, y1, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Bezier3, false);
            this.append(x2, y2, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Bezier3, false);
            this.append(x3, y3, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Bezier3, false);
        }
    };
    GraphicsPath.prototype.appendArc = function (start, x, y, width, height, startAngle, endAngle) {
        var delta, bcp;
        var sin_alpha, sin_beta, cos_alpha, cos_beta;
        var rx = width / 2;
        var ry = height / 2;
        /* center */
        var cx = x + rx;
        var cy = y + ry;
        /* angles in radians */
        var alpha = (startAngle * Math.PI) / 180;
        var beta = (endAngle * Math.PI) / 180;
        /* adjust angles for ellipses */
        alpha = Math.atan2(rx * Math.sin(alpha), ry * Math.cos(alpha));
        beta = Math.atan2(rx * Math.sin(beta), ry * Math.cos(beta));
        if (Math.abs(beta - alpha) > Math.PI) {
            if (beta > alpha)
                beta -= 2 * Math.PI;
            else
                alpha -= 2 * Math.PI;
        }
        delta = beta - alpha;
        // http://www.stillhq.com/ctpfaq/2001/comp.text.pdf-faq-2001-04.txt (section 2.13)
        bcp = ((4.0 / 3) * (1 - Math.cos(delta / 2))) / Math.sin(delta / 2);
        sin_alpha = Math.sin(alpha);
        sin_beta = Math.sin(beta);
        cos_alpha = Math.cos(alpha);
        cos_beta = Math.cos(beta);
        // move to the starting point if we're not continuing a curve
        if (start) {
            // starting point
            var sx = cx + rx * cos_alpha;
            var sy = cy + ry * sin_alpha;
            this.append(sx, sy, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, false);
        }
        this.appendBezier(cx + rx * (cos_alpha - bcp * sin_alpha), cy + ry * (sin_alpha + bcp * cos_alpha), cx + rx * (cos_beta + bcp * sin_beta), cy + ry * (sin_beta - bcp * cos_beta), cx + rx * cos_beta, cy + ry * sin_beta);
    };
    GraphicsPath.NearZero = function (value) {
        return value >= -0.0001 && value <= 0.0001;
    };
    GraphicsPath.prototype.appendArcs = function (x, y, width, height, startAngle, sweepAngle) {
        var drawn = 0;
        var increment;
        var endAngle;
        var enough = false;
        if (Math.abs(sweepAngle) >= 360) {
            this.addEllipse(x, y, width, height);
            return;
        }
        endAngle = startAngle + sweepAngle;
        increment = endAngle < startAngle ? -90 : 90;
        // i is the number of sub-arcs drawn, each sub-arc can be at most 90 degrees.
        // there can be no more then 4 subarcs, ie. 90 + 90 + 90 + (something less than 90)
        for (var i = 0; i < 4; i++) {
            var current = startAngle + drawn;
            var additional = void 0;
            if (enough)
                return;
            additional = endAngle - current; /* otherwise, add the remainder */
            if (Math.abs(additional) > 90) {
                additional = increment;
            }
            else {
                // a near zero value will introduce bad artefact in the drawing (Novell #78999)
                if (GraphicsPath_1.NearZero(additional))
                    return;
                enough = true;
            }
            /* only move to the starting pt in the 1st iteration */
            this.appendArc(i === 0, x, y, width, height /* bounding rectangle */, current, current + additional);
            drawn += additional;
        }
    };
    GraphicsPath.prototype.appendPoint = function (point, type, compress) {
        this.append(point.X, point.Y, type, compress);
    };
    GraphicsPath.prototype.appendCurve = function (points, tangents, offset, length, type) {
        var ptype = type === CurveType.Close || points.length === 0 ? _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start : _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line;
        var i;
        this.appendPoint(points[offset], ptype, true);
        for (i = offset; i < offset + length; i++) {
            var j = i + 1;
            var x1 = points[i].X + tangents[i].X;
            var y1 = points[i].Y + tangents[i].Y;
            var x2 = points[j].X - tangents[j].X;
            var y2 = points[j].Y - tangents[j].Y;
            var x3 = points[j].X;
            var y3 = points[j].Y;
            this.appendBezier(x1, y1, x2, y2, x3, y3);
        }
        /* complete (close) the curve using the first point */
        if (type === CurveType.Close) {
            var x1 = points[i].X + tangents[i].X;
            var y1 = points[i].Y + tangents[i].Y;
            var x2 = points[0].X - tangents[0].X;
            var y2 = points[0].Y - tangents[0].Y;
            var x3 = points[0].X;
            var y3 = points[0].Y;
            this.appendBezier(x1, y1, x2, y2, x3, y3);
            this.closeFigure();
        }
    };
    GraphicsPath.prototype.addClosedCurve = function (points, tension) {
        if (tension === void 0) { tension = 0.5; }
        if (points == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('points');
        if (points.length < 3)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('number of points');
        var tangents = _GeomUtilities__WEBPACK_IMPORTED_MODULE_4__.GeomUtilities.GetCurveTangents(CURVE_MIN_TERMS, points, points.length, tension, CurveType.Close);
        this.appendCurve(points, tangents, 0, points.length - 1, CurveType.Close);
    };
    GraphicsPath.prototype.addCurve = function (param1, param2, param3, param4) {
        if (arguments.length === 1 || arguments.length === 2) {
            var points = param1;
            var tension = param2 == null ? 0.5 : param2;
            if (points == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('points');
            if (points.length < 2)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('not enough points for polygon', 'points');
            var tangents = _GeomUtilities__WEBPACK_IMPORTED_MODULE_4__.GeomUtilities.GetCurveTangents(CURVE_MIN_TERMS, points, points.length, tension, CurveType.Open);
            this.appendCurve(points, tangents, 0, points.length - 1, CurveType.Open);
        }
        else if (arguments.length > 2) {
            var points = param1;
            var numberOfSegments = param3;
            var offset = param2;
            var tension = param4 == null ? 0.5 : param4;
            if (points == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('points');
            }
            if (numberOfSegments < 1)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('numberOfSegments');
            var count = points.length;
            // we need 3 points for the first curve, 2 more for each curves
            // and it's possible to use a point prior to the offset (to calculate)
            if (offset === 0 && numberOfSegments === 1 && count < 3)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('invalid parameters');
            if (numberOfSegments >= points.length - offset) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('offset');
            }
            var tangents = _GeomUtilities__WEBPACK_IMPORTED_MODULE_4__.GeomUtilities.GetCurveTangents(CURVE_MIN_TERMS, points, count, tension, CurveType.Open);
            this.appendCurve(points, tangents, offset, numberOfSegments, CurveType.Open);
        }
    };
    GraphicsPath.prototype.addPolygon = function (points) {
        if (points == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('points');
        }
        if (points.length < 3) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('not enough points for polygon', 'points');
        }
        this.appendPoint(points[0], _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start, false);
        for (var i = 1; i < points.length; i++) {
            this.appendPoint(points[i], _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, false);
        }
        // Add a line from the last point back to the first point if
        // they're not the same
        var last = points[points.length - 1];
        if (points[0] !== last) {
            this.appendPoint(points[0], _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, false);
        }
        /* close the path */
        this.closeFigure();
    };
    GraphicsPath.prototype.startFigure = function () {
        this.start_new_fig = true;
    };
    GraphicsPath.prototype.closeFigure = function () {
        if (this.points.Count > 0) {
            this.types.Set(this.types.Count - 1, this.types.Get(this.types.Count - 1) | _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.CloseSubpath);
        }
        this.start_new_fig = true;
    };
    GraphicsPath.prototype.addEllipse = function (rect, y, width, height) {
        if (typeof rect === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {
            this.addEllipse(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(rect, y, width, height));
        }
        else if (rect instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle) {
            var C1 = 0.552285;
            //const float C2 = 0.552285f;
            var rx = rect.Width / 2;
            var ry = rect.Height / 2;
            var cx = rect.X + rx;
            var cy = rect.Y + ry;
            if (!this.isReverseWindingOnFill) {
                /* origin */
                this.append(cx + rx, cy, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start, false);
                /* quadrant I */
                this.appendBezier(cx + rx, cy - C1 * ry, cx + C1 * rx, cy - ry, cx, cy - ry);
                /* quadrant II */
                this.appendBezier(cx - C1 * rx, cy - ry, cx - rx, cy - C1 * ry, cx - rx, cy);
                /* quadrant III */
                this.appendBezier(cx - rx, cy + C1 * ry, cx - C1 * rx, cy + ry, cx, cy + ry);
                /* quadrant IV */
                this.appendBezier(cx + C1 * rx, cy + ry, cx + rx, cy + C1 * ry, cx + rx, cy);
            }
            else {
                // We need to reverse the drawing of the ellipse so that the
                // winding is taken into account to not leave holes.
                /* origin */
                this.append(cx + rx, cy, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start, false);
                /* quadrant IV */
                this.appendBezier(cx + C1 * rx, cy + ry, cx + rx, cy + C1 * ry, cx + rx, cy);
                /* quadrant I */
                this.appendBezier(cx + rx, cy - C1 * ry, cx + C1 * rx, cy - ry, cx, cy - ry);
                /* quadrant II */
                this.appendBezier(cx - C1 * rx, cy - ry, cx - rx, cy - C1 * ry, cx - rx, cy);
                /* quadrant III */
                this.appendBezier(cx - rx, cy + C1 * ry, cx - C1 * rx, cy + ry, cx, cy + ry);
            }
            this.closeFigure();
        }
    };
    GraphicsPath.prototype.addLine = function (param1, param2, param3, param4) {
        if (param1 instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint && param2 instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint) {
            this.append(param1.X, param1.Y, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, true);
            this.append(param2.X, param2.Y, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, false);
        }
        if (typeof param1 === 'number' && typeof param2 === 'number' && typeof param3 === 'number' && typeof param4 === 'number') {
            this.append(param1, param2, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, true);
            this.append(param3, param4, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, false);
        }
    };
    GraphicsPath.prototype.addLines = function (points) {
        if (points == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('points');
        }
        if (points.length === 0) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('points');
        }
        /* only the first point can be compressed (i.e. removed if identical to previous) */
        for (var i = 0, count = points.length; i < count; i++) {
            this.append(points[i].X, points[i].Y, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, i === 0);
        }
    };
    GraphicsPath.prototype.addRectangle = function (rect) {
        if (rect.Width === 0 || rect.Height === 0) {
            return;
        }
        this.append(rect.X, rect.Y, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start, false);
        this.append(rect.Right, rect.Y, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, false);
        this.append(rect.Right, rect.Bottom, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, false);
        this.append(rect.X, rect.Bottom, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line | _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.CloseSubpath, false);
    };
    GraphicsPath.prototype.addRectangles = function (rects) {
        var _this = this;
        if (rects == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('rects');
        }
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.foreach)(rects, function (rect) {
            _this.addRectangle(rect);
        });
    };
    GraphicsPath.prototype.addPie = function (x, y, width, height, startAngle, sweepAngle) {
        var sin_alpha, cos_alpha;
        var rx = width / 2;
        var ry = height / 2;
        /* center */
        var cx = x + rx;
        var cy = y + ry;
        /* angles in radians */
        var alpha = (startAngle * Math.PI) / 180;
        /* adjust angle for ellipses */
        alpha = Math.atan2(rx * Math.sin(alpha), ry * Math.cos(alpha));
        sin_alpha = Math.sin(alpha);
        cos_alpha = Math.cos(alpha);
        /* move to center */
        this.append(cx, cy, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start, false);
        /* draw pie edge */
        if (Math.abs(sweepAngle) < 360)
            this.append(cx + rx * cos_alpha, cy + ry * sin_alpha, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, false);
        /* draw the arcs */
        this.appendArcs(x, y, width, height, startAngle, sweepAngle);
        /* draw pie edge */
        if (Math.abs(sweepAngle) < 360)
            this.append(cx, cy, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, false);
        this.closeFigure();
    };
    GraphicsPath.prototype.addArc = function (param1, param2, param3, param4, param5, param6) {
        if (param1 instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle) {
            var rect = param1;
            var start_angle = param2;
            var sweep_angle = param3;
            this.appendArcs(rect.X, rect.Y, rect.Width, rect.Height, start_angle, sweep_angle);
        }
        else if (typeof param1 === 'number') {
            var x = param1;
            var y = param2;
            var width = param3;
            var height = param4;
            var start_angle = param5;
            var sweep_angle = param6;
            this.appendArcs(x, y, width, height, start_angle, sweep_angle);
        }
    };
    GraphicsPath.prototype.addBezier = function (param1, param2, param3, param4, param5, param6, param7, param8) {
        if (param1 instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint && param2 instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint && param3 instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint &&
            param4 instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint) {
            var pt1 = param1;
            var pt2 = param2;
            var pt3 = param3;
            var pt4 = param4;
            this.append(pt1.X, pt1.Y, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, true);
            this.appendBezier(pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X, pt4.Y);
        }
        else if (typeof param1 === 'number' && typeof param2 === 'number' && typeof param3 === 'number' && typeof param4 === 'number') {
            var x1 = param1;
            var y1 = param2;
            var x2 = param3;
            var y2 = param4;
            var x3 = param5;
            var y3 = param6;
            var x4 = param7;
            var y4 = param8;
            this.append(x1, y1, _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, true);
            this.appendBezier(x2, y2, x3, y3, x4, y4);
        }
    };
    GraphicsPath.prototype.addBeziers = function (points) {
        if (points == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('points');
        }
        var count = points.length;
        /* first bezier requires 4 points, other 3 more points */
        if (count < 4 || count % 3 !== 1) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('points');
        }
        this.appendPoint(points[0], _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line, true);
        for (var i = 1; i < count; i++) {
            this.appendPoint(points[i], _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Bezier3, false);
        }
    };
    GraphicsPath.prototype.addPath = function (addingPath, connect) {
        if (addingPath == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('addingPath');
        }
        var length = addingPath.PointCount;
        if (length < 1)
            return;
        var pts = addingPath.PathPoints;
        var types = addingPath.PathTypes;
        // We can connect only open figures. If first figure is closed
        // it can't be connected.
        var first = connect ? this.getFirstPointType() : _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start;
        this.appendPoint(pts[0], first, false);
        for (var i = 1; i < length; i++) {
            this.appendPoint(pts[i], types[i], false);
        }
    };
    GraphicsPath.prototype.closeAllFigures = function () {
        var index = 0;
        var currentType;
        var lastType;
        var oldTypes;
        /* first point is not closed */
        if (this.points.Count <= 1)
            return;
        oldTypes = this.types.ToArray();
        this.types = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List();
        lastType = oldTypes[index];
        index++;
        for (index = 1; index < this.points.Count; index++) {
            currentType = oldTypes[index];
            /* we dont close on the first point */
            if (currentType === _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start && index > 1) {
                lastType |= _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.CloseSubpath;
                this.types.Add(lastType);
            }
            else
                this.types.Add(lastType);
            lastType = currentType;
        }
        /* close at the end */
        lastType |= _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.CloseSubpath;
        this.types.Add(lastType);
        this.start_new_fig = true;
    };
    GraphicsPath.prototype.getLastPoint = function () {
        if (this.points.Count <= 0)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('Parameter is not valid');
        var lastPoint = this.points.Get(this.points.Count - 1);
        return lastPoint;
    };
    GraphicsPath.prototype.getBounds = function (matrix, pen) {
        var bounds = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty;
        if (this.points.Count < 1) {
            return bounds;
        }
        var workPath = this.Clone();
        // We don't need a very precise flat value to get the bounds (GDI+ isn't, big time) -
        // however flattening helps by removing curves, making the rest of the algorithm a
        // lot simpler.
        // note: only the matrix is applied if no curves are present in the path
        var status = GraphicsPath_1.FlattenPath(workPath, matrix, 25.0);
        if (status === 0) {
            var i = void 0;
            var boundaryPoints = void 0;
            boundaryPoints = workPath.points.Get(0); //g_array_index (workpath->points, GpPointF, 0);
            bounds.X = boundaryPoints.X; // keep minimum X here
            bounds.Y = boundaryPoints.Y; // keep minimum Y here
            if (workPath.points.Count === 1) {
                // special case #2 - Only one element
                bounds.Width = 0.0;
                bounds.Height = 0.0;
                return bounds;
            }
            bounds.Width = boundaryPoints.X; // keep maximum X here
            bounds.Height = boundaryPoints.Y; // keep maximum Y here
            for (i = 1; i < workPath.points.Count; i++) {
                boundaryPoints = workPath.points.Get(i);
                if (boundaryPoints.X < bounds.X)
                    bounds.X = boundaryPoints.X;
                if (boundaryPoints.Y < bounds.Y)
                    bounds.Y = boundaryPoints.Y;
                if (boundaryPoints.X > bounds.Width)
                    bounds.Width = boundaryPoints.X;
                if (boundaryPoints.Y > bounds.Height)
                    bounds.Height = boundaryPoints.Y;
            }
            // convert maximum values (width/height) as length
            bounds.Width -= bounds.X;
            bounds.Height -= bounds.Y;
            if (pen != null) {
                /* in calculation the pen's width is at least 1.0 */
                var width = pen.Width < 1.0 ? 1.0 : pen.Width;
                var halfw = width / 2;
                bounds.X -= halfw;
                bounds.Y -= halfw;
                bounds.Width += width;
                bounds.Height += width;
            }
        }
        return bounds;
    };
    GraphicsPath.PathHasCurve = function (path) {
        if (path == null) {
            return false;
        }
        var types = path.PathTypes;
        for (var i = 0; i < types.length; i++) {
            if (types[i] === _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Bezier)
                return true;
        }
        return false;
    };
    // nr_curve_flatten comes from Sodipodi's libnr (public domain) available from http://www.sodipodi.com/
    // Mono changes: converted to float (from double), added recursion limit, use List<PointF>
    GraphicsPath.nr_curve_flatten = function (x0, y0, x1, y1, x2, y2, x3, y3, flatness, level, points) {
        var dx1_0, dy1_0, dx2_0, dy2_0, dx3_0, dy3_0, dx2_3, dy2_3, d3_0_2;
        var s1_q, t1_q, s2_q, t2_q, v2_q;
        var f2, f2_q;
        var x00t, y00t, x0tt, y0tt, xttt, yttt, x1tt, y1tt, x11t, y11t;
        dx1_0 = x1 - x0;
        dy1_0 = y1 - y0;
        dx2_0 = x2 - x0;
        dy2_0 = y2 - y0;
        dx3_0 = x3 - x0;
        dy3_0 = y3 - y0;
        dx2_3 = x3 - x2;
        dy2_3 = y3 - y2;
        f2 = flatness;
        d3_0_2 = dx3_0 * dx3_0 + dy3_0 * dy3_0;
        if (d3_0_2 < f2) {
            var d1_0_2 = void 0, d2_0_2 = void 0;
            d1_0_2 = dx1_0 * dx1_0 + dy1_0 * dy1_0;
            d2_0_2 = dx2_0 * dx2_0 + dy2_0 * dy2_0;
            if (d1_0_2 < f2 && d2_0_2 < f2) {
                return nosubdivide();
            }
            else {
                return subdivide();
            }
        }
        f2_q = f2 * d3_0_2;
        s1_q = dx1_0 * dx3_0 + dy1_0 * dy3_0;
        t1_q = dy1_0 * dx3_0 - dx1_0 * dy3_0;
        s2_q = dx2_0 * dx3_0 + dy2_0 * dy3_0;
        t2_q = dy2_0 * dx3_0 - dx2_0 * dy3_0;
        v2_q = dx2_3 * dx3_0 + dy2_3 * dy3_0;
        if (t1_q * t1_q > f2_q) {
            return subdivide();
        }
        if (t2_q * t2_q > f2_q) {
            return subdivide();
        }
        if (s1_q < 0.0 && s1_q * s1_q > f2_q) {
            return subdivide();
        }
        if (v2_q < 0.0 && v2_q * v2_q > f2_q) {
            return subdivide();
        }
        if (s1_q >= s2_q) {
            return subdivide();
        }
        function nosubdivide() {
            points.Add(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(x3, y3));
            return true;
        }
        function subdivide() {
            // things gets *VERY* memory intensive without a limit
            if (level >= FLATTEN_RECURSION_LIMIT)
                return false;
            x00t = (x0 + x1) * 0.5;
            y00t = (y0 + y1) * 0.5;
            x0tt = (x0 + 2 * x1 + x2) * 0.25;
            y0tt = (y0 + 2 * y1 + y2) * 0.25;
            x1tt = (x1 + 2 * x2 + x3) * 0.25;
            y1tt = (y1 + 2 * y2 + y3) * 0.25;
            x11t = (x2 + x3) * 0.5;
            y11t = (y2 + y3) * 0.5;
            xttt = (x0tt + x1tt) * 0.5;
            yttt = (y0tt + y1tt) * 0.5;
            if (!GraphicsPath_1.nr_curve_flatten(x0, y0, x00t, y00t, x0tt, y0tt, xttt, yttt, flatness, level + 1, points))
                return false;
            if (!GraphicsPath_1.nr_curve_flatten(xttt, yttt, x1tt, y1tt, x11t, y11t, x3, y3, flatness, level + 1, points))
                return false;
            return true;
        }
        return false;
    };
    GraphicsPath.ConvertBezierToLines = function (path, index, flatness, flat_points, flat_types) {
        var pt;
        // always PathPointTypeLine
        var type = _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line;
        if (index <= 0 || index + 2 >= path.points.Count)
            return false; // bad path data
        var start = path.points.Get(index - 1);
        var first = path.points.Get(index);
        var second = path.points.Get(index + 1);
        var end = path.points.Get(index + 2);
        // we can't add points directly to the original list as we could end up with too much recursion
        var points = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List();
        if (!GraphicsPath_1.nr_curve_flatten(start.X, start.Y, first.X, first.Y, second.X, second.Y, end.X, end.Y, flatness, 0, points)) {
            // curved path is too complex (i.e. would result in too many points) to render as a polygon
            return false;
        }
        // recursion was within limits, append the result to the original supplied list
        if (points.Count > 0) {
            flat_points.Add(points[0]);
            flat_types.Add(type);
        }
        // always PathPointTypeLine
        for (var i = 1; i < points.Count; i++) {
            pt = points.Get(i);
            flat_points.Add(pt);
            flat_types.Add(type);
        }
        return true;
    };
    GraphicsPath.FlattenPath = function (path, matrix, flatness) {
        var status = 0;
        if (path == null) {
            return -1;
        }
        // apply matrix before flattening (as there's less points at this stage)
        if (matrix != null) {
            path.transform(matrix);
        }
        // if no bezier are present then the path doesn't need to be flattened
        if (!GraphicsPath_1.PathHasCurve(path)) {
            return status;
        }
        var points = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List();
        var types = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List();
        // Iterate the current path and replace each bezier with multiple lines
        for (var i = 0; i < path.points.Count; i++) {
            var point = path.points.Get(i);
            var type = path.types.Get(i);
            // PathPointTypeBezier3 has the same value as PathPointTypeBezier
            if ((type & _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Bezier) === _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Bezier) {
                if (!GraphicsPath_1.ConvertBezierToLines(path, i, Math.abs(flatness), points, types)) {
                    // uho, too much recursion - do not pass go, do not collect 200$
                    var pt = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
                    // mimic MS behaviour when recursion becomes a problem */
                    // note: it's not really an empty rectangle as the last point isn't closing
                    points.Clear();
                    types.Clear();
                    type = _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start;
                    points.Add(pt);
                    types.Add(type);
                    type = _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line;
                    points.Add(pt);
                    types.Add(type);
                    points.Add(pt);
                    types.Add(type);
                    break;
                }
                // beziers have 4 points: the previous one, the current and the next two
                i += 2;
            }
            else {
                // no change required, just copy the point
                points.Add(point);
                types.Add(type);
            }
        }
        // transfer new path informations
        path.points = points;
        path.types = types;
        // note: no error code is given for excessive recursion
        return 0;
    };
    GraphicsPath.prototype.isVisible = function (param1, param2, param3) {
        if (arguments.length === 1 && param1 instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint) {
            this.isVisible(param1, undefined);
        }
        else if (arguments.length === 2 && param1 instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint && (param2 instanceof _Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics || typeof param2 === 'undefined')) {
            var region = new _Region__WEBPACK_IMPORTED_MODULE_6__.Region(this);
            return region.isVisible(param1);
        }
        else if (arguments.length === 2 && typeof param1 === 'number' && typeof param2 === 'number') {
            this.isVisible(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(param1, param2), undefined);
        }
        else if (arguments.length === 3 && typeof param1 === 'number' && typeof param2 === 'number' && param3 instanceof _Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics) {
            this.isVisible(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(param1, param2), param3);
        }
        return false;
    };
    GraphicsPath.prototype.isOutlineVisible = function (pt, pen, graphics) {
        var outlinePath = this.Clone();
        if (graphics != null) {
            outlinePath.transform(graphics.Transform);
        }
        // TODO: Fix below
        // outlinePath.widen(pen);
        var outlineRegion = new _Region__WEBPACK_IMPORTED_MODULE_6__.Region(outlinePath);
        return outlineRegion.isVisible(pt);
    };
    GraphicsPath.prototype.flatten = function (matrix, flatness) {
        if (flatness === void 0) { flatness = 0.25; }
        GraphicsPath_1.FlattenPath(this, matrix, flatness);
    };
    GraphicsPath.prototype.reset = function () {
        this.points.Clear();
        this.types.Clear();
        this.fillMode = _FillMode__WEBPACK_IMPORTED_MODULE_2__.FillMode.Alternate;
        this.start_new_fig = true;
    };
    GraphicsPath.ReverseSubpathAndAdjustFlags = function (start, end, old_types, new_types, isPrevHadMarker) {
        // Copy all but PathPointTypeStart
        if (end !== start)
            new_types.AddRange(old_types.GetRange(start + 1, end - start));
        // Append PathPointTypeStart
        new_types.Add(_PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start);
        console.debug(new_types.Count === end + 1);
        var prev_first = old_types[start];
        var prev_last = old_types[end];
        // Remove potential flags from our future start point
        if (end !== start)
            new_types[end - 1] &= _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathTypeMask;
        // Set the flags on our to-be-last point
        if ((prev_last & _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.DashMode) !== 0)
            new_types[start] |= _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.DashMode;
        if ((prev_last & _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.CloseSubpath) !== 0)
            new_types[start] |= _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.CloseSubpath;
        //
        // Swap markers
        //
        for (var i = start + 1; i < end; i++) {
            if ((old_types[i - 1] & _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathMarker) !== 0)
                new_types[i] |= _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathMarker;
            //new_types[i] &= ~PathPointType.PathMarker;
            // Can not take compliment for negative numbers so we XOR
            else
                new_types[i] &= _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathMarker ^ 0xff;
        }
        // If the last point of the previous subpath had a marker, we inherit it
        if (isPrevHadMarker)
            new_types[start] |= _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathMarker;
        //new_types[start] &= ~PathPointType.PathMarker;
        // Can not take compliment for negative numbers so we XOR
        else
            new_types[start] &= _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathMarker ^ 0xff;
        isPrevHadMarker.value = (prev_last & _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathMarker) === _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathMarker;
    };
    GraphicsPath.prototype.reverse = function () {
        var length = this.points.Count;
        var start = 0;
        var isPrevHadMarker = { value: false };
        // shortcut
        if (length <= 1)
            return;
        // PathTypes reversal
        // First adjust the flags for each subpath
        var newTypes = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List();
        for (var i = 1; i < length; i++) {
            var t = this.types.Get(i);
            if ((t & _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathTypeMask) === _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start) {
                GraphicsPath_1.ReverseSubpathAndAdjustFlags(start, i - 1, this.types, newTypes, isPrevHadMarker);
                start = i;
            }
        }
        if (start < length - 1)
            GraphicsPath_1.ReverseSubpathAndAdjustFlags(start, length - 1, this.types, newTypes, isPrevHadMarker);
        /* Then reverse the resulting array */
        for (var i = 0; i < length >> 1; i++) {
            var a = newTypes.Get(i);
            var b = newTypes.Get(length - i - 1);
            var temp = a;
            newTypes.Set(i, b);
            newTypes.Set(length - i - 1, temp);
        }
        this.types = newTypes;
        // PathPoints reversal
        // note: if length is odd then the middle point doesn't need to switch side
        //
        for (var i = 0; i < length >> 1; i++) {
            var first = this.points.Get(i);
            var last = this.points.Get(length - i - 1);
            var temp = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
            temp.X = first.X;
            temp.Y = first.Y;
            this.points.Set(i, last);
            this.points.Set(length - i - 1, temp);
        }
    };
    GraphicsPath.prototype.setMarkers = function () {
        if (this.points.Count === 0)
            return;
        var current = this.types.Get(this.points.Count - 1);
        this.types.RemoveAt(this.points.Count - 1);
        current |= _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathMarker;
        this.types.Add(current);
    };
    GraphicsPath.prototype.clearMarkers = function () {
        // shortcut to avoid allocations
        if (this.types.Count === 0)
            return;
        var cleared = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List();
        var current = 0;
        for (var i = 0; i < this.types.Count; i++) {
            current = this.types.Get(i);
            /* take out the marker if there is one */
            if ((current & _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathMarker) != 0)
                //current &= ~PathPointType.PathMarker;
                current &= _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.PathMarker ^ 0xff;
            cleared.Add(current);
        }
        /* replace the existing with the cleared array */
        this.types = cleared;
    };
    GraphicsPath.prototype.getFirstPointType = function () {
        /* check for a new figure flag or an empty path */
        if (this.start_new_fig || this.points.Count === 0) {
            return _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start;
        }
        /* check if the previous point is a closure */
        var type = this.types.Get(this.types.Count - 1);
        if ((type & _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.CloseSubpath) !== 0)
            return _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Start;
        else
            return _PathPointType__WEBPACK_IMPORTED_MODULE_3__.PathPointType.Line;
    };
    GraphicsPath.prototype.transform = function (matrix) {
        matrix.transformPoints(this.points.ToArray());
    };
    GraphicsPath.prototype.widen = function (pen, matrix, flatness) {
        if (flatness === void 0) { flatness = 0.25; }
        if (pen == null) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('pen');
        }
        if (this.points.Count <= 1) {
            return;
        }
        var flat_path = this.Clone();
        flat_path.flatten(matrix, flatness);
        var widePoints = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.newOutEmpty)();
        var wideTypes = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.newOutEmpty)();
        // TODO: Fix below
        // GraphicsPath.WidenPath(flat_path, pen, widePoints, wideTypes);
        this.points = widePoints.value;
        this.types = wideTypes.value;
        this.start_new_fig = true;
        this.isReverseWindingOnFill = true;
    };
    /* private static WidenPath (path: GraphicsPath,  pen:Pen,   widePoints: Out<Collection<PointF>>,  wideTypes: Out<Collection<byte>): void
          {
  
              widePoints.out = new Collection<PointF> ();
              wideTypes.out = new Collection<byte> ();
  
              const pathData: PathData = path.PathData;
  
              const iterator = new GraphicsPathIterator(path);
              var subPaths = iterator.SubpathCount;
  
              int startIndex = 0;
              int endIndex = 0;
              bool isClosed = false;
  
              var flattenedSubpath = new Paths();
              var offsetPaths = new Paths();
  
              var width = (pen.Width / 2) * scale;
              var miterLimit = pen.MiterLimit * scale;
  
              var joinType = JoinType.jtMiter;
              switch (pen.LineJoin)
              {
              case LineJoin.Round:
                  joinType = JoinType.jtRound;
                  break;
              case LineJoin.Bevel:
                  joinType = JoinType.jtSquare;
                  break;
              }
  
  
              for (int sp = 0; sp < subPaths; sp++)
              {
  
                  var numOfPoints = iterator.NextSubpath(out startIndex, out endIndex, out isClosed);
                  //Console.WriteLine("subPath {0} - from {1} to {2} closed {3}", sp+1, startIndex, endIndex, isClosed);
  
                  var subPoints = pathData.Points.Skip(startIndex).Take(numOfPoints).ToArray();
  
                  //for (int pp = startIndex; pp <= endIndex; pp++)
                  //{
                  //    Console.WriteLine("         {0} - {1}", pathData.Points[pp], (PathPointType)pathData.Types[pp]);
                  //}
  
  
                  // Load our Figure Subpath
                  flattenedSubpath.Clear();
                  flattenedSubpath.Add(Region.PointFArrayToIntArray(subPoints, scale));
  
                  // Calculate the outter offset region
                  var outerOffsets = Clipper.OffsetPaths(flattenedSubpath, width, joinType, ClipperLib.EndType.etClosed, miterLimit);
                  // Calculate the inner offset region
                  var innerOffsets = Clipper.OffsetPaths(flattenedSubpath, -width, joinType, ClipperLib.EndType.etClosed, miterLimit);
  
                  // Add the offsets to our paths
                  offsetPaths.AddRange(outerOffsets);
  
                  // revers our innerOffsets so that they create a hole when filling
                  Clipper.ReversePaths (innerOffsets);
                  offsetPaths.AddRange(innerOffsets);
  
              }
  
              foreach (var offPath in offsetPaths)
              {
                  if (offPath.Count < 1)
                      continue;
  
                  var pointArray = Region.PathToPointFArray(offPath, scale);
  
                  var type = (byte)PathPointType.Start;
                  widePoints.Add (pointArray [0]);
                  wideTypes.Add (type);
  
                  type = (byte)PathPointType.Line;
                  for (int i = 1; i < offPath.Count; i++)
                  {
                      widePoints.Add (pointArray [i]);
                      wideTypes.Add (type);
  
                  }
  
                  if (widePoints.Count > 0)
                      wideTypes [wideTypes.Count-1] = (byte) (wideTypes [wideTypes.Count-1] | (byte) PathPointType.CloseSubpath);
  
              }
  
          } */
    GraphicsPath.prototype.Dispose = function () { };
    GraphicsPath.prototype.Clone = function () {
        var copy = new GraphicsPath_1(this.fillMode);
        copy.points = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List(this.points.ToArray());
        copy.types = new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.List(this.types.ToArray());
        copy.start_new_fig = this.start_new_fig;
        return copy;
    };
    var GraphicsPath_1;
    GraphicsPath = GraphicsPath_1 = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_7__.GraphicTypes.GraphicsPath,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_7__.GraphicTypes.GraphicsPath
            ]
        }),
        __metadata("design:paramtypes", [Object, Array, Number])
    ], GraphicsPath);
    return GraphicsPath;
}());



/***/ }),

/***/ "./src/drawing/drawing2D/GraphicsState.ts":
/*!************************************************!*\
  !*** ./src/drawing/drawing2D/GraphicsState.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphicsState": () => (/* binding */ GraphicsState)
/* harmony export */ });
var GraphicsState = /** @class */ (function () {
    function GraphicsState() {
        // TODO: set the rest of the states
        // These are just off the top of my head for right now as am sure there are
        // many more
        this.lastPen = undefined;
        this.lastBrush = undefined;
        this.model = undefined;
        this.view = undefined;
        this.renderingOrigin = undefined;
        this.pageUnit = undefined;
        this.pageScale = undefined;
        this.smoothingMode = undefined;
        this.clipRegion = undefined;
    }
    return GraphicsState;
}());



/***/ }),

/***/ "./src/drawing/drawing2D/HatchBrush.ts":
/*!*********************************************!*\
  !*** ./src/drawing/drawing2D/HatchBrush.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HatchBrush": () => (/* binding */ HatchBrush)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Brush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Brush */ "./src/drawing/Brush.ts");
/* harmony import */ var _HatchStyle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HatchStyle */ "./src/drawing/drawing2D/HatchStyle.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_4__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







var HATCH_SIZE = 8;
var LINE_WIDTH = 1;
var HALF_PIXEL_X = 0;
var HALF_PIXEL_Y = 0;
var hatches_const = [
    /* HatchStyleHorizontal */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleVertical */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleForwardDiagonal */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleBackwardDiagonal */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleCross */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleDiagonalCross */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyle05Percent */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyle10Percent */ [HATCH_SIZE, HATCH_SIZE - 3.0, LINE_WIDTH],
    /* HatchStyle20Percent */ [2.0, 2.0, LINE_WIDTH],
    /* HatchStyle25Percent */ [4.0, 2.0, LINE_WIDTH],
    /* HatchStyle30Percent */ [4.0, 4.0, LINE_WIDTH],
    /* HatchStyle40Percent */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyle50Percent */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyle60Percent */ [4.0, 4.0, LINE_WIDTH],
    /* HatchStyle70Percent */ [4.0, 2.0, LINE_WIDTH],
    /* HatchStyle75Percent */ [4.0, 4.0, LINE_WIDTH],
    /* HatchStyle80Percent */ [HATCH_SIZE, 4.0, LINE_WIDTH],
    /* HatchStyle90Percent */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleLightDownwardDiagonal */ [HATCH_SIZE * 0.5, HATCH_SIZE * 0.5, LINE_WIDTH],
    /* HatchStyleLightUpwardDiagonal */ [HATCH_SIZE * 0.5, HATCH_SIZE * 0.5, LINE_WIDTH],
    /* HatchStyleDarkDownwardDiagonal */ [HATCH_SIZE * 0.5, HATCH_SIZE * 0.5, LINE_WIDTH + 1],
    /* HatchStyleDarkUpwardDiagonal */ [HATCH_SIZE * 0.5, HATCH_SIZE * 0.5, LINE_WIDTH + 1],
    /* HatchStyleWideDownwardDiagonal */ [(HATCH_SIZE), (HATCH_SIZE), LINE_WIDTH + 2],
    /* HatchStyleWideUpwardDiagonal */ [(HATCH_SIZE), (HATCH_SIZE), LINE_WIDTH + 2],
    /* HatchStyleLightVertical */ [HATCH_SIZE * 0.5, HATCH_SIZE * 0.5, LINE_WIDTH],
    /* HatchStyleLightHorizontal */ [HATCH_SIZE * 0.5, HATCH_SIZE * 0.5, LINE_WIDTH],
    /* HatchStyleNarrowVertical */ [2.0, 2.0, LINE_WIDTH],
    /* HatchStyleNarrowHorizontal */ [2.0, 2.0, LINE_WIDTH],
    /* HatchStyleDarkVertical */ [HATCH_SIZE * 0.5, HATCH_SIZE * 0.5, LINE_WIDTH * 2.0],
    /* HatchStyleDarkHorizontal */ [HATCH_SIZE * 0.5, HATCH_SIZE * 0.5, LINE_WIDTH * 2.0],
    /* HatchStyleDashedDownwardDiagonal */ [HATCH_SIZE * 0.5, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleDashedUpwardDiagonal */ [HATCH_SIZE * 0.5, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleDashedHorizontal */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleDashedVertical */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleSmallConfetti */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleLargeConfetti */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleZigZag */ [HATCH_SIZE, 4.0, LINE_WIDTH],
    /* HatchStyleWave */ [HATCH_SIZE, HATCH_SIZE * 0.50, LINE_WIDTH],
    /* HatchStyleDiagonalBrick */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleHorizontalBrick */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleWeave */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStylePlaid */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleDivot */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleDottedGrid */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleDottedDiamond */ [HATCH_SIZE, (HATCH_SIZE), LINE_WIDTH],
    /* HatchStyleShingle */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleTrellis */ [4.0, 4.0, LINE_WIDTH],
    /* HatchStyleSphere */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleSmallGrid */ [HATCH_SIZE * 0.5, HATCH_SIZE * 0.5, LINE_WIDTH],
    /* HatchStyleSmallCheckerBoard */ [4.0, 4.0, LINE_WIDTH],
    /* HatchStyleLargeCheckerBoard */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleOutlinedDiamond */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH],
    /* HatchStyleSolidDiamond */ [HATCH_SIZE, HATCH_SIZE, LINE_WIDTH]
];
var HatchBrush = /** @class */ (function (_super) {
    __extends(HatchBrush, _super);
    function HatchBrush() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this.backColor = undefined;
        _this.foreColor = undefined;
        _this.hatchStyle = undefined;
        if (args.length === 2) {
            _this.hatchStyle = args[0];
            _this.foreColor = args[1];
            _this.backColor = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Black;
        }
        else if (args.length === 3) {
            _this.hatchStyle = args[0];
            _this.foreColor = args[1];
            _this.backColor = args[2];
        }
        return _this;
    }
    HatchBrush_1 = HatchBrush;
    HatchBrush.prototype.getHatchWidth = function (hbr) {
        return hatches_const[hbr][0];
    };
    HatchBrush.prototype.getHatchHeight = function (hbr) {
        return hatches_const[hbr][1];
    };
    HatchBrush.prototype.getLineWidth = function (hbr) {
        return hatches_const[hbr][2];
    };
    HatchBrush.prototype.drawBackground = function (context, color, width, height) {
        context.setFillColor(color);
        context.fillRect(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(HALF_PIXEL_X, HALF_PIXEL_Y, width + HALF_PIXEL_X, height + HALF_PIXEL_Y));
        context.fillPath();
    };
    HatchBrush.prototype.initializeContext = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var constext = args[0];
        if (args.length === 3) {
            this.initializeContext(args[0], args[1], args[1], args[2]);
        }
        else if (args.length === 4) {
            constext.setShouldAntialias(args[3]);
        }
    };
    Object.defineProperty(HatchBrush.prototype, "BackgroundColor", {
        get: function () {
            return this.backColor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HatchBrush.prototype, "ForegroundColor", {
        get: function () {
            return this.foreColor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HatchBrush.prototype, "HatchStyle", {
        get: function () {
            return this.hatchStyle;
        },
        enumerable: false,
        configurable: true
    });
    HatchBrush.prototype.Clone = function () {
        return new HatchBrush_1(this.hatchStyle, this.foreColor, this.backColor);
    };
    HatchBrush.prototype.hatchHorizontal = function (context) {
        var hatchSize = this.getHatchWidth(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchSize, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchSize, hatchSize);
        /* draw horizontal line in the foreground color */
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        // draw a horizontal line
        context.beginPath();
        context.moveTo(0, 0);
        context.addLineToPoint(hatchSize, 0);
        context.closePath();
        context.strokePath();
    };
    HatchBrush.prototype.hatchVertical = function (context) {
        var hatchSize = this.getHatchWidth(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchSize, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchSize, hatchSize);
        /* draw horizontal line in the foreground color */
        context.translateCTM(0.5, 0.5);
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        //float halfMe = hatchSize / 2.0f;
        // draw a horizontal line
        context.moveTo(0, 0);
        context.addLineToPoint(0, hatchSize);
        context.strokePath();
        context.translateCTM(-0.5, -0.5);
    };
    HatchBrush.prototype.hatchGrid = function (context) {
        var hatchSize = this.getHatchWidth(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchSize, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchSize, hatchSize);
        /* draw lines in the foreground color */
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        hatchSize -= HALF_PIXEL_X;
        var yoffset = 0;
        if (this.hatchStyle === _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DottedGrid) {
            yoffset = 1;
            var dash = [1, 1];
            context.setLineDash(2, dash);
        }
        /* draw a horizontal line */
        context.moveTo(0, yoffset);
        context.addLineToPoint(0, hatchSize);
        context.strokePath();
        /* draw a vertical line */
        context.moveTo(0, hatchSize);
        context.addLineToPoint(hatchSize, hatchSize);
        context.strokePath();
    };
    /**
     * Percentage patterns were obtained by creating a screen shot from a windows fill
     * and looking at the patterns at the pixel level.  A little tedious to say the least
     * but they do seem correct and recreate the same pattern from windows to here.
     */
    HatchBrush.prototype.hatchPercentage = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* some patterns require us to reverse the colors */
        switch (this.hatchStyle) {
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent05:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent10:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent20:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent25:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent30:
                this.drawBackground(context, this.backColor, hatchWidth, hatchWidth);
                context.setFillColor(this.foreColor);
                break;
            default:
                this.drawBackground(context, this.foreColor, hatchWidth, hatchWidth);
                context.setFillColor(this.backColor);
                break;
        }
        // create a work rectangle for setting pixels
        var rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, 1, 1);
        // Only set the pixels for some
        if (this.hatchStyle !== _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent50 &&
            this.hatchStyle !== _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent40 &&
            this.hatchStyle !== _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent30 &&
            this.hatchStyle !== _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent60) {
            rect.X = 0;
            rect.Y = (hatchHeight / 2.0);
            this.setPixels(context, rect);
            rect.X = hatchWidth / 2.0;
            rect.Y = 0;
            this.setPixels(context, rect);
        }
        // 50 and 40 start out the same with a 50 percent
        if (this.hatchStyle === _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent50 ||
            this.hatchStyle === _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent40) {
            var x = 0;
            var y = 0;
            for (y = 0; y < hatchHeight; y += 2) {
                for (x = 1; x < hatchWidth; x += 2) {
                    rect.X = x;
                    rect.Y = y;
                    this.setPixels(context, rect);
                }
            }
            for (y = 1; y < hatchHeight; y += 2) {
                for (x = 0; x < hatchWidth; x += 2) {
                    rect.X = x;
                    rect.Y = y;
                    this.setPixels(context, rect);
                }
            }
            // Percent40 is a 50 with two more dots set of back color
            // within a set area.  This creates an interesting effect
            // of a double plus sign in opposite corners.
            if (this.hatchStyle === _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent40) {
                rect.X = 1;
                rect.Y = 1;
                this.setPixels(context, rect);
                rect.X = 5;
                rect.Y = 5;
                this.setPixels(context, rect);
            }
        }
        // Percent30 and Percent60 are really messed up so we will just set some dots
        // to present the pattern.  Percent60 is a 30 with colors reversed, go figure.
        if (this.hatchStyle === _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent30 ||
            this.hatchStyle === _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent60) {
            rect.X = 0;
            rect.Y = 0;
            this.setPixels(context, rect);
            rect.X = 2;
            rect.Y = 0;
            this.setPixels(context, rect);
            rect.X = 0;
            rect.Y = 2;
            this.setPixels(context, rect);
            rect.X = 2;
            rect.Y = 2;
            this.setPixels(context, rect);
            rect.X = 1;
            rect.Y = 3;
            this.setPixels(context, rect);
            rect.X = 3;
            rect.Y = 1;
            this.setPixels(context, rect);
        }
    };
    HatchBrush.prototype.hatchUpwardDiagonal = function (context) {
        var hatchSize = this.getHatchWidth(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        if (this.hatchStyle !== _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.ForwardDiagonal &&
            this.hatchStyle !== _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.BackwardDiagonal) {
            this.initializeContext(context, hatchSize, false);
        }
        else {
            this.initializeContext(context, hatchSize, true);
        }
        /* draw background */
        this.drawBackground(context, this.backColor, hatchSize, hatchSize);
        /* draw lines in the foreground color */
        context.setStrokeColor(this.foreColor);
        context.setFillColor(this.foreColor);
        context.setLineWidth(1);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        context.moveTo(0, 0);
        context.addLineToPoint(hatchSize, hatchSize);
        /* draw a diagonal line for as many times as linewidth*/
        for (var l = 0; l < lineWidth; l++) {
            /* draw a diagonal line */
            context.moveTo(l, 0);
            context.addLineToPoint(hatchSize, hatchSize - l);
            context.strokePath();
        }
        /**
         * because we are within a rectangular pattern we have to complete the tip of the preceeding line
         * pattern
         */
        for (var k = 1; k < lineWidth; k++) {
            /* draw a diagonal line */
            context.moveTo(0, hatchSize - k);
            context.addLineToPoint(k - 1, hatchSize - 1);
            context.strokePath();
        }
    };
    HatchBrush.prototype.hatchDiagonalCross = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, true);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        //float halfMe = hatchHeight / 2.0f;
        context.moveTo(0, 0);
        context.addLineToPoint(hatchWidth, hatchHeight);
        context.strokePath();
        context.moveTo(hatchWidth, 0);
        context.addLineToPoint(0, hatchHeight);
        context.strokePath();
    };
    /**
     * This is fill of hackish stuff.
     * Thought this was going to be easier but that just did not work out.
     **/
    HatchBrush.prototype.hatchSphere = function (context) {
        var hatchSize = this.getHatchWidth(this.hatchStyle);
        //var lineWidth = getLineWidth (hatchStyle);
        this.initializeContext(context, hatchSize, false);
        /* draw background in fore ground color*/
        this.drawBackground(context, this.backColor, hatchSize, hatchSize);
        context.setStrokeColor(this.foreColor);
        context.setFillColor(this.foreColor);
        context.setLineWidth(1);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        // Initialize work rectangle
        var rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, 1, 1);
        var quad = hatchSize / 2.0;
        // Left lower quad
        rect.Width = quad;
        rect.Height = quad;
        rect.X = 0;
        rect.Y = 0;
        context.strokeRect(rect);
        // right upper quad
        rect.Width = quad;
        rect.Height = quad;
        rect.X = quad;
        rect.Y = quad;
        context.strokeRect(rect);
        // left upper quad
        rect.Width = quad;
        rect.Height = quad;
        rect.X = 0;
        rect.Y = quad + 1;
        context.fillRect(rect);
        // right lower quod
        rect.Width = quad;
        rect.Height = quad;
        rect.X = quad + 1;
        rect.Y = 0;
        context.fillRect(rect);
        // Now we fill in some corner bits with background
        // This is a bad hack but now sure what else to do
        context.setFillColor(this.backColor);
        rect.Height = 1;
        rect.Width = 1;
        rect.X = 0;
        rect.Y = 0;
        this.setPixels(context, rect);
        rect.X = 0;
        rect.Y = quad;
        this.setPixels(context, rect);
        rect.X = 0;
        rect.Y = quad;
        this.setPixels(context, rect);
        rect.X = quad;
        rect.Y = 0;
        this.setPixels(context, rect);
        rect.X = quad;
        rect.Y = quad;
        this.setPixels(context, rect);
        rect.X = quad;
        rect.Y = hatchSize;
        this.setPixels(context, rect);
        rect.X = hatchSize;
        rect.Y = 0;
        this.setPixels(context, rect);
        rect.X = hatchSize;
        rect.Y = quad;
        this.setPixels(context, rect);
        rect.X = hatchSize;
        rect.Y = hatchSize;
        this.setPixels(context, rect);
        // Now for the fake shiny thingys hack
        // Probably could use a line here but it is already
        // so hacky I will just use this.
        rect.X = 5;
        rect.Y = 3;
        this.setPixels(context, rect);
        rect.X = 6;
        rect.Y = 3;
        this.setPixels(context, rect);
        rect.X = 1;
        rect.Y = 7;
        this.setPixels(context, rect);
        rect.X = 2;
        rect.Y = 7;
        this.setPixels(context, rect);
    };
    HatchBrush.prototype.hatchDashedDiagonal = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        var halfMe = hatchHeight / 2.0;
        context.moveTo(0, halfMe);
        context.addLineToPoint(hatchWidth, hatchHeight);
        context.strokePath();
    };
    HatchBrush.prototype.hatchDashedHorizontal = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        var halfMe = hatchHeight / 2.0 - 1;
        hatchWidth -= 1;
        hatchHeight -= 1;
        context.moveTo(halfMe + 1, halfMe);
        context.addLineToPoint(hatchWidth, halfMe);
        context.strokePath();
        context.moveTo(0, hatchHeight);
        context.addLineToPoint(halfMe, hatchHeight);
        context.strokePath();
    };
    HatchBrush.prototype.hatchConfetti = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        //var lineWidth = getLineWidth (hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw confetti Rectangles in the foreground color */
        context.setFillColor(this.foreColor);
        var rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, 2, 2);
        // Do not see a mathematical equation so will just set
        // the same ones as in windows pattern.
        if (this.hatchStyle === _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.LargeConfetti) {
            this.setPixels(context, rect);
            rect.X = 2;
            rect.Y = 2;
            this.setPixels(context, rect);
            rect.X = 5;
            rect.Y = 1;
            this.setPixels(context, rect);
            rect.X = 6;
            rect.Y = 4;
            this.setPixels(context, rect);
            rect.X = 4;
            rect.Y = 6;
            this.setPixels(context, rect);
            rect.X = 1;
            rect.Y = 5;
            this.setPixels(context, rect);
        }
        else {
            rect.Width = 1;
            rect.Height = 1;
            this.setPixels(context, rect);
            rect.X = 3;
            rect.Y = 1;
            this.setPixels(context, rect);
            rect.X = 6;
            rect.Y = 2;
            this.setPixels(context, rect);
            rect.X = 2;
            rect.Y = 3;
            this.setPixels(context, rect);
            rect.X = 7;
            rect.Y = 4;
            this.setPixels(context, rect);
            rect.X = 4;
            rect.Y = 5;
            this.setPixels(context, rect);
            rect.X = 1;
            rect.Y = 6;
            this.setPixels(context, rect);
            rect.X = 5;
            rect.Y = 7;
            this.setPixels(context, rect);
        }
    };
    HatchBrush.prototype.hatchZigZag = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        var halfMe = hatchWidth / 2.0;
        hatchHeight -= 1;
        context.moveTo(0, 0);
        context.addLineToPoint(halfMe - 1, hatchHeight);
        context.strokePath();
        context.moveTo(halfMe + 1, hatchHeight);
        context.addLineToPoint(hatchWidth, 0);
        context.strokePath();
    };
    HatchBrush.prototype.hatchWave = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        //var lineWidth = getLineWidth (hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setFillColor(this.foreColor);
        var rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, 1, 1);
        // We could maybe draw some arcs here but there are so few pixels
        // that it just is not worth it.
        rect.X = 1;
        this.setPixels(context, rect);
        rect.X = 2;
        this.setPixels(context, rect);
        rect.Y = 1;
        rect.X = 0;
        this.setPixels(context, rect);
        rect.X = 3;
        this.setPixels(context, rect);
        rect.X = 6;
        this.setPixels(context, rect);
        rect.Y = 2;
        rect.X = 4;
        this.setPixels(context, rect);
        rect.X = 5;
        this.setPixels(context, rect);
    };
    HatchBrush.prototype.hatchHorizontalBrick = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setFillColor(this.foreColor);
        /* draw lines in the foreground color */
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        var rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, 1, 1);
        rect.Y = 3;
        rect.Width = hatchWidth;
        rect.Height = hatchHeight - 4;
        context.strokeRect(rect);
        context.moveTo(hatchWidth / 2.0, 0);
        context.addLineToPoint(hatchWidth / 2.0, 3);
        context.strokePath();
    };
    HatchBrush.prototype.hatchDiagonalBrick = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        hatchHeight -= 1;
        hatchWidth -= 1;
        context.moveTo(0, 0);
        context.addLineToPoint(hatchWidth, hatchHeight);
        context.strokePath();
        context.moveTo(0, hatchHeight);
        context.addLineToPoint(hatchWidth / 2.0, hatchHeight / 2.0);
        context.strokePath();
    };
    HatchBrush.prototype.hatchWeave = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setFillColor(this.foreColor);
        /* draw lines in the foreground color */
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        var halfWidth = hatchWidth / 2.0;
        var halfHeight = hatchHeight / 2.0;
        //CGRect rect = new CGRect (0,0,1,1);
        // Add upward diagonals
        context.moveTo(0, 0);
        context.addLineToPoint(halfWidth, halfHeight);
        context.strokePath();
        context.moveTo(0, halfHeight);
        context.addLineToPoint(halfWidth - 1, hatchHeight - 1);
        context.strokePath();
        context.moveTo(halfWidth, 0);
        context.addLineToPoint(6, 2);
        context.strokePath();
        //			context.MoveTo(0, 4);
        //			context.AddLineToPoint(2, 2);
        //			context.StrokePath();
        context.moveTo(2, 6);
        context.addLineToPoint(7, 1);
        context.strokePath();
    };
    HatchBrush.prototype.hatchTrellis = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        //var lineWidth = getLineWidth (hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.foreColor, hatchWidth, hatchHeight);
        context.setFillColor(this.backColor);
        var rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, 2, 1);
        this.setPixels(context, rect);
        rect.X = hatchWidth / 2.0;
        rect.Y = hatchHeight / 2.0;
        this.setPixels(context, rect);
    };
    HatchBrush.prototype.hatchCheckered = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        context.setFillColor(this.foreColor);
        var rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, hatchWidth / 2.0, hatchHeight / 2.0);
        this.setPixels(context, rect);
        rect.X = hatchWidth / 2.0;
        rect.Y = hatchHeight / 2.0;
        this.setPixels(context, rect);
    };
    HatchBrush.prototype.hatchOutlinedDiamond = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setFillColor(this.foreColor);
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        // this is really just two diagonal lines from each corner too
        // their opposite corners.
        context.moveTo(0, 0);
        context.addLineToPoint(hatchWidth, hatchHeight);
        context.strokePath();
        context.moveTo(1, hatchHeight);
        context.addLineToPoint(hatchWidth, 1);
        context.strokePath();
    };
    HatchBrush.prototype.hatchSolidDiamond = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setFillColor(this.foreColor);
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        var halfMe = hatchWidth / 2.0;
        // We will paint two triangles from corners meeting in the middle
        // make sure to offset by half pixels so that the point is actually a point.
        context.moveTo(-HALF_PIXEL_X, HALF_PIXEL_Y);
        context.addLineToPoint(2 + HALF_PIXEL_X, halfMe - HALF_PIXEL_Y);
        context.addLineToPoint(-HALF_PIXEL_X, hatchHeight - (1.0 + HALF_PIXEL_Y));
        context.closePath();
        context.fillPath();
        // now we do the right one
        context.moveTo(hatchWidth, HALF_PIXEL_Y);
        context.addLineToPoint(halfMe + HALF_PIXEL_X, halfMe - HALF_PIXEL_Y);
        context.addLineToPoint(hatchWidth, hatchHeight - (1.0 + HALF_PIXEL_Y));
        context.closePath();
        context.fillPath();
    };
    HatchBrush.prototype.hatchDottedDiamond = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setFillColor(this.foreColor);
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        var halfMe = hatchWidth / 2.0;
        var quarter = halfMe / 2.0;
        // this is really just 6 dots that when tiled will
        // create the effect we are looking for
        var rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, 1, 1);
        this.setPixels(context, rect);
        rect.Y = halfMe;
        this.setPixels(context, rect);
        rect.X = halfMe;
        this.setPixels(context, rect);
        rect.Y = 0;
        this.setPixels(context, rect);
        rect.X = quarter;
        rect.Y = quarter;
        this.setPixels(context, rect);
        rect.X = halfMe + quarter;
        rect.Y = halfMe + quarter;
        this.setPixels(context, rect);
    };
    HatchBrush.prototype.hatchShingle = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setFillColor(this.foreColor);
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        var halfMe = hatchWidth / 2.0;
        // We are basically going to draw a lamda sign
        // Draw base
        context.moveTo(0, 0);
        context.addLineToPoint(halfMe, halfMe - HALF_PIXEL_Y);
        context.addLineToPoint(hatchWidth, HALF_PIXEL_Y);
        context.strokePath();
        // draw the first part of tail
        context.moveTo(halfMe + HALF_PIXEL_X, halfMe);
        context.addLineToPoint(halfMe + HALF_PIXEL_X, halfMe + 1);
        context.strokePath();
        // now the last curl on the tail
        var rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(1, hatchHeight - 1, 1, 1);
        this.setPixels(context, rect);
        rect.X += 1;
        this.setPixels(context, rect);
        rect.X += 1;
        rect.Y -= 1;
        this.setPixels(context, rect);
    };
    HatchBrush.prototype.hatchDivot = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setFillColor(this.foreColor);
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        var halfMe = hatchWidth / 2.0;
        // draw a little wirly thingy
        var rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, 1, 1);
        this.setPixels(context, rect);
        rect.X += 1;
        rect.Y += 1;
        this.setPixels(context, rect);
        rect.X -= 1;
        rect.Y += 1;
        this.setPixels(context, rect);
        // now top one
        rect.X = halfMe; // + HALF_PIXEL_X;
        rect.Y = halfMe; // + HALF_PIXEL_Y;
        this.setPixels(context, rect);
        rect.X -= 1;
        rect.Y += 1;
        this.setPixels(context, rect);
        rect.X += 1;
        rect.Y += 1;
        this.setPixels(context, rect);
    };
    HatchBrush.prototype.hatchPlaid = function (context) {
        var hatchWidth = this.getHatchWidth(this.hatchStyle);
        var hatchHeight = this.getHatchHeight(this.hatchStyle);
        var lineWidth = this.getLineWidth(this.hatchStyle);
        this.initializeContext(context, hatchHeight, false);
        /* draw background */
        this.drawBackground(context, this.backColor, hatchWidth, hatchHeight);
        /* draw lines in the foreground color */
        context.setFillColor(this.foreColor);
        context.setStrokeColor(this.foreColor);
        context.setLineWidth(lineWidth);
        context.setLineCap(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGLineCap.Square);
        var halfMe = hatchWidth / 2.0;
        var rect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, 1, 1);
        // fraw the alternating pattern for half of area
        var x = 0;
        var y = 0;
        for (y = 0; y < halfMe; y += 2) {
            for (x = 1; x < hatchWidth; x += 2) {
                rect.X = x;
                rect.Y = y;
                this.setPixels(context, rect);
            }
        }
        for (y = 1; y < halfMe; y += 2) {
            for (x = 0; x < hatchWidth; x += 2) {
                rect.X = x;
                rect.Y = y;
                this.setPixels(context, rect);
            }
        }
        // draw a square
        rect.X = 0;
        rect.Y = halfMe;
        rect.Width = halfMe;
        rect.Height = halfMe;
        this.setPixels(context, rect);
    };
    HatchBrush.prototype.setPixels = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = args[0];
        if (args.length === 3) {
            this.setPixels(context, new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(args[1], args[2], 1.0, 1.0));
        }
        else if (args.length === 4) {
            this.setPixels(context, new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(args[1], args[2], args[3], args[3]));
        }
        else if (args.length === 2) {
            context.fillRect(args[1]);
        }
    };
    // Purple poka dots test
    HatchBrush.prototype.drawPolkaDotPattern = function (context) {
        context.setFillColor(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Purple);
        context.fillEllipseInRect(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(4, 4, 8, 8));
    };
    HatchBrush.prototype.setup = function (graphics, fill) {
        // if this is the same as the last that was set then return
        if (graphics.LastBrush === this)
            return;
        // obtain our width and height so we can set the pattern rectangle
        var hatch_width = this.getHatchWidth(this.hatchStyle);
        var hatch_height = this.getHatchHeight(this.hatchStyle);
        //choose the pattern to be filled based on the currentPattern selected
        /* var patternSpace = CGColorSpace.CreatePattern(null);
        graphics.context.SetFillColorSpace(patternSpace);
        graphics.context.SetStrokeColorSpace (patternSpace);
        patternSpace.Dispose(); */
        // Pattern default work variables
        var patternRect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(HALF_PIXEL_X, HALF_PIXEL_Y, hatch_width + HALF_PIXEL_X, hatch_height + HALF_PIXEL_Y);
        var patternTransform = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeIdentity();
        // Since all the patterns were developed with MonoMac on Mac OS the coordinate system is
        // defaulted to the lower left corner being 0,0 which means for MonoTouch and any view
        // that is flipped we need to flip it again.  Yep should have thought about it to begin with
        // will look into changing it later if need be.
        if (graphics.isFlipped) {
            patternTransform = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform(1, 0, 0, -1, 0, hatch_height);
        }
        // DrawPattern callback which will be set depending on hatch style
        //CGPattern.DrawPattern drawPattern;
        var drawPattern;
        switch (this.hatchStyle) {
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Horizontal:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.LightHorizontal:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.NarrowHorizontal:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DarkHorizontal:
                drawPattern = this.hatchHorizontal;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Vertical:
                patternTransform.translate(8, 0);
                patternTransform.rotate(90 * Math.PI / 180);
                drawPattern = this.hatchHorizontal;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.LightVertical:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.NarrowVertical:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DarkVertical:
                patternTransform.translate(4, 0);
                patternTransform.rotate(90 * Math.PI / 180);
                drawPattern = this.hatchHorizontal;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.ForwardDiagonal:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.WideDownwardDiagonal:
                patternTransform.translate(8, 0);
                patternTransform.scale(-1, 1);
                drawPattern = this.hatchUpwardDiagonal;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.LightDownwardDiagonal:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DarkDownwardDiagonal:
                // We will flip the x-axis here
                patternTransform.translate(4, 0);
                patternTransform.scale(-1, 1);
                drawPattern = this.hatchUpwardDiagonal;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.BackwardDiagonal:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.LightUpwardDiagonal:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DarkUpwardDiagonal:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.WideUpwardDiagonal:
                drawPattern = this.hatchUpwardDiagonal;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.LargeGrid:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.SmallGrid:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DottedGrid:
                drawPattern = this.hatchGrid;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DiagonalCross:
                drawPattern = this.hatchDiagonalCross;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent05:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent10:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent20:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent25:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent30:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent40:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent50:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent60:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent70:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent75:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent80:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Percent90:
                drawPattern = this.hatchPercentage;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Sphere:
                drawPattern = this.hatchSphere;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DashedDownwardDiagonal:
                patternTransform.translate(4, 0);
                patternTransform.scale(-1, 1);
                drawPattern = this.hatchDashedDiagonal;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DashedUpwardDiagonal:
                drawPattern = this.hatchDashedDiagonal;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DashedHorizontal:
                drawPattern = this.hatchDashedHorizontal;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DashedVertical:
                patternTransform.translate(-4, 0);
                patternTransform.rotate(-90 * Math.PI / 180);
                drawPattern = this.hatchDashedHorizontal;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.LargeConfetti:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.SmallConfetti:
                drawPattern = this.hatchConfetti;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.ZigZag:
                drawPattern = this.hatchZigZag;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Wave:
                drawPattern = this.hatchWave;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.HorizontalBrick:
                drawPattern = this.hatchHorizontalBrick;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DiagonalBrick:
                drawPattern = this.hatchDiagonalBrick;
                break;
            //			case HatchStyle.Weave:
            //				drawPattern = HatchWeave;
            //				break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Trellis:
                drawPattern = this.hatchTrellis;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.LargeCheckerBoard:
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.SmallCheckerBoard:
                drawPattern = this.hatchCheckered;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.OutlinedDiamond:
                drawPattern = this.hatchOutlinedDiamond;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.SolidDiamond:
                drawPattern = this.hatchSolidDiamond;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.DottedDiamond:
                drawPattern = this.hatchDottedDiamond;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Divot:
                drawPattern = this.hatchDivot;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Shingle:
                drawPattern = this.hatchShingle;
                break;
            case _HatchStyle__WEBPACK_IMPORTED_MODULE_2__.HatchStyle.Plaid:
                drawPattern = this.hatchPlaid;
                break;
            default:
                drawPattern = this.drawPolkaDotPattern;
                break;
        }
        //set the pattern as the Current Contexts fill pattern
        var pattern = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPattern(patternRect, patternTransform, hatch_width, hatch_height, _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPatternTiling.NoDistortion, true, drawPattern.bind(this));
        //we dont need to set any color, as the pattern cell itself has chosen its own color
        var aone = [1];
        graphics.renderer.setFillPattern(pattern, aone);
        graphics.renderer.setStrokePattern(pattern, aone);
        graphics.LastBrush = this;
        // I am setting this to be used for Text coloring in DrawString
        graphics.LastBrushColor = this.foreColor;
    };
    var HatchBrush_1;
    HatchBrush = HatchBrush_1 = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_4__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_3__.GraphicTypes.HatchBrush,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_3__.GraphicTypes.HatchBrush
            ]
        }),
        __metadata("design:paramtypes", [Object])
    ], HatchBrush);
    return HatchBrush;
}(_Brush__WEBPACK_IMPORTED_MODULE_1__.Brush));



/***/ }),

/***/ "./src/drawing/drawing2D/HatchStyle.ts":
/*!*********************************************!*\
  !*** ./src/drawing/drawing2D/HatchStyle.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HatchStyle": () => (/* binding */ HatchStyle)
/* harmony export */ });
var HatchStyle;
(function (HatchStyle) {
    HatchStyle[HatchStyle["Horizontal"] = 0] = "Horizontal";
    HatchStyle[HatchStyle["Vertical"] = 1] = "Vertical";
    HatchStyle[HatchStyle["ForwardDiagonal"] = 2] = "ForwardDiagonal";
    HatchStyle[HatchStyle["BackwardDiagonal"] = 3] = "BackwardDiagonal";
    HatchStyle[HatchStyle["Cross"] = 4] = "Cross";
    HatchStyle[HatchStyle["DiagonalCross"] = 5] = "DiagonalCross";
    HatchStyle[HatchStyle["Percent05"] = 6] = "Percent05";
    HatchStyle[HatchStyle["Percent10"] = 7] = "Percent10";
    HatchStyle[HatchStyle["Percent20"] = 8] = "Percent20";
    HatchStyle[HatchStyle["Percent25"] = 9] = "Percent25";
    HatchStyle[HatchStyle["Percent30"] = 10] = "Percent30";
    HatchStyle[HatchStyle["Percent40"] = 11] = "Percent40";
    HatchStyle[HatchStyle["Percent50"] = 12] = "Percent50";
    HatchStyle[HatchStyle["Percent60"] = 13] = "Percent60";
    HatchStyle[HatchStyle["Percent70"] = 14] = "Percent70";
    HatchStyle[HatchStyle["Percent75"] = 15] = "Percent75";
    HatchStyle[HatchStyle["Percent80"] = 16] = "Percent80";
    HatchStyle[HatchStyle["Percent90"] = 17] = "Percent90";
    HatchStyle[HatchStyle["LightDownwardDiagonal"] = 18] = "LightDownwardDiagonal";
    HatchStyle[HatchStyle["LightUpwardDiagonal"] = 19] = "LightUpwardDiagonal";
    HatchStyle[HatchStyle["DarkDownwardDiagonal"] = 20] = "DarkDownwardDiagonal";
    HatchStyle[HatchStyle["DarkUpwardDiagonal"] = 21] = "DarkUpwardDiagonal";
    HatchStyle[HatchStyle["WideDownwardDiagonal"] = 22] = "WideDownwardDiagonal";
    HatchStyle[HatchStyle["WideUpwardDiagonal"] = 23] = "WideUpwardDiagonal";
    HatchStyle[HatchStyle["LightVertical"] = 24] = "LightVertical";
    HatchStyle[HatchStyle["LightHorizontal"] = 25] = "LightHorizontal";
    HatchStyle[HatchStyle["NarrowVertical"] = 26] = "NarrowVertical";
    HatchStyle[HatchStyle["NarrowHorizontal"] = 27] = "NarrowHorizontal";
    HatchStyle[HatchStyle["DarkVertical"] = 28] = "DarkVertical";
    HatchStyle[HatchStyle["DarkHorizontal"] = 29] = "DarkHorizontal";
    HatchStyle[HatchStyle["DashedDownwardDiagonal"] = 30] = "DashedDownwardDiagonal";
    HatchStyle[HatchStyle["DashedUpwardDiagonal"] = 31] = "DashedUpwardDiagonal";
    HatchStyle[HatchStyle["DashedHorizontal"] = 32] = "DashedHorizontal";
    HatchStyle[HatchStyle["DashedVertical"] = 33] = "DashedVertical";
    HatchStyle[HatchStyle["SmallConfetti"] = 34] = "SmallConfetti";
    HatchStyle[HatchStyle["LargeConfetti"] = 35] = "LargeConfetti";
    HatchStyle[HatchStyle["ZigZag"] = 36] = "ZigZag";
    HatchStyle[HatchStyle["Wave"] = 37] = "Wave";
    HatchStyle[HatchStyle["DiagonalBrick"] = 38] = "DiagonalBrick";
    HatchStyle[HatchStyle["HorizontalBrick"] = 39] = "HorizontalBrick";
    HatchStyle[HatchStyle["Weave"] = 40] = "Weave";
    HatchStyle[HatchStyle["Plaid"] = 41] = "Plaid";
    HatchStyle[HatchStyle["Divot"] = 42] = "Divot";
    HatchStyle[HatchStyle["DottedGrid"] = 43] = "DottedGrid";
    HatchStyle[HatchStyle["DottedDiamond"] = 44] = "DottedDiamond";
    HatchStyle[HatchStyle["Shingle"] = 45] = "Shingle";
    HatchStyle[HatchStyle["Trellis"] = 46] = "Trellis";
    HatchStyle[HatchStyle["Sphere"] = 47] = "Sphere";
    HatchStyle[HatchStyle["SmallGrid"] = 48] = "SmallGrid";
    HatchStyle[HatchStyle["SmallCheckerBoard"] = 49] = "SmallCheckerBoard";
    HatchStyle[HatchStyle["LargeCheckerBoard"] = 50] = "LargeCheckerBoard";
    HatchStyle[HatchStyle["OutlinedDiamond"] = 51] = "OutlinedDiamond";
    HatchStyle[HatchStyle["SolidDiamond"] = 52] = "SolidDiamond";
    HatchStyle[HatchStyle["LargeGrid"] = 4] = "LargeGrid";
    HatchStyle[HatchStyle["Min"] = 0] = "Min";
    HatchStyle[HatchStyle["Max"] = 4] = "Max";
})(HatchStyle || (HatchStyle = {}));


/***/ }),

/***/ "./src/drawing/drawing2D/HitTester.ts":
/*!********************************************!*\
  !*** ./src/drawing/drawing2D/HitTester.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HitTester": () => (/* binding */ HitTester)
/* harmony export */ });
/* harmony import */ var _createCanvasElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createCanvasElement */ "./src/drawing/createCanvasElement.ts");
/* harmony import */ var _PathPointType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PathPointType */ "./src/drawing/PathPointType.ts");


var tempCanvas = (0,_createCanvasElement__WEBPACK_IMPORTED_MODULE_0__.createCanvasElement)();
var context = tempCanvas.getContext('2d');
var HitTester = /** @class */ (function () {
    function HitTester(graphicsPath) {
        this.myGraphicsPath = graphicsPath;
    }
    HitTester.prototype.plotPath = function (path) {
        var x1 = 0, y1 = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0;
        var points = path.PathPoints;
        var types = path.PathTypes;
        var bidx = 0;
        context.beginPath();
        for (var i = 0; i < points.length; i++) {
            var point = points[i];
            var type = types[i];
            switch (type & _PathPointType__WEBPACK_IMPORTED_MODULE_1__.PathPointType.PathTypeMask) {
                case _PathPointType__WEBPACK_IMPORTED_MODULE_1__.PathPointType.Start:
                    context.moveTo(point.X, point.Y);
                    break;
                case _PathPointType__WEBPACK_IMPORTED_MODULE_1__.PathPointType.Line:
                    context.lineTo(point.X, point.Y);
                    break;
                case _PathPointType__WEBPACK_IMPORTED_MODULE_1__.PathPointType.Bezier3:
                    // collect 3 points
                    switch (bidx++) {
                        case 0:
                            x1 = point.X;
                            y1 = point.Y;
                            break;
                        case 1:
                            x2 = point.X;
                            y2 = point.Y;
                            break;
                        case 2:
                            x3 = point.X;
                            y3 = point.Y;
                            break;
                    }
                    if (bidx === 3) {
                        context.bezierCurveTo(x1, y1, x2, y2, x3, y3);
                        bidx = 0;
                    }
                    break;
                default:
                    throw new Error("Inconsistent internal state, path type=" + type);
            }
            if ((type & _PathPointType__WEBPACK_IMPORTED_MODULE_1__.PathPointType.CloseSubpath) !== 0)
                context.closePath();
        }
    };
    HitTester.prototype.test = function (point) {
        //context.save();
        this.plotPath(this.myGraphicsPath);
        var result = context.isPointInPath(point.X, point.Y);
        //context.restore();
        return result;
    };
    return HitTester;
}());



/***/ }),

/***/ "./src/drawing/drawing2D/LineCap.ts":
/*!******************************************!*\
  !*** ./src/drawing/drawing2D/LineCap.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LineCap": () => (/* binding */ LineCap)
/* harmony export */ });
var LineCap;
(function (LineCap) {
    LineCap[LineCap["Flat"] = 0] = "Flat";
    LineCap[LineCap["Square"] = 1] = "Square";
    LineCap[LineCap["Round"] = 2] = "Round";
    LineCap[LineCap["Triangle"] = 3] = "Triangle";
    LineCap[LineCap["NoAnchor"] = 16] = "NoAnchor";
    LineCap[LineCap["SquareAnchor"] = 17] = "SquareAnchor";
    LineCap[LineCap["RoundAnchor"] = 18] = "RoundAnchor";
    LineCap[LineCap["DiamondAnchor"] = 19] = "DiamondAnchor";
    LineCap[LineCap["ArrowAnchor"] = 20] = "ArrowAnchor";
    LineCap[LineCap["Custom"] = 255] = "Custom";
    LineCap[LineCap["AnchorMask"] = 240] = "AnchorMask"; // mask to check for anchor or not.
})(LineCap || (LineCap = {}));


/***/ }),

/***/ "./src/drawing/drawing2D/LineJoin.ts":
/*!*******************************************!*\
  !*** ./src/drawing/drawing2D/LineJoin.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LineJoin": () => (/* binding */ LineJoin)
/* harmony export */ });
var LineJoin;
(function (LineJoin) {
    LineJoin[LineJoin["Miter"] = 0] = "Miter";
    LineJoin[LineJoin["Bevel"] = 1] = "Bevel";
    LineJoin[LineJoin["Round"] = 2] = "Round";
    LineJoin[LineJoin["MiterClipped"] = 3] = "MiterClipped";
})(LineJoin || (LineJoin = {}));


/***/ }),

/***/ "./src/drawing/drawing2D/LinearGradientBrush.ts":
/*!******************************************************!*\
  !*** ./src/drawing/drawing2D/LinearGradientBrush.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinearGradientBrush": () => (/* binding */ LinearGradientBrush)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Brush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Brush */ "./src/drawing/Brush.ts");
/* harmony import */ var _WrapMode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WrapMode */ "./src/drawing/drawing2D/WrapMode.ts");
/* harmony import */ var _Matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Matrix */ "./src/drawing/drawing2D/Matrix.ts");
/* harmony import */ var _Blend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Blend */ "./src/drawing/drawing2D/Blend.ts");
/* harmony import */ var _LinearGradientMode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LinearGradientMode */ "./src/drawing/drawing2D/LinearGradientMode.ts");
/* harmony import */ var _GeomUtilities__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../GeomUtilities */ "./src/drawing/GeomUtilities.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_8__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













function isNullOrUndefined(value) {
    return value == null;
}
var LinearGradientBrush = /** @class */ (function (_super) {
    __extends(LinearGradientBrush, _super);
    function LinearGradientBrush() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        // Fields
        _this.interpolationColorsWasSet = false;
        _this.wrapMode = _WrapMode__WEBPACK_IMPORTED_MODULE_2__.WrapMode.Tile;
        _this.gammaCorrection = undefined;
        //bool changed;
        _this.gradientTransform = new _Matrix__WEBPACK_IMPORTED_MODULE_3__.Matrix();
        _this.startPoint = undefined;
        _this.endPoint = undefined;
        _this.colors = new Array(2);
        _this.colorBlend = undefined;
        _this.rectangle = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty;
        _this.angle = 0;
        _this.angleIsScalable = false;
        _this.mode = _LinearGradientMode__WEBPACK_IMPORTED_MODULE_5__.LinearGradientMode.Horizontal;
        _this.modeWasSet = false;
        _this.positions = [0, 0.5, 1];
        _this.factors = undefined;
        // Everything I have read on the internet shows Microsoft
        // using a 2.2 gamma correction for colors.
        // for instance: http://msdn.microsoft.com/en-gb/library/windows/desktop/hh972627(v=vs.85).aspx
        _this.gamma = 1.0 / 2.2;
        // Shading
        _this.shadingColors = undefined;
        // When stroking with a gradient we have to use Transparency Layers.
        _this.hasTransparencyLayer = false;
        if (args.length === 3 && args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle) {
            _this.rectangle = args[0];
            _this.colors[0] = args[1];
            _this.colors[1] = args[2];
        }
        else if (args.length === 4 && args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle && typeof args[3] === 'string') {
            _this.rectangle = args[0];
            _this.colors[0] = args[1];
            _this.colors[1] = args[2];
            _this.mode = args[3];
            _this.modeWasSet = true;
        }
        else if (args.length === 4 && args[0] instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle && typeof args[3] === 'number') {
            /*  this.rectangle = args[0];
             this.colors[0] = args[1];
             this.colors[1] = args[2];
             this.angle = args[3]; */
            var outStartPoint = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.newOutEmpty)();
            var outEndPoint = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.newOutEmpty)();
            _GeomUtilities__WEBPACK_IMPORTED_MODULE_6__.GeomUtilities.ComputeOrientationLine(args[0], args[3], outStartPoint, outEndPoint);
            _this.startPoint = outStartPoint.value;
            _this.endPoint = outEndPoint.value;
            _this.angle = args[3];
            _this.colors[0] = args[1];
            _this.colors[1] = args[2];
            _this.rectangle = args[0];
        }
        else if (args.length === 4) {
            _this.startPoint = args[0];
            _this.endPoint = args[1];
            _this.colors[0] = args[2];
            _this.colors[1] = args[3];
            _this.rectangle.Size = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize(_this.endPoint.X - _this.startPoint.X, _this.endPoint.Y - _this.startPoint.Y);
            _this.rectangle.X = _this.rectangle.Width < 0 ? _this.endPoint.X : _this.startPoint.X;
            _this.rectangle.Y = _this.rectangle.Height < 0 ? _this.endPoint.Y : _this.startPoint.Y;
            if (_this.rectangle.Width < 0) {
                _this.rectangle.Width = -_this.rectangle.Width;
            }
            if (_this.rectangle.Height < 0) {
                _this.rectangle.Height = -_this.rectangle.Height;
            }
            if (_this.rectangle.Height === 0) {
                _this.rectangle.Height = _this.rectangle.Width;
                _this.rectangle.Y = _this.rectangle.Y - _this.rectangle.Height / 2.0;
            }
            else if (_this.rectangle.Width === 0) {
                _this.rectangle.Width = _this.rectangle.Height;
                _this.rectangle.X = _this.rectangle.X - _this.rectangle.Width / 2.0;
            }
        }
        else if (args.length === 5) {
            var outStartPoint = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.newOutEmpty)();
            var outEndPoint = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.newOutEmpty)();
            _GeomUtilities__WEBPACK_IMPORTED_MODULE_6__.GeomUtilities.ComputeOrientationLine(args[0], args[3], outStartPoint, outEndPoint);
            _this.startPoint = outStartPoint.value;
            _this.endPoint = outEndPoint.value;
            _this.angle = args[3];
            _this.angleIsScalable = args[4];
            _this.colors[0] = args[1];
            _this.colors[1] = args[2];
            _this.rectangle = args[0];
        }
        _this.blend = new _Blend__WEBPACK_IMPORTED_MODULE_4__.Blend(1);
        _this.blend.Factors = [1.0];
        _this.blend.Positions = [1.0];
        return _this;
    }
    LinearGradientBrush_1 = LinearGradientBrush;
    Object.defineProperty(LinearGradientBrush.prototype, "Blend", {
        get: function () {
            return this.blend;
        },
        set: function (value) {
            if (isNullOrUndefined(value)) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('Blend');
            }
            this.blend = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinearGradientBrush.prototype, "GammaCorrection", {
        get: function () {
            return this.gammaCorrection;
        },
        set: function (value) {
            if (this.gammaCorrection !== value) {
                this.gammaCorrection = value;
                this.changed = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinearGradientBrush.prototype, "InterpolationColors", {
        get: function () {
            return this.colorBlend;
        },
        set: function (value) {
            if (isNullOrUndefined(value)) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('ColorBlend');
            }
            this.colorBlend = value;
            this.interpolationColorsWasSet = true;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinearGradientBrush.prototype, "LinearColors", {
        get: function () {
            return [this.colors[0], this.colors[1]];
        },
        set: function (value) {
            // TODO: do some sanity tests?
            if (isNullOrUndefined(value) || isNullOrUndefined(value[0]) || isNullOrUndefined(value[1])) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('LinearColors');
            }
            this.colors[0] = value[0];
            this.colors[1] = value[1];
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinearGradientBrush.prototype, "Rectangle", {
        get: function () {
            return this.rectangle;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinearGradientBrush.prototype, "Transform", {
        get: function () {
            return this.gradientTransform;
        },
        set: function (value) {
            if (isNullOrUndefined(value)) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('Transform');
            }
            this.gradientTransform = value.clone();
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinearGradientBrush.prototype, "WrapMode", {
        get: function () {
            return this.wrapMode;
        },
        set: function (value) {
            if (isNullOrUndefined(value)) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('WrapMode');
            }
            this.wrapMode = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    LinearGradientBrush.prototype.Clone = function () {
        var clone = new LinearGradientBrush_1(this.rectangle, this.colors[0], this.colors[1], this.angle /* , this.angleIsScalable */);
        clone.Blend = this.blend;
        if (this.interpolationColorsWasSet) {
            clone.InterpolationColors = this.colorBlend;
        }
        clone.Transform = this.gradientTransform;
        clone.GammaCorrection = this.gammaCorrection;
        return clone;
    };
    LinearGradientBrush.prototype.multiplyTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.multiplyTransform(args[0], _Matrix__WEBPACK_IMPORTED_MODULE_3__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            if (isNullOrUndefined(args[0])) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('matrix');
            }
            this.gradientTransform.multiply(args[0], args[1]);
            this.changed = true;
        }
    };
    LinearGradientBrush.prototype.resetTransform = function () {
        this.gradientTransform.reset();
        this.changed = true;
    };
    LinearGradientBrush.prototype.rotateTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.rotateTransform(args[0], _Matrix__WEBPACK_IMPORTED_MODULE_3__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            if (isNullOrUndefined(args[0])) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('matrix');
            }
            this.gradientTransform.rotate(args[0], args[1]);
            this.changed = true;
        }
    };
    LinearGradientBrush.prototype.scaleTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.scaleTransform(args[0], args[1], _Matrix__WEBPACK_IMPORTED_MODULE_3__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            if (isNullOrUndefined(args[0])) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('matrix');
            }
            this.gradientTransform.scale(args[0], args[1], args[2]);
            this.changed = true;
        }
    };
    LinearGradientBrush.prototype.translateTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.translateTransform(args[0], args[1], _Matrix__WEBPACK_IMPORTED_MODULE_3__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            this.gradientTransform.translate(args[0], args[1], args[2]);
            this.changed = true;
        }
    };
    LinearGradientBrush.prototype.setBlendTriangularShape = function (focus, scale) {
        if (scale === void 0) { scale = 1.0; }
        if (focus < 0 || focus > 1 || scale < 0 || scale > 1) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('Invalid parameter passed.');
        }
        this.blend = new _Blend__WEBPACK_IMPORTED_MODULE_4__.Blend(3);
        this.blend.Positions[1] = focus;
        this.blend.Positions[2] = 1.0;
        this.blend.Factors[1] = scale;
        this.changed = true;
    };
    LinearGradientBrush.prototype.setSigmaBellShape = function (focus, scale) {
        if (scale === void 0) { scale = 1.0; }
        if (focus < 0 || focus > 1 || scale < 0 || scale > 1) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('Invalid parameter passed.');
        }
        this.Blend = _GeomUtilities__WEBPACK_IMPORTED_MODULE_6__.GeomUtilities.SigmaBellShape(focus, scale);
    };
    LinearGradientBrush.prototype.gradientLerp = function (data, outData) {
        var lerpDist = data;
        var i = 0;
        var numPositions = this.positions.length;
        // Make sure we put the linear distance value back into the 0.0 .. 1.0 range
        // depending on the wrap mode
        if (this.wrapMode === _WrapMode__WEBPACK_IMPORTED_MODULE_2__.WrapMode.Tile || this.wrapMode === _WrapMode__WEBPACK_IMPORTED_MODULE_2__.WrapMode.TileFlipY) {
            // Repeat
            lerpDist = lerpDist - Math.floor(lerpDist);
        }
        else {
            // Reflect
            lerpDist = Math.abs(lerpDist) % 2.0;
            if (lerpDist > 1.0) {
                lerpDist = 2.0 - lerpDist;
            }
        }
        for (i = 0; i < numPositions; i++) {
            if (this.positions[i] > lerpDist)
                break;
        }
        var prevPosition = 0;
        var dist = 0;
        var normalized = 0;
        if (i == 0 || i == numPositions) {
            if (i == numPositions)
                --i;
            // When we have multiple positions we need to interpolate the colors
            // between the two positions.
            // normalized will be the normalized [0,1] amount
            // of the gradiant area between the two positions.
            //
            // The shading colors have already
            // been setup with the color factors taken into account.
            // Get the distance between current position and last position
            dist = this.factors[i] - prevPosition;
            // normalized value between the two shading colors
            normalized = (lerpDist - prevPosition) / dist;
            for (var ctr = 0; ctr < 4; ctr++) {
                outData[ctr] = _GeomUtilities__WEBPACK_IMPORTED_MODULE_6__.GeomUtilities.Lerp(this.shadingColors[0][ctr], this.shadingColors[1][ctr], normalized);
            }
        }
        else {
            // When we have multiple positions we need to interpolate the colors
            // between the two positions.
            // normalized will be the normalized [0,1] amount
            // of the gradiant area between the two positions.
            //
            // The shading colors have already
            // been setup with the color factors taken into account.
            prevPosition = this.positions[i - 1];
            // Get the distance between current position and last position
            dist = this.positions[i] - prevPosition;
            // normalized value between the two shading colors
            normalized = (lerpDist - prevPosition) / dist;
            for (var ctr = 0; ctr < 4; ctr++) {
                outData[ctr] = _GeomUtilities__WEBPACK_IMPORTED_MODULE_6__.GeomUtilities.Lerp(this.shadingColors[i - 1][ctr], this.shadingColors[i][ctr], normalized);
            }
        }
        if (this.GammaCorrection) {
            // * NOTE * Here I am only computing the gamma correction for RGB values not alpha
            // I am really not sure if this is correct or not but from my reading on this topic
            // it is really never mentioned that alpha is included.
            for (var ctr = 0; ctr < 3; ctr++) {
                outData[ctr] = Math.pow(outData[ctr], this.gamma);
            }
        }
    };
    LinearGradientBrush.prototype.setColorsUsingBlend = function () {
        var size = this.blend.Positions.length;
        if (size == 1) {
            this.shadingColors = new Array(2);
            for (var i = 0; i < this.shadingColors.length; i++) {
                this.shadingColors[i] = [];
            }
            this.factors = new Array(2);
            for (var i = 0; i < this.factors.length; i++) {
                this.factors[i] = 0;
            }
            this.positions = new Array(2);
            for (var i = 0; i < this.positions.length; i++) {
                this.positions[i] = 0;
            }
            // check for default Blend to setup the shading colors
            // appropriately.
            if (this.blend.Factors[0] === 1 && this.blend.Positions[0] === 1) {
                this.factors[0] = 0;
                this.positions[0] = 0;
            }
            else {
                // This is a special case where a blend was set
                // with a factor.  It still does not give exact
                // results with windows.  Need to look at this as
                // still not sure what it should do.
                // Example:
                //	float[] myFactors = { 0.2f };
                //	float[] myPositions = { 0.0f };
                //	Blend myBlend = new Blend();
                //	myBlend.Factors = myFactors;
                //	myBlend.Positions = myPositions;
                //	lgBrush2.Blend = myBlend;
                this.factors[0] = this.blend.Factors[0];
                this.positions[0] = 1.0;
            }
            // Close off the color shadings
            this.factors[1] = 1.0;
            this.positions[1] = 1.0;
        }
        else {
            this.shadingColors = new Array(size);
            for (var i = 0; i < this.shadingColors.length; i++) {
                this.shadingColors[i] = [];
            }
            this.factors = this.blend.Factors;
            this.positions = this.blend.Positions;
        }
        var sc = [this.colors[0].R / 255, this.colors[0].G / 255, this.colors[0].B / 255, this.colors[0].A / 255];
        var ec = [this.colors[1].R / 255, this.colors[1].G / 255, this.colors[1].B / 255, this.colors[1].A / 255];
        var factor = 0;
        for (var s = 0; s < this.positions.length; s++) {
            this.shadingColors[s] = new Array(4);
            for (var i = 0; i < this.shadingColors[s].length; i++) {
                this.shadingColors[s][i] = 0;
            }
            factor = this.factors[s];
            //Console.WriteLine("shadingIndex {0} position {1} factor {2}",s, positions[s], factor);
            for (var c = 0; c < 4; c++) {
                this.shadingColors[s][c] = _GeomUtilities__WEBPACK_IMPORTED_MODULE_6__.GeomUtilities.Lerp(sc[c], ec[c], factor);
            }
        }
    };
    LinearGradientBrush.prototype.drawGradient = function (context) {
        var startColor = '#' + _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.RgbToHex(this.colors[0].R, this.colors[0].G, this.colors[0].B);
        var endColor = '#' + _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.RgbToHex(this.colors[1].R, this.colors[1].G, this.colors[1].B);
        if (this.modeWasSet) {
            switch (this.mode) {
                case _LinearGradientMode__WEBPACK_IMPORTED_MODULE_5__.LinearGradientMode.Horizontal:
                    this.angle = 0;
                    break;
                case _LinearGradientMode__WEBPACK_IMPORTED_MODULE_5__.LinearGradientMode.Vertical:
                    this.angle = 90;
                    break;
                case _LinearGradientMode__WEBPACK_IMPORTED_MODULE_5__.LinearGradientMode.ForwardDiagonal:
                    this.angle = 45;
                    break;
                case _LinearGradientMode__WEBPACK_IMPORTED_MODULE_5__.LinearGradientMode.BackwardDiagonal:
                    this.angle = 315;
                    break;
            }
        }
        if (this.angle === 90) {
            this.angle = 91;
        }
        if (this.angle === 180) {
            this.angle = 181;
        }
        if (this.angle === 270) {
            this.angle = 271;
        }
        if (this.angle === 360) {
            this.angle = 1;
        }
        var points = _GeomUtilities__WEBPACK_IMPORTED_MODULE_6__.GeomUtilities.GetSurroundingRectangle(this.angle, this.rectangle);
        //grd = context.canvasContext.createLinearGradient(this.startPoint.X, this.startPoint.Y, this.endPoint.X, this.endPoint.Y);
        var grd = context.canvasContext.createLinearGradient((points[1].X + points[0].X) / 2, (points[1].Y + points[0].Y) / 2, (points[2].X + points[3].X) / 2, (points[2].Y + points[3].Y) / 2);
        if (this.interpolationColorsWasSet) {
            for (var i = 0; i < this.InterpolationColors.Colors.length; i++) {
                grd.addColorStop(this.InterpolationColors.Positions[i], this.InterpolationColors.Colors[i].toString());
            }
        }
        else if (this.blend) {
            for (var i = 0; i < this.shadingColors.length; i++) {
                grd.addColorStop(this.positions[i], new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(this.shadingColors[i][0] * 255, this.shadingColors[i][1] * 255, this.shadingColors[i][2] * 255, this.shadingColors[i][3] * 255).toString());
            }
        }
        else {
            grd.addColorStop(0, this.colors[0].toString());
            grd.addColorStop(1, this.colors[1].toString());
        }
        context.canvasContext.fillStyle = grd;
        context.canvasContext.rect(0, 0, this.rectangle.Width, this.rectangle.Height);
        context.canvasContext.fill();
    };
    LinearGradientBrush.prototype.applyGammaCorrection = function (ctx) {
        if (this.GammaCorrection) {
            var image = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGImage(ctx.canvasContext);
            image.loadPixels();
            for (var x = 0; x < image.Width; x++) {
                for (var y = 0; y < image.Height; y++) {
                    var pixelColor = image.getPixelColor(x, y);
                    var newRed = 255 * Math.pow((pixelColor.R / 255), this.gamma);
                    var newGreen = 255 * Math.pow((pixelColor.G / 255), this.gamma);
                    var newBlue = 255 * Math.pow((pixelColor.B / 255), this.gamma);
                    var newAlpha = pixelColor.A;
                    image.set(x, y, new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor(Math.round(newRed), Math.round(newGreen), Math.round(newBlue), newAlpha));
                }
            }
            image.updatePixels();
        }
    };
    // TODO: Implement setup method
    LinearGradientBrush.prototype.setup = function (graphics, fill) {
        if (graphics.LastBrush === this)
            return;
        this.setColorsUsingBlend();
        /*  const startColor: string = '#' + Color.RgbToHex(this.colors[0].R, this.colors[0].G, this.colors[0].B);
         const endColor: string = '#' + Color.RgbToHex(this.colors[1].R, this.colors[1].G, this.colors[1].B);

         let grd;
         if (this.mode === LinearGradientMode.Horizontal) {
             grd = graphics.context.canvasContext.createLinearGradient(this.rectangle.Left, this.rectangle.Top, this.rectangle.Right, this.rectangle.Top);
         } else if (this.mode === LinearGradientMode.Vertical) {
             grd = graphics.context.canvasContext.createLinearGradient(this.rectangle.Left, this.rectangle.Top, this.rectangle.Left, this.rectangle.Bottom);
         } else if (this.mode === LinearGradientMode.ForwardDiagonal) {
             grd = graphics.context.canvasContext.createLinearGradient(this.rectangle.Left, this.rectangle.Top, this.rectangle.Right, this.rectangle.Bottom);
         } else if (this.mode === LinearGradientMode.BackwardDiagonal) {
             grd = graphics.context.canvasContext.createLinearGradient(this.rectangle.Right, this.rectangle.Top, this.rectangle.Left, this.rectangle.Bottom);
         }

         grd.addColorStop(0, startColor);
         grd.addColorStop(1, endColor);

         graphics.context.canvasContext.fillStyle = grd; */
        //let drawPattern: (context: CGContext) => void;
        var patternTransform = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeIdentity();
        patternTransform.multiply(this.gradientTransform.transform);
        var points = _GeomUtilities__WEBPACK_IMPORTED_MODULE_6__.GeomUtilities.GetSurroundingRectangle(30, this.rectangle);
        var transform = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeIdentity();
        transform.rotate((360 - 30) * Math.PI / 180);
        var point1 = transform.point(points[0]);
        var point2 = transform.point(points[1]);
        var point3 = transform.point(points[2]);
        var point4 = transform.point(points[3]);
        //this.rectangle = new RectangleF(point1, new SizeF(point4.X - point1.X, point2.Y - point1.Y));
        //patternTransform.translate( 0, -this.rectangle.Height / 2);
        /*  patternTransform.translate(this.rectangle.X + this.rectangle.Width / 2, this.rectangle.Y + this.rectangle.Height / 2);
         patternTransform.rotate(30 * Math.PI / 180);
         patternTransform.translate(-(this.rectangle.X + this.rectangle.Width / 2), -(this.rectangle.Y + this.rectangle.Height / 2)); */
        var pattern = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPattern(this.rectangle, patternTransform, this.rectangle.Width, this.rectangle.Height, _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPatternTiling.NoDistortion, true, this.drawGradient.bind(this), this.WrapMode, this.applyGammaCorrection.bind(this));
        //we dont need to set any color, as the pattern cell itself has chosen its own color
        var aone = [1];
        graphics.renderer.setFillPattern(pattern, aone);
        graphics.renderer.setStrokePattern(pattern, aone);
        graphics.LastBrush = this;
    };
    var LinearGradientBrush_1;
    LinearGradientBrush = LinearGradientBrush_1 = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_7__.GraphicTypes.LinearGradientBrush,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_7__.GraphicTypes.LinearGradientBrush
            ]
        }),
        __metadata("design:paramtypes", [Object])
    ], LinearGradientBrush);
    return LinearGradientBrush;
}(_Brush__WEBPACK_IMPORTED_MODULE_1__.Brush));



/***/ }),

/***/ "./src/drawing/drawing2D/LinearGradientMode.ts":
/*!*****************************************************!*\
  !*** ./src/drawing/drawing2D/LinearGradientMode.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinearGradientMode": () => (/* binding */ LinearGradientMode)
/* harmony export */ });
var LinearGradientMode;
(function (LinearGradientMode) {
    LinearGradientMode["Horizontal"] = "Horizontal";
    LinearGradientMode["Vertical"] = "Vertical";
    LinearGradientMode["ForwardDiagonal"] = "ForwardDiagonal";
    LinearGradientMode["BackwardDiagonal"] = "BackwardDiagonal";
})(LinearGradientMode || (LinearGradientMode = {}));


/***/ }),

/***/ "./src/drawing/drawing2D/Matrix.ts":
/*!*****************************************!*\
  !*** ./src/drawing/drawing2D/Matrix.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MatrixOrder": () => (/* binding */ MatrixOrder),
/* harmony export */   "Matrix": () => (/* binding */ Matrix)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);


var MatrixOrder;
(function (MatrixOrder) {
    MatrixOrder[MatrixOrder["Prepend"] = 0] = "Prepend";
    MatrixOrder[MatrixOrder["Append"] = 1] = "Append";
})(MatrixOrder || (MatrixOrder = {}));
var Matrix = /** @class */ (function () {
    function Matrix(param1, param2, param3, param4, param5, param6) {
        this.transform = undefined;
        if (arguments.length === 0) {
            this.transform = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeIdentity();
        }
        else if (arguments.length === 1 && param1 instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform) {
            this.transform = param1;
        }
        else if (arguments.length === 2 && param1 instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle && Array.isArray(param2)) {
            var rect = param1;
            var plgpts = param2;
            if (param2 == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException("plgpts");
            if (param2.length !== 3)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentException("plgpts");
            var p0 = plgpts[0];
            var p1 = plgpts[1];
            var p2 = plgpts[2];
            var m11 = (p1.X - p0.X) / rect.Width;
            var m12 = (p1.Y - p0.Y) / rect.Width;
            var m21 = (p2.X - p0.X) / rect.Height;
            var m22 = (p2.Y - p0.Y) / rect.Height;
            this.transform = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeTranslation(-rect.X, -rect.Y);
            this.transform.multiply(new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform(m11, m12, m21, m22, p0.X, p0.Y));
        }
        else if (arguments.length === 6 && typeof param1 === 'number' && typeof param2 === 'number' && typeof param3 === 'number' && typeof param4 === 'number' && typeof param5 === 'number' && typeof param6 === 'number') {
            this.transform = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform(param1, param2, param3, param4, param5, param6);
        }
    }
    Object.defineProperty(Matrix.prototype, "Elements", {
        get: function () {
            return [this.transform.m[0], this.transform.m[1], this.transform.m[2], this.transform.m[3], this.transform.m[4], this.transform.m[5]];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Matrix.prototype, "IsIdentity", {
        get: function () {
            return this.transform.IsIdentity;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Matrix.prototype, "IsInvertible", {
        get: function () {
            var inverted = this.transform.invert();
            if (inverted.m[0] === this.transform.m[0] &&
                inverted.m[2] === this.transform.m[2] &&
                inverted.m[1] === this.transform.m[1] &&
                inverted.m[3] === this.transform.m[3] &&
                inverted.m[4] === this.transform.m[4] &&
                inverted.m[5] === this.transform.m[5])
                return false;
            return true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Matrix.prototype, "OffsetX", {
        get: function () {
            return this.transform.m[4];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Matrix.prototype, "OffsetY", {
        get: function () {
            return this.transform.m[5];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Matrix.prototype, "IsScaled", {
        get: function () {
            return this.transform.m[0] !== 1 || this.transform.m[3] !== 1;
        },
        enumerable: false,
        configurable: true
    });
    Matrix.prototype.clone = function () {
        var copy = new Matrix();
        copy.transform = this.transform;
        return copy;
    };
    Matrix.prototype.Dispose = function () {
    };
    Matrix.prototype.equals = function (m) {
        if (m != null) {
            var o = m.transform;
            var t = this.transform;
            return (o.m[4] === t.m[4] && o.m[5] === t.m[5] &&
                o.m[0] === t.m[0] && o.m[3] === t.m[3] &&
                o.m[2] === t.m[2] && o.m[1] == t.m[1]);
        }
        else
            return false;
    };
    Matrix.prototype.getHashCode = function () {
        return this.transform.getHashCode();
    };
    Matrix.prototype.invert = function () {
        this.transform = this.transform.invert();
    };
    Matrix.prototype.multiply = function (matrix, order) {
        if (arguments.length === 1) {
            if (matrix == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException("matrix");
            this.multiply(matrix, MatrixOrder.Prepend);
        }
        else if (arguments.length === 2) {
            if (matrix == null)
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException("matrix");
            if (order == MatrixOrder.Append)
                this.transform.multiply(matrix.transform);
            else {
                var mtrans = matrix.transform;
                mtrans.multiply(this.transform);
                this.transform = mtrans;
            }
        }
    };
    Matrix.prototype.reset = function () {
        this.transform = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeIdentity();
    };
    Matrix.prototype.rotate = function (angle, order) {
        if (arguments.length === 1) {
            this.rotate(angle, MatrixOrder.Prepend);
        }
        else if (arguments.length === 2) {
            angle *= (Math.PI / 180.0); // degrees to radians
            var affine = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeRotation(angle);
            if (order === MatrixOrder.Append)
                this.transform.multiply(affine);
            else {
                affine.multiply(this.transform);
                this.transform = affine;
            }
        }
    };
    Matrix.prototype.rotateAt = function (angle, point, order) {
        if (arguments.length === 2) {
            this.rotateAt(angle, point, MatrixOrder.Prepend);
        }
        else if (arguments.length === 3 && order != null) {
            if ((order < MatrixOrder.Prepend) || (order > MatrixOrder.Append))
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentException("order");
            angle *= (Math.PI / 180.0); // degrees to radians
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var e4 = -point.X * cos + point.Y * sin + point.X;
            var e5 = -point.X * sin - point.Y * cos + point.Y;
            var m = this.Elements;
            if (order == MatrixOrder.Prepend) {
                this.transform = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform(cos * m[0] + sin * m[2], cos * m[1] + sin * m[3], -sin * m[0] + cos * m[2], -sin * m[1] + cos * m[3], e4 * m[0] + e5 * m[2] + m[4], e4 * m[1] + e5 * m[3] + m[5]);
            }
            else {
                this.transform = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform(m[0] * cos + m[1] * -sin, m[0] * sin + m[1] * cos, m[2] * cos + m[3] * -sin, m[2] * sin + m[3] * cos, m[4] * cos + m[5] * -sin + e4, m[4] * sin + m[5] * cos + e5);
            }
        }
    };
    Matrix.prototype.scale = function (scaleX, scaleY, order) {
        if (arguments.length === 2) {
            this.scale(scaleX, scaleY, MatrixOrder.Prepend);
        }
        else if (arguments.length === 3) {
            var affine = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeScale(scaleX, scaleY);
            if (order === MatrixOrder.Append)
                this.transform.multiply(affine);
            else {
                affine.multiply(this.transform);
                this.transform = affine;
            }
        }
    };
    Matrix.prototype.shear = function (shearX, shearY, order) {
        if (arguments.length === 2) {
            this.shear(shearX, shearY, MatrixOrder.Prepend);
        }
        else if (arguments.length === 3) {
            var affine = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform(1, shearY, shearX, 1, 0, 0);
            if (order == MatrixOrder.Append)
                this.transform.multiply(affine);
            else {
                affine.multiply(this.transform);
                this.transform = affine;
            }
        }
    };
    Matrix.prototype.transformPoints = function (pts) {
        if (pts == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException("pts");
        for (var i = 0; i < pts.length; i++) {
            var point = pts[i];
            pts[i] = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint((this.transform.m[0] * point.X + this.transform.m[2] * point.Y + this.transform.m[4]), (this.transform.m[1] * point.X + this.transform.m[3] * point.Y + this.transform.m[5]));
        }
    };
    Matrix.prototype.transformVectors = function (pts) {
        if (pts == null)
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.ArgumentNullException("pts");
        for (var i = 0; i < pts.length; i++) {
            var point = pts[i];
            pts[i] = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint((this.transform.m[0] * point.X + this.transform.m[2] * point.Y), (this.transform.m[1] * point.X + this.transform.m[3] * point.Y));
        }
    };
    Matrix.prototype.translate = function (offsetX, offsetY, order) {
        if (arguments.length === 2) {
            this.translate(offsetX, offsetY, MatrixOrder.Prepend);
        }
        else if (arguments.length === 3) {
            var affine = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGAffineTransform.MakeTranslation(offsetX, offsetY);
            if (order === MatrixOrder.Append)
                this.transform.multiply(affine);
            else {
                affine.multiply(this.transform);
                this.transform = affine;
            }
        }
    };
    Matrix.prototype.vectorTransformPoints = function (pts) {
        this.transformVectors(pts);
    };
    return Matrix;
}());



/***/ }),

/***/ "./src/drawing/drawing2D/PathData.ts":
/*!*******************************************!*\
  !*** ./src/drawing/drawing2D/PathData.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathData": () => (/* binding */ PathData)
/* harmony export */ });
var PathData = /** @class */ (function () {
    function PathData(points, types) {
        this.Points = points;
        this.Types = types;
    }
    return PathData;
}());



/***/ }),

/***/ "./src/drawing/drawing2D/PathGradientBrush.ts":
/*!****************************************************!*\
  !*** ./src/drawing/drawing2D/PathGradientBrush.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PathGradientBrush": () => (/* binding */ PathGradientBrush)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Brush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Brush */ "./src/drawing/Brush.ts");
/* harmony import */ var _WrapMode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WrapMode */ "./src/drawing/drawing2D/WrapMode.ts");
/* harmony import */ var _Matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Matrix */ "./src/drawing/drawing2D/Matrix.ts");
/* harmony import */ var _Blend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Blend */ "./src/drawing/drawing2D/Blend.ts");
/* harmony import */ var _ColorBlend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ColorBlend */ "./src/drawing/drawing2D/ColorBlend.ts");
/* harmony import */ var _FillMode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FillMode */ "./src/drawing/drawing2D/FillMode.ts");
/* harmony import */ var _GraphicsPath__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GraphicsPath */ "./src/drawing/drawing2D/GraphicsPath.ts");
/* harmony import */ var _GeomUtilities__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../GeomUtilities */ "./src/drawing/GeomUtilities.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_10__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};













var Edge = /** @class */ (function () {
    function Edge(v1, v2, v3, origin, color) {
        var ax = ~~v1.X;
        var ay = ~~v1.Y;
        var bx = ~~v2.X;
        var by = ~~v2.Y;
        var cx = ~~origin.X;
        var cy = ~~origin.Y;
        // Edge setup
        this.A = ~~Math.floor(ay) - ~~Math.floor(by);
        this.B = ~~Math.floor(bx) - ~~Math.floor(ax);
        this.C = ax * by - ay * bx;
        // Step deltas - This is setup here in case we want to process more than 1 x 1 pixel groups
        this.StepX = this.A * Edge.StepXSize;
        this.StepY = this.B * Edge.StepYSize;
        this.VertexFactor = 1.0 / ((bx - ax) * (~~v3.Y - ay) - (by - ay) * (~~v3.X - ax));
        // x/y values for initial pixel block
        var x = ~~origin.X;
        var y = ~~origin.Y;
        this.EdgeOrigin = this.A * x + this.B * y + this.C;
        this.Color = color;
    }
    // Dimensions of our pixel group
    Edge.StepXSize = 1;
    Edge.StepYSize = 1;
    return Edge;
}());
var PathGradientBrush = /** @class */ (function (_super) {
    __extends(PathGradientBrush, _super);
    function PathGradientBrush() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this.pathPoints = undefined;
        _this.wrapMode = _WrapMode__WEBPACK_IMPORTED_MODULE_2__.WrapMode.Clamp;
        _this.gradientTransform = new _Matrix__WEBPACK_IMPORTED_MODULE_3__.Matrix();
        _this.blend = undefined;
        _this.centerColor = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.White;
        _this.focusScales = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        _this.surroundColors = [_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.White];
        _this.colorBlend = new _ColorBlend__WEBPACK_IMPORTED_MODULE_5__.ColorBlend();
        _this.rectangle = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty;
        _this.centerPoint = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint.Empty;
        _this.polygonWinding = _FillMode__WEBPACK_IMPORTED_MODULE_6__.FillMode.Winding;
        _this.edge32Red = 0;
        _this.edge32Green = 0;
        _this.edge32Blue = 0;
        _this.edge32Alpha = 0;
        _this.edge13Red = 0;
        _this.edge13Green = 0;
        _this.edge13Blue = 0;
        _this.edge13Alpha = 0;
        _this.edge21Red = 0;
        _this.edge21Green = 0;
        _this.edge21Blue = 0;
        _this.edge21Alpha = 0;
        _this.pixelRect = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(0, 0, 1, 1);
        _this.colorOutput = new Array(4);
        if (args.length === 1 && args[0] instanceof _GraphicsPath__WEBPACK_IMPORTED_MODULE_7__.GraphicsPath) {
            var path = args[0];
            if (path == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("path");
            }
            var pathClone = path.Clone();
            pathClone.closeAllFigures();
            pathClone.flatten();
            _this.pathPoints = pathClone.PathPoints;
            // make sure we have a closed path
            if (_this.pathPoints[0] !== _this.pathPoints[_this.pathPoints.length - 1]) {
                var first = _this.pathPoints[0];
                var temps = new Array(_this.pathPoints.length + 1);
                for (var p = 0; p < _this.pathPoints.length; p++)
                    temps[p] = _this.pathPoints[p];
                temps[temps.length - 1] = first;
                _this.pathPoints = temps;
            }
            _this.rectangle = _GeomUtilities__WEBPACK_IMPORTED_MODULE_8__.GeomUtilities.PolygonBoundingBox(_this.pathPoints);
            _this.centerPoint = _GeomUtilities__WEBPACK_IMPORTED_MODULE_8__.GeomUtilities.PolygonCentroid(_this.pathPoints);
            _this.wrapMode = _WrapMode__WEBPACK_IMPORTED_MODULE_2__.WrapMode.Clamp;
            // verify the winding of the polygon so that we cen calculate the
            // edges correctly
            var vt1 = _this.pathPoints[0];
            var vt2 = _this.centerPoint;
            var vt3 = _this.pathPoints[1];
            var pWinding = vt1.X * vt2.Y - vt2.X * vt1.Y;
            pWinding += vt2.X * vt3.Y - vt3.X * vt2.Y;
            pWinding += vt3.X * vt1.Y - vt1.X * vt3.Y;
            // Positive is counter clockwise
            if (pWinding < 0)
                _this.polygonWinding = _FillMode__WEBPACK_IMPORTED_MODULE_6__.FillMode.Alternate;
            _this.blend = new _Blend__WEBPACK_IMPORTED_MODULE_4__.Blend(1);
            _this.blend.Factors = [1.0];
            _this.blend.Positions = [1.0];
        }
        else if ((args.length === 1 || args.length === 2) && Array.isArray(args[0])) {
            var points = args[0];
            var wrapMode = args[1] || _WrapMode__WEBPACK_IMPORTED_MODULE_2__.WrapMode.Clamp;
            if (points == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("points");
            }
            if ((wrapMode < _WrapMode__WEBPACK_IMPORTED_MODULE_2__.WrapMode.Tile) || (wrapMode > _WrapMode__WEBPACK_IMPORTED_MODULE_2__.WrapMode.Clamp)) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentException("WrapMode");
            }
            _this.pathPoints = points;
            // make sure we have a closed path
            if (_this.pathPoints[0] !== _this.pathPoints[_this.pathPoints.length - 1]) {
                var first = _this.pathPoints[0];
                var temps = new Array(_this.pathPoints.length + 1);
                for (var p = 0; p < _this.pathPoints.length; p++)
                    temps[p] = _this.pathPoints[p];
                temps[temps.length - 1] = first;
                _this.pathPoints = temps;
            }
            _this.rectangle = _GeomUtilities__WEBPACK_IMPORTED_MODULE_8__.GeomUtilities.PolygonBoundingBox(_this.pathPoints);
            _this.centerPoint = _GeomUtilities__WEBPACK_IMPORTED_MODULE_8__.GeomUtilities.PolygonCentroid(_this.pathPoints);
            _this.wrapMode = wrapMode;
            // verify the winding of the polygon so that we cen calculate the
            // edges correctly
            var vt1 = _this.pathPoints[0];
            var vt2 = _this.centerPoint;
            var vt3 = _this.pathPoints[1];
            var pWinding = vt1.X * vt2.Y - vt2.X * vt1.Y;
            pWinding += vt2.X * vt3.Y - vt3.X * vt2.Y;
            pWinding += vt3.X * vt1.Y - vt1.X * vt3.Y;
            if (pWinding < 0)
                _this.polygonWinding = _FillMode__WEBPACK_IMPORTED_MODULE_6__.FillMode.Alternate;
            _this.blend = new _Blend__WEBPACK_IMPORTED_MODULE_4__.Blend(1);
            _this.blend.Factors = [1.0];
            _this.blend.Positions = [1.0];
        }
        return _this;
    }
    Object.defineProperty(PathGradientBrush.prototype, "Blend", {
        get: function () {
            return this.blend;
        },
        set: function (value) {
            if (value == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("Blend");
            }
            this.blend = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PathGradientBrush.prototype, "CenterColor", {
        get: function () {
            return this.centerColor;
        },
        set: function (value) {
            if (value == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("CenterColor");
            }
            this.centerColor = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PathGradientBrush.prototype, "CenterPoint", {
        get: function () {
            return this.centerPoint;
        },
        set: function (value) {
            if (value == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("CenterPoint");
            }
            this.centerPoint = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PathGradientBrush.prototype, "FocusScales", {
        get: function () {
            return this.focusScales;
        },
        set: function (value) {
            if (value == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("focusScales");
            }
            this.focusScales = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PathGradientBrush.prototype, "InterpolationColors", {
        get: function () {
            return this.colorBlend;
        },
        set: function (value) {
            // no null check, MS throws a NullReferenceException here
            var count;
            var colors = value.Colors;
            var positions = value.Positions;
            count = colors.length;
            if (count === 0 || positions.length === 0) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentException("Invalid ColorBlend object. It should have at least 2 elements in each of the colors and positions arrays.");
            }
            if (count !== positions.length) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentException("Invalid ColorBlend object. It should contain the same number of positions and color values.");
            }
            if (positions[0] !== 0.0) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentException("Invalid ColorBlend object. The positions array must have 0.0 as its first element.");
            }
            if (positions[count - 1] !== 1.0) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentException("Invalid ColorBlend object. The positions array must have 1.0 as its last element.");
            }
            var blend = new Array(colors.length);
            for (var i = 0; i < colors.length; i++)
                blend[i] = colors[i].toRgba();
            this.colorBlend = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PathGradientBrush.prototype, "Rectangle", {
        get: function () {
            return this.rectangle;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PathGradientBrush.prototype, "SurroundColors", {
        get: function () {
            return this.surroundColors;
        },
        set: function (value) {
            if (value == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("SurroundColors");
            }
            this.surroundColors = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PathGradientBrush.prototype, "Transform", {
        get: function () {
            return this.gradientTransform;
        },
        set: function (value) {
            if (value == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("Transform");
            }
            this.gradientTransform = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PathGradientBrush.prototype, "WrapMode", {
        get: function () {
            return this.wrapMode;
        },
        set: function (value) {
            if (value == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("WrapMode");
            }
            this.wrapMode = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    PathGradientBrush.prototype.multiplyTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.multiplyTransform(args[0], _Matrix__WEBPACK_IMPORTED_MODULE_3__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("matrix");
            }
            this.gradientTransform.multiply(args[0], args[1]);
            this.changed = true;
        }
    };
    PathGradientBrush.prototype.resetTransform = function () {
        this.gradientTransform.reset();
        this.changed = true;
    };
    PathGradientBrush.prototype.rotateTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.rotateTransform(args[0], _Matrix__WEBPACK_IMPORTED_MODULE_3__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("matrix");
            }
            this.gradientTransform.rotate(args[0], args[1]);
            this.changed = true;
        }
    };
    PathGradientBrush.prototype.scaleTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.scaleTransform(args[0], args[1], _Matrix__WEBPACK_IMPORTED_MODULE_3__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentNullException("matrix");
            }
            this.gradientTransform.scale(args[0], args[1], args[2]);
            this.changed = true;
        }
    };
    PathGradientBrush.prototype.translateTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.translateTransform(args[0], args[1], _Matrix__WEBPACK_IMPORTED_MODULE_3__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            this.gradientTransform.translate(args[0], args[1], args[2]);
            this.changed = true;
        }
    };
    PathGradientBrush.prototype.setBlendTriangularShape = function (focus, scale) {
        if (scale === void 0) { scale = 1.0; }
        if (focus < 0 || focus > 1 || scale < 0 || scale > 1) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentException("Invalid parameter passed.");
        }
        this.blend = new _Blend__WEBPACK_IMPORTED_MODULE_4__.Blend(3);
        this.blend.Positions[1] = focus;
        this.blend.Positions[2] = 1.0;
        this.blend.Factors[1] = scale;
        this.changed = true;
    };
    PathGradientBrush.prototype.setSigmaBellShape = function (focus, scale) {
        if (scale === void 0) { scale = 1.0; }
        if (focus < 0 || focus > 1 || scale < 0 || scale > 1) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_10__.ArgumentException("Invalid parameter passed.");
        }
        this.Blend = _GeomUtilities__WEBPACK_IMPORTED_MODULE_8__.GeomUtilities.SigmaBellShape(focus, scale);
    };
    PathGradientBrush.prototype.Clone = function () {
        return undefined;
    };
    PathGradientBrush.prototype.setup = function (graphics, fill) {
        var context = graphics.renderer;
        // if fill is false then we are being called from a Pen stroke so
        // we need to setup a transparency layer
        // http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_shadings/dq_shadings.html#//apple_ref/doc/uid/TP30001066-CH207-BBCECJBF
        if (!fill) {
            // FIXME:
            // context.beginTransparencyLayer();
            // this.hasTransparencyLayer = true;
            // Make sure we set a color here so that the gradient shows up
            graphics.LastBrushColor = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Black;
            return;
        }
        // if this is the same as the last that was set and no changes have been made
        // then return.
        if (graphics.LastBrush != this || this.changed) {
            //setupShadingColors();
        }
        // Transform the start and end points using the brush's transformation matrix
        this.gradientTransform.transformPoints(this.pathPoints);
        this.rasterizePolygon(context, this.centerPoint, this.pathPoints, this.surroundColors, this.centerColor);
        // If we are in a Transparency layer then we need to end the transparency
        /* if (this.hasTransparencyLayer) {
            context.endTransparencyLayer();
        } */
        this.changed = false;
        graphics.LastBrush = this;
        // We will reset the last pen so that it can be setup again
        // so that we do not loose the settings after stroking the gradient
        // not sure where the setting are being reset so this may be a hack
        // and things are just not being restored correctly.
        graphics.LastPen = null;
        // I am setting this to be used for Text coloring in DrawString
        graphics.LastBrushColor = this.surroundColors[this.surroundColors.length - 1];
    };
    PathGradientBrush.prototype.rasterizePolygon = function (context, center, pathPoints, surroundColors, centerColor) {
        var last = pathPoints[0];
        var start = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Empty;
        var end = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Empty;
        var count = pathPoints.length - 1;
        var colorCount = surroundColors.length;
        var startIndex = 0;
        var endIndex = 1;
        //			// Create new stopwatch
        //			var stopwatch = new System.Diagnostics.Stopwatch ();
        //
        //			// Begin timing
        //			stopwatch.Start();
        for (var p = 1; p <= count; p++) {
            var next = pathPoints[p];
            if (startIndex >= colorCount) {
                start = surroundColors[colorCount - 1];
                end = surroundColors[colorCount - 1];
            }
            else {
                start = surroundColors[startIndex++];
                if (startIndex == colorCount) {
                    end = surroundColors[0];
                }
                else {
                    if (endIndex >= colorCount) {
                        end = surroundColors[colorCount - 1];
                    }
                    else {
                        end = surroundColors[endIndex++];
                    }
                }
            }
            //Console.WriteLine("triangle {0} P1 {1} P2 {2} P3 {3} color {4}", p, last, next, center, start);
            if (this.polygonWinding === _FillMode__WEBPACK_IMPORTED_MODULE_6__.FillMode.Winding)
                this.rasterizeTriangle(context, center, last, next, centerColor, start, end);
            else
                this.rasterizeTriangle(context, last, center, next, start, centerColor, end);
            last = next;
        }
        //			// Stop timing
        //			stopwatch.Stop();
        //
        //			// Write result
        //			Console.WriteLine("Time elapsed: {0}",
        //				stopwatch.Elapsed);
    };
    /// <summary>
    /// Rasterizes the triangle specified by the vector / points and their associated colors
    /// using barycentric coordinates.
    /// </summary>
    /// <param name="context"></param>
    /// <param name="vt1"></param>
    /// <param name="vt2"></param>
    /// <param name="vt3"></param>
    /// <param name="colorV1"></param>
    /// <param name="colorV2"></param>
    /// <param name="colorV3"></param>
    PathGradientBrush.prototype.rasterizeTriangle = function (context, vt1, vt2, vt3, colorV1, colorV2, colorV3) {
        // get the bounding box of the triangle
        var maxX = ~~Math.max(vt1.X, Math.max(vt2.X, vt3.X));
        var minX = ~~Math.min(vt1.X, Math.min(vt2.X, vt3.X));
        var maxY = ~~Math.max(vt1.Y, Math.max(vt2.Y, vt3.Y));
        var minY = ~~Math.min(vt1.Y, Math.min(vt2.Y, vt3.Y));
        // Barycentric coordinates at minX/minY corner
        var pm = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(minX, minY);
        var edge32 = new Edge(vt3, vt2, vt1, pm, colorV1);
        var edge13 = new Edge(vt1, vt3, vt2, pm, colorV2);
        var edge21 = new Edge(vt2, vt1, vt3, pm, colorV3);
        var span32 = edge32.EdgeOrigin;
        var span13 = edge13.EdgeOrigin;
        var span21 = edge21.EdgeOrigin;
        this.edge32Red = colorV1.R;
        this.edge32Green = colorV1.G;
        this.edge32Blue = colorV1.B;
        this.edge32Alpha = colorV1.A;
        this.edge13Red = colorV2.R;
        this.edge13Green = colorV2.G;
        this.edge13Blue = colorV2.B;
        this.edge13Alpha = colorV2.A;
        this.edge21Red = colorV3.R;
        this.edge21Green = colorV3.G;
        this.edge21Blue = colorV3.B;
        this.edge21Alpha = colorV3.A;
        var span32XOffset = 0;
        var span13XOffset = 0;
        var span21XOffset = 0;
        var inside = false;
        var mask = 0;
        //  Iterate over each pixel of bounding box and check if it's inside
        //  the triangle using the barycentirc approach.
        for (var y = minY; y <= maxY; y += Edge.StepYSize) {
            // Barycentric coordinates at start of row
            span32XOffset = span32;
            span13XOffset = span13;
            span21XOffset = span21;
            inside = false;
            for (var x = minX; x <= maxX; x += Edge.StepXSize) {
                mask = span32XOffset | span13XOffset | span21XOffset;
                // If p is on or inside all edges for any pixels,
                // render those pixels.
                if (mask >= 0) {
                    if (!inside) {
                        inside = true;
                    }
                    this.renderPixels(context, x, y, edge32, edge13, edge21, span32XOffset, span13XOffset, span21XOffset);
                }
                // Step to the right
                span32XOffset += edge32.StepX;
                span13XOffset += edge13.StepX;
                span21XOffset += edge21.StepX;
                if (mask < 0 && inside) {
                    inside = false;
                    break;
                }
            }
            // Row step
            span32 += edge32.StepY;
            span13 += edge13.StepY;
            span21 += edge21.StepY;
        }
    };
    PathGradientBrush.prototype.renderPixels = function (context, x, y, edge32, edge13, edge21, w1, w2, w3) {
        //VertexInterpoliation = A * x + B * y + C;
        //			float alpha = (edge32.A * x + edge32.B * y + edge32.C) * edge32.VertexFactor;
        //			float beta = (edge13.A * x + edge13.B * y + edge13.C)  * edge13.VertexFactor;
        //			float gamma = (edge21.A * x + edge21.B * y + edge21.C) * edge21.VertexFactor;
        // Determine barycentric coordinates
        var alpha = (w1 * edge32.VertexFactor);
        var beta = (w2 * edge13.VertexFactor);
        var gamma = (w3 * edge21.VertexFactor);
        this.gradientLerp3(alpha, beta, gamma);
        // Set the color
        this.colorOutput = this.colorOutput.map(function (item) { return Math.round(item); });
        context.setFillColor(this.colorOutput[0], this.colorOutput[1], this.colorOutput[2], this.colorOutput[3]);
        // Set our pixel location
        this.pixelRect.X = x;
        this.pixelRect.Y = y;
        // Fill the pixel
        context.fillRect(this.pixelRect);
    };
    PathGradientBrush.prototype.gradientLerp3 = function (alpha, beta, gamma) {
        var resRed = (alpha * this.edge32Red) + ((beta * this.edge13Red) + (gamma * this.edge21Red));
        var resGreen = (alpha * this.edge32Green) + ((beta * this.edge13Green) + (gamma * this.edge21Green));
        var resBlue = (alpha * this.edge32Blue) + ((beta * this.edge13Blue) + (gamma * this.edge21Blue));
        var resAlpha = (alpha * this.edge32Alpha) + ((beta * this.edge13Alpha) + (gamma * this.edge21Alpha));
        this.colorOutput[0] = resRed;
        this.colorOutput[1] = resGreen;
        this.colorOutput[2] = resBlue;
        this.colorOutput[3] = resAlpha;
    };
    PathGradientBrush.prototype.equals = function (obj) {
        return false;
        /* return (obj instanceof PathGradientBrush)
            && this.pathPoints.Equals(b.pathPoints)
            && wrapMode.Equals(b.wrapMode)
            && gradientTransform.Equals(b.gradientTransform)
            && centerColor.Equals(b.centerColor)
            && focusScales.Equals(b.focusScales)
            && surroundColors.Equals(b.surroundColors)
            && colorBlend.Equals(b.colorBlend)
            && rectangle.Equals(b.rectangle)
            && centerPoint.Equals(b.centerPoint)
            && polygonWinding.Equals(b.polygonWinding)
            && blend.Equals(b.blend); */
    };
    PathGradientBrush = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_10__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.PathGradientBrush,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_9__.GraphicTypes.PathGradientBrush
            ]
        }),
        __metadata("design:paramtypes", [Object])
    ], PathGradientBrush);
    return PathGradientBrush;
}(_Brush__WEBPACK_IMPORTED_MODULE_1__.Brush));



/***/ }),

/***/ "./src/drawing/drawing2D/PixelOffsetMode.ts":
/*!**************************************************!*\
  !*** ./src/drawing/drawing2D/PixelOffsetMode.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PixelOffsetMode": () => (/* binding */ PixelOffsetMode)
/* harmony export */ });
var PixelOffsetMode;
(function (PixelOffsetMode) {
    PixelOffsetMode[PixelOffsetMode["Invalid"] = -1] = "Invalid";
    PixelOffsetMode[PixelOffsetMode["Default"] = 0] = "Default";
    PixelOffsetMode[PixelOffsetMode["HighSpeed"] = 1] = "HighSpeed";
    PixelOffsetMode[PixelOffsetMode["HighQuality"] = 2] = "HighQuality";
    PixelOffsetMode[PixelOffsetMode["None"] = 3] = "None";
    PixelOffsetMode[PixelOffsetMode["Half"] = 4] = "Half"; // offset by -0.5, -0.5 for fast anti-alias perf
})(PixelOffsetMode || (PixelOffsetMode = {}));


/***/ }),

/***/ "./src/drawing/drawing2D/RadialGradientBrush.ts":
/*!******************************************************!*\
  !*** ./src/drawing/drawing2D/RadialGradientBrush.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RadialGradientBrush": () => (/* binding */ RadialGradientBrush)
/* harmony export */ });
/* harmony import */ var _LinearGradientBrush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LinearGradientBrush */ "./src/drawing/drawing2D/LinearGradientBrush.ts");
/* harmony import */ var _GeomUtilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GeomUtilities */ "./src/drawing/GeomUtilities.ts");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Brush__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Brush */ "./src/drawing/Brush.ts");
/* harmony import */ var _Matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Matrix */ "./src/drawing/drawing2D/Matrix.ts");
/* harmony import */ var _Blend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Blend */ "./src/drawing/drawing2D/Blend.ts");
/* harmony import */ var _WrapMode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WrapMode */ "./src/drawing/drawing2D/WrapMode.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_8__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};










var RadialGradientBrush = /** @class */ (function (_super) {
    __extends(RadialGradientBrush, _super);
    function RadialGradientBrush() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this.x1 = 0;
        _this.y1 = 0;
        _this.outerRadius = 0;
        _this.x2 = 0;
        _this.y2 = 0;
        _this.innerRadius = 0;
        _this.isRectangleMode = false;
        _this.angle = 0;
        // Fields
        _this.interpolationColorsWasSet = false;
        _this.gammaCorrection = false;
        //bool changed;
        _this.gradientTransform = new _Matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix();
        _this.startPoint = undefined;
        _this.endPoint = undefined;
        _this.colors = new Array(2);
        _this.colorBlend = undefined;
        _this.rectangle = _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGRectangle.Empty;
        _this.positions = [0, 0.5, 1];
        _this.factors = undefined;
        // Everything I have read on the internet shows Microsoft
        // using a 2.2 gamma correction for colors.
        // for instance: http://msdn.microsoft.com/en-gb/library/windows/desktop/hh972627(v=vs.85).aspx
        _this.gamma = 1.0 / 2.2;
        // Shading
        _this.shadingColors = undefined;
        // When stroking with a gradient we have to use Transparency Layers.
        _this.hasTransparencyLayer = false;
        if (args.length === 8 && typeof args[0] === 'number') {
            _this.x1 = args[0];
            _this.y1 = args[1];
            _this.innerRadius = args[2];
            _this.x2 = args[3];
            _this.y2 = args[4];
            _this.outerRadius = args[5];
            _this.colors[0] = args[6];
            _this.colors[1] = args[7];
            _this.rectangle = new _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGRectangle(0, 0, _this.outerRadius * 2, _this.outerRadius * 2);
        }
        else if (args.length === 3) {
            _this.rectangle = args[0];
            _this.colors[0] = args[1];
            _this.colors[1] = args[2];
            _this.isRectangleMode = true;
        }
        _this.blend = new _Blend__WEBPACK_IMPORTED_MODULE_5__.Blend(1);
        _this.blend.Factors = [1.0];
        _this.blend.Positions = [1.0];
        return _this;
    }
    Object.defineProperty(RadialGradientBrush.prototype, "Blend", {
        get: function () {
            return this.blend;
        },
        set: function (value) {
            if (value == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('Blend');
            }
            this.blend = value;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RadialGradientBrush.prototype, "GammaCorrection", {
        get: function () {
            return this.gammaCorrection;
        },
        set: function (value) {
            if (this.gammaCorrection !== value) {
                this.gammaCorrection = value;
                this.changed = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RadialGradientBrush.prototype, "InterpolationColors", {
        get: function () {
            return this.colorBlend;
        },
        set: function (value) {
            if (value == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('ColorBlend');
            }
            this.colorBlend = value;
            this.interpolationColorsWasSet = true;
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RadialGradientBrush.prototype, "LinearColors", {
        get: function () {
            return [this.colors[0], this.colors[1]];
        },
        set: function (value) {
            // TODO: do some sanity tests?
            if (value == null || value[0] == null || value[1] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('LinearColors');
            }
            this.colors[0] = value[0];
            this.colors[1] = value[1];
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RadialGradientBrush.prototype, "Rectangle", {
        get: function () {
            return this.rectangle;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RadialGradientBrush.prototype, "Transform", {
        get: function () {
            return this.gradientTransform;
        },
        set: function (value) {
            if (value == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('Transform');
            }
            this.gradientTransform = value.clone();
            this.changed = true;
        },
        enumerable: false,
        configurable: true
    });
    RadialGradientBrush.prototype.Clone = function () {
        var clone = new _LinearGradientBrush__WEBPACK_IMPORTED_MODULE_0__.LinearGradientBrush(this.rectangle, this.colors[0], this.colors[1], this.angle /* , this.angleIsScalable */);
        clone.Blend = this.blend;
        if (this.interpolationColorsWasSet) {
            clone.InterpolationColors = this.colorBlend;
        }
        clone.Transform = this.gradientTransform;
        clone.GammaCorrection = this.gammaCorrection;
        return clone;
    };
    RadialGradientBrush.prototype.multiplyTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.multiplyTransform(args[0], _Matrix__WEBPACK_IMPORTED_MODULE_4__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('matrix');
            }
            this.gradientTransform.multiply(args[0], args[1]);
            this.changed = true;
        }
    };
    RadialGradientBrush.prototype.resetTransform = function () {
        this.gradientTransform.reset();
        this.changed = true;
    };
    RadialGradientBrush.prototype.rotateTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.rotateTransform(args[0], _Matrix__WEBPACK_IMPORTED_MODULE_4__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('matrix');
            }
            this.gradientTransform.rotate(args[0], args[1]);
            this.changed = true;
        }
    };
    RadialGradientBrush.prototype.scaleTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.scaleTransform(args[0], args[1], _Matrix__WEBPACK_IMPORTED_MODULE_4__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            if (args[0] == null) {
                throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentNullException('matrix');
            }
            this.gradientTransform.scale(args[0], args[1], args[2]);
            this.changed = true;
        }
    };
    RadialGradientBrush.prototype.translateTransform = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            this.translateTransform(args[0], args[1], _Matrix__WEBPACK_IMPORTED_MODULE_4__.MatrixOrder.Prepend);
        }
        else if (args.length === 2) {
            this.gradientTransform.translate(args[0], args[1], args[2]);
            this.changed = true;
        }
    };
    RadialGradientBrush.prototype.setBlendTriangularShape = function (focus, scale) {
        if (scale === void 0) { scale = 1.0; }
        if (focus < 0 || focus > 1 || scale < 0 || scale > 1) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('Invalid parameter passed.');
        }
        this.blend = new _Blend__WEBPACK_IMPORTED_MODULE_5__.Blend(3);
        this.blend.Positions[1] = focus;
        this.blend.Positions[2] = 1.0;
        this.blend.Factors[1] = scale;
        this.changed = true;
    };
    RadialGradientBrush.prototype.setSigmaBellShape = function (focus, scale) {
        if (scale === void 0) { scale = 1.0; }
        if (focus < 0 || focus > 1 || scale < 0 || scale > 1) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_8__.ArgumentException('Invalid parameter passed.');
        }
        this.Blend = _GeomUtilities__WEBPACK_IMPORTED_MODULE_1__.GeomUtilities.SigmaBellShape(focus, scale);
    };
    RadialGradientBrush.prototype.setColorsUsingBlend = function () {
        var size = this.blend.Positions.length;
        if (size == 1) {
            this.shadingColors = new Array(2);
            for (var i = 0; i < this.shadingColors.length; i++) {
                this.shadingColors[i] = [];
            }
            this.factors = new Array(2);
            for (var i = 0; i < this.factors.length; i++) {
                this.factors[i] = 0;
            }
            this.positions = new Array(2);
            for (var i = 0; i < this.positions.length; i++) {
                this.positions[i] = 0;
            }
            // check for default Blend to setup the shading colors
            // appropriately.
            if (this.blend.Factors[0] === 1 && this.blend.Positions[0] === 1) {
                this.factors[0] = 0;
                this.positions[0] = 0;
            }
            else {
                // This is a special case where a blend was set
                // with a factor.  It still does not give exact
                // results with windows.  Need to look at this as
                // still not sure what it should do.
                // Example:
                //	float[] myFactors = { 0.2f };
                //	float[] myPositions = { 0.0f };
                //	Blend myBlend = new Blend();
                //	myBlend.Factors = myFactors;
                //	myBlend.Positions = myPositions;
                //	lgBrush2.Blend = myBlend;
                this.factors[0] = this.blend.Factors[0];
                this.positions[0] = 1.0;
            }
            // Close off the color shadings
            this.factors[1] = 1.0;
            this.positions[1] = 1.0;
        }
        else {
            this.shadingColors = new Array(size);
            for (var i = 0; i < this.shadingColors.length; i++) {
                this.shadingColors[i] = [];
            }
            this.factors = this.blend.Factors;
            this.positions = this.blend.Positions;
        }
        var sc = [this.colors[0].R / 255, this.colors[0].G / 255, this.colors[0].B / 255, this.colors[0].A / 255];
        var ec = [this.colors[1].R / 255, this.colors[1].G / 255, this.colors[1].B / 255, this.colors[1].A / 255];
        var factor = 0;
        for (var s = 0; s < this.positions.length; s++) {
            this.shadingColors[s] = new Array(4);
            for (var i = 0; i < this.shadingColors[s].length; i++) {
                this.shadingColors[s][i] = 0;
            }
            factor = this.factors[s];
            //Console.WriteLine("shadingIndex {0} position {1} factor {2}",s, positions[s], factor);
            for (var c = 0; c < 4; c++) {
                this.shadingColors[s][c] = _GeomUtilities__WEBPACK_IMPORTED_MODULE_1__.GeomUtilities.Lerp(sc[c], ec[c], factor);
            }
        }
    };
    RadialGradientBrush.prototype.drawGradient = function (context) {
        var startColor = '#' + _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGColor.RgbToHex(this.colors[0].R, this.colors[0].G, this.colors[0].B);
        var endColor = '#' + _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGColor.RgbToHex(this.colors[1].R, this.colors[1].G, this.colors[1].B);
        //const points = GeomUtilities.GetSurroundingRectangle(this.angle, this.rectangle);
        //grd = context.canvasContext.createLinearGradient(this.startPoint.X, this.startPoint.Y, this.endPoint.X, this.endPoint.Y);
        if (this.isRectangleMode) {
            var rx = this.rectangle.Width / Math.sqrt(2);
            var ry = this.rectangle.Height / Math.sqrt(2);
            var cx = this.rectangle.Width / 2;
            var cy = this.rectangle.Height / 2;
            var scaleX;
            var scaleY;
            var invScaleX;
            var invScaleY;
            var grad;
            rx = (rx == 0) ? 0.25 : rx;
            ry = (ry == 0) ? 0.25 : ry;
            var grd = void 0;
            if (rx >= ry) {
                scaleX = 1;
                invScaleX = 1;
                scaleY = ry / rx;
                invScaleY = rx / ry;
                grd = context.drawingContext.createRadialGradient(cx, cy * invScaleY, 0, cx, cy * invScaleY, rx);
            }
            else {
                scaleY = 1;
                invScaleY = 1;
                scaleX = rx / ry;
                invScaleX = ry / rx;
                grd = context.drawingContext.createRadialGradient(cx * invScaleX, cy, 0, cx * invScaleX, cy, ry);
            }
            if (this.interpolationColorsWasSet) {
                for (var i = 0; i < this.InterpolationColors.Colors.length; i++) {
                    grd.addColorStop(this.InterpolationColors.Positions[i], this.InterpolationColors.Colors[i].toString());
                }
            }
            else if (this.blend) {
                for (var i = 0; i < this.shadingColors.length; i++) {
                    grd.addColorStop(this.positions[i], new _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGColor(this.shadingColors[i][0] * 255, this.shadingColors[i][1] * 255, this.shadingColors[i][2] * 255, this.shadingColors[i][3] * 255).toString());
                }
            }
            else {
                grd.addColorStop(0, this.colors[0].toString());
                grd.addColorStop(1, this.colors[1].toString());
            }
            context.drawingContext.fillStyle = grd;
            context.drawingContext.setTransform(scaleX, 0, 0, scaleY, 0, 0);
            context.drawingContext.rect(0, 0, this.rectangle.Width * invScaleX, this.rectangle.Height * invScaleY);
            context.drawingContext.fill();
        }
        else {
            var grd = context.drawingContext.createRadialGradient(this.x1, this.y1, this.innerRadius, this.x2, this.y2, this.outerRadius);
            if (this.interpolationColorsWasSet) {
                for (var i = 0; i < this.InterpolationColors.Colors.length; i++) {
                    grd.addColorStop(this.InterpolationColors.Positions[i], this.InterpolationColors.Colors[i].toString());
                }
            }
            else if (this.blend) {
                for (var i = 0; i < this.shadingColors.length; i++) {
                    grd.addColorStop(this.positions[i], new _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGColor(this.shadingColors[i][0] * 255, this.shadingColors[i][1] * 255, this.shadingColors[i][2] * 255, this.shadingColors[i][3] * 255).toString());
                }
            }
            else {
                grd.addColorStop(0, this.colors[0].toString());
                grd.addColorStop(1, this.colors[1].toString());
            }
            context.drawingContext.fillStyle = grd;
            context.drawingContext.rect(0, 0, this.rectangle.Width, this.rectangle.Height);
            context.drawingContext.fill();
        }
    };
    RadialGradientBrush.prototype.applyGammaCorrection = function (ctx) {
        if (this.GammaCorrection) {
            var image = new _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGImage(ctx.drawingContext);
            image.loadPixels();
            for (var x = 0; x < image.Width; x++) {
                for (var y = 0; y < image.Height; y++) {
                    var pixelColor = image.getPixelColor(x, y);
                    var newRed = 255 * Math.pow((pixelColor.R / 255), this.gamma);
                    var newGreen = 255 * Math.pow((pixelColor.G / 255), this.gamma);
                    var newBlue = 255 * Math.pow((pixelColor.B / 255), this.gamma);
                    var newAlpha = pixelColor.A;
                    image.set(x, y, new _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGColor(Math.round(newRed), Math.round(newGreen), Math.round(newBlue), newAlpha));
                }
            }
            image.updatePixels();
        }
    };
    // TODO: Implement setup method
    RadialGradientBrush.prototype.setup = function (graphics, fill) {
        if (graphics.LastBrush === this)
            return;
        this.setColorsUsingBlend();
        /*  const startColor: string = '#' + Color.RgbToHex(this.colors[0].R, this.colors[0].G, this.colors[0].B);
         const endColor: string = '#' + Color.RgbToHex(this.colors[1].R, this.colors[1].G, this.colors[1].B);

         let grd;
         if (this.mode === LinearGradientMode.Horizontal) {
             grd = graphics.context.canvasContext.createLinearGradient(this.rectangle.Left, this.rectangle.Top, this.rectangle.Right, this.rectangle.Top);
         } else if (this.mode === LinearGradientMode.Vertical) {
             grd = graphics.context.canvasContext.createLinearGradient(this.rectangle.Left, this.rectangle.Top, this.rectangle.Left, this.rectangle.Bottom);
         } else if (this.mode === LinearGradientMode.ForwardDiagonal) {
             grd = graphics.context.canvasContext.createLinearGradient(this.rectangle.Left, this.rectangle.Top, this.rectangle.Right, this.rectangle.Bottom);
         } else if (this.mode === LinearGradientMode.BackwardDiagonal) {
             grd = graphics.context.canvasContext.createLinearGradient(this.rectangle.Right, this.rectangle.Top, this.rectangle.Left, this.rectangle.Bottom);
         }

         grd.addColorStop(0, startColor);
         grd.addColorStop(1, endColor);

         graphics.context.canvasContext.fillStyle = grd; */
        //let drawPattern: (context: CGContext) => void;
        var patternTransform = _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGAffineTransform.MakeIdentity();
        patternTransform.multiply(this.gradientTransform.transform);
        var points = _GeomUtilities__WEBPACK_IMPORTED_MODULE_1__.GeomUtilities.GetSurroundingRectangle(30, this.rectangle);
        var transform = _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGAffineTransform.MakeIdentity();
        transform.rotate((360 - 30) * Math.PI / 180);
        var point1 = transform.point(points[0]);
        var point2 = transform.point(points[1]);
        var point3 = transform.point(points[2]);
        var point4 = transform.point(points[3]);
        //this.rectangle = new RectangleF(point1, new SizeF(point4.X - point1.X, point2.Y - point1.Y));
        //patternTransform.translate( 0, -this.rectangle.Height / 2);
        /*  patternTransform.translate(this.rectangle.X + this.rectangle.Width / 2, this.rectangle.Y + this.rectangle.Height / 2);
         patternTransform.rotate(30 * Math.PI / 180);
         patternTransform.translate(-(this.rectangle.X + this.rectangle.Width / 2), -(this.rectangle.Y + this.rectangle.Height / 2)); */
        var pattern = new _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGPattern(this.rectangle, patternTransform, this.rectangle.Width, this.rectangle.Height, _tuval_cg__WEBPACK_IMPORTED_MODULE_2__.CGPatternTiling.NoDistortion, true, this.drawGradient.bind(this), _WrapMode__WEBPACK_IMPORTED_MODULE_6__.WrapMode.Tile, this.applyGammaCorrection.bind(this));
        //we dont need to set any color, as the pattern cell itself has chosen its own color
        var aone = [1];
        graphics.renderer.setFillPattern(pattern, aone);
        graphics.renderer.setStrokePattern(pattern, aone);
        graphics.LastBrush = this;
    };
    RadialGradientBrush = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_8__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_7__.GraphicTypes.RadialGradientBrush,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_7__.GraphicTypes.RadialGradientBrush
            ]
        }),
        __metadata("design:paramtypes", [Object])
    ], RadialGradientBrush);
    return RadialGradientBrush;
}(_Brush__WEBPACK_IMPORTED_MODULE_3__.Brush));



/***/ }),

/***/ "./src/drawing/drawing2D/WrapMode.ts":
/*!*******************************************!*\
  !*** ./src/drawing/drawing2D/WrapMode.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WrapMode": () => (/* binding */ WrapMode)
/* harmony export */ });
var WrapMode;
(function (WrapMode) {
    WrapMode[WrapMode["Tile"] = 0] = "Tile";
    WrapMode[WrapMode["TileFlipX"] = 1] = "TileFlipX";
    WrapMode[WrapMode["TileFlipY"] = 2] = "TileFlipY";
    WrapMode[WrapMode["TileFlipXY"] = 3] = "TileFlipXY";
    WrapMode[WrapMode["Clamp"] = 4] = "Clamp";
})(WrapMode || (WrapMode = {}));


/***/ }),

/***/ "./src/drawing/fontMeasure.ts":
/*!************************************!*\
  !*** ./src/drawing/fontMeasure.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "measureFont": () => (/* binding */ measureFont)
/* harmony export */ });
/* let measure = requrie('font-measure')

measure('Roboto') */
measureFont.canvas = document.createElement('canvas');
measureFont.cache = {};
function measureFont(font, o) {
    if (!o)
        o = {};
    if (typeof font === 'string' || Array.isArray(font)) {
        o.family = font;
    }
    var family = Array.isArray(o.family) ? o.family.join(', ') : o.family;
    if (!family)
        throw Error('`family` must be defined');
    var fs = o.size || o.fontSize || o.em || 48;
    var weight = o.weight || o.fontWeight || '';
    var style = o.style || o.fontStyle || '';
    var font = [style, weight, fs].join(' ') + 'px ' + family;
    var origin = o.origin || 'top';
    if (measureFont.cache[family]) {
        // return more precise values if cache has them
        if (fs <= measureFont.cache[family].em) {
            return applyOrigin(measureFont.cache[family], origin);
        }
    }
    var canvas = o.canvas || measureFont.canvas;
    var ctx = canvas.getContext('2d');
    var chars = {
        upper: o.upper !== undefined ? o.upper : 'H',
        lower: o.lower !== undefined ? o.lower : 'x',
        descent: o.descent !== undefined ? o.descent : 'p',
        ascent: o.ascent !== undefined ? o.ascent : 'h',
        tittle: o.tittle !== undefined ? o.tittle : 'i',
        overshoot: o.overshoot !== undefined ? o.overshoot : 'O'
    };
    var l = Math.ceil(fs * 1.5);
    canvas.height = l;
    canvas.width = l * .5;
    ctx.font = font;
    var char = 'H';
    var result = {
        top: 0
    };
    // measure line-height
    ctx.clearRect(0, 0, l, l);
    ctx.textBaseline = 'top';
    ctx.fillStyle = 'black';
    ctx.fillText(char, 0, 0);
    var topPx = firstTop(ctx.getImageData(0, 0, l, l));
    ctx.clearRect(0, 0, l, l);
    ctx.textBaseline = 'bottom';
    ctx.fillText(char, 0, l);
    var bottomPx = firstTop(ctx.getImageData(0, 0, l, l));
    result.lineHeight =
        result.bottom = l - bottomPx + topPx;
    // measure baseline
    ctx.clearRect(0, 0, l, l);
    ctx.textBaseline = 'alphabetic';
    ctx.fillText(char, 0, l);
    var baselinePx = firstTop(ctx.getImageData(0, 0, l, l));
    var baseline = l - baselinePx - 1 + topPx;
    result.baseline =
        result.alphabetic = baseline;
    // measure median
    ctx.clearRect(0, 0, l, l);
    ctx.textBaseline = 'middle';
    ctx.fillText(char, 0, l * .5);
    var medianPx = firstTop(ctx.getImageData(0, 0, l, l));
    result.median =
        result.middle = l - medianPx - 1 + topPx - l * .5;
    // measure hanging
    ctx.clearRect(0, 0, l, l);
    ctx.textBaseline = 'hanging';
    ctx.fillText(char, 0, l * .5);
    var hangingPx = firstTop(ctx.getImageData(0, 0, l, l));
    result.hanging = l - hangingPx - 1 + topPx - l * .5;
    // measure ideographic
    ctx.clearRect(0, 0, l, l);
    ctx.textBaseline = 'ideographic';
    ctx.fillText(char, 0, l);
    var ideographicPx = firstTop(ctx.getImageData(0, 0, l, l));
    result.ideographic = l - ideographicPx - 1 + topPx;
    // measure cap
    if (chars.upper) {
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = 'top';
        ctx.fillText(chars.upper, 0, 0);
        result.upper = firstTop(ctx.getImageData(0, 0, l, l));
        result.capHeight = (result.baseline - result.upper);
    }
    // measure x
    if (chars.lower) {
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = 'top';
        ctx.fillText(chars.lower, 0, 0);
        result.lower = firstTop(ctx.getImageData(0, 0, l, l));
        result.xHeight = (result.baseline - result.lower);
    }
    // measure tittle
    if (chars.tittle) {
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = 'top';
        ctx.fillText(chars.tittle, 0, 0);
        result.tittle = firstTop(ctx.getImageData(0, 0, l, l));
    }
    // measure ascent
    if (chars.ascent) {
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = 'top';
        ctx.fillText(chars.ascent, 0, 0);
        result.ascent = firstTop(ctx.getImageData(0, 0, l, l));
    }
    // measure descent
    if (chars.descent) {
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = 'top';
        ctx.fillText(chars.descent, 0, 0);
        result.descent = firstBottom(ctx.getImageData(0, 0, l, l));
    }
    // measure overshoot
    if (chars.overshoot) {
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = 'top';
        ctx.fillText(chars.overshoot, 0, 0);
        var overshootPx = firstBottom(ctx.getImageData(0, 0, l, l));
        result.overshoot = overshootPx - baseline;
    }
    // normalize result
    for (var name in result) {
        result[name] /= fs;
    }
    result.em = fs;
    measureFont.cache[family] = result;
    return applyOrigin(result, origin);
    function applyOrigin(obj, origin) {
        var res = {};
        if (typeof origin === 'string')
            origin = obj[origin];
        for (var name in obj) {
            if (name === 'em')
                continue;
            res[name] = obj[name] - origin;
        }
        return res;
    }
    function firstTop(iData) {
        var l = iData.height;
        var data = iData.data;
        for (var i = 3; i < data.length; i += 4) {
            if (data[i] !== 0) {
                return Math.floor((i - 3) * .25 / l);
            }
        }
    }
    function firstBottom(iData) {
        var l = iData.height;
        var data = iData.data;
        for (var i = data.length - 1; i > 0; i -= 4) {
            if (data[i] !== 0) {
                return Math.floor((i - 3) * .25 / l);
            }
        }
    }
}


/***/ }),

/***/ "./src/drawing/gdipEnums.ts":
/*!**********************************!*\
  !*** ./src/drawing/gdipEnums.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Status": () => (/* binding */ Status),
/* harmony export */   "BrushType": () => (/* binding */ BrushType),
/* harmony export */   "ImageType": () => (/* binding */ ImageType),
/* harmony export */   "GetSysColorIndex": () => (/* binding */ GetSysColorIndex)
/* harmony export */ });
var Status;
(function (Status) {
    Status[Status["Ok"] = 0] = "Ok";
    Status[Status["GenericError"] = 1] = "GenericError";
    Status[Status["InvalidParameter"] = 2] = "InvalidParameter";
    Status[Status["OutOfMemory"] = 3] = "OutOfMemory";
    Status[Status["ObjectBusy"] = 4] = "ObjectBusy";
    Status[Status["InsufficientBuffer"] = 5] = "InsufficientBuffer";
    Status[Status["NotImplemented"] = 6] = "NotImplemented";
    Status[Status["Win32Error"] = 7] = "Win32Error";
    Status[Status["WrongState"] = 8] = "WrongState";
    Status[Status["Aborted"] = 9] = "Aborted";
    Status[Status["FileNotFound"] = 10] = "FileNotFound";
    Status[Status["ValueOverflow"] = 11] = "ValueOverflow";
    Status[Status["AccessDenied"] = 12] = "AccessDenied";
    Status[Status["UnknownImageFormat"] = 13] = "UnknownImageFormat";
    Status[Status["FontFamilyNotFound"] = 14] = "FontFamilyNotFound";
    Status[Status["FontStyleNotFound"] = 15] = "FontStyleNotFound";
    Status[Status["NotTrueTypeFont"] = 16] = "NotTrueTypeFont";
    Status[Status["UnsupportedGdiplusVersion"] = 17] = "UnsupportedGdiplusVersion";
    Status[Status["GdiplusNotInitialized"] = 18] = "GdiplusNotInitialized";
    Status[Status["PropertyNotFound"] = 19] = "PropertyNotFound";
    Status[Status["PropertyNotSupported"] = 20] = "PropertyNotSupported";
    Status[Status["ProfileNotFound"] = 21] = "ProfileNotFound";
    Status[Status["NativeImageNotFound"] = 22] = "NativeImageNotFound";
    Status[Status["NativeContext2DNotFound"] = 23] = "NativeContext2DNotFound";
})(Status || (Status = {}));
var BrushType;
(function (BrushType) {
    BrushType[BrushType["BrushTypeSolidColor"] = 0] = "BrushTypeSolidColor";
    BrushType[BrushType["BrushTypeHatchFill"] = 1] = "BrushTypeHatchFill";
    BrushType[BrushType["BrushTypeTextureFill"] = 2] = "BrushTypeTextureFill";
    BrushType[BrushType["BrushTypePathGradient"] = 3] = "BrushTypePathGradient";
    BrushType[BrushType["BrushTypeLinearGradient"] = 4] = "BrushTypeLinearGradient";
})(BrushType || (BrushType = {}));
var ImageType;
(function (ImageType) {
    ImageType[ImageType["Unknown"] = 0] = "Unknown";
    ImageType[ImageType["Bitmap"] = 1] = "Bitmap";
    ImageType[ImageType["Metafile"] = 2] = "Metafile";
})(ImageType || (ImageType = {}));
var GetSysColorIndex;
(function (GetSysColorIndex) {
    GetSysColorIndex[GetSysColorIndex["COLOR_SCROLLBAR"] = 0] = "COLOR_SCROLLBAR";
    GetSysColorIndex[GetSysColorIndex["COLOR_BACKGROUND"] = 1] = "COLOR_BACKGROUND";
    GetSysColorIndex[GetSysColorIndex["COLOR_ACTIVECAPTION"] = 2] = "COLOR_ACTIVECAPTION";
    GetSysColorIndex[GetSysColorIndex["COLOR_INACTIVECAPTION"] = 3] = "COLOR_INACTIVECAPTION";
    GetSysColorIndex[GetSysColorIndex["COLOR_MENU"] = 4] = "COLOR_MENU";
    GetSysColorIndex[GetSysColorIndex["COLOR_WINDOW"] = 5] = "COLOR_WINDOW";
    GetSysColorIndex[GetSysColorIndex["COLOR_WINDOWFRAME"] = 6] = "COLOR_WINDOWFRAME";
    GetSysColorIndex[GetSysColorIndex["COLOR_MENUTEXT"] = 7] = "COLOR_MENUTEXT";
    GetSysColorIndex[GetSysColorIndex["COLOR_WINDOWTEXT"] = 8] = "COLOR_WINDOWTEXT";
    GetSysColorIndex[GetSysColorIndex["COLOR_CAPTIONTEXT"] = 9] = "COLOR_CAPTIONTEXT";
    GetSysColorIndex[GetSysColorIndex["COLOR_ACTIVEBORDER"] = 10] = "COLOR_ACTIVEBORDER";
    GetSysColorIndex[GetSysColorIndex["COLOR_INACTIVEBORDER"] = 11] = "COLOR_INACTIVEBORDER";
    GetSysColorIndex[GetSysColorIndex["COLOR_APPWORKSPACE"] = 12] = "COLOR_APPWORKSPACE";
    GetSysColorIndex[GetSysColorIndex["COLOR_HIGHLIGHT"] = 13] = "COLOR_HIGHLIGHT";
    GetSysColorIndex[GetSysColorIndex["COLOR_HIGHLIGHTTEXT"] = 14] = "COLOR_HIGHLIGHTTEXT";
    GetSysColorIndex[GetSysColorIndex["COLOR_BTNFACE"] = 15] = "COLOR_BTNFACE";
    GetSysColorIndex[GetSysColorIndex["COLOR_BTNSHADOW"] = 16] = "COLOR_BTNSHADOW";
    GetSysColorIndex[GetSysColorIndex["COLOR_GRAYTEXT"] = 17] = "COLOR_GRAYTEXT";
    GetSysColorIndex[GetSysColorIndex["COLOR_BTNTEXT"] = 18] = "COLOR_BTNTEXT";
    GetSysColorIndex[GetSysColorIndex["COLOR_INACTIVECAPTIONTEXT"] = 19] = "COLOR_INACTIVECAPTIONTEXT";
    GetSysColorIndex[GetSysColorIndex["COLOR_BTNHIGHLIGHT"] = 20] = "COLOR_BTNHIGHLIGHT";
    GetSysColorIndex[GetSysColorIndex["COLOR_3DDKSHADOW"] = 21] = "COLOR_3DDKSHADOW";
    GetSysColorIndex[GetSysColorIndex["COLOR_3DLIGHT"] = 22] = "COLOR_3DLIGHT";
    GetSysColorIndex[GetSysColorIndex["COLOR_INFOTEXT"] = 23] = "COLOR_INFOTEXT";
    GetSysColorIndex[GetSysColorIndex["COLOR_INFOBK"] = 24] = "COLOR_INFOBK";
    GetSysColorIndex[GetSysColorIndex["COLOR_HOTLIGHT"] = 26] = "COLOR_HOTLIGHT";
    GetSysColorIndex[GetSysColorIndex["COLOR_GRADIENTACTIVECAPTION"] = 27] = "COLOR_GRADIENTACTIVECAPTION";
    GetSysColorIndex[GetSysColorIndex["COLOR_GRADIENTINACTIVECAPTION"] = 28] = "COLOR_GRADIENTINACTIVECAPTION";
    GetSysColorIndex[GetSysColorIndex["COLOR_MENUHIGHLIGHT"] = 29] = "COLOR_MENUHIGHLIGHT";
    GetSysColorIndex[GetSysColorIndex["COLOR_MENUBAR"] = 30] = "COLOR_MENUBAR";
    GetSysColorIndex[GetSysColorIndex["COLOR_DESKTOP"] = 1] = "COLOR_DESKTOP";
    GetSysColorIndex[GetSysColorIndex["COLOR_3DFACE"] = 16] = "COLOR_3DFACE";
    GetSysColorIndex[GetSysColorIndex["COLOR_3DSHADOW"] = 16] = "COLOR_3DSHADOW";
    GetSysColorIndex[GetSysColorIndex["COLOR_3DHIGHLIGHT"] = 20] = "COLOR_3DHIGHLIGHT";
    GetSysColorIndex[GetSysColorIndex["COLOR_3DHILIGHT"] = 20] = "COLOR_3DHILIGHT";
    GetSysColorIndex[GetSysColorIndex["COLOR_BTNHILIGHT"] = 20] = "COLOR_BTNHILIGHT";
    GetSysColorIndex[GetSysColorIndex["COLOR_MAXVALUE"] = 30] = "COLOR_MAXVALUE";
})(GetSysColorIndex || (GetSysColorIndex = {}));


/***/ }),

/***/ "./src/drawing/gdipStructs.ts":
/*!************************************!*\
  !*** ./src/drawing/gdipStructs.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GdipEncoderParameter": () => (/* binding */ GdipEncoderParameter),
/* harmony export */   "GdiplusStartupInput": () => (/* binding */ GdiplusStartupInput),
/* harmony export */   "GdiplusStartupOutput": () => (/* binding */ GdiplusStartupOutput),
/* harmony export */   "GdipPropertyItem": () => (/* binding */ GdipPropertyItem),
/* harmony export */   "GdipImageCodecInfo": () => (/* binding */ GdipImageCodecInfo),
/* harmony export */   "GdiColorPalette": () => (/* binding */ GdiColorPalette)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var GdipEncoderParameter = /** @class */ (function (_super) {
    __extends(GdipEncoderParameter, _super);
    function GdipEncoderParameter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.GUID,
        __metadata("design:type", Object)
    ], GdipEncoderParameter.prototype, "guid", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdipEncoderParameter.prototype, "numberOfValues", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdipEncoderParameter.prototype, "type", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdipEncoderParameter.prototype, "value", void 0);
    return GdipEncoderParameter;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.UMP));

var GdiplusStartupInput = /** @class */ (function (_super) {
    __extends(GdiplusStartupInput, _super);
    function GdiplusStartupInput() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GdiplusStartupInput.MakeGdiplusStartupInput = function () {
        var result = new GdiplusStartupInput();
        result.GdiplusVersion = 1;
        result.DebugEventCallback = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
        result.SuppressBackgroundThread = 0;
        result.SuppressExternalCodecs = 0;
        return result;
    };
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdiplusStartupInput.prototype, "GdiplusVersion", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdiplusStartupInput.prototype, "DebugEventCallback", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdiplusStartupInput.prototype, "SuppressBackgroundThread", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdiplusStartupInput.prototype, "SuppressExternalCodecs", void 0);
    return GdiplusStartupInput;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.UMP));

var GdiplusStartupOutput = /** @class */ (function (_super) {
    __extends(GdiplusStartupOutput, _super);
    function GdiplusStartupOutput() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GdiplusStartupOutput.MakeGdiplusStartupOutput = function () {
        var result = new GdiplusStartupOutput();
        result.NotificationHook = result.NotificationUnhook = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
        return result;
    };
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdiplusStartupOutput.prototype, "NotificationHook", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdiplusStartupOutput.prototype, "NotificationUnhook", void 0);
    return GdiplusStartupOutput;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.UMP));

var GdipPropertyItem = /** @class */ (function (_super) {
    __extends(GdipPropertyItem, _super);
    function GdipPropertyItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /* internal */ GdipPropertyItem.MarshalTo = function (gdipProp, prop) {
        prop.Id = gdipProp.id;
        prop.Len = gdipProp.len;
        prop.Type = gdipProp.type;
        prop.Value = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(gdipProp.len);
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.Copy(gdipProp.value, prop.Value, 0, gdipProp.len);
    };
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* int */,
        __metadata("design:type", Object)
    ], GdipPropertyItem.prototype, "id", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* int */,
        __metadata("design:type", Object)
    ], GdipPropertyItem.prototype, "len", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* short */,
        __metadata("design:type", Object)
    ], GdipPropertyItem.prototype, "type", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* IntPtr */,
        __metadata("design:type", Object)
    ], GdipPropertyItem.prototype, "value", void 0);
    return GdipPropertyItem;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.UMP));

var GdipImageCodecInfo = /** @class */ (function (_super) {
    __extends(/* internal */ GdipImageCodecInfo, _super); /*Size 76 bytes*/
    function GdipImageCodecInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GdipImageCodecInfo.MarshalTo = function (gdipcodec, codec) {
        codec.CodecName = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStringUni(gdipcodec.CodecName);
        codec.DllName = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStringUni(gdipcodec.DllName);
        codec.FormatDescription = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStringUni(gdipcodec.FormatDescription);
        codec.FilenameExtension = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStringUni(gdipcodec.FilenameExtension);
        codec.MimeType = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStringUni(gdipcodec.MimeType);
        codec.Clsid = gdipcodec.Clsid;
        codec.FormatID = gdipcodec.FormatID;
        codec.Flags = gdipcodec.Flags;
        codec.Version = gdipcodec.Version;
        codec.SignatureMasks = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Array(gdipcodec.SigCount);
        codec.SignaturePatterns = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Array(gdipcodec.SigCount);
        var p = gdipcodec.SigPattern;
        var m = gdipcodec.SigMask;
        for (var i = 0; i < gdipcodec.SigCount; i++) {
            codec.SignatureMasks[i] = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(gdipcodec.SigSize);
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.Copy(m, codec.SignatureMasks[i], 0, gdipcodec.SigSize);
            m = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(m.ToInt64() + gdipcodec.SigSize);
            codec.SignaturePatterns[i] = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.ByteArray(gdipcodec.SigSize);
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.Copy(p, codec.SignaturePatterns[i], 0, gdipcodec.SigSize);
            p = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(p.ToInt64() + gdipcodec.SigSize);
        }
    };
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.GUID /* Guid */,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "Clsid", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* Guid */,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "FormatID", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* IntPtr */,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "CodecName", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* IntPtr */,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "DllName", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* IntPtr */,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "FormatDescription", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* IntPtr */,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "FilenameExtension", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* IntPtr */,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "MimeType", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "Flags", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "Version", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "SigCount", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "SigSize", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "SigPattern", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG,
        __metadata("design:type", Object)
    ], GdipImageCodecInfo.prototype, "SigMask", void 0);
    return GdipImageCodecInfo;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.UMP /*Size 76 bytes*/));

var GdiColorPalette = /** @class */ (function (_super) {
    __extends(GdiColorPalette, _super);
    function GdiColorPalette() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* internal */ /* int */,
        __metadata("design:type", Object)
    ], GdiColorPalette.prototype, "Flags", void 0);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.LONG /* internal */ /* int */,
        __metadata("design:type", Object)
    ], GdiColorPalette.prototype, "Count", void 0);
    return GdiColorPalette;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.UMP));



/***/ }),

/***/ "./src/drawing/imaging/BitmapData.ts":
/*!*******************************************!*\
  !*** ./src/drawing/imaging/BitmapData.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitmapData": () => (/* binding */ BitmapData)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);

var BitmapData = /** @class */ (function () {
    function BitmapData() {
        this.width = 0;
        this.height = 0;
        this.stride = 0;
        this.pixel_format = 0; // int
        this.scan0 = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
        this.reserved = 0;
        // *** Warning ***	don't depend on those fields in managed
        //			code as they won't exists when using MS
        //			GDI+
        this.palette = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
        this.property_count = 0;
        this.property = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
        this.dpi_horz = 0;
        this.dpi_vert = 0;
        this.image_flags = 0;
        this.left = 0;
        this.top = 0;
        this.x = 0;
        this.y = 0;
        this.transparent = 0;
    }
    Object.defineProperty(BitmapData.prototype, "Height", {
        // *** Warning ***
        get: function () {
            return this.height;
        },
        set: function (value) {
            this.height = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BitmapData.prototype, "Width", {
        get: function () {
            return this.width;
        },
        set: function (value) {
            this.width = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BitmapData.prototype, "PixelFormat", {
        get: function () {
            return this.pixel_format;
        },
        set: function (value) {
            this.pixel_format = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BitmapData.prototype, "Reserved", {
        get: function () {
            return this.reserved;
        },
        set: function (value) {
            this.reserved = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BitmapData.prototype, "Scan0", {
        get: function () {
            return this.scan0;
        },
        set: function (value) {
            this.scan0 = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BitmapData.prototype, "Stride", {
        get: function () {
            return this.stride;
        },
        set: function (value) {
            this.stride = value;
        },
        enumerable: false,
        configurable: true
    });
    return BitmapData;
}());



/***/ }),

/***/ "./src/drawing/imaging/ColorAdjustType.ts":
/*!************************************************!*\
  !*** ./src/drawing/imaging/ColorAdjustType.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorAdjustType": () => (/* binding */ ColorAdjustType)
/* harmony export */ });
var ColorAdjustType;
(function (ColorAdjustType) {
    /// <summary>Color adjustment information that is used by all GDI+ objects that do not have their own color adjustment information.</summary>
    ColorAdjustType[ColorAdjustType["Default"] = 0] = "Default";
    /// <summary>Color adjustment information for <see cref="T:System.Drawing.Bitmap" /> objects.</summary>
    ColorAdjustType[ColorAdjustType["Bitmap"] = 1] = "Bitmap";
    /// <summary>Color adjustment information for <see cref="T:System.Drawing.Brush" /> objects.</summary>
    ColorAdjustType[ColorAdjustType["Brush"] = 2] = "Brush";
    /// <summary>Color adjustment information for <see cref="T:System.Drawing.Pen" /> objects.</summary>
    ColorAdjustType[ColorAdjustType["Pen"] = 3] = "Pen";
    /// <summary>Color adjustment information for text.</summary>
    ColorAdjustType[ColorAdjustType["Text"] = 4] = "Text";
    /// <summary>The number of types specified.</summary>
    ColorAdjustType[ColorAdjustType["Count"] = 5] = "Count";
    /// <summary>The number of types specified.</summary>
    ColorAdjustType[ColorAdjustType["Any"] = 6] = "Any";
})(ColorAdjustType || (ColorAdjustType = {}));


/***/ }),

/***/ "./src/drawing/imaging/ColorMatrixFlag.ts":
/*!************************************************!*\
  !*** ./src/drawing/imaging/ColorMatrixFlag.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorMatrixFlag": () => (/* binding */ ColorMatrixFlag)
/* harmony export */ });
var ColorMatrixFlag;
(function (ColorMatrixFlag) {
    /// <summary>All color values, including gray shades, are adjusted by the same color-adjustment matrix.</summary>
    ColorMatrixFlag[ColorMatrixFlag["Default"] = 0] = "Default";
    /// <summary>All colors are adjusted, but gray shades are not adjusted. A gray shade is any color that has the same value for its red, green, and blue components.</summary>
    ColorMatrixFlag[ColorMatrixFlag["SkipGrays"] = 1] = "SkipGrays";
    /// <summary>Only gray shades are adjusted.</summary>
    ColorMatrixFlag[ColorMatrixFlag["AltGrays"] = 2] = "AltGrays";
})(ColorMatrixFlag || (ColorMatrixFlag = {}));


/***/ }),

/***/ "./src/drawing/imaging/ColorPalette.ts":
/*!*********************************************!*\
  !*** ./src/drawing/imaging/ColorPalette.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorPalette": () => (/* binding */ ColorPalette)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _gdipStructs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gdipStructs */ "./src/drawing/gdipStructs.ts");



var ColorPalette = /** @class */ (function () {
    function ColorPalette() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // 0x1: the color values in the array contain alpha information
        // 0x2: the color values are grayscale values.
        // 0x4: the colors in the array are halftone values.
        this.flags = 0;
        this.entries = null;
        if (arguments.length === 0) {
            this.entries = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Array(0);
        }
        else if (args.length === 2) {
            var flags = args[0];
            var colors = args[1];
            this.flags = flags;
            this.entries = colors;
        }
    }
    Object.defineProperty(ColorPalette.prototype, "Entries", {
        get: function () {
            return this.entries;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColorPalette.prototype, "Flags", {
        get: function () {
            return this.flags;
        },
        enumerable: false,
        configurable: true
    });
    /* Caller should call FreeHGlobal*/
    ColorPalette.prototype.getGDIPalette = function () {
        var palette = new _gdipStructs__WEBPACK_IMPORTED_MODULE_2__.GdiColorPalette();
        var entries = this.Entries;
        var entry = 0;
        var size = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Marshal.SizeOf(palette) + (_tuval_core__WEBPACK_IMPORTED_MODULE_1__.Marshal.SizeOf(entry) * entries.length);
        var lfBuffer = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Marshal.AllocHGlobal(size);
        palette.Flags = this.Flags;
        palette.Count = entries.length;
        var values = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.IntArray(palette.Count);
        for (var i = 0; i < values.length; i++) {
            values[i] = entries[i].toInt();
        }
        _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Marshal.StructureToPtr(palette, lfBuffer, false);
        _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Marshal.Copy(values, 0, new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.IntPtr(lfBuffer.ToInt64() + _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Marshal.SizeOf(palette)), values.length);
        return lfBuffer;
    };
    ColorPalette.prototype.setFromGDIPalette = function (palette) {
        var ptr = palette;
        var cnt, color;
        var offset;
        this.flags = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Marshal.ReadInt32(ptr, 0);
        ptr = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.IntPtr(ptr.ToInt64() + 4);
        cnt = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Marshal.ReadInt32(ptr, 0);
        ptr = new _tuval_core__WEBPACK_IMPORTED_MODULE_1__.IntPtr(ptr.ToInt64() + 4);
        this.entries = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.New.Array(cnt);
        offset = 0;
        for (var i = 0; i < cnt; i++) {
            var R = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Marshal.ReadByte(ptr, offset++);
            var G = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Marshal.ReadByte(ptr, offset++);
            var B = _tuval_core__WEBPACK_IMPORTED_MODULE_1__.Marshal.ReadByte(ptr, offset++);
            this.entries[i] = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromRgba(R, G, B);
            // offset += 4;
        }
    };
    return ColorPalette;
}());



/***/ }),

/***/ "./src/drawing/imaging/Encoder.ts":
/*!****************************************!*\
  !*** ./src/drawing/imaging/Encoder.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Encoder": () => (/* binding */ Encoder)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);

var Encoder = /** @class */ (function () {
    function Encoder() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.guid = null;
        if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_0__.is.string(args[0])) {
            var guid = args[0];
            this.guid = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Guid(guid);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_0__.is["typeof"](args[0], _tuval_core__WEBPACK_IMPORTED_MODULE_0__.System.Types.Guid)) {
            var guid = args[0];
            this.guid = guid;
        }
    }
    Encoder.StaticConstructor = function () {
        // GUID values are taken from my windows machine.
        Encoder.ChrominanceTable = new Encoder("f2e455dc-09b3-4316-8260-676ada32481c");
        Encoder.ColorDepth = new Encoder("66087055-ad66-4c7c-9a18-38a2310b8337");
        Encoder.Compression = new Encoder("e09d739d-ccd4-44ee-8eba-3fbf8be4fc58");
        Encoder.LuminanceTable = new Encoder("edb33bce-0266-4a77-b904-27216099e717");
        Encoder.Quality = new Encoder("1d5be4b5-fa4a-452d-9cdd-5db35105e7eb");
        Encoder.RenderMethod = new Encoder("6d42c53a-229a-4825-8bb7-5c99e2b9a8b8");
        Encoder.SaveFlag = new Encoder("292266fc-ac40-47bf-8cfc-a85b89a655de");
        Encoder.ScanMethod = new Encoder("3a4e2661-3109-4e56-8536-42c156e7dcfa");
        Encoder.Transformation = new Encoder("8d0eb2d1-a58e-4ea8-aa14-108074b7b6f9");
        Encoder.Version = new Encoder("24d18c76-814a-41a4-bf53-1c219cccf797");
    };
    Object.defineProperty(Encoder.prototype, "Guid", {
        get: function () {
            return this.guid;
        },
        enumerable: false,
        configurable: true
    });
    return Encoder;
}());

Encoder.StaticConstructor();


/***/ }),

/***/ "./src/drawing/imaging/EncoderParameter.ts":
/*!*************************************************!*\
  !*** ./src/drawing/imaging/EncoderParameter.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EncoderParameter": () => (/* binding */ EncoderParameter)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _gdipStructs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gdipStructs */ "./src/drawing/gdipStructs.ts");
/* harmony import */ var _Encoder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Encoder */ "./src/drawing/imaging/Encoder.ts");
/* harmony import */ var _EncoderParameterValueType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EncoderParameterValueType */ "./src/drawing/imaging/EncoderParameterValueType.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../GDITypes */ "./src/GDITypes.ts");





var EncoderParameter = /** @class */ (function () {
    function EncoderParameter() {
        this.encoder = null;
        this.valuesCount = 0;
        this.type = 0;
        this.valuePtr = null;
    }
    Object.defineProperty(EncoderParameter.prototype, "Encoder", {
        /* public EncoderParameter (Encoder encoder, byte value)
        {
            this.encoder = encoder;
            this.valuesCount = 1;
            this.type = EncoderParameterValueType.ValueTypeByte;
            this.valuePtr = Marshal.AllocHGlobal (1);
            Marshal.WriteByte (this.valuePtr, value);
        }
    
        public EncoderParameter (Encoder encoder, byte[] value)
        {
            this.encoder = encoder;
            this.valuesCount = value.Length;
            this.type = EncoderParameterValueType.ValueTypeByte;
            this.valuePtr = Marshal.AllocHGlobal (1 * valuesCount);
            Marshal.Copy (value, 0, this.valuePtr, valuesCount);
        }
    
        public EncoderParameter (Encoder encoder, short value)
        {
            this.encoder = encoder;
            this.valuesCount = 1;
            this.type = EncoderParameterValueType.ValueTypeShort;
            this.valuePtr = Marshal.AllocHGlobal (2);
            Marshal.WriteInt16 (this.valuePtr, value);
        }
    
        public EncoderParameter (Encoder encoder, short[] value)
        {
            this.encoder = encoder;
            this.valuesCount = value.Length;
            this.type = EncoderParameterValueType.ValueTypeShort;
            this.valuePtr = Marshal.AllocHGlobal (2 * valuesCount);
            Marshal.Copy (value, 0, this.valuePtr, valuesCount);
        }
    
    
        public EncoderParameter (Encoder encoder, long value)
        {
            this.encoder = encoder;
            this.valuesCount = 1;
            this.type = EncoderParameterValueType.ValueTypeLong;
            this.valuePtr = Marshal.AllocHGlobal (4);
            Marshal.WriteInt32 (this.valuePtr, (int) value);
        }
    
        public EncoderParameter (Encoder encoder, long[] value)
        {
            this.encoder = encoder;
            this.valuesCount = value.Length;
            this.type = EncoderParameterValueType.ValueTypeLong;
            this.valuePtr = Marshal.AllocHGlobal (4 * valuesCount);
            int [] ivals = new int[value.Length];
            for (int i = 0; i < value.Length; i++) ivals[i] = (int) value[i];
            Marshal.Copy (ivals, 0, this.valuePtr, valuesCount);
        }
    
        public EncoderParameter (Encoder encoder, string value)
        {
            this.encoder = encoder;
    
            ASCIIEncoding ascii = new ASCIIEncoding ();
            int asciiByteCount = ascii.GetByteCount (value);
            byte[] bytes = new byte [asciiByteCount];
            ascii.GetBytes (value, 0, value.Length, bytes, 0);
    
            this.valuesCount = bytes.Length;
            this.type = EncoderParameterValueType.ValueTypeAscii;
            this.valuePtr = Marshal.AllocHGlobal (valuesCount);
            Marshal.Copy (bytes, 0, this.valuePtr, valuesCount);
        }
    
        public EncoderParameter (Encoder encoder, byte value, bool undefined)
        {
            this.encoder = encoder;
            this.valuesCount = 1;
            if (undefined)
                this.type = EncoderParameterValueType.ValueTypeUndefined;
            else
                this.type = EncoderParameterValueType.ValueTypeByte;
            this.valuePtr = Marshal.AllocHGlobal (1);
            Marshal.WriteByte (this.valuePtr, value);
        }
    
        public EncoderParameter (Encoder encoder, byte[] value, bool undefined)
        {
            this.encoder = encoder;
            this.valuesCount = value.Length;
            if (undefined)
                this.type = EncoderParameterValueType.ValueTypeUndefined;
            else
                this.type = EncoderParameterValueType.ValueTypeByte;
            this.valuePtr = Marshal.AllocHGlobal (valuesCount);
            Marshal.Copy (value, 0, this.valuePtr, valuesCount);
        }
    
        public EncoderParameter (Encoder encoder, int numerator, int denominator)
        {
            this.encoder = encoder;
            this.valuesCount = 1;
            this.type = EncoderParameterValueType.ValueTypeRational;
            this.valuePtr = Marshal.AllocHGlobal (8);
            int [] valuearray = { numerator, denominator };
            Marshal.Copy (valuearray, 0, this.valuePtr, valuearray.Length);
        }
    
        public EncoderParameter (Encoder encoder, int[] numerator, int[] denominator)
        {
            if (numerator.Length != denominator.Length)
                throw new ArgumentException ("Invalid parameter used.");
    
            this.encoder = encoder;
            this.valuesCount = numerator.Length;
            this.type = EncoderParameterValueType.ValueTypeRational;
            this.valuePtr = Marshal.AllocHGlobal (4 * valuesCount * 2);
            for (int i = 0; i < valuesCount; i++) {
                Marshal.WriteInt32 (valuePtr, i * 4, (int) numerator[i]);
                Marshal.WriteInt32 (valuePtr, (i + 1) * 4, (int) denominator[i]);
            }
        }
    
        public EncoderParameter (Encoder encoder, long rangebegin, long rangeend)
        {
            this.encoder = encoder;
            this.valuesCount = 1;
            this.type = EncoderParameterValueType.ValueTypeLongRange;
            this.valuePtr = Marshal.AllocHGlobal (8);
            int [] valuearray = { (int) rangebegin, (int) rangeend };
            Marshal.Copy (valuearray, 0, this.valuePtr, valuearray.Length);
        }
    
        public EncoderParameter (Encoder encoder, long[] rangebegin, long[] rangeend)
        {
            if (rangebegin.Length != rangeend.Length)
                throw new ArgumentException ("Invalid parameter used.");
    
            this.encoder = encoder;
            this.valuesCount = rangebegin.Length;
            this.type = EncoderParameterValueType.ValueTypeLongRange;
    
            this.valuePtr = Marshal.AllocHGlobal (4 * valuesCount * 2);
            IntPtr dest = this.valuePtr;
            for (int i = 0; i < valuesCount; i++) {
                Marshal.WriteInt32 (dest, i * 4, (int) rangebegin[i]);
                Marshal.WriteInt32 (dest, (i + 1) * 4, (int) rangeend[i]);
            }
        }
    
        public EncoderParameter (Encoder encoder, int numberOfValues, int type, int value)
        {
            this.encoder = encoder;
            this.valuePtr = (IntPtr) value;
            this.valuesCount = numberOfValues;
            this.type = (EncoderParameterValueType) type;
        }
    
        public EncoderParameter (Encoder encoder, int numerator1, int denominator1, int numerator2, int denominator2)
        {
            this.encoder = encoder;
            this.valuesCount = 1;
            this.type = EncoderParameterValueType.ValueTypeRationalRange;
            this.valuePtr = Marshal.AllocHGlobal (4 * 4);
            int [] valuearray = { numerator1, denominator1, numerator2, denominator2 };
            Marshal.Copy (valuearray, 0, this.valuePtr, 4);
        }
    
        public EncoderParameter (Encoder encoder, int[] numerator1, int[] denominator1, int[] numerator2, int[] denominator2)
        {
            if (numerator1.Length != denominator1.Length ||
                numerator2.Length != denominator2.Length ||
                numerator1.Length != numerator2.Length)
                throw new ArgumentException ("Invalid parameter used.");
    
            this.encoder = encoder;
            this.valuesCount = numerator1.Length;
            this.type = EncoderParameterValueType.ValueTypeRationalRange;
    
            this.valuePtr = Marshal.AllocHGlobal (4 * valuesCount * 4);
            IntPtr dest = this.valuePtr;
            for (int i = 0; i < valuesCount; i++) {
                Marshal.WriteInt32 (dest, i * 4, numerator1[i]);
                Marshal.WriteInt32 (dest, (i + 1) * 4, denominator1[i]);
                Marshal.WriteInt32 (dest, (i + 2) * 4, numerator2[i]);
                Marshal.WriteInt32 (dest, (i + 3) * 4, denominator2[i]);
            }
        } */
        get: function () {
            return this.encoder;
        },
        set: function (value) {
            this.encoder = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EncoderParameter.prototype, "NumberOfValues", {
        get: function () {
            return this.valuesCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EncoderParameter.prototype, "Type", {
        get: function () {
            return this.type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EncoderParameter.prototype, "ValueType", {
        get: function () {
            return this.type;
        },
        enumerable: false,
        configurable: true
    });
    EncoderParameter.prototype.dispose = function (disposing) {
        if (this.valuePtr !== _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero) {
            //Marshal.FreeHGlobal(valuePtr);
            this.valuePtr = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero;
        }
    };
    EncoderParameter.prototype.Dispose = function () {
        this.dispose(true);
        //GC.SuppressFinalize(this);
    };
    EncoderParameter.NativeSize = function () {
        return _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.SizeOf(_gdipStructs__WEBPACK_IMPORTED_MODULE_1__.GdipEncoderParameter);
    };
    EncoderParameter.prototype.ToNativePtr = function (epPtr) {
        var ep = new _gdipStructs__WEBPACK_IMPORTED_MODULE_1__.GdipEncoderParameter();
        ep.guid = this.encoder.Guid;
        ep.numberOfValues = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Convert.ToUInt32(this.valuesCount);
        ep.type = this.type;
        ep.value = this.valuePtr;
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.StructureToPtr(ep, epPtr, false);
    };
    EncoderParameter.FromNativePtr = function (epPtr) {
        var ep;
        ep = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStructure(epPtr, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_GDITypes__WEBPACK_IMPORTED_MODULE_4__.GraphicTypes.GdipEncoderParameter));
        var valType;
        var valCount;
        switch (ep.type) {
            case _EncoderParameterValueType__WEBPACK_IMPORTED_MODULE_3__.EncoderParameterValueType.ValueTypeAscii:
            case _EncoderParameterValueType__WEBPACK_IMPORTED_MODULE_3__.EncoderParameterValueType.ValueTypeByte:
            case _EncoderParameterValueType__WEBPACK_IMPORTED_MODULE_3__.EncoderParameterValueType.ValueTypeUndefined:
                valType = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.System.Types.Primitives.Byte);
                valCount = ep.numberOfValues;
                break;
            case _EncoderParameterValueType__WEBPACK_IMPORTED_MODULE_3__.EncoderParameterValueType.ValueTypeShort:
                valType = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.System.Types.Primitives.Short);
                valCount = ep.numberOfValues;
                break;
            case _EncoderParameterValueType__WEBPACK_IMPORTED_MODULE_3__.EncoderParameterValueType.ValueTypeLong:
                valType = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.System.Types.Primitives.Int);
                valCount = ep.numberOfValues;
                break;
            case _EncoderParameterValueType__WEBPACK_IMPORTED_MODULE_3__.EncoderParameterValueType.ValueTypeLongRange:
            case _EncoderParameterValueType__WEBPACK_IMPORTED_MODULE_3__.EncoderParameterValueType.ValueTypeRational:
                valType = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.System.Types.Primitives.Int);
                valCount = ep.numberOfValues * 2;
                break;
            case _EncoderParameterValueType__WEBPACK_IMPORTED_MODULE_3__.EncoderParameterValueType.ValueTypeRationalRange:
                valType = (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.System.Types.Primitives.Int);
                valCount = ep.numberOfValues * 4;
                break;
            default:
                return null;
        }
        var eparam = new EncoderParameter();
        eparam.encoder = new _Encoder__WEBPACK_IMPORTED_MODULE_2__.Encoder(ep.guid);
        eparam.valuesCount = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Convert.ToInt32(ep.numberOfValues);
        eparam.type = ep.type;
        eparam.valuePtr = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.AllocHGlobal(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Convert.ToInt32(valCount * _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.SizeOf(valType))); // TODO:  sizeof dzelt
        /* There's nothing in Marshal to do a memcpy() between two IntPtrs.  This sucks. */
        /*   unsafe {
              byte * s = (byte *) ep.value;
              byte * d = (byte *) eparam.valuePtr;
              for (int i = 0; i < valCount * Marshal.SizeOf(valType); i++)
                  * d++ = * s++;
          } */
        return eparam;
    };
    return EncoderParameter;
}());



/***/ }),

/***/ "./src/drawing/imaging/EncoderParameterValueType.ts":
/*!**********************************************************!*\
  !*** ./src/drawing/imaging/EncoderParameterValueType.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EncoderParameterValueType": () => (/* binding */ EncoderParameterValueType)
/* harmony export */ });
var EncoderParameterValueType;
(function (EncoderParameterValueType) {
    EncoderParameterValueType[EncoderParameterValueType["ValueTypeAscii"] = 2] = "ValueTypeAscii";
    EncoderParameterValueType[EncoderParameterValueType["ValueTypeByte"] = 1] = "ValueTypeByte";
    EncoderParameterValueType[EncoderParameterValueType["ValueTypeLong"] = 4] = "ValueTypeLong";
    EncoderParameterValueType[EncoderParameterValueType["ValueTypeLongRange"] = 6] = "ValueTypeLongRange";
    EncoderParameterValueType[EncoderParameterValueType["ValueTypeRational"] = 5] = "ValueTypeRational";
    EncoderParameterValueType[EncoderParameterValueType["ValueTypeRationalRange"] = 8] = "ValueTypeRationalRange";
    EncoderParameterValueType[EncoderParameterValueType["ValueTypeShort"] = 3] = "ValueTypeShort";
    EncoderParameterValueType[EncoderParameterValueType["ValueTypeUndefined"] = 7] = "ValueTypeUndefined";
})(EncoderParameterValueType || (EncoderParameterValueType = {}));


/***/ }),

/***/ "./src/drawing/imaging/EncoderParameters.ts":
/*!**************************************************!*\
  !*** ./src/drawing/imaging/EncoderParameters.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EncoderParameters": () => (/* binding */ EncoderParameters)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _EncoderParameter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EncoderParameter */ "./src/drawing/imaging/EncoderParameter.ts");


var EncoderParameters = /** @class */ (function () {
    function EncoderParameters() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.parameters = null;
        if (args.length === 0) {
            this.parameters = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Array(1);
        }
        else if (args.length === 1) {
            this.parameters = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Array(args[0]);
        }
    }
    Object.defineProperty(EncoderParameters.prototype, "Param", {
        get: function () {
            return this.parameters;
        },
        set: function (value) {
            this.parameters = value;
        },
        enumerable: false,
        configurable: true
    });
    EncoderParameters.prototype.Dispose = function () {
        // Nothing
        //GC.SuppressFinalize(this);
    };
    EncoderParameters.prototype.ToNativePtr = function () {
        var result;
        var ptr;
        // 4 is the initial int32 "count" value
        result = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.AllocHGlobal(4 + this.parameters.length * _EncoderParameter__WEBPACK_IMPORTED_MODULE_1__.EncoderParameter.NativeSize());
        ptr = result;
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.WriteInt32(ptr, 0, this.parameters.length);
        ptr = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(ptr.ToInt64() + 4);
        for (var i = 0; i < this.parameters.length; i++) {
            this.parameters[i].ToNativePtr(ptr);
            ptr = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(ptr.ToInt64() + _EncoderParameter__WEBPACK_IMPORTED_MODULE_1__.EncoderParameter.NativeSize());
        }
        return result;
    };
    /* The IntPtr passed in here is a blob returned from
     * GdipImageGetEncoderParameterList.  Its internal pointers
     * (i.e. the Value pointers in the EncoderParameter entries)
     * point to areas within this block of memeory; this means
     * that we need to free it as a whole, and also means that
     * we can't Marshal.PtrToStruct our way to victory.
     */
    EncoderParameters.FromNativePtr = function (epPtr) {
        if (epPtr === _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr.Zero)
            return null;
        var ptr = epPtr;
        var count = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.ReadInt32(ptr, 0);
        ptr = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(ptr.ToInt64() + 4);
        if (count === 0)
            return null;
        var result = new EncoderParameters(count);
        for (var i = 0; i < count; i++) {
            result.parameters[i] = _EncoderParameter__WEBPACK_IMPORTED_MODULE_1__.EncoderParameter.FromNativePtr(ptr);
            ptr = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(ptr.ToInt64() + _EncoderParameter__WEBPACK_IMPORTED_MODULE_1__.EncoderParameter.NativeSize());
        }
        return result;
    };
    return EncoderParameters;
}());



/***/ }),

/***/ "./src/drawing/imaging/ImageAttributes.ts":
/*!************************************************!*\
  !*** ./src/drawing/imaging/ImageAttributes.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageAttributes": () => (/* binding */ ImageAttributes)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ColorMatrixFlag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorMatrixFlag */ "./src/drawing/imaging/ColorMatrixFlag.ts");
/* harmony import */ var _ColorAdjustType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ColorAdjustType */ "./src/drawing/imaging/ColorAdjustType.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_4__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






var ImageAttributes = /** @class */ (function () {
    function ImageAttributes() {
        this.colorMatrix = undefined;
        this.colorMatrixFlags = undefined;
        this.colorAdjustType = undefined;
        this.gamma = 0;
        this.isColorMatrixSet = false;
        this.isGammaSet = false;
        //#endregion
    }
    ImageAttributes_1 = ImageAttributes;
    /// <summary>
    /// Clears the color matrix.
    /// </summary>
    ImageAttributes.prototype.clearColorMatrix = function () {
        this.colorMatrix = null;
        this.colorMatrixFlags = _ColorMatrixFlag__WEBPACK_IMPORTED_MODULE_1__.ColorMatrixFlag.Default;
        this.colorAdjustType = _ColorAdjustType__WEBPACK_IMPORTED_MODULE_2__.ColorAdjustType.Default;
        this.isColorMatrixSet = false;
    };
    /// <summary>
    /// Clears the gamma.
    /// </summary>
    /* public  clearGamma():void
    {
        this.clearGamma(ColorAdjustType.Default);
    } */
    /// <summary>
    /// Clears the gamma for the color adjust type.
    /// </summary>
    /// <param name="type">Type.</param>
    ImageAttributes.prototype.clearGamma = function (type) {
        this.isGammaSet = false;
    };
    ImageAttributes.prototype.setColorMatrix = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_4__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_3__.GraphicTypes.ColorMatrix)) {
            var newColorMatrix = args[0];
            this.setColorMatrix(newColorMatrix, _ColorMatrixFlag__WEBPACK_IMPORTED_MODULE_1__.ColorMatrixFlag.Default);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_4__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_3__.GraphicTypes.ColorMatrix)) {
            var newColorMatrix = args[0];
            this.setColorMatrix(newColorMatrix, _ColorMatrixFlag__WEBPACK_IMPORTED_MODULE_1__.ColorMatrixFlag.Default, _ColorAdjustType__WEBPACK_IMPORTED_MODULE_2__.ColorAdjustType.Default);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_4__.is["typeof"](args[0], _GDITypes__WEBPACK_IMPORTED_MODULE_3__.GraphicTypes.ColorMatrix)) {
            var newColorMatrix = args[0];
            var mode = args[1];
            var type = args[2];
            this.colorMatrix = newColorMatrix;
            this.colorMatrixFlags = mode;
            this.colorAdjustType = type;
            this.isColorMatrixSet = true;
        }
    };
    ImageAttributes.prototype.setGamma = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var gamma = args[0];
            this.setGamma(gamma, _ColorAdjustType__WEBPACK_IMPORTED_MODULE_2__.ColorAdjustType.Default);
        }
        else if (args.length === 2) {
            var gamma = args[0];
            var type = args[1];
            this.gamma = gamma;
            this.colorAdjustType = type;
            this.isGammaSet = true;
        }
    };
    ImageAttributes.prototype.setWrapMode = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var mode = args[0];
            this.setWrapMode(mode, _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Empty, false);
        }
        else if (args.length === 2) {
            var mode = args[0];
            var color = args[1];
            this.setWrapMode(mode, color, false);
        }
        else if (args.length === 3) {
            // FIXME
        }
    };
    ImageAttributes.prototype.SetColorKey = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_4__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CoreGraphicTypes.CGColor) && _tuval_core__WEBPACK_IMPORTED_MODULE_4__.is["typeof"](args[1], _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CoreGraphicTypes.CGColor)) {
            var lowColor = args[0];
            var highColor = args[1];
            this.SetColorKey(lowColor, highColor, _ColorAdjustType__WEBPACK_IMPORTED_MODULE_2__.ColorAdjustType.Default);
        }
        else if (args.length === 3) {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_4__.NotImplementedException('setColorKey');
        }
    };
    //#region ICloneable implementation
    ImageAttributes.prototype.Clone = function () {
        var copy = new ImageAttributes_1();
        copy.colorMatrix = this.colorMatrix;
        copy.colorAdjustType = this.colorAdjustType;
        copy.colorMatrixFlags = this.colorMatrixFlags;
        copy.gamma = this.gamma;
        copy.isColorMatrixSet = this.isColorMatrixSet;
        copy.isGammaSet = this.isGammaSet;
        return copy;
    };
    //#endregion
    //#region IDisposable implementation
    ImageAttributes.prototype.Dispose = function () {
    };
    var ImageAttributes_1;
    ImageAttributes = ImageAttributes_1 = __decorate([
        (0,_tuval_core__WEBPACK_IMPORTED_MODULE_4__.ClassInfo)({
            fullName: _GDITypes__WEBPACK_IMPORTED_MODULE_3__.GraphicTypes.Imaging.ImageAttributes,
            instanceof: [
                _GDITypes__WEBPACK_IMPORTED_MODULE_3__.GraphicTypes.Imaging.ImageAttributes
            ]
        })
    ], ImageAttributes);
    return ImageAttributes;
}());



/***/ }),

/***/ "./src/drawing/imaging/ImageCodecInfo.ts":
/*!***********************************************!*\
  !*** ./src/drawing/imaging/ImageCodecInfo.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageCodecInfo": () => (/* binding */ ImageCodecInfo)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _GDIPlus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GDIPlus */ "./src/drawing/GDIPlus.ts");
/* harmony import */ var _gdipStructs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gdipStructs */ "./src/drawing/gdipStructs.ts");



var ImageCodecInfo = /** @class */ (function () {
    function ImageCodecInfo() {
        this.clsid = null;
        this.codecName = '';
        this.dllName = '';
        this.filenameExtension = '';
        this.flags = 0;
        this.formatDescription = '';
        this.formatID = null;
        this.mimeType = '';
        this.signatureMasks = null;
        this.signaturePatterns = null;
        this.version = 0;
    }
    // methods
    ImageCodecInfo.GetImageDecoders = function () {
        var decoderNums = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
        var arraySize = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0);
        var decoder_size;
        var decoders;
        var decoder_ptr;
        var result;
        var gdipdecoder = new _gdipStructs__WEBPACK_IMPORTED_MODULE_2__.GdipImageCodecInfo();
        var status;
        status = _GDIPlus__WEBPACK_IMPORTED_MODULE_1__.GDIPlus.GdipGetImageDecodersSize(decoderNums, arraySize);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_1__.GDIPlus.CheckStatus(status);
        result = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Array(decoderNums.value);
        if (decoderNums.value === 0)
            return result;
        /* Get decoders list*/
        decoders = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.AllocHGlobal(arraySize.value);
        try {
            status = _GDIPlus__WEBPACK_IMPORTED_MODULE_1__.GDIPlus.GdipGetImageDecoders(decoderNums.value, arraySize.value, decoders);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_1__.GDIPlus.CheckStatus(status);
            decoder_size = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.SizeOf(gdipdecoder);
            decoder_ptr = decoders;
            for (var i = 0; i < decoderNums.value; i++, decoder_ptr = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(decoder_ptr.ToInt64() + decoder_size)) {
                gdipdecoder = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStructure(decoder_ptr, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_gdipStructs__WEBPACK_IMPORTED_MODULE_2__.GdipImageCodecInfo));
                result[i] = new ImageCodecInfo();
                _gdipStructs__WEBPACK_IMPORTED_MODULE_2__.GdipImageCodecInfo.MarshalTo(gdipdecoder, result[i]);
            }
        }
        finally {
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(decoders);
        }
        return result;
    };
    ImageCodecInfo.GetImageEncoders = function () {
        var encoderNums = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0), arraySize = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Out(0), encoder_size = 0;
        var encoders, encoder_ptr;
        var result;
        var gdipencoder = new _gdipStructs__WEBPACK_IMPORTED_MODULE_2__.GdipImageCodecInfo();
        var status;
        status = _GDIPlus__WEBPACK_IMPORTED_MODULE_1__.GDIPlus.GdipGetImageEncodersSize(encoderNums, arraySize);
        _GDIPlus__WEBPACK_IMPORTED_MODULE_1__.GDIPlus.CheckStatus(status);
        result = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.New.Array(encoderNums.value);
        if (encoderNums.value === 0)
            return result;
        /* Get encoders list*/
        encoders = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.AllocHGlobal(arraySize.value);
        try {
            status = _GDIPlus__WEBPACK_IMPORTED_MODULE_1__.GDIPlus.GdipGetImageEncoders(encoderNums.value, arraySize.value, encoders);
            _GDIPlus__WEBPACK_IMPORTED_MODULE_1__.GDIPlus.CheckStatus(status);
            encoder_size = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.SizeOf(gdipencoder);
            encoder_ptr = encoders;
            for (var i = 0; i < encoderNums.value; i++, encoder_ptr = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.IntPtr(encoder_ptr.ToInt64() + encoder_size)) {
                gdipencoder = _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.PtrToStructure(encoder_ptr, (0,_tuval_core__WEBPACK_IMPORTED_MODULE_0__.typeOf)(_gdipStructs__WEBPACK_IMPORTED_MODULE_2__.GdipImageCodecInfo));
                result[i] = new ImageCodecInfo();
                _gdipStructs__WEBPACK_IMPORTED_MODULE_2__.GdipImageCodecInfo.MarshalTo(gdipencoder, result[i]);
            }
        }
        finally {
            _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Marshal.FreeHGlobal(encoders);
        }
        return result;
    };
    Object.defineProperty(ImageCodecInfo.prototype, "Clsid", {
        // properties
        get: function () {
            return this.clsid;
        },
        set: function (value) {
            this.clsid = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageCodecInfo.prototype, "CodecName", {
        get: function () {
            return this.codecName;
        },
        set: function (value) {
            this.codecName = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageCodecInfo.prototype, "DllName", {
        get: function () {
            return this.dllName;
        },
        set: function (value) {
            this.dllName = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageCodecInfo.prototype, "FilenameExtension", {
        get: function () {
            return this.filenameExtension;
        },
        set: function (value) {
            this.filenameExtension = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageCodecInfo.prototype, "Flags", {
        get: function () {
            return this.flags;
        },
        set: function (value) {
            this.flags = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageCodecInfo.prototype, "FormatDescription", {
        get: function () {
            return this.formatDescription;
        },
        set: function (value) {
            this.formatDescription = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageCodecInfo.prototype, "FormatID", {
        get: function () {
            return this.formatID;
        },
        set: function (value) {
            this.formatID = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageCodecInfo.prototype, "MimeType", {
        get: function () {
            return this.mimeType;
        },
        set: function (value) {
            this.mimeType = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageCodecInfo.prototype, "SignatureMasks", {
        get: function () {
            return this.signatureMasks;
        },
        set: function (value) {
            this.signatureMasks = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageCodecInfo.prototype, "SignaturePatterns", {
        get: function () {
            return this.signaturePatterns;
        },
        set: function (value) {
            this.signaturePatterns = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageCodecInfo.prototype, "Version", {
        get: function () {
            return this.version;
        },
        set: function (value) {
            this.version = value;
        },
        enumerable: false,
        configurable: true
    });
    return ImageCodecInfo;
}());



/***/ }),

/***/ "./src/drawing/imaging/ImageFormat.ts":
/*!********************************************!*\
  !*** ./src/drawing/imaging/ImageFormat.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageFormat": () => (/* binding */ ImageFormat)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var ImageFormat = /** @class */ (function () {
    function ImageFormat() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.guid = null;
        this.name = '';
        if (args.length === 1) {
            var guid = args[0];
            this.guid = guid;
        }
        else if (args.length === 2) {
            var name_1 = args[0];
            var guid = args[1];
            this.name = name_1;
            this.guid = new _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Guid(guid);
        }
    }
    // methods
    ImageFormat.prototype.Equals = function (o) {
        var f = o;
        if (f == null)
            return false;
        return f.Guid.Equals(this.guid);
    };
    ImageFormat.prototype.GetHashCode = function () {
        return this.guid.GetHashCode();
    };
    ImageFormat.prototype.ToString = function () {
        if (this.name != null)
            return this.name;
        return ("[ImageFormat: " + this.guid.ToString() + "]");
    };
    Object.defineProperty(ImageFormat.prototype, "Guid", {
        // properties
        get: function () {
            return this.guid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFormat, "Bmp", {
        get: function () {
            if (ImageFormat.BmpImageFormat == null)
                ImageFormat.BmpImageFormat = new ImageFormat("Bmp", ImageFormat.BmpGuid);
            return ImageFormat.BmpImageFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFormat, "Emf", {
        get: function () {
            if (ImageFormat.EmfImageFormat == null)
                ImageFormat.EmfImageFormat = new ImageFormat("Emf", ImageFormat.EmfGuid);
            return ImageFormat.EmfImageFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFormat, "Exif", {
        get: function () {
            if (ImageFormat.ExifImageFormat == null)
                ImageFormat.ExifImageFormat = new ImageFormat("Exif", ImageFormat.ExifGuid);
            return ImageFormat.ExifImageFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFormat, "Gif", {
        get: function () {
            if (ImageFormat.GifImageFormat == null)
                ImageFormat.GifImageFormat = new ImageFormat("Gif", ImageFormat.GifGuid);
            return ImageFormat.GifImageFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFormat, "Icon", {
        get: function () {
            if (ImageFormat.IconImageFormat == null)
                ImageFormat.IconImageFormat = new ImageFormat("Icon", ImageFormat.IconGuid);
            return ImageFormat.IconImageFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFormat, "Jpeg", {
        get: function () {
            if (ImageFormat.JpegImageFormat == null)
                ImageFormat.JpegImageFormat = new ImageFormat("Jpeg", ImageFormat.JpegGuid);
            return ImageFormat.JpegImageFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFormat, "MemoryBmp", {
        get: function () {
            if (ImageFormat.MemoryBmpImageFormat == null)
                ImageFormat.MemoryBmpImageFormat = new ImageFormat("MemoryBMP", ImageFormat.MemoryBmpGuid);
            return ImageFormat.MemoryBmpImageFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFormat, "Png", {
        get: function () {
            if (ImageFormat.PngImageFormat == null)
                ImageFormat.PngImageFormat = new ImageFormat("Png", ImageFormat.PngGuid);
            return ImageFormat.PngImageFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFormat, "Tiff", {
        get: function () {
            if (ImageFormat.TiffImageFormat == null)
                ImageFormat.TiffImageFormat = new ImageFormat("Tiff", ImageFormat.TiffGuid);
            return ImageFormat.TiffImageFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ImageFormat, "Wmf", {
        get: function () {
            if (ImageFormat.WmfImageFormat == null)
                ImageFormat.WmfImageFormat = new ImageFormat("Wmf", ImageFormat.WmfGuid);
            return ImageFormat.WmfImageFormat;
        },
        enumerable: false,
        configurable: true
    });
    ImageFormat.BmpGuid = "b96b3cab-0728-11d3-9d7b-0000f81ef32e";
    ImageFormat.EmfGuid = "b96b3cac-0728-11d3-9d7b-0000f81ef32e";
    ImageFormat.ExifGuid = "b96b3cb2-0728-11d3-9d7b-0000f81ef32e";
    ImageFormat.GifGuid = "b96b3cb0-0728-11d3-9d7b-0000f81ef32e";
    ImageFormat.TiffGuid = "b96b3cb1-0728-11d3-9d7b-0000f81ef32e";
    ImageFormat.PngGuid = "b96b3caf-0728-11d3-9d7b-0000f81ef32e";
    ImageFormat.MemoryBmpGuid = "b96b3caa-0728-11d3-9d7b-0000f81ef32e";
    ImageFormat.IconGuid = "b96b3cb5-0728-11d3-9d7b-0000f81ef32e";
    ImageFormat.JpegGuid = "b96b3cae-0728-11d3-9d7b-0000f81ef32e";
    ImageFormat.WmfGuid = "b96b3cad-0728-11d3-9d7b-0000f81ef32e";
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Override,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [ImageFormat]),
        __metadata("design:returntype", Boolean)
    ], ImageFormat.prototype, "Equals", null);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Override,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Number)
    ], ImageFormat.prototype, "GetHashCode", null);
    __decorate([
        _tuval_core__WEBPACK_IMPORTED_MODULE_0__.Override,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", String)
    ], ImageFormat.prototype, "ToString", null);
    return ImageFormat;
}());



/***/ }),

/***/ "./src/drawing/imaging/PixelFormat.ts":
/*!********************************************!*\
  !*** ./src/drawing/imaging/PixelFormat.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PixelFormat": () => (/* binding */ PixelFormat)
/* harmony export */ });
var PixelFormat;
(function (PixelFormat) {
    PixelFormat[PixelFormat["Alpha"] = 262144] = "Alpha";
    PixelFormat[PixelFormat["Canonical"] = 2097152] = "Canonical";
    PixelFormat[PixelFormat["DontCare"] = 0] = "DontCare";
    PixelFormat[PixelFormat["Extended"] = 1048576] = "Extended";
    PixelFormat[PixelFormat["Format16bppArgb1555"] = 397319] = "Format16bppArgb1555";
    PixelFormat[PixelFormat["Format16bppGrayScale"] = 1052676] = "Format16bppGrayScale";
    PixelFormat[PixelFormat["Format16bppRgb555"] = 135173] = "Format16bppRgb555";
    PixelFormat[PixelFormat["Format16bppRgb565"] = 135174] = "Format16bppRgb565";
    PixelFormat[PixelFormat["Format1bppIndexed"] = 196865] = "Format1bppIndexed";
    PixelFormat[PixelFormat["Format24bppRgb"] = 137224] = "Format24bppRgb";
    PixelFormat[PixelFormat["Format32bppArgb"] = 2498570] = "Format32bppArgb";
    PixelFormat[PixelFormat["Format32bppPArgb"] = 925707] = "Format32bppPArgb";
    PixelFormat[PixelFormat["Format32bppRgb"] = 139273] = "Format32bppRgb";
    PixelFormat[PixelFormat["Format48bppRgb"] = 1060876] = "Format48bppRgb";
    PixelFormat[PixelFormat["Format4bppIndexed"] = 197634] = "Format4bppIndexed";
    PixelFormat[PixelFormat["Format64bppArgb"] = 3424269] = "Format64bppArgb";
    PixelFormat[PixelFormat["Format64bppPArgb"] = 1851406] = "Format64bppPArgb";
    PixelFormat[PixelFormat["Format8bppIndexed"] = 198659] = "Format8bppIndexed";
    PixelFormat[PixelFormat["Gdi"] = 131072] = "Gdi";
    PixelFormat[PixelFormat["Indexed"] = 65536] = "Indexed";
    PixelFormat[PixelFormat["Max"] = 15] = "Max";
    PixelFormat[PixelFormat["PAlpha"] = 524288] = "PAlpha";
    PixelFormat[PixelFormat["Undefined"] = 0] = "Undefined"; //shows up in enumcheck as second "dontcare".
})(PixelFormat || (PixelFormat = {}));


/***/ }),

/***/ "./src/drawing/imaging/PropertyItem.ts":
/*!*********************************************!*\
  !*** ./src/drawing/imaging/PropertyItem.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PropertyItem": () => (/* binding */ PropertyItem)
/* harmony export */ });
var PropertyItem = /** @class */ (function () {
    //constructor
    function PropertyItem() {
        this.id = 0;
        this.len = 0;
        this.type = 0;
        this.value = null;
        //Nothing to be done here
    }
    Object.defineProperty(PropertyItem.prototype, "Id", {
        // properties
        get: function () {
            return this.id;
        },
        set: function (value) {
            this.id = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyItem.prototype, "Len", {
        get: function () {
            return this.len;
        },
        set: function (value) {
            this.len = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyItem.prototype, "Type", {
        get: function () {
            return this.type;
        },
        set: function (value) {
            this.type = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyItem.prototype, "Value", {
        get: function () {
            return this.value;
        },
        set: function (value) {
            this.value = value;
        },
        enumerable: false,
        configurable: true
    });
    return PropertyItem;
}());



/***/ }),

/***/ "./src/drawing/printing/PageSettings.ts":
/*!**********************************************!*\
  !*** ./src/drawing/printing/PageSettings.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PageSettings": () => (/* binding */ PageSettings)
/* harmony export */ });
var PageSettings = /** @class */ (function () {
    function PageSettings() {
    }
    return PageSettings;
}());



/***/ }),

/***/ "./src/drawing/printing/PrintDocument.ts":
/*!***********************************************!*\
  !*** ./src/drawing/printing/PrintDocument.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrintDocument": () => (/* binding */ PrintDocument)
/* harmony export */ });
var PrintDocument = /** @class */ (function () {
    function PrintDocument() {
        //public PrintPage: EventD<PrintPageEventHandler> = undefined as any;
        this.DocumentName = '';
        this.DefaultPageSettings = undefined;
    }
    PrintDocument.prototype.print = function () {
    };
    return PrintDocument;
}());



/***/ }),

/***/ "./src/drawing/printing/PrintPageEventArgs.ts":
/*!****************************************************!*\
  !*** ./src/drawing/printing/PrintPageEventArgs.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrintPageEventArgs": () => (/* binding */ PrintPageEventArgs)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var PrintPageEventArgs = /** @class */ (function (_super) {
    __extends(PrintPageEventArgs, _super);
    function PrintPageEventArgs() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.MarginBounds = undefined;
        _this.Graphics = undefined;
        _this.PageSettings = undefined;
        _this.HasMorePages = undefined;
        return _this;
    }
    return PrintPageEventArgs;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.EventArgs));



/***/ }),

/***/ "./src/drawing/printing/PrintPageEventHandler.ts":
/*!*******************************************************!*\
  !*** ./src/drawing/printing/PrintPageEventHandler.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrintPageEventHandler": () => (/* binding */ PrintPageEventHandler)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var PrintPageEventHandler = /** @class */ (function (_super) {
    __extends(PrintPageEventHandler, _super);
    function PrintPageEventHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PrintPageEventHandler;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.Delegate));



/***/ }),

/***/ "./src/drawing/printing/PrintRange.ts":
/*!********************************************!*\
  !*** ./src/drawing/printing/PrintRange.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PrintRange": () => (/* binding */ PrintRange)
/* harmony export */ });
var PrintRange;
(function (PrintRange) {
    PrintRange[PrintRange["AllPages"] = 0] = "AllPages";
    PrintRange[PrintRange["Selection"] = 1] = "Selection";
    PrintRange[PrintRange["SomePages"] = 2] = "SomePages";
    PrintRange[PrintRange["CurrentPage"] = 4194304] = "CurrentPage";
})(PrintRange || (PrintRange = {}));


/***/ }),

/***/ "./src/drawing/scene/display/Bitmap.ts":
/*!*********************************************!*\
  !*** ./src/drawing/scene/display/Bitmap.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SceneBitmap": () => (/* binding */ SceneBitmap)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _DisplayObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DisplayObject */ "./src/drawing/scene/display/DisplayObject.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing
 * HTML element, or a string.
 *
 * <strong>Notes:</strong>
 * <ol>
 * 	<li>When using a video source that may loop or seek, use a {@link VideoBuffer} object to
 * 	 prevent blinking / flashing.
 * 	<li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it
 * 	 will be displayed.</li>
 * 	<li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,
 * 	the Bitmap can be cached.</li>
 * 	<li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This
 * 	happens in all browsers except recent Firefox builds.</li>
 * 	<li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using
 * 	methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting
 * 	`crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`</li>
 * </ol>
 *
 * @memberof easeljs
 * @extends DisplayObject
 * @example
 * const bitmap = new Bitmap("./imagePath.jpg");
 */
var SceneBitmap = /** @class */ (function (_super) {
    __extends(SceneBitmap, _super);
    /**
     * @param {CanvasImageSource|String|Object} imageOrUri The source image to display. This can be a CanvasImageSource
     * (image, video, canvas), an object with a `getImage` method that returns a CanvasImageSource, or a string URL to an image.
     * If the latter, a new Image instance with the URL as its src will be used.
     */
    function SceneBitmap(imageOrUri) {
        var _this = _super.call(this) || this;
        if (typeof imageOrUri === "string") {
            _this.image = document.createElement("img");
            _this.image.src = imageOrUri;
        }
        else {
            _this.image = imageOrUri;
        }
        _this.sourceRect = null;
        _this._webGLRenderStyle = _DisplayObject__WEBPACK_IMPORTED_MODULE_1__.DisplayObject._StageGL_BITMAP;
        return _this;
    }
    SceneBitmap.prototype.isVisible = function () {
        var image = this.image;
        var hasContent = this.cacheCanvas || (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
        return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
    };
    SceneBitmap.prototype.draw = function (ctx, ignoreCache) {
        if (ignoreCache === void 0) { ignoreCache = false; }
        if (_super.prototype.draw.call(this, ctx, ignoreCache)) {
            return true;
        }
        var rect = this.sourceRect;
        var img = this.image;
        if (img.getImage) {
            img = img.getImage();
        }
        if (!img) {
            return true;
        }
        if (rect) {
            // some browsers choke on out of bound values, so we'll fix them:
            var x1 = rect.X, y1 = rect.Y, x2 = x1 + rect.Width, y2 = y1 + rect.Height, x = 0, y = 0, w = img.width, h = img.height;
            if (x1 < 0) {
                x -= x1;
                x1 = 0;
            }
            if (x2 > w) {
                x2 = w;
            }
            if (y1 < 0) {
                y -= y1;
                y1 = 0;
            }
            if (y2 > h) {
                y2 = h;
            }
            ctx.drawImage(img, x1, y1, x2 - x1, y2 - y1, x, y, x2 - x1, y2 - y1);
        }
        else {
            ctx.drawImage(img, 0, 0);
        }
        return true;
    };
    SceneBitmap.prototype.getBounds = function () {
        var rect = _super.prototype.getBounds.call(this);
        if (rect) {
            return rect;
        }
        var image = this.image;
        var o = this.sourceRect || new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGSize(image.width, image.height);
        var hasContent = (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
        return hasContent ? this._rectangle.setValues(0, 0, o.Width, o.Height) : null;
    };
    /**
     * Returns a clone of the Bitmap instance.
     * @param {Boolean} [node=false] Whether the underlying dom element should be cloned as well.
     * @return {Bitmap} a clone of the Bitmap instance.
     */
    SceneBitmap.prototype.clone = function (node) {
        if (node === void 0) { node = false; }
        var image = this.image;
        if (image && node) {
            image = image.cloneNode();
            image.src = image.src; // IE cloneNode bug fix
        }
        var o = new SceneBitmap(image);
        if (this.sourceRect) {
            o.sourceRect = this.sourceRect.clone();
        }
        this._cloneProps(o);
        return o;
    };
    return SceneBitmap;
}(_DisplayObject__WEBPACK_IMPORTED_MODULE_1__.DisplayObject));



/***/ }),

/***/ "./src/drawing/scene/display/Container.ts":
/*!************************************************!*\
  !*** ./src/drawing/scene/display/Container.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Container": () => (/* binding */ Container)
/* harmony export */ });
/* harmony import */ var _DisplayObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DisplayObject */ "./src/drawing/scene/display/DisplayObject.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * A Container is a nestable display list that allows you to work with compound display elements. For  example you could
 * group arm, leg, torso and head {{#crossLink "Bitmap"}}{{/crossLink}} instances together into a Person Container, and
 * transform them as a group, while still being able to move the individual parts relative to each other. Children of
 * containers have their `transform` and `alpha` properties concatenated with their parent
 * Container.
 *
 * For example, a {{#crossLink "Shape"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with `x=50`
 * and `alpha=0.7` will be rendered to the canvas at `x=150` and `alpha=0.35`.
 * Containers have some overhead, so you generally shouldn't create a Container to hold a single child.
 *
 * @memberof Tuval
 * @extends DisplayObject
 * @example
 * const container = new Tuval.Container();
 * container.addChild(bitmapInstance, shapeInstance);
 * container.x = 100;
 */
var Container = /** @class */ (function (_super) {
    __extends(Container, _super);
    function Container() {
        var _this = _super.call(this) || this;
        _this.children = [];
        _this.mouseChildren = true;
        _this.tickChildren = true;
        return _this;
    }
    Object.defineProperty(Container.prototype, "numChildren", {
        /**
         * Returns the number of children in the container.
         * @type {Number}
         * @readonly
         */
        get: function () {
            return this.children.length;
        },
        enumerable: false,
        configurable: true
    });
    Container.prototype.isVisible = function () {
        var hasContent = this.cacheCanvas || this.children.length;
        return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
    };
    Container.prototype.draw = function (ctx, ignoreCache) {
        if (ignoreCache === void 0) { ignoreCache = false; }
        if (_super.prototype.draw.call(this, ctx, ignoreCache)) {
            return true;
        }
        // this ensures we don't have issues with display list changes that occur during a draw:
        var list = this.children.slice();
        for (var i = 0, l = list.length; i < l; i++) {
            var child = list[i];
            if (!child.isVisible()) {
                continue;
            }
            // draw the child:
            ctx.save();
            child.updateContext(ctx);
            child.draw(ctx);
            ctx.restore();
        }
        return true;
    };
    /**
     * Adds a child to the top of the display list.
     *
     * @example
     * container.addChild(bitmapInstance);
     * // You can also add multiple children at once:
     * container.addChild(bitmapInstance, shapeInstance, textInstance);
     *
     * @param {...DisplayObject} children The display object(s) to add.
     * @return {DisplayObject} The child that was added, or the last child if multiple children were added.
     */
    Container.prototype.addChild = function () {
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            children[_i] = arguments[_i];
        }
        var l = children.length;
        if (l === 0) {
            return null;
        }
        var child = children[0];
        if (l > 1) {
            for (var i = 0; i < l; i++) {
                child = this.addChild(children[i]);
            }
            return child;
        }
        // Note: a lot of duplication with addChildAt, but push is WAY faster than splice.
        var parent = child.parent, silent = parent === this;
        parent && parent._removeChildAt(parent.children.indexOf(child), silent);
        child.parent = this;
        this.children.push(child);
        if (!silent) {
            child.dispatchEvent("added");
        }
        return child;
    };
    /**
     * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and
     * setting its parent to this container.
     *
     * @example
     * container.addChildAt(child1, index);
     * // You can also add multiple children, such as:
     * container.addChildAt(child1, child2, ..., index);
     * // The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list, you could use:
     * container.addChildAt(myShape, container.getChildIndex(otherShape));
     * // This would also bump otherShape's index up by one. Fails silently if the index is out of range.
     *
     * @param {...DisplayObject} children The display object(s) to add.
     * @param {Number} index The index to add the child at.
     * @return {DisplayObject} Returns the last child that was added, or the last child if multiple children were added.
     */
    Container.prototype.addChildAt = function () {
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            children[_i] = arguments[_i];
        }
        var l = arguments.length;
        if (l === 0) {
            return null;
        }
        var index = arguments[l - 1];
        if (index < 0 || index > this.children.length) {
            return children[l - 2];
        }
        if (l > 2) {
            for (var i = 0; i < l - 1; i++) {
                this.addChildAt(children[i], index++);
            }
            return children[l - 2];
        }
        var child = children[0];
        var parent = child.parent, silent = parent === this;
        parent && parent._removeChildAt(parent.children.indexOf(child), silent);
        child.parent = this;
        this.children.splice(index++, 0, child);
        if (!silent) {
            child.dispatchEvent("added");
        }
        return child;
    };
    /**
     * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is
     * already known.
     *
     * @example
     * container.removeChild(child);
     * // You can also remove multiple children:
     * container.removeChild(child1, child2, ...);
     *
     * @param {...DisplayObject} children The display object(s) to remove.
     * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.
     */
    Container.prototype.removeChild = function () {
        var children = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            children[_i] = arguments[_i];
        }
        var l = children.length;
        if (l === 0) {
            return true;
        }
        if (l > 1) {
            var good = true;
            for (var i = 0; i < l; i++) {
                good = good && this.removeChild(children[i]);
            }
            return good;
        }
        return this._removeChildAt(this.children.indexOf(children[0]));
    };
    /**
     * Removes the child at the specified index from the display list, and sets its parent to null.
     *
     * @example
     * container.removeChildAt(2);
     * // You can also remove multiple children:
     * container.removeChildAt(2, 7, ...)
     *
     * @param {...Number} indexes The indexes of children to remove.
     * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
     */
    Container.prototype.removeChildAt = function () {
        var indexes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            indexes[_i] = arguments[_i];
        }
        var l = indexes.length;
        if (l === 0) {
            return true;
        }
        if (l > 1) {
            indexes.sort(function (a, b) { return b - a; });
            var good = true;
            for (var i = 0; i < l; i++) {
                good = good && this._removeChildAt(indexes[i]);
            }
            return good;
        }
        return this._removeChildAt(indexes[0]);
    };
    /**
     * Removes all children from the display list.
     */
    Container.prototype.removeAllChildren = function () {
        var kids = this.children;
        while (kids.length) {
            this._removeChildAt(0);
        }
    };
    /**
     * Returns the child at the specified index.
     * @param {Number} index The index of the child to return.
     * @return {DisplayObject} The child at the specified index. Returns null if there is no child at the index.
     */
    Container.prototype.getChildAt = function (index) {
        return this.children[index];
    };
    /**
     * Returns the child with the specified name.
     * @param {String} name The name of the child to return.
     * @return {DisplayObject} The child with the specified name.
     */
    Container.prototype.getChildByName = function (name) {
        var kids = this.children;
        var l = kids.length;
        for (var i = 0; i < l; i++) {
            if (kids[i].name === name) {
                return kids[i];
            }
        }
        return null;
    };
    /**
     * Performs an array sort operation on the child list.
     *
     * @example
     * // Display children with a higher y in front.
     * container.sortChildren((obj1, obj2, options) => {
     * 	 if (obj1.y > obj2.y) { return 1; }
     *   if (obj1.y < obj2.y) { return -1; }
     *   return 0;
     * });
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}
     * @param {Function} sortFunction the function to use to sort the child list.
     */
    Container.prototype.sortChildren = function (sortFunction) {
        this.children.sort(sortFunction);
    };
    /**
     * Returns the index of the specified child in the display list, or -1 if it is not in the display list.
     * @param {DisplayObject} child The child to return the index of.
     * @return {Number} The index of the specified child. -1 if the child is not found.
     */
    Container.prototype.getChildIndex = function (child) {
        return this.children.indexOf(child);
    };
    /**
     * Swaps the children at the specified indexes. Fails silently if either index is out of range.
     * @param {Number} index1
     * @param {Number} index2
     */
    Container.prototype.swapChildrenAt = function (index1, index2) {
        var kids = this.children;
        var o1 = kids[index1];
        var o2 = kids[index2];
        if (!o1 || !o2) {
            return;
        }
        kids[index1] = o2;
        kids[index2] = o1;
    };
    ;
    /**
     * Swaps the specified children's depth in the display list. Fails silently if either child is not a child of this
     * Container.
     * @param {DisplayObject} child1
     * @param {DisplayObject} child2
     */
    Container.prototype.swapChildren = function (child1, child2) {
        var kids = this.children;
        var l = kids.length;
        var index1, index2;
        for (var i = 0; i < l; i++) {
            if (kids[i] === child1) {
                index1 = i;
            }
            if (kids[i] === child2) {
                index2 = i;
            }
            if (index1 != null && index2 != null) {
                break;
            }
        }
        if (i === l) {
            return;
        } // TODO: throw error?
        kids[index1] = child2;
        kids[index2] = child1;
    };
    /**
     * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.
     * @param {DisplayObject} child
     * @param {Number} index
     */
    Container.prototype.setChildIndex = function (child, index) {
        var kids = this.children;
        var l = kids.length;
        if (child.parent != this || index < 0 || index >= l) {
            return;
        }
        for (var i = 0; i < l; i++) {
            if (kids[i] === child) {
                break;
            }
        }
        if (i === l || i === index) {
            return;
        }
        kids.splice(i, 1);
        kids.splice(index, 0, child);
    };
    /**
     * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)
     * of this container.
     * @param {DisplayObject} child The DisplayObject to be checked.
     * @return {Boolean} true if the specified display object either is this container or is a descendent.
     */
    Container.prototype.contains = function (child) {
        while (child) {
            if (child === this) {
                return true;
            }
            child = child.parent;
        }
        return false;
    };
    /**
     * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the
     * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all
     * transform properties including regX/Y.
     * @param {Number} x The x position to check in the display object's local coordinates.
     * @param {Number} y The y position to check in the display object's local coordinates.
     * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified
     * coordinates.
     */
    Container.prototype.hitTest = function (x, y) {
        // TODO: optimize to use the fast cache check where possible.
        return this.getObjectUnderPoint(x, y) != null;
    };
    /**
     * Returns an array of all display objects under the specified coordinates that are in this container's display
     * list. This routine ignores any display objects with {@link DisplayObject#mouseEnabled} set to `false`.
     * The array will be sorted in order of visual depth, with the top-most display object at index 0.
     * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.
     * For example, if testing for objects under the mouse, test on tick (instead of on {@link DisplayObject#event:mousemove}),
     * and only if the mouse's position has changed.
     *
     * <ul>
     *   <li>By default (mode=0) this method evaluates all display objects.</li>
     *   <li>By setting the `mode` parameter to `1`, the {@link DisplayObject#mouseEnabled}
     *       and {@link DisplayObject#mouseChildren} properties will be respected.</li>
     *   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event
     *       listeners or a {@link DisplayObject#cursor} property. That is, only objects
     *       that would normally intercept mouse interaction will be included. This can significantly improve performance
     *       in some cases by reducing the number of display objects that need to be tested.</li>
     * </ul>
     *
     * This method accounts for both {@link DisplayObject#hitArea} and {@link DisplayObject#mask}.
     *
     * @param {Number} x The x position in the container to test.
     * @param {Number} y The y position in the container to test.
     * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
     * @return {Array<DisplayObject>} An array of DisplayObjects under the specified coordinates.
     */
    Container.prototype.getObjectsUnderPoint = function (x, y, mode) {
        if (mode === void 0) { mode = 0; }
        var arr = [];
        var pt = this.localToGlobal(x, y);
        this._getObjectsUnderPoint(pt.X, pt.Y, arr, mode > 0, mode === 1);
        return arr;
    };
    /**
     * Similar to {@link Container#getObjectsUnderPoint}, but returns only the top-most display
     * object. This runs significantly faster than `getObjectsUnderPoint()`, but is still potentially an expensive
     * operation.
     *
     * @param {Number} x The x position in the container to test.
     * @param {Number} y The y position in the container to test.
     * @param {Number} [mode=0] The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
     * @return {DisplayObject} The top-most display object under the specified coordinates.
     */
    Container.prototype.getObjectUnderPoint = function (x, y, mode) {
        if (mode === void 0) { mode = 0; }
        var pt = this.localToGlobal(x, y);
        return this._getObjectsUnderPoint(pt.X, pt.Y, null, mode > 0, mode === 1);
    };
    Container.prototype.getBounds = function () {
        return this._getBounds(null, true);
    };
    Container.prototype.getTransformedBounds = function () {
        return this._getBounds();
    };
    /**
     * Returns a clone of this Container. Some properties that are specific to this instance's current context are
     * reverted to their defaults (for example `.parent`).
     * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the
     * properties of the container will be cloned, but the new instance will not have any children.
     * @return {Container} A clone of the current Container instance.
     */
    Container.prototype.clone = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        var o = this._cloneProps(new Container());
        if (recursive) {
            this._cloneChildren(o);
        }
        return o;
    };
    Container.prototype._tick = function (evtObj) {
        if (this.tickChildren) {
            for (var i = this.children.length - 1; i >= 0; i--) {
                var child = this.children[i];
                if (child.tickEnabled && child._tick) {
                    child._tick(evtObj);
                }
            }
        }
        _super.prototype._tick.call(this, evtObj);
    };
    /**
     * Recursively clones all children of this container, and adds them to the target container.
     * @protected
     * @param {Container} o The target container.
     */
    Container.prototype._cloneChildren = function (o) {
        if (o.children.length) {
            o.removeAllChildren();
        }
        var arr = o.children;
        var l = this.children.length;
        for (var i = 0; i < l; i++) {
            var clone = this.children[i].clone(true);
            clone.parent = o;
            arr.push(clone);
        }
    };
    /**
     * Removes the child at the specified index from the display list, and sets its parent to null.
     * Used by `removeChildAt`, `addChild`, and `addChildAt`.
     *
     * @protected
     * @param {Number} index The index of the child to remove.
     * @param {Boolean} [silent=false] Prevents dispatch of `removed` event if true.
     * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
     */
    Container.prototype._removeChildAt = function (index, silent) {
        if (silent === void 0) { silent = false; }
        if (index < 0 || index > this.children.length - 1) {
            return false;
        }
        var child = this.children[index];
        if (child) {
            child.parent = null;
        }
        this.children.splice(index, 1);
        if (!silent) {
            child.dispatchEvent("removed");
        }
        return true;
    };
    /**
     * @protected
     * @param {Number} x
     * @param {Number} y
     * @param {Array} arr
     * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.
     * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.
     * @param {Number} [currentDepth=0] Indicates the current depth of the search.
     * @return {DisplayObject}
     */
    Container.prototype._getObjectsUnderPoint = function (x, y, arr, mouse, activeListener, currentDepth) {
        if (currentDepth === void 0) { currentDepth = 0; }
        if (!currentDepth && !this._testMask(this, x, y)) {
            return null;
        }
        var mtx, ctx = _DisplayObject__WEBPACK_IMPORTED_MODULE_0__.DisplayObject._hitTestContext;
        activeListener = activeListener || (mouse && this._hasMouseEventListener());
        // draw children one at a time, and check if we get a hit:
        var children = this.children;
        var l = children.length;
        for (var i = l - 1; i >= 0; i--) {
            var child = children[i];
            var hitArea = child.hitArea;
            if (!child.visible || (!hitArea && !child.isVisible()) || (mouse && !child.mouseEnabled)) {
                continue;
            }
            if (!hitArea && !this._testMask(child, x, y)) {
                continue;
            }
            // if a child container has a hitArea then we only need to check its hitArea, so we can treat it as a normal DO:
            if (!hitArea && child instanceof Container) {
                var result = child._getObjectsUnderPoint(x, y, arr, mouse, activeListener, currentDepth + 1);
                if (!arr && result) {
                    return (mouse && !this.mouseChildren) ? this : result;
                }
            }
            else {
                if (mouse && !activeListener && !child._hasMouseEventListener()) {
                    continue;
                }
                // TODO: can we pass displayProps forward, to avoid having to calculate this backwards every time? It's kind of a mixed bag. When we're only hunting for DOs with event listeners, it may not make sense.
                var props = child.getConcatenatedDisplayProps(child._props);
                mtx = props.matrix;
                if (hitArea) {
                    mtx.appendMatrix(hitArea.getMatrix(hitArea._props.matrix));
                    props.alpha = hitArea.alpha;
                }
                ctx.globalAlpha = props.alpha;
                ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx - x, mtx.ty - y);
                (hitArea || child).draw(ctx);
                if (!this._testHit(ctx)) {
                    continue;
                }
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, 2, 2);
                if (arr) {
                    arr.push(child);
                }
                else {
                    return (mouse && !this.mouseChildren) ? this : child;
                }
            }
        }
        return null;
    };
    /**
     * @protected
     * @param {DisplayObject} target
     * @param {Number} x
     * @param {Number} y
     * @return {Boolean} Indicates whether the x/y is within the masked region.
     */
    Container.prototype._testMask = function (target, x, y) {
        var mask = target.mask;
        if (!mask || !mask.graphics || mask.graphics.isEmpty()) {
            return true;
        }
        var mtx = this._props.matrix, parent = target.parent;
        mtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();
        mtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);
        var ctx = _DisplayObject__WEBPACK_IMPORTED_MODULE_0__.DisplayObject._hitTestContext;
        ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx - x, mtx.ty - y);
        // draw the mask as a solid fill:
        mask.graphics.drawAsPath(ctx);
        ctx.fillStyle = "#000";
        ctx.fill();
        if (!this._testHit(ctx)) {
            return false;
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, 2, 2);
        return true;
    };
    /**
     * @protected
     * @param {Matrix2D} matrix
     * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
     * @return {Rectangle}
     */
    Container.prototype._getBounds = function (matrix, ignoreTransform) {
        var bounds = _super.prototype.getBounds.call(this);
        if (bounds) {
            return this._transformBounds(bounds, matrix, ignoreTransform);
        }
        var mtx = this._props.matrix;
        mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);
        if (matrix) {
            mtx.prependMatrix(matrix);
        }
        var l = this.children.length;
        var rect = null;
        for (var i = 0; i < l; i++) {
            var child = this.children[i];
            if (!child.visible || !(bounds = child._getBounds(mtx))) {
                continue;
            }
            if (rect) {
                rect.extend(bounds.X, bounds.Y, bounds.Width, bounds.Height);
            }
            else {
                rect = bounds.clone();
            }
        }
        return rect;
    };
    return Container;
}(_DisplayObject__WEBPACK_IMPORTED_MODULE_0__.DisplayObject));



/***/ }),

/***/ "./src/drawing/scene/display/DisplayObject.ts":
/*!****************************************************!*\
  !*** ./src/drawing/scene/display/DisplayObject.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DisplayObject": () => (/* binding */ DisplayObject)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _filter_BitmapCache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../filter/BitmapCache */ "./src/drawing/scene/filter/BitmapCache.ts");
/* harmony import */ var _utils_uid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/uid */ "./src/drawing/scene/utils/uid.ts");
/* harmony import */ var _Shadow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Shadow */ "./src/drawing/Shadow.ts");
/* harmony import */ var _geom_Matrix2D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/Matrix2D */ "./src/drawing/scene/geom/Matrix2D.ts");
/* harmony import */ var _geom_DisplayProps__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/DisplayProps */ "./src/drawing/scene/geom/DisplayProps.ts");
/* harmony import */ var _utils_Canvas__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/Canvas */ "./src/drawing/scene/utils/Canvas.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_7__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









var DisplayObject = /** @class */ (function (_super) {
    __extends(DisplayObject, _super);
    function DisplayObject() {
        var _this = _super.call(this) || this;
        _this.alpha = 1;
        _this.cacheCanvas = null;
        _this.bitmapCache = null;
        _this.id = (0,_utils_uid__WEBPACK_IMPORTED_MODULE_2__.uid)();
        _this.mouseEnabled = true;
        _this.tickEnabled = true;
        /**
         * An optional name for this display object. Included in {@link DisplayObject#toString}.
         * @type {String}
         * @default null
         */
        _this.name = null;
        _this.parent = null;
        _this.regX = 0;
        _this.regY = 0;
        _this.rotation = 0;
        _this.scaleX = 1;
        _this.scaleY = 1;
        _this.skewX = 0;
        _this.skewY = 0;
        _this.shadow = null;
        _this.visible = true;
        _this.x = 0;
        _this.y = 0;
        _this.transformMatrix = null;
        _this.compositeOperation = null;
        _this.snapToPixel = true;
        _this.filters = null;
        _this.mask = null;
        _this.hitArea = null;
        _this.cursor = null;
        _this._props = new _geom_DisplayProps__WEBPACK_IMPORTED_MODULE_5__.DisplayProps();
        _this._rectangle = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle();
        _this._bounds = null;
        _this._webGLRenderStyle = DisplayObject._StageGL_NONE;
        _this._glMtx = new _geom_Matrix2D__WEBPACK_IMPORTED_MODULE_4__.Matrix2D();
        return _this;
    }
    Object.defineProperty(DisplayObject.prototype, "stage", {
        /**
         * Returns the {@link Stage} instance that this display object will be rendered on, or null if it has not been added to one.
         * @type {Stage}
         * @readonly
         */
        get: function () {
            // uses dynamic access to avoid circular dependencies;
            var o = this;
            while (o.parent) {
                o = o.parent;
            }
            if (/^\[Stage(GL)?(\s\(name=\w+\))?\]$/.test(o.toString())) {
                return o;
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "scale", {
        /**
         * Set both the {@link DisplayObject#scaleX} and the {@link DisplayObject#scaleY} property to the same value.
         * @type {Number}
         * @default 1
         */
        set: function (value) {
            this.scaleX = this.scaleY = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
     * This does not account for whether it would be visible within the boundaries of the stage.
     *
     * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
     * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
     */
    DisplayObject.prototype.isVisible = function () {
        return !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0);
    };
    /**
     * Alias for {@link DisplayObject#drawCache}. Use drawCache() directly from a grandchild to bypass
     * the middle parent's draw().
     *
     * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
     * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
     * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
     * @return {Boolean}
     */
    DisplayObject.prototype.draw = function (ctx, ignoreCache) {
        if (ignoreCache === void 0) { ignoreCache = false; }
        return this.drawCache(ctx, ignoreCache);
    };
    /**
     * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
     * Returns `true` if the draw was handled (useful for overriding functionality).
     *
     * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
     * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
     * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
     * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
     * @return {Boolean}
     */
    DisplayObject.prototype.drawCache = function (ctx, ignoreCache) {
        if (ignoreCache === void 0) { ignoreCache = false; }
        var cache = this.bitmapCache;
        if (cache && !ignoreCache) {
            return cache.draw(ctx);
        }
        return false;
    };
    /**
     * Applies this display object's `transformation`, `alpha`, `globalCompositeOperation`, `mask` (clipping path), and `shadow`
     * to the specified context. This is typically called prior to {@link DisplayObject#draw}.
     * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.
     */
    DisplayObject.prototype.updateContext = function (ctx) {
        var mask = this.mask, mtx = this._props.matrix;
        if (mask && mask.graphics && !mask.graphics.isEmpty()) {
            mask.getMatrix(mtx);
            ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
            mask.graphics.drawAsPath(ctx);
            ctx.clip();
            mtx.invert();
            ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
        }
        this.getMatrix(mtx);
        var tx = mtx.tx, ty = mtx.ty;
        if (DisplayObject._snapToPixelEnabled && this.snapToPixel) {
            tx = tx + (tx < 0 ? -0.5 : 0.5) | 0;
            ty = ty + (ty < 0 ? -0.5 : 0.5) | 0;
        }
        ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, tx, ty);
        ctx.globalAlpha *= this.alpha;
        if (this.compositeOperation) {
            ctx.globalCompositeOperation = this.compositeOperation;
        }
        if (this.shadow) {
            this._applyShadow(ctx, this.shadow);
        }
    };
    ;
    /**
     * Draws the display object into a new element, which is then used for subsequent draws. Intended for complex content
     * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),
     * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The
     * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must manually
     * update the cache by calling `updateCache()` again. You must specify the cached area via the x, y, w, and h
     * parameters. This defines the rectangle that will be rendered and cached using this display object's coordinates.
     *
     * Filters need to be defined <em>before</em> the cache is applied or you will have to call updateCache after
     * application. Check out the {@link Filter} class for more information. Some filters
     * (ex. {@link BlurFilter}) may not work as expected in conjunction with the scale param.
     *
     * Usually, the resulting cacheCanvas will have the dimensions width * scale, height * scale, however some filters (ex. BlurFilter)
     * will add padding to the canvas dimensions.
     *
     * In previous versions, caching was handled on DisplayObject but has since been moved to {@link BitmapCache}.
     * This allows for easier interaction and alternate cache methods like WebGL with {@link StageGL}.
     * For more information on the options object, see the {@link BitmapCache#define}.
     *
     * @example
     * const shape = new Shape();
     * shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 25);
     * shape.cache(-25, -25, 50, 50);
     *
     * @param {Number} x The x coordinate origin for the cache region.
     * @param {Number} y The y coordinate origin for the cache region.
     * @param {Number} width The width of the cache region.
     * @param {Number} height The height of the cache region.
     * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using
     * 	myShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate
     * 	cached elements with greater fidelity.
     * @param {Object} [options] Specify additional parameters for the cache logic
     */
    DisplayObject.prototype.cache = function (x, y, width, height, scale, options) {
        if (scale === void 0) { scale = 1; }
        if (!this.bitmapCache) {
            this.bitmapCache = new _filter_BitmapCache__WEBPACK_IMPORTED_MODULE_1__.BitmapCache();
        }
        else {
            this.bitmapCache._autoGenerated = false;
        }
        this.bitmapCache.define(this, x, y, width, height, scale, options);
    };
    /**
     * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.
     * If `compositeOperation` is null the current cache will be cleared prior to drawing. Otherwise the display object
     * will be drawn over the existing cache using the specified `compositeOperation`.
     *
     * In previous versions caching was handled on DisplayObject but has since been moved to {@link BitmapCache}
     * This allows for easier interaction and alternate cache methods like WebGL and {@link StageGL}.
     *
     * @example
     * // clear current graphics
     * shapeInstance.clear();
     * // draw some new instructions
     * shapeInstance.setStrokeStyle(3).beginStroke("#ff0000").moveTo(100, 100).lineTo(200,200);
     * // update cache, new line will be drawn on top of the old one
     * shapeInstance.updateCache();
     *
     * @see {@link https://html.spec.whatwg.org/multipage/scripting.html#dom-context-2d-globalcompositeoperation "WHATWG spec on compositing"}
     * @param {String} [compositeOperation] The composite operation to use, or nul to clear it
     */
    DisplayObject.prototype.updateCache = function (compositeOperation) {
        if (!this.bitmapCache) {
            throw "cache() must be called before updateCache()";
        }
        this.bitmapCache.update(compositeOperation);
    };
    /**
     * Clears the current cache.
     * @see {@link DisplayObject#cache}
     */
    DisplayObject.prototype.uncache = function () {
        if (this.bitmapCache) {
            this.bitmapCache.release();
            this.bitmapCache = undefined;
        }
    };
    /**
     * Returns a data URL for the cache, or null if this display object is not cached.
     * Only generated if the cache has changed, otherwise returns last result.
     * @param {} type
     * @params {} encoderOptions
     * @return {String} The image data url for the cache.
     */
    DisplayObject.prototype.getCacheDataURL = function (type, encoderOptions) {
        return this.bitmapCache ? this.bitmapCache.getCacheDataURL(type, encoderOptions) : null;
    };
    /**
     * Transforms the specified x and y position from the coordinate space of the display object
     * to the global (stage) coordinate space. For example, this could be used to position an HTML label
     * over a specific point on a nested display object. Returns a Point instance with x and y properties
     * correlating to the transformed coordinates on the stage.
     *
     * @example
     * displayObject.x = 300;
     * displayObject.y = 200;
     * stage.addChild(displayObject);
     * const point = displayObject.localToGlobal(100, 100);
     * // x=400, y=300
     *
     * @param {Number} x The x position in the source display object to transform.
     * @param {Number} y The y position in the source display object to transform.
     * @param {Point|Object} [pt=Point] An object to copy the result into.
     * @return {PointF} A Point instance with x and y properties correlating to the transformed coordinates
     * on the stage.
     */
    DisplayObject.prototype.localToGlobal = function (x, y, pt) {
        if (pt === void 0) { pt = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(); }
        return this.getConcatenatedMatrix(this._props.matrix).transformPoint(x, y, pt);
    };
    /**
     * Transforms the specified x and y position from the global (stage) coordinate space to the
     * coordinate space of the display object. For example, this could be used to determine
     * the current mouse position within the display object. Returns a Point instance with x and y properties
     * correlating to the transformed position in the display object's coordinate space.
     *
     * @example
     * displayObject.x = 300;
     * displayObject.y = 200;
     * stage.addChild(displayObject);
     * const point = displayObject.globalToLocal(100, 100);
     * // x=-200, y=-100
     *
     * @method globalToLocal
     * @param {Number} x The x position on the stage to transform.
     * @param {Number} y The y position on the stage to transform.
     * @param {Point|Object} [pt=Point] An object to copy the result into.
     * @return {Point} A Point instance with x and y properties correlating to the transformed position in the
     * display object's coordinate space.
     */
    DisplayObject.prototype.globalToLocal = function (x, y, pt) {
        if (pt === void 0) { pt = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(); }
        return this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x, y, pt);
    };
    /**
     * Transforms the specified x and y position from the coordinate space of this display object to the coordinate
     * space of the target display object. Returns a Point instance with x and y properties correlating to the
     * transformed position in the target's coordinate space. Effectively the same as using the following code with
     * {@link DisplayObject#localToGlobal} and {@link DisplayObject#globalToLocal}.
     *
     * @example
     * let pt = this.localToGlobal(x, y);
     * pt = target.globalToLocal(pt.x, pt.y);
     *
     * @param {Number} x The x position in the source display object to transform.
     * @param {Number} y The y position on the source display object to transform.
     * @param {DisplayObject} target The target display object to which the coordinates will be transformed.
     * @param {Point|Object} [pt=Point] An object to copy the result into.
     * @return {Point} Returns a Point instance with x and y properties correlating to the transformed position
     * in the target's coordinate space.
     */
    DisplayObject.prototype.localToLocal = function (x, y, target, pt) {
        if (pt === void 0) { pt = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(); }
        pt = this.localToGlobal(x, y, pt);
        return target.globalToLocal(pt.X, pt.Y, pt);
    };
    /**
     * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.
     * Omitted parameters will have the default value set.
     *
     * @example
     * displayObject.setTransform(100, 100, 2, 2);
     *
     * @param {Number|Object} [x=0] The horizontal translation (x position) in pixels
     * @param {Number} [y=0] The vertical translation (y position) in pixels
     * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1
     * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1
     * @param {Number} [rotation=0] The rotation, in degrees
     * @param {Number} [skewX=0] The horizontal skew factor
     * @param {Number} [skewY=0] The vertical skew factor
     * @param {Number} [regX=0] The horizontal registration point in pixels
     * @param {Number} [regY=0] The vertical registration point in pixels
     * @return {DisplayObject} Returns this instance. Useful for chaining commands.
     * @chainable
    */
    DisplayObject.prototype.setTransform = function (xOrParams, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
        if (xOrParams === void 0) { xOrParams = 0; }
        if (y === void 0) { y = 0; }
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (skewX === void 0) { skewX = 0; }
        if (skewY === void 0) { skewY = 0; }
        if (regX === void 0) { regX = 0; }
        if (regY === void 0) { regY = 0; }
        if (typeof xOrParams !== "number") {
            this.set(xOrParams);
        }
        else {
            this.x = xOrParams;
            this.y = y;
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            this.rotation = rotation;
            this.skewX = skewX;
            this.skewY = skewY;
            this.regX = regX;
            this.regY = regY;
        }
        return this;
    };
    /**
     * Returns a matrix based on this object's current transform.
     * @param {Matrix2D} [matrix=Matrix2D] A Matrix2D object to populate with the calculated values. If null, a new
     * Matrix object is returned.
     * @return {Matrix2D} A matrix representing this display object's transform.
     */
    DisplayObject.prototype.getMatrix = function (matrix) {
        if (matrix === void 0) { matrix = new _geom_Matrix2D__WEBPACK_IMPORTED_MODULE_4__.Matrix2D(); }
        var o = this;
        return o.transformMatrix ? matrix.copy(o.transformMatrix) :
            (matrix.identity() && matrix.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY));
    };
    /**
     * Generates a Matrix2D object representing the combined transform of the display object and all of its
     * parent Containers up to the highest level ancestor (usually the {@link Stage}). This can
     * be used to transform positions between coordinate spaces, such as with {@link DisplayObject#localToGlobal}
     * and {@link DisplayObject#globalToLocal}.
     * @param {Matrix2D} [matrix=Matrix2D] A Matrix2D object to populate with the calculated values.
     * If null, a new Matrix2D object is returned.
     * @return {Matrix2D} The combined matrix.
     */
    DisplayObject.prototype.getConcatenatedMatrix = function (matrix) {
        if (matrix === void 0) { matrix = new _geom_Matrix2D__WEBPACK_IMPORTED_MODULE_4__.Matrix2D(); }
        var mtx = this.getMatrix(matrix);
        var o;
        while (o = o.parent) {
            mtx.prependMatrix(o.getMatrix(o._props.matrix));
        }
        return mtx;
    };
    /**
     * Generates a DisplayProps object representing the combined display properties of the  object and all of its
     * parent Containers up to the highest level ancestor (usually the {@link Stage}).
     * @param {DisplayProps} [props=DisplayProps] A DisplayProps object to populate with the calculated values.
     * If null, a new DisplayProps object is returned.
     * @return {DisplayProps} The combined display properties.
     */
    DisplayObject.prototype.getConcatenatedDisplayProps = function (props) {
        if (props === void 0) { props = new _geom_DisplayProps__WEBPACK_IMPORTED_MODULE_5__.DisplayProps(); }
        props = props.identity();
        var o = this;
        var mtx = o.getMatrix(props.matrix);
        do {
            props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);
            // we do this to avoid problems with the matrix being used for both operations when o._props.matrix is passed in as the props param.
            // this could be simplified (ie. just done as part of the prepend above) if we switched to using a pool.
            if (o != this) {
                mtx.prependMatrix(o.getMatrix(o._props.matrix));
            }
        } while (o = o.parent);
        return props;
    };
    /**
     * Tests whether the display object intersects the specified point in local coordinates (ie. draws a pixel with alpha > 0 at
     * the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation of the display object.
     *
     * Please note that shape-to-shape collision is not currently supported by
     *
     * @example
     * stage.addEventListener("stagemousedown", event => {
     *   const didHit = myShape.hitTest(event.stageX, event.stageY);
     * });
     *
     * @param {Number} x The x position to check in the display object's local coordinates.
     * @param {Number} y The y position to check in the display object's local coordinates.
     * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified
     * local Point.
    */
    DisplayObject.prototype.hitTest = function (x, y) {
        var ctx = DisplayObject._hitTestContext;
        ctx.setTransform(1, 0, 0, 1, -x, -y);
        // hit tests occur in a 2D context, so don't attempt to draw a GL only Texture into a 2D context
        this.draw(ctx, !(this.bitmapCache && !(this.bitmapCache._cacheCanvas instanceof WebGLTexture)));
        var hit = this._testHit(ctx);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, 2, 2);
        return hit;
    };
    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     *
     * @example
     * const myGraphics = new Graphics().beginFill("#ff0000").drawCircle(0, 0, 25);
     * const shape = new Shape().set({ graphics: myGraphics, x: 100, y: 100, alpha: 0.5 });
     *
     * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
     * @return {DisplayObject} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
    */
    DisplayObject.prototype.set = function (props) {
        for (var n in props) {
            this[n] = props[n];
        }
        return this;
    };
    /**
     * Returns a rectangle representing this object's bounds in its local coordinate system (ie. with no transformation).
     * Objects that have been cached will return the bounds of the cache.
     *
     * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use
     * {@link DisplayObject#setBounds} so that they are included when calculating Container bounds.
     *
     * <table>
     * 	<tr><td><b>All</b></td><td>
     * 		All display objects support setting bounds manually using setBounds(). Likewise, display objects that
     * 		have been cached using cache() will return the bounds of their cache. Manual and cache bounds will override
     * 		the automatic calculations listed below.
     * 	</td></tr>
     * 	<tr><td><b>Bitmap</b></td><td>
     * 		Returns the width and height of the {{#crossLink "Bitmap/sourceRect"}}{{/crossLink}} (if specified) or image,
     * 		extending from (x=0,y=0).
     * 	</td></tr>
     * 	<tr><td><b>Sprite</b></td><td>
     * 		Returns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified
     * 		in the spritesheet data. See also {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}}
     * 	</td></tr>
     * 	<tr><td><b>Container</b></td><td>
     * 		Returns the aggregate (combined) bounds of all children that return a non-null value from `getBounds()`.
     * 	</td></tr>
     * 	<tr><td><b>Shape</b></td><td>
     * 		Does not currently support automatic bounds calculations. Use `setBounds()` to manually define bounds.
     * 	</td></tr>
     * 	<tr><td><b>Text</b></td><td>
     * 		Returns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height)
     * 		are not, especially when using {{#crossLink "Text/textBaseline:property"}}{{/crossLink}} values other than "top".
     * 	</td></tr>
     * 	<tr><td><b>BitmapText</b></td><td>
     * 		Returns approximate bounds. Values will be more accurate if spritesheet frame registration points are close
     * 		to (x=0,y=0).
     * 	</td></tr>
    * </table>
     *
     * @example <caption>Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and
     * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the
     * bounds explicitly<caption>
     *
     * const bounds = obj.getBounds();
     * obj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
     * // getBounds will now use the set values, instead of recalculating
     *
     * @example <caption>To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
     * values if you need to retain it</caption>
     *
     * const bounds = obj.getBounds().clone();
     * // OR:
     * myRect.copy(obj.getBounds());
     *
     * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this
     * object.
     */
    DisplayObject.prototype.getBounds = function () {
        if (this._bounds) {
            return this._rectangle.copy(this._bounds);
        }
        var cache = this.bitmapCache;
        if (cache && this.cacheCanvas) {
            return cache.getBounds();
        }
        return null;
    };
    /**
     * Returns a rectangle representing this object's bounds in its parent's coordinate system (ie. with transformations applied).
     * Objects that have been cached will return the transformed bounds of the cache.
     *
     * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use
     * {@link DisplayObject#setBounds} so that they are included when calculating Container
     * bounds.
     *
     * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
     * values if you need to retain it.
     *
     * Container instances calculate aggregate bounds for all children that return bounds via getBounds.
     * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.
     */
    DisplayObject.prototype.getTransformedBounds = function () {
        return this._getBounds();
    };
    /**
     * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &
     * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always
     * override calculated bounds.
     *
     * The bounds should be specified in the object's local (untransformed) coordinates. For example, a Shape instance
     * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).
     * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.
     * @param {Number} y The y origin of the bounds.
     * @param {Number} width The width of the bounds.
     * @param {Number} height The height of the bounds.
     */
    DisplayObject.prototype.setBounds = function (x, y, width, height) {
        if (x == null) {
            this._bounds = null;
            return;
        }
        this._bounds = (this._bounds || new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle()).setValues(x, y, width, height);
    };
    /**
     * Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are
     * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements
     * are copied by reference (masks, individual filter instances, hit area)
     * @return {DisplayObject} A clone of the current DisplayObject instance.
     */
    DisplayObject.prototype.clone = function (test) {
        return this._cloneProps(new DisplayObject());
    };
    /**
     * Returns a string representation of this object.
     * @return {String} a string representation of the instance.
     */
    DisplayObject.prototype.toString = function () {
        return "[" + this.constructor.name + " (name=" + this.name + ")]";
    };
    /**
     * Called before the object gets drawn and is a chance to ensure the display state of the object is correct.
     * Mostly used by {@link MovieClip} and {@link BitmapText} to
     * correct their internal state and children prior to being drawn.
     *
     * Is manually called via draw in a {@link Stage} but is automatically called when
     * present in a {@link StageGL} instance.
     *
     * @method _updateState
     * @protected
     */
    DisplayObject.prototype._updateState = function () { };
    /**
     * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject
     * instance copied into.
     * @return {DisplayObject} o
     * @protected
     */
    DisplayObject.prototype._cloneProps = function (o) {
        o.alpha = this.alpha;
        o.mouseEnabled = this.mouseEnabled;
        o.tickEnabled = this.tickEnabled;
        o.name = this.name;
        o.regX = this.regX;
        o.regY = this.regY;
        o.rotation = this.rotation;
        o.scaleX = this.scaleX;
        o.scaleY = this.scaleY;
        o.shadow = this.shadow;
        o.skewX = this.skewX;
        o.skewY = this.skewY;
        o.visible = this.visible;
        o.x = this.x;
        o.y = this.y;
        o.compositeOperation = this.compositeOperation;
        o.snapToPixel = this.snapToPixel;
        o.filters = this.filters == null ? null : this.filters.slice();
        o.mask = this.mask;
        o.hitArea = this.hitArea;
        o.cursor = this.cursor;
        o._bounds = this._bounds;
        o._webGLRenderStyle = this._webGLRenderStyle;
        return o;
    };
    /**
     * @protected
     * @param {CanvasRenderingContext2D} ctx
     * @param {Shadow} shadow
     */
    DisplayObject.prototype._applyShadow = function (ctx, shadow) {
        if (shadow === void 0) { shadow = _Shadow__WEBPACK_IMPORTED_MODULE_3__.Shadow.identity; }
        ctx.shadowColor = shadow.color.toString();
        ctx.shadowOffsetX = shadow.offsetX;
        ctx.shadowOffsetY = shadow.offsetY;
        ctx.shadowBlur = shadow.blur;
    };
    /**
     * @param {Object} evt An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
     * @protected
     */
    DisplayObject.prototype._tick = function (evt) {
        // because tick can be really performance sensitive, check for listeners before calling dispatchEvent.
        var ls = this._listeners;
        if (ls && ls.tick) {
            // reset & reuse the event object to avoid construction / GC costs:
            evt.target = null;
            evt.propagationStopped = evt.immediatePropagationStopped = false;
            this.dispatchEvent(evt);
        }
    };
    /**
     * @protected
     * @param {CanvasRenderingContext2D} ctx
     * @return {Boolean}
     */
    DisplayObject.prototype._testHit = function (ctx) {
        var hit = false;
        try {
            hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;
        }
        catch (e) {
            if (!DisplayObject.suppressCrossDomainErrors) {
                throw "An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.";
            }
        }
        return hit;
    };
    /**
     * @param {Matrix2D} matrix
     * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
     * @return {Rectangle}
     * @protected
     */
    DisplayObject.prototype._getBounds = function (matrix, ignoreTransform) {
        return this._transformBounds(this.getBounds(), matrix, ignoreTransform);
    };
    /**
     * @param {Rectangle} bounds
     * @param {Matrix2D} matrix
     * @param {Boolean} ignoreTransform
     * @return {Rectangle}
     * @protected
     */
    DisplayObject.prototype._transformBounds = function (bounds, matrix, ignoreTransform) {
        if (!bounds) {
            return bounds;
        }
        var x = bounds.X;
        var y = bounds.Y;
        var width = bounds.Width;
        var height = bounds.Height;
        var mtx = ignoreTransform ? this._props.matrix.identity() : this.getMatrix(this._props.matrix);
        if (x || y) {
            mtx.appendTransform(0, 0, 1, 1, 0, 0, 0, -x, -y);
        } // TODO: simplify this.
        if (matrix) {
            mtx.prependMatrix(matrix);
        }
        var x_a = width * mtx.a, x_b = width * mtx.b, y_c = height * mtx.c, y_d = height * mtx.d, tx = mtx.tx, ty = mtx.ty;
        var minX = tx, maxX = tx, minY = ty, maxY = ty;
        if ((x = x_a + tx) < minX) {
            minX = x;
        }
        else if (x > maxX) {
            maxX = x;
        }
        if ((x = x_a + y_c + tx) < minX) {
            minX = x;
        }
        else if (x > maxX) {
            maxX = x;
        }
        if ((x = y_c + tx) < minX) {
            minX = x;
        }
        else if (x > maxX) {
            maxX = x;
        }
        if ((y = x_b + ty) < minY) {
            minY = y;
        }
        else if (y > maxY) {
            maxY = y;
        }
        if ((y = x_b + y_d + ty) < minY) {
            minY = y;
        }
        else if (y > maxY) {
            maxY = y;
        }
        if ((y = y_d + ty) < minY) {
            minY = y;
        }
        else if (y > maxY) {
            maxY = y;
        }
        return bounds.setValues(minX, minY, maxX - minX, maxY - minY);
    };
    /**
     * Indicates whether the display object has any mouse event listeners or a cursor.
     * @return {Boolean}
     * @protected
     */
    DisplayObject.prototype._hasMouseEventListener = function () {
        var evts = DisplayObject._MOUSE_EVENTS;
        for (var i = 0, l = evts.length; i < l; i++) {
            if (this.hasEventListener(evts[i])) {
                return true;
            }
        }
        return !!this.cursor;
    };
    return DisplayObject;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_7__.EventDispatcher));

DisplayObject._MOUSE_EVENTS = ["click", "dblclick", "mousedown", "mouseout", "mouseover", "pressmove", "pressup", "rollout", "rollover"];
DisplayObject.suppressCrossDomainErrors = false;
DisplayObject._snapToPixelEnabled = false;
DisplayObject._StageGL_NONE = 0;
DisplayObject._StageGL_SPRITE = 1;
DisplayObject._StageGL_BITMAP = 2;
var canvas = (0,_utils_Canvas__WEBPACK_IMPORTED_MODULE_6__.createCanvas)();
DisplayObject._hitTestCanvas = canvas;
DisplayObject._hitTestContext = canvas.getContext("2d");
/**
* Dispatched when the user presses their left mouse button over the display object.
* @see {@link MouseEvent}
* @event DisplayObject#mousedown
* @since 0.6.0
*/
/**
* Dispatched when the user presses their left mouse button and then releases it while over the display object.
* @see {@link MouseEvent}
* @event DisplayObject#click
* @since 0.6.0
*/
/**
* Dispatched when the user double clicks their left mouse button over this display object.
* @see {@link MouseEvent}
* @event DisplayObject#dblclick
* @since 0.6.0
*/
/**
* Dispatched when the user's mouse enters this display object. This event must be enabled using
* {@link Stage#enableMouseOver}.
* @see {@link DisplayObject#event:rollover}
* @see {@link MouseEvent}
* @event DisplayObject#mouseover
* @since 0.6.0
*/
/**
* Dispatched when the user's mouse leaves this display object. This event must be enabled using
* {@link Stage#enableMouseOver}.
* @see {@link DisplayObject#event:rollout}
* @see {@link MouseEvent}
* @event DisplayObject#mouseout
* @since 0.6.0
*/
/**
* This event is similar to {@link DisplayObject#event:mouseover}, with the following
* differences: it does not bubble, and it considers {@link Container} instances as an
* aggregate of their content.
*
* For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
* shapeA and then directly on to shapeB. With a listener for {@link DisplayObject#event:mouseover} on
* myContainer, two events would be received, each targeting a child element:
* <ol>
*   <li>when the mouse enters shapeA (target=shapeA)</li>
*   <li>when the mouse enters shapeB (target=shapeB)</li>
* </ol>
* However, with a listener for "rollover" instead, only a single event is received when the mouse first enters
* the aggregate myContainer content (target=myContainer).
*
* This event must be enabled using {@link Stage#enableMouseOver}.
* @see {@link MouseEvent}
* @event DisplayObject#rollover
* @since 0.7.0
*/
/**
* This event is similar to {@link DisplayObject#event:mouseout}, with the following
* differences: it does not bubble, and it considers {@link Container} instances as an
* aggregate of their content.
*
* For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
* shapeA, then directly on to shapeB, then off both. With a listener for {@link DisplayObject#event:mouseout}
* on myContainer, two events would be received, each targeting a child element:<OL>
* <LI>when the mouse leaves shapeA (target=shapeA)</LI>
* <LI>when the mouse leaves shapeB (target=shapeB)</LI>
* </OL>
* However, with a listener for "rollout" instead, only a single event is received when the mouse leaves
* the aggregate myContainer content (target=myContainer).
*
* This event must be enabled using {@link Stage#enableMouseOver}.
* @see {@link MouseEvent}
* @event DisplayObject#rollout
* @since 0.7.0
*/
/**
* After a {@link DisplayObject#event:mousedown} occurs on a display object, a pressmove
* event will be generated on that object whenever the mouse moves until the mouse press is released. This can be
* useful for dragging and similar operations.
* @event DisplayObject#pressmove
* @since 0.7.0
*/
/**
* After a {@link DisplayObject#event:mousedown} occurs on a display object, a pressup event
* will be generated on that object when that mouse press is released. This can be useful for dragging and similar
* operations.
* @event DisplayObject#pressup
* @since 0.7.0
*/
/**
* Dispatched when the display object is added to a parent container.
* @event DisplayObject#added
*/
/**
* Dispatched when the display object is removed from its parent container.
* @event DisplayObject#removed
*/
/**
* Dispatched on each display object on a stage whenever the stage updates. This occurs immediately before the
* rendering (draw) pass. When {@link Stage#update} is called, first all display objects on
* the stage dispatch the tick event, then all of the display objects are drawn to stage. Children will have their
* tick event dispatched in order of their depth prior to the event being dispatched on their parent.
* @event DisplayObject#tick
* @param {Object} target The object that dispatched the event.
* @param {String} type The event type.
* @param {Array} params An array containing any arguments that were passed to the Stage.update() method.
* @since 0.6.0
*/ 


/***/ }),

/***/ "./src/drawing/scene/display/Graphics.ts":
/*!***********************************************!*\
  !*** ./src/drawing/scene/display/Graphics.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Graphics": () => (/* binding */ Graphics)
/* harmony export */ });
/* harmony import */ var _utils_Canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Canvas */ "./src/drawing/scene/utils/Canvas.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a
 * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {@link Graphics#draw}
 * directly, or it can be used with the {@link Shape} object to draw vector graphics within the
 * context of an EaselJS display list.
 *
 * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the "Graphics API"), or
 * instantiating Graphics command objects and adding them to the graphics queue via {@link Graphics#append}.
 * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.
 *
 * <h4>Tiny API</h4>
 * The Graphics class also includes a "tiny API", which is one or two-letter methods that are shortcuts for all of the
 * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS
 * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected
 * descriptions in the docs.
 *
 * <table>
 *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>
 *     <tr><td>mt</td><td>{@link Graphics#moveTo}</td>
 *     <td>lt</td> <td>{@link Graphics#lineTo}</td></tr>
 *     <tr><td>a/at</td><td>{@link Graphics#arc} / {@link Graphics#arcTo}</td>
 *     <td>bt</td><td>{@link Graphics#bezierCurveTo}</td></tr>
 *     <tr><td>qt</td><td>{@link Graphics#quadraticCurveTo} (also curveTo)</td>
 *     <td>r</td><td>{@link Graphics#rect}</td></tr>
 *     <tr><td>cp</td><td>{@link Graphics#closePath}</td>
 *     <td>c</td><td>{@link Graphics#clear}</td></tr>
 *     <tr><td>f</td><td>{@link Graphics#beginFill}</td>
 *     <td>lf</td><td>{@link Graphics#beginLinearGradientFill}</td></tr>
 *     <tr><td>rf</td><td>{@link Graphics#beginRadialGradientFill}</td>
 *     <td>bf</td><td>{@link Graphics#beginBitmapFill}</td></tr>
 *     <tr><td>ef</td><td>{@link Graphics#endFill}</td>
 *     <td>ss / sd</td><td>{@link Graphics#setStrokeStyle} / {@link Graphics#setStrokeDash}</td></tr>
 *     <tr><td>s</td><td>{@link Graphics#beginStroke}</td>
 *     <td>ls</td><td>{@link Graphics#beginLinearGradientStroke}</td></tr>
 *     <tr><td>rs</td><td>{@link Graphics#beginRadialGradientStroke}</td>
 *     <td>bs</td><td>{@link Graphics#beginBitmapStroke}</td></tr>
 *     <tr><td>es</td><td>{@link Graphics#endStroke}</td>
 *     <td>dr</td><td>{@link Graphics#drawRect}</td></tr>
 *     <tr><td>rr</td><td>{@link Graphics#drawRoundRect}</td>
 *     <td>rc</td><td>{@link Graphics#drawRoundRectComplex}</td></tr>
 *     <tr><td>dc</td><td>{@link Graphics#drawCircle}</td>
 *     <td>de</td><td>{@link Graphics#drawEllipse}</td></tr>
 *     <tr><td>dp</td><td>{@link Graphics#drawPolyStar}</td>
 *     <td>p</td><td>{@link Graphics#decodePath}</td></tr>
 * </table>
 *
 * @example
 * var g = new Graphics();
 * g.setStrokeStyle(1);
 * g.beginStroke("#000000");
 * g.beginFill("red");
 * g.drawCircle(0,0,30);
 *
 * @example
 * // All drawing methods in Graphics return the Graphics instance, so they can be chained together.
 * graphics.beginStroke("red").beginFill("blue").drawRect(20, 20, 100, 50);
 *
 * @example
 * // Each graphics API call generates a command object (see below). The last command to be created can be accessed via .command
 * let fillCommand = graphics.beginFill("red").command;
 * fillCommand.style = "blue";
 * // or change it to a bitmap fill:
 * fillCommand.bitmap(img);
 *
 * @example
 * // For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly.
 * // In this case, you need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:
 *
 * // start a new path. Graphics.beginCmd is a reusable BeginPath instance:
 * graphics.append(Graphics.beginCmd);
 * // we need to define the path before applying the fill:
 * let circle = new Graphics.Circle(0,0,30);
 * graphics.append(circle);
 * // fill the path we just defined:
 * let fill = new Graphics.Fill("red");
 * graphics.append(fill);
 *
 * // These approaches can be used together, for example to insert a custom command:
 * graphics.beginFill("red");
 * let customCommand = new CustomSpiralCommand(etc);
 * graphics.append(customCommand);
 * graphics.beginFill("blue");
 * graphics.drawCircle(0, 0, 30);
 *
 * @example <caption>Using the Tiny API</caption>
 * graphics.s("red").f("blue").r(20, 20, 100, 50);
 *
 * @see {@link Graphics#append}
 * @memberof easeljs
 */
var Graphics = /** @class */ (function () {
    function Graphics() {
        this.command = null;
        this._stroke = null;
        this._strokeStyle = null;
        this._oldStrokeStyle = null;
        this._strokeDash = null;
        this._oldStrokeDash = null;
        this._fill = null;
        this._strokeIgnoreScale = false;
        this._commitIndex = 0;
        this._instructions = [];
        this._activeInstructions = [];
        this._dirty = false;
        this._storeIndex = 0;
        this.curveTo = this.quadraticCurveTo;
        this.drawRect = this.rect;
        // tiny api
        this.mt = this.moveTo;
        this.lt = this.lineTo;
        this.at = this.arcTo;
        this.bt = this.bezierCurveTo;
        this.qt = this.quadraticCurveTo;
        this.a = this.arc;
        this.r = this.rect;
        this.cp = this.closePath;
        this.c = this.clear;
        this.f = this.beginFill;
        this.lf = this.beginLinearGradientFill;
        this.rf = this.beginRadialGradientFill;
        this.bf = this.beginBitmapFill;
        this.ef = this.endFill;
        this.ss = this.setStrokeStyle;
        this.sd = this.setStrokeDash;
        this.s = this.beginStroke;
        this.ls = this.beginLinearGradientStroke;
        this.rs = this.beginRadialGradientStroke;
        this.bs = this.beginBitmapStroke;
        this.es = this.endStroke;
        this.dr = this.drawRect;
        this.rr = this.drawRoundRect;
        this.rc = this.drawRoundRectComplex;
        this.dc = this.drawCircle;
        this.de = this.drawEllipse;
        this.dp = this.drawPolyStar;
        this.p = this.decodePath;
        this.clear();
    }
    /**
     * Returns a CSS compatible color string based on the specified RGB numeric color values in the format
     * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".
     * It also supports passing a single hex color value as the first param, and an optional alpha value as the second
     * param.
     *
     * @example
     * Graphics.getRGB(50, 100, 150, 0.5); // rgba(50,100,150,0.5)
     * Graphics.getRGB(0xFF00FF, 0.2); // rgba(255,0,255,0.2)
     *
     * @static
     * @param {Number} r The red component for the color, between 0 and 0xFF (255).
     * @param {Number} g The green component for the color, between 0 and 0xFF (255).
     * @param {Number} b The blue component for the color, between 0 and 0xFF (255).
     * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
     * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format
     * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".
     */
    Graphics.getRGB = function (r, g, b, alpha) {
        if (r != null && b == null) {
            alpha = g;
            b = r & 0xFF;
            g = r >> 8 & 0xFF;
            r = r >> 16 & 0xFF;
        }
        if (alpha == null) {
            return "rgb(" + r + "," + g + "," + b + ")";
        }
        else {
            return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
        }
    };
    /**
     * Returns a CSS compatible color string based on the specified HSL numeric color values in the format "hsla(360,100,100,1.0)",
     * or if alpha is null then in the format "hsl(360,100,100)".
     *
     * @example
     * Graphics.getHSL(150, 100, 70); // hsl(150,100,70)
     *
     * @static
     * @param {Number} hue The hue component for the color, between 0 and 360.
     * @param {Number} saturation The saturation component for the color, between 0 and 100.
     * @param {Number} lightness The lightness component for the color, between 0 and 100.
     * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
     * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format
     * "hsla(360,100,100,1.0)", or if alpha is null then in the format "hsl(360,100,100)".
     */
    Graphics.getHSL = function (hue, saturation, lightness, alpha) {
        if (alpha == null) {
            return "hsl(" + hue % 360 + "," + saturation + "%," + lightness + "%)";
        }
        else {
            return "hsl(" + hue % 360 + "," + saturation + "%," + lightness + "%," + alpha + ")";
        }
    };
    Object.defineProperty(Graphics.prototype, "instructions", {
        /**
         * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)
         * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.
         *
         * This property is mainly intended for introspection of the instructions (ex. for graphics export).
         * @type {Array}
         * @readonly
         */
        get: function () {
            this._updateInstructions();
            return this._instructions;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns true if this Graphics instance has no drawing commands.
     * @return {Boolean} Returns true if this Graphics instance has no drawing commands.
     */
    Graphics.prototype.isEmpty = function () {
        return !(this._instructions.length || this._activeInstructions.length);
    };
    /**
     * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
     * Returns true if the draw was handled (useful for overriding functionality).
     *
     * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
     *
     * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
     * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.
     */
    Graphics.prototype.draw = function (ctx, data) {
        this._updateInstructions();
        var instr = this._instructions;
        var l = instr.length;
        for (var i = this._storeIndex; i < l; i++) {
            instr[i].exec(ctx, data);
        }
    };
    Graphics.prototype.drawTGI = function (tg, data) {
        this._updateInstructions();
        var instr = this._instructions;
        var l = instr.length;
        for (var i = this._storeIndex + 1; i < l; i++) {
            instr[i].exec(tg, data);
        }
    };
    /**
     * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and
     * stroke descriptions. Used for `DisplayObject.mask` to draw the clipping path, for example.
     *
     * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
     *
     * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
     */
    Graphics.prototype.drawAsPath = function (ctx) {
        this._updateInstructions();
        var instr, instrs = this._instructions;
        var l = instrs.length;
        for (var i = this._storeIndex; i < l; i++) {
            // the first command is always a beginPath command.
            if ((instr = instrs[i]).path !== false) {
                instr.exec(ctx);
            }
        }
    };
    /**
     * Moves the drawing point to the specified position.
     * A tiny API method "mt" also exists.
     * @param {Number} x The x coordinate the drawing point should move to.
     * @param {Number} y The y coordinate the drawing point should move to.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
     * @chainable
     */
    Graphics.prototype.moveTo = function (x, y) {
        return this.append(new MoveTo(x, y), true);
    };
    /**
     * Draws a line from the current drawing point to the specified position, which become the new current drawing
     * point. Note that you *must* call {@link Graphics#moveTo} before the first `lineTo()`.
     * A tiny API method "lt" also exists.
     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths) "WHATWG spec"}
     * @param {Number} x The x coordinate the drawing point should draw to.
     * @param {Number} y The y coordinate the drawing point should draw to.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.lineTo = function (x, y) {
        return this.append(new LineTo(x, y));
    };
    /**
 * Draws a line from the current drawing point to the specified position, which become the new current drawing
 * point. Note that you *must* call {@link Graphics#moveTo} before the first `lineTo()`.
 * A tiny API method "lt" also exists.
 * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths) "WHATWG spec"}
 * @param {Number} x The x coordinate the drawing point should draw to.
 * @param {Number} y The y coordinate the drawing point should draw to.
 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
 * @chainable
 */
    Graphics.prototype.drawLine = function (pen, x, y, x1, y1) {
        return this.append(new DrawLine(pen, x, y, x1, y1));
    };
    /**
     * Draws an arc with the specified control points and radius.
     * A tiny API method "at" also exists.
     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto "WHATWG spec"}
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     * @param {Number} radius
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.arcTo = function (x1, y1, x2, y2, radius) {
        return this.append(new ArcTo(x1, y1, x2, y2, radius));
    };
    /**
     * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y).
     * A tiny API method "a" also exists.
     *
     * @example
     * // draw a full circle with a radius of 20 centered at (100, 100)
     * arc(100, 100, 20, 0, Math.PI*2);
     *
     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc "WHATWG spec"}
     * @param {Number} x
     * @param {Number} y
     * @param {Number} radius
     * @param {Number} startAngle Measured in radians.
     * @param {Number} endAngle Measured in radians.
     * @param {Boolean} anticlockwise
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
        return this.append(new Arc(x, y, radius, startAngle, endAngle, anticlockwise));
    };
    /**
     * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy).
     * A tiny API method "qt" also exists.
     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto "WHATWG spec"}
     * @param {Number} cpx
     * @param {Number} cpy
     * @param {Number} x
     * @param {Number} y
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
        return this.append(new QuadraticCurveTo(cpx, cpy, x, y));
    };
    /**
     * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x, cp2y).
     * A tiny API method "bt" also exists.
     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto "WHATWG spec"}
     * @param {Number} cp1x
     * @param {Number} cp1y
     * @param {Number} cp2x
     * @param {Number} cp2y
     * @param {Number} x
     * @param {Number} y
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
        return this.append(new BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));
    };
    /**
     * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.
     * A tiny API method "r" also exists.
     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect "WHATWG spec"}
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w Width of the rectangle
     * @param {Number} h Height of the rectangle
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.rect = function (x, y, w, h) {
        return this.append(new Rect(x, y, w, h));
    };
    /**
     * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified
     * since the fill or stroke was last set.
     * A tiny API method "cp" also exists.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.closePath = function () {
        return this._activeInstructions.length ? this.append(new ClosePath()) : this;
    };
    /**
     * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need
     * to be redefined to draw shapes following a clear call.
     * A tiny API method "c" also exists.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.clear = function () {
        this._instructions.length = this._activeInstructions.length = this._commitIndex = 0;
        this._strokeStyle = this._oldStrokeStyle = this._stroke = this._fill = this._strokeDash = this._oldStrokeDash = null;
        this._dirty = this._strokeIgnoreScale = false;
        return this;
    };
    /**
     * Begins a fill with the specified color. This ends the current sub-path.
     * A tiny API method "f" also exists.
     * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
     * null will result in no fill.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.beginFill = function (color) {
        return this._setFill(color ? new Fill(color) : null);
    };
    /**
     * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1).
     * A tiny API method "lf" also exists.
     *
     * @example <caption>Define a black to white vertical gradient ranging from 20px to 120px, and draw a square to display it</caption>
     * graphics.beginLinearGradientFill(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
     *
     * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
     * drawing from red to blue.
     * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
     * the first color to 10% then interpolating to the second color at 90%.
     * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
     * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
     * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
     * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.beginLinearGradientFill = function (colors, ratios, x0, y0, x1, y1) {
        return this._setFill(new Fill().linearGradient(colors, ratios, x0, y0, x1, y1));
    };
    /**
     * Begins a radial gradient fill. This ends the current sub-path.
     * A tiny API method "rf" also exists.
     *
     * @example <caption>Define a red to blue radial gradient centered at (100, 100), with a radius of 50, and draw a circle to display it</caption>
     * graphics.beginRadialGradientFill(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);
     *
     * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
     * a gradient drawing from red to blue.
     * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
     * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
     * @param {Number} x0 Center position of the inner circle that defines the gradient.
     * @param {Number} y0 Center position of the inner circle that defines the gradient.
     * @param {Number} r0 Radius of the inner circle that defines the gradient.
     * @param {Number} x1 Center position of the outer circle that defines the gradient.
     * @param {Number} y1 Center position of the outer circle that defines the gradient.
     * @param {Number} r1 Radius of the outer circle that defines the gradient.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.beginRadialGradientFill = function (colors, ratios, x0, y0, r0, x1, y1, r1) {
        return this._setFill(new Fill().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
    };
    /**
     * Begins a pattern fill using the specified image. This ends the current sub-path.
     * A tiny API method "bf" also exists.
     * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
     * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
     * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
     * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
     * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
     * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
     * will be applied relative to the parent transform.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.beginBitmapFill = function (image, repetition, matrix) {
        return this._setFill(new Fill(null, matrix).bitmap(image, repetition));
    };
    /**
     * Ends the current sub-path, and begins a new one with no fill. Functionally identical to `beginFill(null)`.
     * A tiny API method "ef" also exists.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.endFill = function () {
        return this.beginFill();
    };
    /**
     * Sets the stroke style.
     * A tiny API method "ss" also exists.
     *
     * @example
     * graphics.setStrokeStyle(8,"round").beginStroke("#F00");
     *
     * @param {Number} thickness The width of the stroke.
     * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
     * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
     * the tiny API.
     * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
     * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
     * for use with the tiny API.
     * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
     * controls at what point a mitered joint will be clipped.
     * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
     * of active transformations.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.setStrokeStyle = function (thickness, caps, joints, miterLimit, ignoreScale) {
        if (caps === void 0) { caps = 0; }
        if (joints === void 0) { joints = 0; }
        if (miterLimit === void 0) { miterLimit = 10; }
        if (ignoreScale === void 0) { ignoreScale = false; }
        this._updateInstructions(true);
        this._strokeStyle = this.command = new StrokeStyle(thickness, caps, joints, miterLimit, ignoreScale);
        // ignoreScale lives on Stroke, not StrokeStyle, so we do a little trickery:
        if (this._stroke) {
            this._stroke.ignoreScale = ignoreScale;
        }
        this._strokeIgnoreScale = ignoreScale;
        return this;
    };
    /**
     * Sets or clears the stroke dash pattern.
     * A tiny API method `sd` also exists.
     *
     * @example
     * graphics.setStrokeDash([20, 10], 0);
     *
     * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
     * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.
     * Passing null or an empty array will clear the existing stroke dash.
     * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.setStrokeDash = function (segments, offset) {
        if (offset === void 0) { offset = 0; }
        this._updateInstructions(true);
        this._strokeDash = this.command = new StrokeDash(segments, offset);
        return this;
    };
    /**
     * Begins a stroke with the specified color. This ends the current sub-path.
     * A tiny API method "s" also exists.
     *
     * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
     * null will result in no stroke.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.beginStroke = function (color) {
        return this._setStroke(color ? new Stroke(color) : null);
    };
    /**
     * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path.
     * A tiny API method "ls" also exists.
     *
     * @example <caption>Define a black to white vertical gradient ranging from 20px to 120px, and draw a square to display it</caption>
     * graphics.setStrokeStyle(10)
     *   .beginLinearGradientStroke(["#000","#FFF"], [0, 1], 0, 20, 0, 120)
     *   .drawRect(20, 20, 120, 120);
     *
     * @param {Array<String>} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
     * a gradient drawing from red to blue.
     * @param {Array<Number>} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
     * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
     * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
     * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
     * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
     * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.beginLinearGradientStroke = function (colors, ratios, x0, y0, x1, y1) {
        return this._setStroke(new Stroke().linearGradient(colors, ratios, x0, y0, x1, y1));
    };
    /**
     * Begins a radial gradient stroke. This ends the current sub-path.
     * A tiny API method "rs" also exists.
     *
     * @example <caption>Define a red to blue radial gradient centered at (100, 100), with a radius of 50, and draw a rectangle to display it</caption>
     * graphics.setStrokeStyle(10)
     *   .beginRadialGradientStroke(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50)
     *   .drawRect(50, 90, 150, 110);
     *
     * @param {Array<String>} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
     * a gradient drawing from red to blue.
     * @param {Array<Number>} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
     * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
     * to 100%.
     * @param {Number} x0 Center position of the inner circle that defines the gradient.
     * @param {Number} y0 Center position of the inner circle that defines the gradient.
     * @param {Number} r0 Radius of the inner circle that defines the gradient.
     * @param {Number} x1 Center position of the outer circle that defines the gradient.
     * @param {Number} y1 Center position of the outer circle that defines the gradient.
     * @param {Number} r1 Radius of the outer circle that defines the gradient.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.beginRadialGradientStroke = function (colors, ratios, x0, y0, r0, x1, y1, r1) {
        return this._setStroke(new Stroke().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
    };
    /**
     * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,
     * strokes do not currently support a matrix parameter due to limitations in the canvas API.
     * A tiny API method "bs" also exists.
     *
     * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
     * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
     * @param {String} [repetition="repeat"] Indicates whether to repeat the image in the fill area. One of
     * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.beginBitmapStroke = function (image, repetition) {
        if (repetition === void 0) { repetition = "repeat"; }
        // NOTE: matrix is not supported for stroke because transforms on strokes also affect the drawn stroke width.
        return this._setStroke(new Stroke().bitmap(image, repetition));
    };
    /**
     * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to `beginStroke(null)`.
     * A tiny API method "es" also exists.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.endStroke = function () {
        return this.beginStroke();
    };
    /**
     * Draws a rounded rectangle with all corners with the specified radius.
     * @param {Number} x
     * @param {Number} y
     * @param {Number} w
     * @param {Number} h
     * @param {Number} radius Corner radius.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.drawRoundRect = function (x, y, w, h, radius) {
        return this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);
    };
    /**
     * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii.
     * A tiny API method "rc" also exists.
     * @param {Number} x The horizontal coordinate to draw the round rect.
     * @param {Number} y The vertical coordinate to draw the round rect.
     * @param {Number} w The width of the round rect.
     * @param {Number} h The height of the round rect.
     * @param {Number} radiusTL Top left corner radius.
     * @param {Number} radiusTR Top right corner radius.
     * @param {Number} radiusBR Bottom right corner radius.
     * @param {Number} radiusBL Bottom left corner radius.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.drawRoundRectComplex = function (x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
        return this.append(new RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL));
    };
    /**
     * Draws a circle with the specified radius at (x, y).
     * A tiny API method "dc" also exists.
     *
     * @example
     * let g = new Graphics();
     * g.setStrokeStyle(1);
     * g.beginStroke(Graphics.getRGB(0,0,0));
     * g.beginFill(Graphics.getRGB(255,0,0));
     * g.drawCircle(0,0,3);
     * let s = new Shape(g);
     * s.x = 100;
     * s.y = 100;
     * stage.addChild(s);
     * stage.update();
     *
     * @param {Number} x x coordinate center point of circle.
     * @param {Number} y y coordinate center point of circle.
     * @param {Number} radius Radius of circle.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.drawCircle = function (x, y, radius) {
        return this.append(new Circle(x, y, radius));
    };
    /**
     * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {@link easels.Graphics#drawCircle},
     * except the width and height can be different.
     * A tiny API method "de" also exists.
     * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {@link easels.Graphics#drawCircle}
     * which draws from center.
     * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {@link easels.Graphics#drawCircle}
     * which draws from the center.
     * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
     * number.
     * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.drawEllipse = function (pen, x, y, w, h) {
        return this.append(new Ellipse(pen, x, y, w, h));
    };
    /**
     * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {@link easels.Graphics#drawCircle},
     * except the width and height can be different.
     * A tiny API method "de" also exists.
     * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {@link easels.Graphics#drawCircle}
     * which draws from center.
     * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {@link easels.Graphics#drawCircle}
     * which draws from the center.
     * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
     * number.
     * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.fillEllipse = function (brush, x, y, w, h) {
        return this.append(new FillEllipse(brush, x, y, w, h));
    };
    /**
     * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of points.
     * A tiny API method "dp" also exists.
     *
     * @example <caption>Draw a 5 pointed star shape centered at 100, 100 and with a radius of 50</caption>
     * graphics.beginFill("#FF0").drawPolyStar(100, 100, 50, 5, 0.6, -90);
     * // Note: -90 makes the first point vertical
     *
     * @param {Number} x Position of the center of the shape.
     * @param {Number} y Position of the center of the shape.
     * @param {Number} radius The outer radius of the shape.
     * @param {Number} sides The number of points on the star or sides on the polygon.
     * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
     * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
     * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
     * directly to the right of the center.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.drawPolyStar = function (x, y, radius, sides, pointSize, angle) {
        return this.append(new PolyStar(x, y, radius, sides, pointSize, angle));
    };
    /**
     * Appends a graphics command object to the graphics queue. Command objects expose an "exec" method
     * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into
     * {@link Graphics#draw}. The latter will usually be the Shape instance that called draw.
     *
     * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert
     * built-in or custom graphics commands.
     *
     * @example
     * // attach data to our shape, so we can access it during the draw:
     * shape.color = "red";
     *
     * // append a Circle command object:
     * shape.graphics.append(new Graphics.Circle(50, 50, 30));
     *
     * // append a custom command object with an exec method that sets the fill style
     * // based on the shape's data, and then fills the circle.
     * shape.graphics.append({
     *   exec: (ctx, shape) => {
     *     ctx.fillStyle = shape.color;
     *     ctx.fill();
     *   }
     * });
     *
     * @param {Object} command A graphics command object exposing an "exec" method.
     * @param {Boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.append = function (command, clean) {
        this._activeInstructions.push(command);
        this.command = command;
        if (!clean) {
            this._dirty = true;
        }
        return this;
    };
    /**
     * Decodes a compact encoded path string into a series of draw instructions.
     * This format is not intended to be human readable, and is meant for use by authoring tools.
     * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw
     * commands.
     *
     * Each command is comprised of a single "header" character followed by a variable number of alternating x and y
     * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the
     * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4
     * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the
     * latter. Bits 5 and 6 are currently unused.
     *
     * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)
     * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the
     * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed
     * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the
     * case of move operations which are absolute, this value is a delta from the previous x or y position (as
     * appropriate).
     *
     * For example, the string "A3cAAMAu4AAA" represents a line starting at -150,0 and ending at 150,0.
     * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per
     * parameter.
     * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits
     * indicate 1500 tenths of a pixel.
     * <br />AA - 000000000000. Absolute y position of 0.
     * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.
     * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to
     * provide an absolute position of +150.0px.
     * <br />AAA - 000000000000000000. A y delta value of 0.
     *
     * A tiny API method "p" also exists.
     *
     * @param {String} str The path string to decode.
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.decodePath = function (str) {
        var instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo, this.closePath];
        var paramCount = [2, 2, 4, 6, 0];
        var i = 0;
        var l = str.length;
        var params = [];
        var x = 0, y = 0;
        var base64 = Graphics._BASE_64;
        while (i < l) {
            var c = str.charAt(i);
            var n = base64[c];
            var fi = n >> 3; // highest order bits 1-3 code for operation.
            var f = instructions[fi];
            // check that we have a valid instruction & that the unused bits are empty:
            if (!f || (n & 3)) {
                throw "Bad path data (@" + i + "):c";
            }
            var pl = paramCount[fi];
            if (!fi) {
                x = y = 0;
            } // move operations reset the position.
            params.length = 0;
            i++;
            var charCount = (n >> 2 & 1) + 2; // 4th header bit indicates number size for this operation.
            for (var p = 0; p < pl; p++) {
                var num = base64[str.charAt(i)];
                var sign = (num >> 5) ? -1 : 1;
                num = ((num & 31) << 6) | (base64[str.charAt(i + 1)]);
                if (charCount === 3) {
                    num = (num << 6) | (base64[str.charAt(i + 2)]);
                }
                num = sign * num / 10;
                if (p % 2) {
                    x = (num += x);
                }
                else {
                    y = (num += y);
                }
                params[p] = num;
                i += charCount;
            }
            f.apply(this, params);
        }
        return this;
    };
    /**
     * Stores all graphics commands so they won't be executed in future draws. Calling store() a second time adds to
     * the existing store. This also affects `drawAsPath()`.
     *
     * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so
     * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all
     * of the vector instructions for later use (ex. scaling, modifying, or exporting).
     *
     * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing
     * the fill or stroke.
     *
     * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of
     * segments) are added to a Shape, it can be rasterized using {@link DisplayObject#updateCache},
     * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVGraphics.
     *
     * @example
     * // set up cache:
     * shape.cache(0,0,500,500,scale);
     *
     * // when the user drags, draw a new line:
     * shape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);
     * // then draw it into the existing cache:
     * shape.updateCache("source-over");
     * // store the new line, so it isn't redrawn next time:
     * shape.store();
     *
     * // then, when the window resizes, we can re-render at a different scale:
     * // first, unstore all our lines:
     * shape.unstore();
     * // then cache using the new scale:
     * shape.cache(0,0,500,500,newScale);
     * // finally, store the existing commands again:
     * shape.store();
     *
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.store = function () {
        this._updateInstructions(true);
        this._storeIndex = this._instructions.length;
        return this;
    };
    /**
     * Unstores any graphics commands that were previously stored using {@link Graphics#store}
     * so that they will be executed in subsequent draw calls.
     *
     * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    Graphics.prototype.unstore = function () {
        this._storeIndex = 0;
        return this;
    };
    /**
     * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.
     * @return {Graphics} A clone of the current Graphics instance.
     */
    Graphics.prototype.clone = function () {
        var o = new Graphics();
        o.command = this.command;
        o._stroke = this._stroke;
        o._strokeStyle = this._strokeStyle;
        o._strokeDash = this._strokeDash;
        o._strokeIgnoreScale = this._strokeIgnoreScale;
        o._fill = this._fill;
        o._instructions = this._instructions.slice();
        o._commitIndex = this._commitIndex;
        o._activeInstructions = this._activeInstructions.slice();
        o._dirty = this._dirty;
        o._storeIndex = this._storeIndex;
        return o;
    };
    /**
     * Returns a string representation of this object.
     * @return {String} a string representation of the instance.
     */
    Graphics.prototype.toString = function () {
        return "[" + this.constructor.name + "]";
    };
    /**
     * @param {Boolean} commit
     * @protected
     */
    Graphics.prototype._updateInstructions = function (commit) {
        var instr = this._instructions, active = this._activeInstructions, commitIndex = this._commitIndex;
        if (this._dirty && active.length) {
            instr.length = commitIndex; // remove old, uncommitted commands
            instr.push(Graphics.beginCmd);
            var l = active.length, ll = instr.length;
            instr.length = ll + l;
            for (var i = 0; i < l; i++) {
                instr[i + ll] = active[i];
            }
            if (this._fill) {
                instr.push(this._fill);
            }
            if (this._stroke) {
                // doesn't need to be re-applied if it hasn't changed.
                if (this._strokeDash !== this._oldStrokeDash) {
                    instr.push(this._strokeDash);
                }
                if (this._strokeStyle !== this._oldStrokeStyle) {
                    instr.push(this._strokeStyle);
                }
                if (commit) {
                    this._oldStrokeDash = this._strokeDash;
                    this._oldStrokeStyle = this._strokeStyle;
                }
                instr.push(this._stroke);
            }
            this._dirty = false;
        }
        if (commit) {
            active.length = 0;
            this._commitIndex = instr.length;
        }
    };
    /**
     * @param {Graphics.Fill} fill
     * @protected
     */
    Graphics.prototype._setFill = function (fill) {
        this._updateInstructions(true);
        this.command = this._fill = fill;
        return this;
    };
    /**
     * @param {Graphics.Stroke} stroke
     * @protected
     */
    Graphics.prototype._setStroke = function (stroke) {
        this._updateInstructions(true);
        if (this.command = this._stroke = stroke) {
            stroke.ignoreScale = this._strokeIgnoreScale;
        }
        return this;
    };
    Object.defineProperty(Graphics, "LineTo", {
        get: function () { return LineTo; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "MoveTo", {
        get: function () { return MoveTo; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "ArcTo", {
        get: function () { return ArcTo; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "Arc", {
        get: function () { return Arc; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "QuadraticCurveTo", {
        get: function () { return QuadraticCurveTo; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "BezierCurveTo", {
        get: function () { return BezierCurveTo; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "Rect", {
        get: function () { return Rect; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "ClosePath", {
        get: function () { return ClosePath; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "BeginPath", {
        get: function () { return BeginPath; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "Fill", {
        get: function () { return Fill; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "Stroke", {
        get: function () { return Stroke; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "StrokeStyle", {
        get: function () { return StrokeStyle; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "StrokeDash", {
        get: function () { return StrokeDash; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "RoundRect", {
        get: function () { return RoundRect; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "Circle", {
        get: function () { return Circle; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "Ellipse", {
        get: function () { return Ellipse; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphics, "PolyStar", {
        get: function () { return PolyStar; },
        enumerable: false,
        configurable: true
    });
    return Graphics;
}());

/**
 * @see {@link Graphics#lineTo}
 * @alias Graphics.LineTo
 * @param {Number} x
 * @param {Number} y
 */
var LineTo = /** @class */ (function () {
    function LineTo(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    LineTo.prototype.exec = function (ctx) {
        ctx.lineTo(this.x, this.y);
    };
    return LineTo;
}());
var DrawMethod = /** @class */ (function () {
    function DrawMethod(pen) {
        this.pen = pen;
    }
    return DrawMethod;
}());
/**
 * @see {@link Graphics#lineTo}
 * @alias Graphics.DrawLine
 * @param {Number} x
 * @param {Number} y
 */
var DrawLine = /** @class */ (function (_super) {
    __extends(DrawLine, _super);
    function DrawLine(pen, x, y, x1, y1) {
        var _this = _super.call(this, pen) || this;
        _this.x = x;
        _this.y = y;
        _this.x1 = x1;
        _this.y1 = y1;
        return _this;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    DrawLine.prototype.exec = function (tgi) {
        tgi.DrawLine(this.pen, this.x, this.y, this.x1, this.y1);
    };
    return DrawLine;
}(DrawMethod));
/**
 * @see {@link Graphics#moveTo}
 * @alias Graphics.MoveTo
 * @param {Number} x
 * @param {Number} y
 */
var MoveTo = /** @class */ (function () {
    function MoveTo(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * @param {CanvasRenderingContext2D} ctx
     */
    MoveTo.prototype.exec = function (ctx) {
        ctx.moveTo(this.x, this.y);
    };
    return MoveTo;
}());
/**
 * @see {@link Graphics#arcTo}
 * @alias Graphics.ArcTo
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} x2
 * @param {Number} y2
 * @param {Number} radius
 */
var ArcTo = /** @class */ (function () {
    function ArcTo(x1, y1, x2, y2, radius) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.radius = radius;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    ArcTo.prototype.exec = function (ctx) {
        ctx.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);
    };
    return ArcTo;
}());
/**
 * @see {@link Graphics#arc}
 * @alias Graphics.Arc
 * @param {Number} x
 * @param {Number} y
 * @param {Number} radius
 * @param {Number} startAngle
 * @param {Number} endAngle
 * @param {Boolean} [anticlockwise=false]
 */
var Arc = /** @class */ (function () {
    function Arc(x, y, radius, startAngle, endAngle, anticlockwise) {
        if (anticlockwise === void 0) { anticlockwise = false; }
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.startAngle = startAngle;
        this.endAngle = endAngle;
        this.anticlockwise = anticlockwise;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    Arc.prototype.exec = function (ctx) {
        ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
    };
    return Arc;
}());
/**
 * @see {@link Graphics#quadraticCurveTo}
 * @alias Graphics.QuadraticCurveTo
 * @param {Number} cpx
 * @param {Number} cpy
 * @param {Number} x
 * @param {Number} y
 */
var QuadraticCurveTo = /** @class */ (function () {
    function QuadraticCurveTo(cpx, cpy, x, y) {
        this.cpx = cpx;
        this.cpy = cpy;
        this.x = x;
        this.y = y;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    QuadraticCurveTo.prototype.exec = function (ctx) {
        ctx.quadraticCurveTo(this.cpx, this.cpy, this.x, this.y);
    };
    return QuadraticCurveTo;
}());
/**
 * @see {@link Graphics#bezierCurveTo}
 * @alias Graphics.BezierCurveTo
 * @param {Number} cp1x
 * @param {Number} cp1y
 * @param {Number} cp2x
 * @param {Number} cp2y
 * @param {Number} x
 * @param {Number} y
 */
var BezierCurveTo = /** @class */ (function () {
    function BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.cp1x = cp1x;
        this.cp1y = cp1y;
        this.cp2x = cp2x;
        this.cp2y = cp2y;
        this.x = x;
        this.y = y;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    BezierCurveTo.prototype.exec = function (ctx) {
        ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x, this.y);
    };
    return BezierCurveTo;
}());
/**
 * @see {@link Graphics#rect}
 * @alias Graphics.Rect
 * @param {Number} x
 * @param {Number} y
 * @param {Number} w
 * @param {Number} h
 */
var Rect = /** @class */ (function () {
    function Rect(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    Rect.prototype.exec = function (ctx) {
        ctx.rect(this.x, this.y, this.w, this.h);
    };
    return Rect;
}());
/**
 * @see {@link Graphics#closePath}
 * @alias Graphics.ClosePath
 */
var ClosePath = /** @class */ (function () {
    function ClosePath() {
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    ClosePath.prototype.exec = function (ctx) {
        ctx.closePath();
    };
    return ClosePath;
}());
/**
 * @see {@link Graphics#beginPath}
 * @alias Graphics.BeginPath
 */
var BeginPath = /** @class */ (function () {
    function BeginPath() {
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    BeginPath.prototype.exec = function (ctx) {
        ctx.beginPath();
    };
    return BeginPath;
}());
/**
 * @see {@link Graphics#beginFill}
 * @alias Graphics.Fill
 * @param {Object} style A valid Context2D fillStyle.
 * @param {Matrix2D} matrix
 */
var Fill = /** @class */ (function () {
    function Fill(style, matrix) {
        this.style = style;
        this.matrix = matrix;
        this.path = false;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    Fill.prototype.exec = function (ctx) {
        if (!this.style) {
            return;
        }
        ctx.fillStyle = this.style;
        var mtx = this.matrix;
        if (mtx) {
            ctx.save();
            ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
        }
        ctx.fill();
        if (mtx) {
            ctx.restore();
        }
    };
    /**
     * Creates a linear gradient style and assigns it to {@link Graphics.Fill#style}.
     * @see {@link Graphics#beginLinearGradientFill}
     * @param {Array<String>} colors
     * @param {Array<Number>} ratios
     * @param {Number} x0
     * @param {Number} y0
     * @param {Number} x1
     * @param {Number} y1
     * @return {Graphics.Fill} Returns this Fill object for chaining or assignment.
     */
    Fill.prototype.linearGradient = function (colors, ratios, x0, y0, x1, y1) {
        var o = this.style = Graphics._ctx.createLinearGradient(x0, y0, x1, y1);
        var l = colors.length;
        for (var i = 0; i < l; i++) {
            o.addColorStop(ratios[i], colors[i]);
        }
        o.props = { colors: colors, ratios: ratios, x0: x0, y0: y0, x1: x1, y1: y1, type: "linear" };
        return this;
    };
    /**
     * Creates a linear gradient style and assigns it to {@link Graphics.Fill#style}.
     * @see {@link Graphics#beginRadialGradientFill}
     * @param {Array<String>} colors
     * @param {Array<Number>} ratios
     * @param {Number} x0
     * @param {Number} y0
     * @param {Number} r0
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} r1
     * @return {Graphics.Fill} Returns this Fill object for chaining or assignment.
     */
    Fill.prototype.radialGradient = function (colors, ratios, x0, y0, r0, x1, y1, r1) {
        var o = this.style = Graphics._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
        var l = colors.length;
        for (var i = 0; i < l; i++) {
            o.addColorStop(ratios[i], colors[i]);
        }
        o.props = { colors: colors, ratios: ratios, x0: x0, y0: y0, r0: r0, x1: x1, y1: y1, r1: r1, type: "radial" };
        return this;
    };
    /**
     * Creates a linear gradient style and assigns it to {@link Graphics.Fill#style}.
     * @see {@link Graphics#beginBitmapFill}
     * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.
     * @param {String} [repetition=""] One of: repeat, repeat-x, repeat-y, or no-repeat.
     * @return {Graphics.Fill} Returns this Fill object for chaining or assignment.
     */
    Fill.prototype.bitmap = function (image, repetition) {
        if (repetition === void 0) { repetition = ""; }
        if (image.naturalWidth || image.getContext || image.readyState >= 2) {
            var o = this.style = Graphics._ctx.createPattern(image, repetition);
            o.props = { image: image, repetition: repetition, type: "bitmap" };
        }
        return this;
    };
    return Fill;
}());
/**
 * @see {@link Graphics#beginStroke}
 * @alias Graphics.Stroke
 * @extends Graphics.Fill
 * @param {Object} style A valid Context2D fillStyle.
 * @param {Boolean} ignoreScale
 */
var Stroke = /** @class */ (function (_super) {
    __extends(Stroke, _super);
    function Stroke(style, ignoreScale) {
        var _this = _super.call(this) || this;
        _this.style = style;
        _this.ignoreScale = ignoreScale;
        _this.path = false;
        return _this;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @override
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    Stroke.prototype.exec = function (ctx) {
        if (!this.style) {
            return;
        }
        ctx.strokeStyle = this.style;
        if (this.ignoreScale) {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        ctx.stroke();
        if (this.ignoreScale) {
            ctx.restore();
        }
    };
    return Stroke;
}(Fill));
/**
 * @see {@link Graphics#setStrokeStyle}
 * @alias Graphics.StrokeStyle
 * @param {Number} [width=1]
 * @param {String} [caps=butt]
 * @param {String} [joints=miter]
 * @param {Number} [miterLimit=10]
 * @param {Boolean} [ignoreScale=false]
 */
var StrokeStyle = /** @class */ (function () {
    function StrokeStyle(width, caps, joints, miterLimit, ignoreScale) {
        if (width === void 0) { width = 1; }
        if (caps === void 0) { caps = "butt"; }
        if (joints === void 0) { joints = "miter"; }
        if (miterLimit === void 0) { miterLimit = 10; }
        if (ignoreScale === void 0) { ignoreScale = false; }
        this.width = width;
        this.caps = caps;
        this.joints = joints;
        this.miterLimit = miterLimit;
        this.ignoreScale = ignoreScale;
        this.path = false;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    StrokeStyle.prototype.exec = function (ctx) {
        ctx.lineWidth = this.width;
        ctx.lineCap = (isNaN(this.caps) ? this.caps : Graphics._STROKE_CAPS_MAP[this.caps]);
        ctx.lineJoin = (isNaN(this.joints) ? this.joints : Graphics._STROKE_JOINTS_MAP[this.joints]);
        ctx.miterLimit = this.miterLimit;
        ctx.ignoreScale = this.ignoreScale;
    };
    return StrokeStyle;
}());
/**
 * @see {@link Graphics#setStrokeDash}
 * @alias Graphics.StrokeDash
 * @param {Array} [segments=[]]
 * @param {Number} [offset=0]
 */
var StrokeDash = /** @class */ (function () {
    function StrokeDash(segments, offset) {
        if (segments === void 0) { segments = []; }
        if (offset === void 0) { offset = 0; }
        this.segments = segments;
        this.offset = offset;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    StrokeDash.prototype.exec = function (ctx) {
        if (ctx.setLineDash) { // feature detection.
            ctx.setLineDash(this.segments);
            ctx.lineDashOffset = this.offset;
        }
    };
    return StrokeDash;
}());
/**
 * @see {@link Graphics#drawRoundRectComplex}
 * @alias Graphics.RoundRect
 * @param {Number} x
 * @param {Number} y
 * @param {Number} w
 * @param {Number} h
 * @param {Number} radiusTL
 * @param {Number} radiusTR
 * @param {Number} radiusBR
 * @param {Number} radiusBL
 */
var RoundRect = /** @class */ (function () {
    function RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.radiusTL = radiusTL;
        this.radiusTR = radiusTR;
        this.radiusBR = radiusBR;
        this.radiusBL = radiusBL;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    RoundRect.prototype.exec = function (ctx) {
        var max = (this.w < this.h ? this.w : this.h) / 2;
        var mTL = 0, mTR = 0, mBR = 0, mBL = 0;
        var x = this.x, y = this.y, w = this.w, h = this.h;
        var rTL = this.radiusTL, rTR = this.radiusTR, rBR = this.radiusBR, rBL = this.radiusBL;
        if (rTL < 0) {
            rTL *= (mTL = -1);
        }
        if (rTL > max) {
            rTL = max;
        }
        if (rTR < 0) {
            rTR *= (mTR = -1);
        }
        if (rTR > max) {
            rTR = max;
        }
        if (rBR < 0) {
            rBR *= (mBR = -1);
        }
        if (rBR > max) {
            rBR = max;
        }
        if (rBL < 0) {
            rBL *= (mBL = -1);
        }
        if (rBL > max) {
            rBL = max;
        }
        ctx.moveTo(x + w - rTR, y);
        ctx.arcTo(x + w + rTR * mTR, y - rTR * mTR, x + w, y + rTR, rTR);
        ctx.lineTo(x + w, y + h - rBR);
        ctx.arcTo(x + w + rBR * mBR, y + h + rBR * mBR, x + w - rBR, y + h, rBR);
        ctx.lineTo(x + rBL, y + h);
        ctx.arcTo(x - rBL * mBL, y + h + rBL * mBL, x, y + h - rBL, rBL);
        ctx.lineTo(x, y + rTL);
        ctx.arcTo(x - rTL * mTL, y - rTL * mTL, x + rTL, y, rTL);
        ctx.closePath();
    };
    return RoundRect;
}());
/**
 * @see {@link Graphics#drawCircle}
 * @alias Graphics.Circle
 * @param {Number} x
 * @param {Number} y
 * @param {Number} radius
 */
var Circle = /** @class */ (function () {
    function Circle(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    Circle.prototype.exec = function (ctx) {
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    };
    return Circle;
}());
/**
 * @see {@link Graphics#drawEllipse}
 * @alias Graphics.Ellipse
 * @param {Number} x
 * @param {Number} y
 * @param {Number} w
 * @param {Number} h
 */
var Ellipse = /** @class */ (function () {
    function Ellipse(pen, x, y, w, h) {
        this.pen = pen;
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    Ellipse.prototype.exec = function (ctx) {
        if (ctx instanceof CanvasRenderingContext2D) {
            var x = this.x, y = this.y;
            var w = this.w, h = this.h;
            var k = 0.5522848;
            var ox = (w / 2) * k;
            var oy = (h / 2) * k;
            var xe = x + w;
            var ye = y + h;
            var xm = x + w / 2;
            var ym = y + h / 2;
            ctx.moveTo(x, ym);
            ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
        }
        else {
            var tg = ctx;
            tg.DrawEllipse(this.pen, this.x, this.y, this.w, this.h);
        }
    };
    return Ellipse;
}());
/**
 * @see {@link Graphics#drawEllipse}
 * @alias Graphics.FillEllipse
 * @param {Number} x
 * @param {Number} y
 * @param {Number} w
 * @param {Number} h
 */
var FillEllipse = /** @class */ (function () {
    function FillEllipse(brush, x, y, w, h) {
        this.brush = brush;
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    FillEllipse.prototype.exec = function (ctx) {
        if (ctx instanceof CanvasRenderingContext2D) {
        }
        else {
            var tg = ctx;
            tg.FillEllipse(this.brush, this.x, this.y, this.w, this.h);
        }
    };
    return FillEllipse;
}());
/**
 *  @see {@link Graphics#drawPolyStar}
 * @alias Graphics.PolyStar
 * @param {Number} x
 * @param {Number} y
 * @param {Number} radius
 * @param {Number} sides
 * @param {Number} [pointSize=0]
 * @param {Number} [angle=0]
 */
var PolyStar = /** @class */ (function () {
    function PolyStar(x, y, radius, sides, pointSize, angle) {
        if (pointSize === void 0) { pointSize = 0; }
        if (angle === void 0) { angle = 0; }
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.sides = sides;
        this.pointSize = pointSize;
        this.angle = angle;
    }
    /**
     * Execute the Graphics command in the provided Canvas context.
     * @param {CanvasRenderingContext2D} ctx The canvas rendering context
     */
    PolyStar.prototype.exec = function (ctx) {
        var x = this.x, y = this.y;
        var radius = this.radius;
        var angle = this.angle / 180 * Math.PI;
        var sides = this.sides;
        var ps = 1 - this.pointSize;
        var a = Math.PI / sides;
        ctx.moveTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
        for (var i = 0; i < sides; i++) {
            angle += a;
            if (ps != 1) {
                ctx.lineTo(x + Math.cos(angle) * radius * ps, y + Math.sin(angle) * radius * ps);
            }
            angle += a;
            ctx.lineTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
        }
        ctx.closePath();
    };
    return PolyStar;
}());
/**
 * A reusable instance of {@link Graphics.BeginPath} to avoid unnecessary instantiation.
 * @static
 * @readonly
 * @type {Graphics.BeginPath}
 */
Graphics.beginCmd = new BeginPath();
/**
 * Map of Base64 characters to values. Used by {@link Graphics#decodePath}.
 * @static
 * @readonly
 * @protected
 * @type {Object}
 */
Graphics._BASE_64 = { "A": 0, "B": 1, "C": 2, "D": 3, "E": 4, "F": 5, "G": 6, "H": 7, "I": 8, "J": 9, "K": 10, "L": 11, "M": 12, "N": 13, "O": 14, "P": 15, "Q": 16, "R": 17, "S": 18, "T": 19, "U": 20, "V": 21, "W": 22, "X": 23, "Y": 24, "Z": 25, "a": 26, "b": 27, "c": 28, "d": 29, "e": 30, "f": 31, "g": 32, "h": 33, "i": 34, "j": 35, "k": 36, "l": 37, "m": 38, "n": 39, "o": 40, "p": 41, "q": 42, "r": 43, "s": 44, "t": 45, "u": 46, "v": 47, "w": 48, "x": 49, "y": 50, "z": 51, "0": 52, "1": 53, "2": 54, "3": 55, "4": 56, "5": 57, "6": 58, "7": 59, "8": 60, "9": 61, "+": 62, "/": 63 };
/**
 * Maps numeric values for the caps parameter of {@link Graphics#setStrokeStyle} to
 * corresponding string values. This is primarily for use with the tiny API.<br />
 * The mappings are as follows:
 * <ul>
 *   <li>0 to "butt"</li>
 *   <li>1 to "round"</li>
 *   <li>2 to "square".</li>
 * </ul>
 *
 * @example <caption>Set line caps to "square"</caption>
 * graphics.ss(16, 2);
 *
 * @static
 * @readonly
 * @protected
 * @type {Array<String>}
 */
Graphics._STROKE_CAPS_MAP = ["butt", "round", "square"];
/**
 * Maps numeric values for the joints parameter of {@link Graphics#setStrokeStyle} to
 * corresponding string values. This is primarily for use with the tiny API.<br />
 * The mappings are as follows:
 * <ul>
 *   <li>0 to "miter"</li>
 *   <li>1 to "round"</li>
 *   <li>2 to "bevel".</li>
 * </ul>
 *
 * @example <caption>Set the line joints to "bevel"</caption>
 * graphics.ss(16, 0, 2);
 *
 * @static
 * @readonly
 * @protected
 * @type {Array<String>}
 */
Graphics._STROKE_JOINTS_MAP = ["miter", "round", "bevel"];
/**
 * @static
 * @readonly
 * @protected
 * @type {CanvasRenderingContext2D}
 */
Graphics._ctx = (0,_utils_Canvas__WEBPACK_IMPORTED_MODULE_0__.createCanvas)().getContext("2d");


/***/ }),

/***/ "./src/drawing/scene/display/Shape.ts":
/*!********************************************!*\
  !*** ./src/drawing/scene/display/Shape.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Shape": () => (/* binding */ Shape)
/* harmony export */ });
/* harmony import */ var _DisplayObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DisplayObject */ "./src/drawing/scene/display/DisplayObject.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Graphics */ "./src/drawing/scene/display/Graphics.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * A Shape allows you to display vector art in the display list. It composites a {@link Graphics}
 * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape
 * instances to display the same vector graphics with different positions or transforms.
 *
 * If the vector art will not change between draws, you may want to use the {@link DisplayObject#cache}
 * method to reduce the rendering cost.
 *
 * @memberof easeljs
 * @example
 * var graphics = new Graphics().beginFill("#ff0000").drawRect(0, 0, 100, 100);
 * var shape = new Shape(graphics);
 * // Alternatively use can also use the graphics property of the Shape class to renderer the same as above.
 * var shape = new Shape();
 * shape.graphics.beginFill("#ff0000").drawRect(0, 0, 100, 100);
 *
 * @extends DisplayObject
 * @param {Graphics} [graphics] The graphics instance to display. If null, a new Graphics instance will be created.
 */
var Shape = /** @class */ (function (_super) {
    __extends(Shape, _super);
    function Shape(graphics) {
        if (graphics === void 0) { graphics = new _Graphics__WEBPACK_IMPORTED_MODULE_1__.Graphics(); }
        var _this = _super.call(this) || this;
        _this.graphics = graphics;
        return _this;
    }
    Shape.prototype.isVisible = function () {
        var hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());
        return !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0 && hasContent);
    };
    Shape.prototype.draw = function (ctx, ignoreCache) {
        if (ignoreCache === void 0) { ignoreCache = false; }
        if (_super.prototype.draw.call(this, ctx, ignoreCache)) {
            return true;
        }
        this.graphics.draw(ctx, this);
        return true;
    };
    /**
     * Returns a clone of this Shape. Some properties that are specific to this instance's current context are reverted to
     * their defaults (for example .parent).
     * @override
     * @param {Boolean} [recursive=false] If true, this Shape's {@link Graphics} instance will also be
     * cloned. If false, the Graphics instance will be shared with the new Shape.
     */
    Shape.prototype.clone = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        var g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;
        return this._cloneProps(new Shape(g));
    };
    return Shape;
}(_DisplayObject__WEBPACK_IMPORTED_MODULE_0__.DisplayObject));



/***/ }),

/***/ "./src/drawing/scene/display/Stage.ts":
/*!********************************************!*\
  !*** ./src/drawing/scene/display/Stage.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Stage": () => (/* binding */ Stage)
/* harmony export */ });
/* harmony import */ var _Container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Container */ "./src/drawing/scene/display/Container.ts");
/* harmony import */ var _DisplayObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DisplayObject */ "./src/drawing/scene/display/DisplayObject.ts");
/* harmony import */ var _events_MouseEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/MouseEvent */ "./src/drawing/scene/events/MouseEvent.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



/**
 * A stage is the root level {@link Container} for a display list. Each time its {@link Stage#tick}
 * method is called, it will render its display list to its target canvas.
 *
 * @memberof easeljs
 * @extends Container
 * @example
 * let stage = new Stage("canvasElementId");
 * let image = new Bitmap("imagePath.png");
 * stage.addChild(image);
 * Ticker.addEventListener("tick", event => {
 *   image.x += 10;
 * 	 stage.update();
 * });
 *
 * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id
 * of a canvas object in the current document.
 */
var Stage = /** @class */ (function (_super) {
    __extends(Stage, _super);
    function Stage(canvas) {
        var _this = _super.call(this) || this;
        _this._mouseOverX = 0;
        _this._mouseOverY = 0;
        _this._mouseOverTarget = undefined;
        _this.isUpdateRequired = true;
        _this.autoClear = true;
        _this.canvas = (typeof canvas === "string") ? document.getElementById(canvas) : canvas;
        _this.mouseX = 0;
        _this.mouseY = 0;
        _this.drawRect = null;
        _this.snapToPixelEnabled = false;
        _this.mouseInBounds = false;
        _this.tickOnUpdate = true;
        _this.mouseMoveOutside = false;
        _this.preventSelection = true;
        _this._pointerData = {};
        _this._pointerCount = 0;
        _this._primaryPointerID = null;
        _this._mouseOverIntervalID = null;
        _this._nextStage = null;
        _this._prevStage = null;
        return _this;
        // this.enableDOMEvents(true);
    }
    Object.defineProperty(Stage.prototype, "nextStage", {
        /**
         * Specifies a target stage that will have mouse/touch interactions relayed to it after this stage handles them.
         * This can be useful in cases where you have multiple layered canvases and want user interactions
         * events to pass through.
         *
         * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings
         * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.
         * Considerations when using roll over in relay targets:
         * <ol>
         *   <li> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</li>
         *   <li> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</li>
         *   <li> All relay targets will share the frequency value of the top-most stage</li>
         * </ol>
         *
         * @example <caption>Relay mouse events from topStage to bottomStage</caption>
         * topStage.nextStage = bottomStage;
         *
         * @example <caption>Disable DOM events</caption>
         * stage.enableDOMEvents(false);
         *
         * @type {Stage}
         */
        get: function () { return this._nextStage; },
        set: function (stage) {
            if (this._nextStage) {
                this._nextStage._prevStage = null;
            }
            if (stage) {
                stage._prevStage = this;
            }
            this._nextStage = stage;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Each time the update method is called, the stage will call {@link Stage#tick}
     * unless {@link Stage#tickOnupdate} is set to false,
     * and then render the display list to the canvas.
     *
     * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {@link core.Ticker} event object, or similar object with a delta property.
     */
    Stage.prototype.update = function (props) {
        if (!this.canvas) {
            return;
        }
        if (this.tickOnUpdate) {
            this.tick(props);
        }
        if (this.dispatchEvent("drawstart", false, true) === false) {
            return;
        }
        _DisplayObject__WEBPACK_IMPORTED_MODULE_1__.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;
        var r = this.drawRect, ctx = this.canvas.getContext("2d");
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (this.autoClear) {
            if (r) {
                ctx.clearRect(r.X, r.Y, r.Width, r.Height);
            }
            else {
                ctx.clearRect(0, 0, this.canvas.width + 1, this.canvas.height + 1);
            }
        }
        ctx.save();
        if (this.drawRect) {
            ctx.beginPath();
            ctx.rect(r.X, r.Y, r.Width, r.Height);
            ctx.clip();
        }
        this.updateContext(ctx);
        this.draw(ctx, false);
        ctx.restore();
        this.dispatchEvent("drawend");
    };
    Stage.prototype.draw = function (ctx, ignoreCache) {
        var result = _super.prototype.draw.call(this, ctx, ignoreCache);
        this.canvas._invalid = true;
        return result;
    };
    /**
     * Propagates a tick event through the display list. This is automatically called by {@link Stage#update}
     * unless {@link Stage#tickOnUpdate} is set to false.
     *
     * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is
     * propagated to listeners.
     *
     * Some time-based features in EaselJS (for example {@link Sprite#framerate} require that
     * a {@link core.Ticker#event:tick} event object (or equivalent object with a delta property) be
     * passed as the `props` parameter to `tick()`.
     *
     * @example
     * Ticker.on("tick", (evt) => {
     *   // clone the event object from Ticker, and add some custom data to it:
     * 	 let data = evt.clone().set({ greeting: "hello", name: "world" });
     * 	 // pass it to stage.update():
     * 	 stage.update(data); // subsequently calls tick() with the same param
     * });
     *
     * shape.on("tick", (evt) => {
     *   console.log(evt.delta); // the delta property from the Ticker tick event object
     * 	 console.log(evt.greeting, evt.name); // custom data: "hello world"
     * });
     *
     * @emits Stage#event:tickstart
     * @emits Stage#event:tickend
     * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.
     */
    Stage.prototype.tick = function (props) {
        if (!this.tickEnabled || this.dispatchEvent("tickstart", false, true) === false) {
            return;
        }
        var evtObj = new Event("tick");
        if (props) {
            for (var n in props) {
                if (props.hasOwnProperty(n)) {
                    evtObj[n] = props[n];
                }
            }
        }
        this._tick(evtObj);
        this.dispatchEvent("tickend");
    };
    /**
     * Default event handler that calls the Stage {@link Stage#update} method when a {@link DisplayObject#event:tick}
     * event is received. This allows you to register a Stage instance as a event listener on {@link core.Ticker} directly.
     * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to
     * display object tick handlers, instead of `delta` and `paused` parameters.
     */
    Stage.prototype.handleEvent = function (evt) {
        if (evt.type === "tick") {
            this.update(evt);
        }
    };
    /**
     * Clears the target canvas. Useful if {@link State#autoClear} is set to `false`.
     */
    Stage.prototype.clear = function () {
        if (!this.canvas) {
            return;
        }
        var ctx = this.canvas.getContext("2d");
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, this.canvas.width + 1, this.canvas.height + 1);
    };
    /**
     * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can
     * be specified as the src value of an image element.
     *
     * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color
     * value is allowed. The default value is a transparent background.
     * @param {String} [mimeType="image/png"] The MIME type of the image format to be create. If an unknown MIME type
     * is passed in, or if the browser does not support the specified MIME type, the default value will be used.
     * @param {Number} [encoderOptions=0.92] A Number between 0 and 1 indicating the image quality to use for image
     * formats that use lossy  compression such as image/jpeg and image/webp.
     * @return {String} a Base64 encoded image.
     */
    Stage.prototype.toDataURL = function (backgroundColor, mimeType, encoderOptions) {
        if (mimeType === void 0) { mimeType = "image/png"; }
        if (encoderOptions === void 0) { encoderOptions = 0.92; }
        var data, ctx = this.canvas.getContext('2d'), w = this.canvas.width, h = this.canvas.height;
        if (backgroundColor) {
            data = ctx.getImageData(0, 0, w, h);
            var compositeOperation = ctx.globalCompositeOperation;
            ctx.globalCompositeOperation = "destination-over";
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, w, h);
        }
        var dataURL = this.canvas.toDataURL(mimeType, encoderOptions);
        if (backgroundColor) {
            ctx.putImageData(data, 0, 0);
            ctx.globalCompositeOperation = compositeOperation;
        }
        return dataURL;
    };
    /**
     * Enables or disables (by passing a frequency of 0) mouse over {@link DisplayObject#event:mouseover}
     * and {@link DisplayObject#event:mouseout} and roll over events {@link DisplayObject#event:rollover}
     * and {@link DisplayObject#event:rollout} for this stage's display list. These events can
     * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled
     * independently of mouse move events via the optional `frequency` parameter.
     *
     * @example
     * const stage = new Stage("canvasId");
     * stage.enableMouseOver(10); // 10 updates per second
     *
     * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast
     * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less
     * responsive, but uses less CPU.
     */
    Stage.prototype.enableMouseOver = function (frequency) {
        var _this = this;
        if (frequency === void 0) { frequency = 20; }
        if (this._mouseOverIntervalID) {
            clearInterval(this._mouseOverIntervalID);
            this._mouseOverIntervalID = null;
            if (frequency === 0) {
                this._testMouseOver(true);
            }
        }
        if (frequency <= 0) {
            return;
        }
        this._mouseOverIntervalID = setInterval(function () { return _this._testMouseOver(); }, 1000 / Math.min(50, frequency));
    };
    /**
     * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good
     * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive
     * events from the page.
     * When changing the canvas property you must disable the events on the old canvas, and enable events on the
     * new canvas or mouse events will not work as expected.
     *
     * @example
     * stage.enableDOMEvents(false);
     * stage.canvas = anotherCanvas;
     * stage.enableDOMEvents(true);
     *
     * @param {Boolean} [enable=true] Indicates whether to enable or disable the events.
     */
    Stage.prototype.enableDOMEvents = function (enable) {
        var _this = this;
        if (enable === void 0) { enable = true; }
        var ls = this._eventListeners;
        if (!enable && ls) {
            for (var n in ls) {
                var o = ls[n];
                o.t.removeEventListener(n, o.f, false);
            }
            this._eventListeners = null;
        }
        else if (enable && !ls && this.canvas) {
            var t = window.addEventListener ? window : document;
            ls = this._eventListeners = {
                mouseup: { t: t, f: function (e) { return _this._handleMouseUp(e); } },
                mousemove: { t: t, f: function (e) { return _this._handleMouseMove(e); } },
                dblclick: { t: this.canvas, f: function (e) { return _this._handleDoubleClick(e); } },
                mousedown: { t: this.canvas, f: function (e) { return _this._handleMouseDown(e); } }
            };
            for (var n in ls) {
                var o = ls[n];
                if (o.t != null && o.t.addEventListener != null) {
                    o.t.addEventListener(n, o.f, false);
                }
            }
        }
    };
    /**
     * Stage instances cannot be cloned.
     * @throws Stage cannot be cloned
     * @override
     */
    Stage.prototype.clone = function (test) {
        throw "Stage cannot be cloned.";
    };
    /**
     * @protected
     * @param {HTMLElement} e
     * @returns {Object}
     */
    Stage.prototype._getElementRect = function (e) {
        var bounds;
        try {
            if (e.parentElement == null && e.parentNode == null) {
                bounds = { x: 0, y: 0, width: e.width, height: e.height, left: 0, top: 0, right: e.width, bottom: e.height };
            }
            else {
                bounds = e.getBoundingClientRect();
            }
        } // this can fail on disconnected DOM elements in IE9
        catch (err) {
            bounds = { top: e.offsetTop, left: e.offsetLeft, width: e.offsetWidth, height: e.offsetHeight };
        }
        var offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);
        var offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || document.body.clientTop || 0);
        var styles = window.getComputedStyle ? getComputedStyle(e, null) : e.currentStyle; // IE <9 compatibility.
        var padL = parseInt(styles.paddingLeft === '' ? '0px' : styles.paddingLeft) + parseInt(styles.borderLeftWidth === '' ? '0px' : styles.borderLeftWidth);
        var padT = parseInt(styles.paddingTop === '' ? '0px' : styles.paddingTop) + parseInt(styles.borderTopWidth === '' ? '0px' : styles.borderTopWidth);
        var padR = parseInt(styles.paddingRight === '' ? '0px' : styles.paddingRight) + parseInt(styles.borderRightWidth === '' ? '0px' : styles.borderRightWidth);
        var padB = parseInt(styles.paddingBottom === '' ? '0px' : styles.paddingBottom) + parseInt(styles.borderBottomWidth === '' ? '0px' : styles.borderBottomWidth);
        // note: in some browsers bounds properties are read only.
        return {
            left: bounds.left + offX + padL,
            right: bounds.right + offX - padR,
            top: bounds.top + offY + padT,
            bottom: bounds.bottom + offY - padB
        };
    };
    /**
     * @protected
     * @param {Number} id
     * @returns {Object}
     */
    Stage.prototype._getPointerData = function (id) {
        var data = this._pointerData[id];
        if (!data) {
            data = this._pointerData[id] = { x: 0, y: 0 };
        }
        return data;
    };
    /**
     * @protected
     * @param {MouseEvent} [e=window.event]
     */
    Stage.prototype._handleMouseMove = function (e) {
        if (e === void 0) { e = window.event; }
        this._handlePointerMove(-1, e, e.pageX, e.pageY);
    };
    Stage.prototype.onMouseMove = function (e) {
        this._handlePointerMove(-1, e, e.pageX, e.pageY);
    };
    /**
     * @emits {@link DisplayObject#event:mouseleave}
     * @emits {@link DisplayObject#event:mouseenter}
     * @emits {@link DisplayObject#event:pressmove}
     * @emits {@link Stage#event:stagemousemove}
     * @protected
     * @param {Number} id
     * @param {MouseEvent | Event} e
     * @param {Number} pageX
     * @param {Number} pageY
     * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
     */
    Stage.prototype._handlePointerMove = function (id, e, pageX, pageY, owner) {
        if (this._prevStage && owner === undefined) {
            return;
        } // redundant listener.
        if (!this.canvas) {
            return;
        }
        var nextStage = this._nextStage, o = this._getPointerData(id);
        var inBounds = o.inBounds;
        this._updatePointerPosition(id, e, pageX, pageY);
        if (inBounds || o.inBounds || this.mouseMoveOutside) {
            if (id === -1 && o.inBounds === !inBounds) {
                this._dispatchMouseEvent(this, (inBounds ? "mouseleave" : "mouseenter"), false, id, o, e);
            }
            this._dispatchMouseEvent(this, "stagemousemove", false, id, o, e);
            this._dispatchMouseEvent(o.target, "pressmove", true, id, o, e);
        }
        nextStage && nextStage._handlePointerMove(id, e, pageX, pageY, null);
    };
    /**
     * @protected
     * @param {Number} id
     * @param {MouseEvent | Event} e
     * @param {Number} pageX
     * @param {Number} pageY
     */
    Stage.prototype._updatePointerPosition = function (id, e, pageX, pageY) {
        var rect = this._getElementRect(this.canvas);
        pageX -= rect.left;
        pageY -= rect.top;
        var w = this.canvas.width;
        var h = this.canvas.height;
        pageX /= (rect.right - rect.left) / w;
        pageY /= (rect.bottom - rect.top) / h;
        var o = this._getPointerData(id);
        if (o.inBounds = (pageX >= 0 && pageY >= 0 && pageX <= w - 1 && pageY <= h - 1)) {
            o.x = pageX;
            o.y = pageY;
        }
        else if (this.mouseMoveOutside) {
            o.x = pageX < 0 ? 0 : (pageX > w - 1 ? w - 1 : pageX);
            o.y = pageY < 0 ? 0 : (pageY > h - 1 ? h - 1 : pageY);
        }
        o.posEvtObj = e;
        o.rawX = pageX;
        o.rawY = pageY;
        if (id.toString() === this._primaryPointerID || id === -1) {
            this.mouseX = o.x;
            this.mouseY = o.y;
            this.mouseInBounds = o.inBounds;
        }
    };
    /**
     * @protected
     * @param {MouseEvent} e
     */
    Stage.prototype._handleMouseUp = function (e) {
        this._handlePointerUp(-1, e, false);
    };
    Stage.prototype.onMouseUp = function (e) {
        this._handlePointerUp(-1, e, false);
    };
    /**
     * @emits {@link Stage#event:stagemouseup}
     * @emits {@link DisplayObject#event:click}
     * @emits {@link DisplayObject#event:pressup}
     * @protected
     * @param {Number} id
     * @param {MouseEvent | Event} e
     * @param {Boolean} clear
     * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
     */
    Stage.prototype._handlePointerUp = function (id, e, clear, owner) {
        var nextStage = this._nextStage, o = this._getPointerData(id);
        if (this._prevStage && owner === undefined) {
            return;
        } // redundant listener.
        var target = null, oTarget = o.target;
        if (!owner && (oTarget || nextStage)) {
            target = this._getObjectsUnderPoint(o.x, o.y, null, true);
        }
        if (o.down) {
            this._dispatchMouseEvent(this, "stagemouseup", false, id, o, e, target);
            o.down = false;
        }
        if (target === oTarget) {
            this._dispatchMouseEvent(oTarget, "click", true, id, o, e);
        }
        this._dispatchMouseEvent(oTarget, "pressup", true, id, o, e);
        if (clear) {
            if (id.toString() === this._primaryPointerID) {
                this._primaryPointerID = null;
            }
            delete (this._pointerData[id]);
        }
        else {
            o.target = null;
        }
        nextStage && nextStage._handlePointerUp(id, e, clear, (owner || target && this));
    };
    /**
     * @protected
     * @param {MouseEvent} e
     */
    Stage.prototype._handleMouseDown = function (e) {
        this._handlePointerDown(-1, e, e.pageX, e.pageY);
    };
    Stage.prototype.onMouseDown = function (e) {
        this._handlePointerDown(-1, e, e.pageX, e.pageY);
    };
    /**
     * @emits {@link Stage#event:stagemousedown}
     * @emits {@link DisplayObject#event:mousedown}
     * @protected
     * @param {Number} id
     * @param {MouseEvent | Event} e
     * @param {Number} pageX
     * @param {Number} pageY
     * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
     */
    Stage.prototype._handlePointerDown = function (id, e, pageX, pageY, owner) {
        if (this.preventSelection) {
            e.preventDefault();
        }
        if (this._primaryPointerID == null || id === -1) {
            this._primaryPointerID = id.toString();
        } // mouse always takes over.
        if (pageY != null) {
            this._updatePointerPosition(id, e, pageX, pageY);
        }
        var target = null;
        var nextStage = this._nextStage;
        var o = this._getPointerData(id);
        if (!owner) {
            target = o.target = this._getObjectsUnderPoint(o.x, o.y, null, true);
        }
        if (o.inBounds) {
            this._dispatchMouseEvent(this, "stagemousedown", false, id, o, e, target);
            o.down = true;
        }
        this._dispatchMouseEvent(target, "mousedown", true, id, o, e);
        nextStage && nextStage._handlePointerDown(id, e, pageX, pageY, (owner || target && this));
    };
    /**
     * @emits {@link DisplayObject#event:mouseout}
     * @emits {@link DisplayObject#event:rollout}
     * @emits {@link DisplayObject#event:rollover}
     * @emits {@link DisplayObject#event:mouseover}
     * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)
     * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
     * @param {Stage} eventTarget The stage that the cursor is actively over.
     * @protected
     */
    Stage.prototype._testMouseOver = function (clear, owner, eventTarget) {
        if (this._prevStage && owner === undefined) {
            return;
        } // redundant listener.
        var nextStage = this._nextStage;
        if (!this._mouseOverIntervalID) {
            // not enabled for mouseover, but should still relay the event.
            nextStage && nextStage._testMouseOver(clear, owner, eventTarget);
            return;
        }
        var o = this._getPointerData(-1);
        // only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.
        if (!o || (!clear && this.mouseX === this._mouseOverX && this.mouseY === this._mouseOverY && this.mouseInBounds)) {
            return;
        }
        var e = o.posEvtObj;
        var isEventTarget = eventTarget || e && (e.target === this.canvas);
        var target = null, common = -1, cursor = "";
        if (!owner && (clear || this.mouseInBounds && isEventTarget)) {
            target = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);
            this._mouseOverX = this.mouseX;
            this._mouseOverY = this.mouseY;
        }
        var oldList = this._mouseOverTarget || [];
        var oldTarget = oldList[oldList.length - 1];
        var list = this._mouseOverTarget = [];
        // generate ancestor list and check for cursor:
        var t = target;
        while (t) {
            list.unshift(t);
            if (!cursor) {
                cursor = t.cursor;
            }
            t = t.parent;
        }
        this.canvas.style.cursor = cursor;
        if (!owner && eventTarget) {
            eventTarget.canvas.style.cursor = cursor;
        }
        // find common ancestor:
        for (var i = 0, l = list.length; i < l; i++) {
            if (list[i] != oldList[i]) {
                break;
            }
            common = i;
        }
        if (oldTarget != target) {
            this._dispatchMouseEvent(oldTarget, "mouseout", true, -1, o, e, target);
        }
        for (var i = oldList.length - 1; i > common; i--) {
            this._dispatchMouseEvent(oldList[i], "rollout", false, -1, o, e, target);
        }
        for (var i = list.length - 1; i > common; i--) {
            this._dispatchMouseEvent(list[i], "rollover", false, -1, o, e, oldTarget);
        }
        if (oldTarget != target) {
            this._dispatchMouseEvent(target, "mouseover", true, -1, o, e, oldTarget);
        }
        nextStage && nextStage._testMouseOver(clear, (owner || target && this), (eventTarget || isEventTarget && this));
    };
    /**
     * @emits {@link DisplayObject#event:dblclick}
     * @protected
     * @param {MouseEvent} e
     * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
     */
    Stage.prototype._handleDoubleClick = function (e, owner) {
        var target = null, nextStage = this._nextStage, o = this._getPointerData(-1);
        if (!owner) {
            target = this._getObjectsUnderPoint(o.x, o.y, null, true);
            this._dispatchMouseEvent(target, "dblclick", true, -1, o, e);
        }
        nextStage && nextStage._handleDoubleClick(e, (owner || target && this));
    };
    Stage.prototype.onDbClick = function (e, owner) {
        this._handleDoubleClick(e);
    };
    /**
     * @protected
     * @param {DisplayObject} target
     * @param {String} type
     * @param {Boolean} bubbles
     * @param {Number} pointerId
     * @param {Object} o
     * @param {MouseEvent} [nativeEvent]
     * @param {DisplayObject} [relatedTarget]
     */
    Stage.prototype._dispatchMouseEvent = function (target, type, bubbles, pointerId, o, nativeEvent, relatedTarget) {
        // TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.
        if (!target || (!bubbles && !target.hasEventListener(type))) {
            return;
        }
        /*
        // TODO: account for stage transformations?
        this._mtx = this.getConcatenatedMatrix(this._mtx).invert();
        let pt = this._mtx.transformPoint(o.x, o.y);
        let evt = new MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID || pointerId==-1, o.rawX, o.rawY);
        */
        var evt = new _events_MouseEvent__WEBPACK_IMPORTED_MODULE_2__.MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId.toString() === this._primaryPointerID || pointerId === -1, o.rawX, o.rawY, relatedTarget);
        target.dispatchEvent(evt);
    };
    return Stage;
}(_Container__WEBPACK_IMPORTED_MODULE_0__.Container));

/**
 * Dispatched when the user moves the mouse over the canvas.
 * @see {@link MouseEvent}
 * @event Stage#stagemousemove
 * @since 0.6.0
 */
/**
 * Dispatched when the user presses their left mouse button on the canvas.
 * You can use {@link Stage#mouseInBounds} to check whether the mouse is currently within the stage bounds.
 * @see {@link MouseEvent}
 * @event Stage#stagemousedown
 * @since 0.6.0
 */
/**
 * Dispatched when the user the user presses somewhere on the stage, then releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).
 * You can use {@link Stage#mouseInBounds} to check whether the mouse is currently within the stage bounds.
 * @see {@link MouseEvent}
 * @event Stage#stagemouseup
 * @since 0.6.0
 */
/**
 * Dispatched when the mouse moves from within the canvas area (mouseInBounds === true) to outside it (mouseInBounds === false).
 * This is currently only dispatched for mouse input (not touch).
 * @see {@link MouseEvent}
 * @event Stage#mouseleave
 * @since 0.7.0
 */
/**
 * Dispatched when the mouse moves into the canvas area (mouseInBounds === false) from outside it (mouseInBounds === true).
 * This is currently only dispatched for mouse input (not touch).
 * @see {@link MouseEvent}
 * @event Stage#mouseenter
 * @since 0.7.0
 */
/**
 * Dispatched each update immediately before the tick event is propagated through the display list.
 * You can call preventDefault on the event object to cancel propagating the tick event.
 * @event Stage#tickstart
 * @since 0.7.0
 */
/**
 * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if
 * tickOnUpdate is false. Precedes the "drawstart" event.
 * @event Stage#tickend
 * @since 0.7.0
 */
/**
 * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.
 * You can call preventDefault on the event object to cancel the draw.
 * @event Stage#drawstart
 * @since 0.7.0
 */
/**
 * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.
 * @event Stage#drawend
 * @since 0.7.0
 */ 


/***/ }),

/***/ "./src/drawing/scene/display/StageGL.ts":
/*!**********************************************!*\
  !*** ./src/drawing/scene/display/StageGL.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StageGL": () => (/* binding */ StageGL)
/* harmony export */ });
var StageGL = /** @class */ (function () {
    function StageGL(arg1, arg2) {
        throw new Error("\n\t\t\tStageGL is not currently supported on the EaselJS 2.0 branch.\n\t\t\tEnd of Q1 2018 is targetted for StageGL support.\n\t\t\tFollow @CreateJS on Twitter for updates.\n\t\t");
    }
    return StageGL;
}());



/***/ }),

/***/ "./src/drawing/scene/display/Text.ts":
/*!*******************************************!*\
  !*** ./src/drawing/scene/display/Text.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Text": () => (/* binding */ Text)
/* harmony export */ });
/* harmony import */ var _DisplayObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DisplayObject */ "./src/drawing/scene/display/DisplayObject.ts");
/* harmony import */ var _utils_Canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Canvas */ "./src/drawing/scene/utils/Canvas.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text(text, font, color) {
        var _this = _super.call(this) || this;
        /**
         * The text to display.
         * @type {String}
         */
        _this.text = text;
        /**
         * The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold 36px Arial").
         * @type {String}
         */
        _this.font = font;
        /**
         * The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. "#F00"). Default is "#000".
         * It will also accept valid canvas fillStyle values.
         * @type {String}
         */
        _this.color = color;
        /**
         * The horizontal text alignment. Any of "start", "end", "left", "right", and "center".
         * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles "WHATWG spec"}
         * @type {String}
         * @default left
         */
        _this.textAlign = "left";
        /**
         * The vertical alignment point on the font. Any of "top", "hanging", "middle", "alphabetic", "ideographic", or "bottom".
         * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles "WHATWG spec"}
         * @type {String}
         * @default top
        */
        _this.textBaseline = "top";
        /**
         * The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or
         * shrunk to make it fit in this width.
         * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles "WHATWG spec"}
         * @type {Number}
        */
        _this.maxWidth = null;
        /**
         * If greater than 0, the text will be drawn as a stroke (outline) of the specified width.
         * @type {Number}
         */
        _this.outline = 0;
        /**
         * Indicates the line height (vertical distance between baselines) for multi-line text. If null or 0,
         * the value of getMeasuredLineHeight is used.
         * @type {Number}
         * @default 0
         */
        _this.lineHeight = 0;
        /**
         * Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null,
         * the text will not be wrapped.
         * @type {Number}
         */
        _this.lineWidth = null;
        return _this;
    }
    Text.prototype.isVisible = function () {
        var hasContent = this.cacheCanvas || (this.text != null && this.text !== "");
        return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
    };
    Text.prototype.draw = function (ctx, ignoreCache) {
        if (ignoreCache === void 0) { ignoreCache = false; }
        if (_super.prototype.draw.call(this, ctx, ignoreCache)) {
            return true;
        }
        var col = this.color || "#000";
        if (this.outline) {
            ctx.strokeStyle = col;
            ctx.lineWidth = this.outline * 1;
        }
        else {
            ctx.fillStyle = col;
        }
        this._drawText(this._prepContext(ctx));
        return true;
    };
    /**
     * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.
     * @return {Number} The measured, untransformed width of the text.
     */
    Text.prototype.getMeasuredWidth = function () {
        return this._getMeasuredWidth(this.text);
    };
    /**
     * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured
     * width of a "M" character multiplied by 1.2, which provides an approximate line height for most fonts.
     * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is
     * based on the measured width of a "M" character multiplied by 1.2, which approximates em for most fonts.
     */
    Text.prototype.getMeasuredLineHeight = function () {
        return this._getMeasuredWidth("M") * 1.2;
    };
    /**
     * Returns the approximate height of multi-line text by multiplying the number of lines against either the
     * `lineHeight` (if specified) or {@link easeljs.Text#getMeasuredLineHeight}. Note that
     * this operation requires the text flowing logic to run, which has an associated CPU cost.
     * @return {Number} The approximate height of the untransformed multi-line text.
     */
    Text.prototype.getMeasuredHeight = function () {
        return this._drawText(null, {}).height;
    };
    Text.prototype.getBounds = function () {
        var rect = _super.prototype.getBounds.call(this);
        if (rect) {
            return rect;
        }
        if (this.text == null || this.text === "") {
            return null;
        }
        var o = this._drawText(null, {});
        var w = (this.maxWidth && this.maxWidth < o.width) ? this.maxWidth : o.width;
        var x = w * Text.H_OFFSETS[this.textAlign || "left"];
        var lineHeight = this.lineHeight || this.getMeasuredLineHeight();
        var y = lineHeight * Text.V_OFFSETS[this.textBaseline || "top"];
        return this._rectangle.setValues(x, y, w, o.height);
    };
    /**
     * Returns an object with width, height, and lines properties. The width and height are the visual width and height
     * of the drawn text. The lines property contains an array of strings, one for
     * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing
     * whitespace removed.
     * @return {Object} An object with width, height, and lines properties.
     */
    Text.prototype.getMetrics = function () {
        var o = { lines: [] };
        o.lineHeight = this.lineHeight || this.getMeasuredLineHeight();
        o.vOffset = o.lineHeight * Text.V_OFFSETS[this.textBaseline || "top"];
        return this._drawText(null, o, o.lines);
    };
    /**
     * Returns a clone of the Text instance.
     * @return {easeljs.Text} a clone of the Text instance.
     */
    Text.prototype.clone = function (test) {
        return this._cloneProps(new Text(this.text, this.font, this.color));
    };
    /**
     * Returns a string representation of this object.
     * @override
     * @return {String} a string representation of the instance.
     */
    Text.prototype.toString = function () {
        return "[" + this.constructor.name + " (text=" + (this.text.length > 20 ? this.text.substr(0, 17) + "..." : this.text) + ")]";
    };
    /**
     * @param {easeljs.Text} o
     * @protected
     * @return {easeljs.Text} o
     */
    Text.prototype._cloneProps = function (o) {
        _super.prototype._cloneProps.call(this, o);
        o.textAlign = this.textAlign;
        o.textBaseline = this.textBaseline;
        o.maxWidth = this.maxWidth;
        o.outline = this.outline;
        o.lineHeight = this.lineHeight;
        o.lineWidth = this.lineWidth;
        return o;
    };
    /**
     * @param {CanvasRenderingContext2D} ctx
     * @return {CanvasRenderingContext2D}
     * @protected
     */
    Text.prototype._prepContext = function (ctx) {
        ctx.font = this.font || "10px sans-serif";
        ctx.textAlign = this.textAlign || "left";
        ctx.textBaseline = this.textBaseline || "top";
        ctx.lineJoin = "miter";
        ctx.miterLimit = 2.5;
        return ctx;
    };
    /**
     * Draws multiline text.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Object} o
     * @param {Array} lines
     * @return {Object}
     * @protected
     */
    Text.prototype._drawText = function (ctx, o, lines) {
        var paint = !!ctx;
        if (!paint) {
            ctx = Text._ctx;
            ctx.save();
            this._prepContext(ctx);
        }
        var lineHeight = this.lineHeight || this.getMeasuredLineHeight();
        var maxW = 0, count = 0;
        var hardLines = String(this.text).split(/(?:\r\n|\r|\n)/);
        for (var _i = 0, hardLines_1 = hardLines; _i < hardLines_1.length; _i++) {
            var str = hardLines_1[_i];
            var w = null;
            if (this.lineWidth != null && (w = ctx.measureText(str).width) > this.lineWidth) {
                // text wrapping:
                var words = str.split(/(\s)/);
                str = words[0];
                w = ctx.measureText(str).width;
                var l = words.length;
                for (var i = 1; i < l; i += 2) {
                    // Line needs to wrap:
                    var wordW = ctx.measureText(words[i] + words[i + 1]).width;
                    if (w + wordW > this.lineWidth) {
                        if (paint) {
                            this._drawTextLine(ctx, str, count * lineHeight);
                        }
                        if (lines) {
                            lines.push(str);
                        }
                        if (w > maxW) {
                            maxW = w;
                        }
                        str = words[i + 1];
                        w = ctx.measureText(str).width;
                        count++;
                    }
                    else {
                        str += words[i] + words[i + 1];
                        w += wordW;
                    }
                }
            }
            if (paint) {
                this._drawTextLine(ctx, str, count * lineHeight);
            }
            if (lines) {
                lines.push(str);
            }
            if (o && w == null) {
                w = ctx.measureText(str).width;
            }
            if (w > maxW) {
                maxW = w;
            }
            count++;
        }
        if (o) {
            o.width = maxW;
            o.height = count * lineHeight;
        }
        if (!paint) {
            ctx.restore();
        }
        return o;
    };
    /**
     * @param {CanvasRenderingContext2D} ctx
     * @param {String} text
     * @param {Number} y
     * @protected
     */
    Text.prototype._drawTextLine = function (ctx, text, y) {
        // Chrome 17 will fail to draw the text if the last param is included but null, so we feed it a large value instead:
        if (this.outline) {
            ctx.strokeText(text, 0, y, this.maxWidth || 0xFFFF);
        }
        else {
            ctx.fillText(text, 0, y, this.maxWidth || 0xFFFF);
        }
    };
    /**
     * @param {String} text
     * @protected
     */
    Text.prototype._getMeasuredWidth = function (text) {
        var ctx = Text._ctx;
        ctx.save();
        var w = this._prepContext(ctx).measureText(text).width;
        ctx.restore();
        return w;
    };
    Text._ctx = (0,_utils_Canvas__WEBPACK_IMPORTED_MODULE_1__.createCanvas)().getContext("2d");
    Text.V_OFFSETS = { top: 0, hanging: -0.01, middle: -0.4, alphabetic: -0.8, ideographic: -0.85, bottom: -1 };
    Text.H_OFFSETS = { start: 0, left: 0, center: -0.5, end: -1, right: -1 };
    return Text;
}(_DisplayObject__WEBPACK_IMPORTED_MODULE_0__.DisplayObject));



/***/ }),

/***/ "./src/drawing/scene/events/Event.ts":
/*!*******************************************!*\
  !*** ./src/drawing/scene/events/Event.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Event": () => (/* binding */ Event)
/* harmony export */ });
var Event = /** @class */ (function () {
    function Event(type, bubbles, cancelable) {
        if (bubbles === void 0) { bubbles = false; }
        if (cancelable === void 0) { cancelable = false; }
        /**
         * The type of event.
         * @type string
         */
        this.type = type;
        /**
         * The object that generated an event.
         *
         * @type Object
         * @default null
         * @readonly
         */
        this.target = null;
        /**
         * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
         * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
         * is generated from childObj, then a listener on parentObj would receive the event with
         * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
         *
         * @type Object
         * @default null
         * @readonly
         */
        this.currentTarget = null;
        /**
         * For bubbling events, this indicates the current event phase:
         * <OL>
         * 	<LI> capture phase: starting from the top parent to the target</LI>
         * 	<LI> at target phase: currently being dispatched from the target</LI>
         * 	<LI> bubbling phase: from the target to the top parent</LI>
         * </OL>
         *
         * @type number
         * @default 0
         * @readonly
         */
        this.eventPhase = 0;
        /**
         * Indicates whether the event will bubble through the display list.
         *
         * @type boolean
         * @readonly
         */
        this.bubbles = bubbles;
        /**
         * Indicates whether the default behaviour of this event can be cancelled via {@link core.Event#preventDefault}.
         *
         * @type boolean
         * @readonly
         */
        this.cancelable = cancelable;
        /**
         * The epoch time at which this event was created.
         *
         * @type number
         * @readonly
         */
        this.timeStamp = new Date().getTime();
        /**
         * Indicates if {@link core.Event#preventDefault} has been called on this event.
         *
         * @type boolean
         * @default false
         * @readonly
         */
        this.defaultPrevented = false;
        /**
         * Indicates if {@link core.Event#stopPropagation} or {@link core.Event#stopImmediatePropagation} has been called on this event.
         *
         * @type boolean
         * @default false
         * @readonly
         */
        this.propagationStopped = false;
        /**
         * Indicates if {@link core.Event#stopImmediatePropagation} has been called on this event.
         *
         * @type boolean
         * @default false
         * @readonly
         */
        this.immediatePropagationStopped = false;
        /**
         * Indicates if {@link core.Event#remove} has been called on this event.
         *
         * @type boolean
         * @default false
         * @readonly
         */
        this.removed = false;
    }
    /**
     * Sets {@link core.Event#defaultPrevented} to true if the event is cancelable.
     * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will
     * cancel the default behaviour associated with the event.
     * @return {core.Event} this, chainable
     */
    Event.prototype.preventDefault = function () {
        this.defaultPrevented = this.cancelable;
        return this;
    };
    /**
     * Sets {@link core.Event#propagationStopped} to true.
     * Mirrors the DOM event standard.
     * @return {core.Event} this, chainable
     */
    Event.prototype.stopPropagation = function () {
        this.propagationStopped = true;
        return this;
    };
    /**
     * Sets {@link core.Event#propagationStopped} and {@link core.Event#immediatePropagationStopped} to true.
     * Mirrors the DOM event standard.
     * @return {core.Event} this, chainable
     */
    Event.prototype.stopImmediatePropagation = function () {
        this.immediatePropagationStopped = this.propagationStopped = true;
        return this;
    };
    /**
     * Causes the active listener to be removed via removeEventListener();
     *
     * @example
     * myBtn.addEventListener("click", event => {
     *   event.remove(); // removes this listener.
     * });
     *
     * @return {core.Event} this, chainable
     */
    Event.prototype.remove = function () {
        this.removed = true;
        return this;
    };
    /**
     * Returns a clone of the Event instance.
     *
     * @return {core.Event} a clone of the Event instance.
     */
    Event.prototype.clone = function () {
        var event = new Event(this.type, this.bubbles, this.cancelable);
        for (var n in this) {
            if (this.hasOwnProperty(n)) {
                event[n] = this[n];
            }
        }
        return event;
    };
    /**
     * Provides a return {core.Event} this, chainable shortcut method for setting a number of properties on the instance.
     *
     * @param {Object} props A generic object containing properties to copy to the instance.
     * @return {core.Event} this, chainable
     */
    Event.prototype.set = function (props) {
        for (var n in props) {
            this[n] = props[n];
        }
        return this;
    };
    /**
     * Returns a string representation of this object.
     *
     * @return {string} A string representation of the instance.
     */
    Event.prototype.toString = function () {
        return "[" + this.constructor.name + " (type=" + this.type + ")]";
    };
    return Event;
}());



/***/ }),

/***/ "./src/drawing/scene/events/MouseEvent.ts":
/*!************************************************!*\
  !*** ./src/drawing/scene/events/MouseEvent.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MouseEvent": () => (/* binding */ MouseEvent)
/* harmony export */ });
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Event */ "./src/drawing/scene/events/Event.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,
 * see the {@link DisplayObject} and {@link Stage} event listings.
 * @extends core.Event
 * @param {String} type The event type.
 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
 * @param {Number} stageX The normalized x position relative to the stage.
 * @param {Number} stageY The normalized y position relative to the stage.
 * @param {MouseEvent} nativeEvent The native DOM event related to this mouse event.
 * @param {Number} pointerID The unique id for the pointer.
 * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.
 * @param {Number} rawX The raw x position relative to the stage.
 * @param {Number} rawY The raw y position relative to the stage.
 * @param {DisplayObject} relatedTarget The secondary target for the event.
 */
var MouseEvent = /** @class */ (function (_super) {
    __extends(MouseEvent, _super);
    function MouseEvent(type, bubbles, cancelable, stageX, stageY, nativeEvent, pointerID, primary, rawX, rawY, relatedTarget) {
        var _this = _super.call(this, type, bubbles /*, cancelable */) || this;
        /**
         * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.
         * For touch pointers, the first pointer in the current stack will be considered the primary pointer.
         * @type {Boolean}
         */
        _this.primary = false;
        _this.currentTarget = undefined;
        // public properties:
        _this.stageX = stageX;
        _this.stageY = stageY;
        _this.rawX = (rawX == null) ? stageX : rawX;
        _this.rawY = (rawY == null) ? stageY : rawY;
        _this.nativeEvent = nativeEvent;
        _this.pointerID = pointerID;
        _this.primary = !!primary;
        _this.relatedTarget = relatedTarget;
        return _this;
    }
    Object.defineProperty(MouseEvent.prototype, "localX", {
        /**
         * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
         * @type {Number}
         * @readonly
         */
        get: function () {
            return (this.currentTarget).globalToLocal(this.rawX, this.rawY).X;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MouseEvent.prototype, "localY", {
        /**
         * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
         * @type {Number}
         * @readonly
         */
        get: function () {
            return this.currentTarget.globalToLocal(this.rawX, this.rawY).Y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MouseEvent.prototype, "isTouch", {
        /**
         * Indicates whether the event was generated by a touch input (versus a mouse input).
         * @type {Boolean}
         * @readonly
         */
        get: function () {
            return this.pointerID !== -1;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns a clone of the MouseEvent instance.
     * @return {MouseEvent} a clone of the MouseEvent instance.
     */
    MouseEvent.prototype.clone = function () {
        return new MouseEvent(this.type, this.bubbles, this.cancelable, this.stageX, this.stageY, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);
    };
    /**
     * Returns a string representation of this object.
     * @return {String} a string representation of the instance.
     */
    MouseEvent.prototype.toString = function () {
        return "[" + this.constructor.name + " (type=" + this.type + " stageX=" + this.stageX + " stageY=" + this.stageY + ")]";
    };
    return MouseEvent;
}(_Event__WEBPACK_IMPORTED_MODULE_0__.Event));



/***/ }),

/***/ "./src/drawing/scene/filter/BitmapCache.ts":
/*!*************************************************!*\
  !*** ./src/drawing/scene/filter/BitmapCache.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitmapCache": () => (/* binding */ BitmapCache)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _display_StageGL__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../display/StageGL */ "./src/drawing/scene/display/StageGL.ts");
/* harmony import */ var _utils_Canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Canvas */ "./src/drawing/scene/utils/Canvas.ts");



/**
 * The BitmapCache is an internal representation of all the cache properties and logic required in order to "cache"
 * an object. This information and functionality used to be located on a {@link easeljs.DisplayObject#cache}
 * method in {@link easeljs.DisplayObject}, but was moved to its own class.
 *
 * Caching in this context is purely visual, and will render the DisplayObject out into an image to be used instead
 * of the object. The actual cache itself is still stored on the target with the {@link easeljs.DisplayObject#cacheCanvas}.
 * Working with a singular image like a {@link easeljs.Bitmap} there is little benefit to performing
 * a cache as it is already a single image. Caching is best done on containers containing multiple complex parts that
 * do not move often, so that rendering the image instead will improve overall rendering speed. A cached object will
 * not visually update until explicitly told to do so with a call to update, much like a Stage. If a cache is being
 * updated every frame it is likely not improving rendering performance. Cache are best used when updates will be sparse.
 *
 * Caching is also a co-requisite for applying filters to prevent expensive filters running constantly without need,
 * and to physically enable some effects. The BitmapCache is also responsible for applying filters to objects and
 * reads each {@link easeljs.Filter} due to this relationship. Real-time Filters are not recommended
 * performance wise when dealing with a Context2D canvas. On a StageGL performance is better so the presence of a
 * filter will automatically create a cache if one is not made manually.
 *
 * Some visual effects can be achieved with a {@link easeljs.DisplayObject#compositeOperation}
 * so check out that setting before settling on a filter.
 */
var BitmapCache = /** @class */ (function () {
    function BitmapCache() {
        /**
             * Width of the cache relative to the target object.
             * @property width
             * @protected
             * @type {Number}
             * @default undefined
             */
        this.width = 0;
        /**
         * Height of the cache relative to the target object.
         * @property height
         * @protected
         * @type {Number}
         * @default undefined
         * @todo Should the width and height be protected?
         */
        this.height = 0;
        /**
         * Horizontal position of the cache relative to the target's origin.
         * @property x
         * @protected
         * @type {Number}
         * @default undefined
         */
        this.x = 0;
        /**
         * Vertical position of the cache relative to target's origin.
         * @property y
         * @protected
         * @type {Number}
         * @default undefined
         */
        this.y = 0;
        /**
         * The internal scale of the cache image, does not affects display size. This is useful to both increase and
         * decrease render quality. Objects with increased scales are more likely to look good when scaled up or rotated.
         * Objects with decreased scales can save on rendering performance.
         * @property scale
         * @protected
         * @type {Number}
         * @default 1
         */
        this.scale = 1;
        /**
         * The x offset used for drawing into the cache itself, accounts for both transforms applied.
         * @property offX
         * @protected
         * @type {Number}
         * @default 0
         */
        this.offX = 0;
        /**
         * The y offset used for drawing into the cache itself, accounts for both transforms applied.
         * @property offY
         * @protected
         * @type {Number}
         * @default 0
         */
        this.offY = 0;
        /**
         * Track how many times the cache has been updated, mostly used for preventing duplicate cacheURLs.
         * This can be useful to see if a cache has been updated.
         * @property cacheID
         * @type {Number}
         * @default 0
         */
        this.cacheID = 0;
        // protected:
        /**
         * The number of filters found to process this update, used to optimize some decisions and surfaces
         * @type {number}
         * @private
         */
        this._filterCount = 0;
        /**
         * The relative offset of the filter's x position, used for drawing the cache onto its container.
         * Re-calculated every update call before drawing.
         * @property _filterOffY
         * @protected
         * @type {Number}
         * @default 0
         */
        this._filterOffX = 0;
        /**
         * The relative offset of the filter's y position, used for drawing the cache onto its container.
         * Re-calculated every update call before drawing.
         * @property _filterOffY
         * @protected
         * @type {Number}
         * @default 0
         */
        this._filterOffY = 0;
        /**
         * Internal tracking of the disabled state, use the getter/setters.
         * @property _disabled
         * @type {boolean}
         * @protected
         */
        this._disabled = false;
        /**
         * Internal tracking of whether this cache was automatically created and thus automatically controlled
         * @type {boolean}
         * @protected
         */
        this._autoGenerated = false;
        /**
         * Internal tracking of intended cacheCanvas, may or may not be assigned based on disabled state.
         * @property _cacheCanvas
         * @type {HTMLCanvasElement | WebGLTexture | Object}
         * @protected
         */
        this._cacheCanvas = null;
        /**
         * Output StageGL target for GL drawing
         * @property _stageGL
         * @type {StageGL}
         * @protected
         */
        this._stageGL = null;
        /**
         * The cacheID when a DataURL was requested.
         * @property _cacheDataURLID
         * @protected
         * @type {Number}
         * @default 0
         */
        this._cacheDataURLID = 0;
        /**
         * The cache's DataURL, generated on-demand using the getter.
         * @property _cacheDataURL
         * @protected
         * @type {String}
         * @default null
         */
        this._cacheDataURL = null;
        /**
         * Internal tracking of final bounding width, approximately width*scale; however, filters can complicate the actual value.
         * @property _drawWidth
         * @protected
         * @type {Number}
         * @default 0
         */
        this._drawWidth = 0;
        /**
         * Internal tracking of final bounding height, approximately height*scale; however, filters can complicate the actual value.
         * @property _drawHeight
         * @protected
         * @type {Number}
         * @default 0
         */
        this._drawHeight = 0;
        /**
         * Internal tracking of the last requested bounds, may happen repeadtedly so stored to avoid object creation
         * @property _boundRect
         * @protected
         * @type {Rectangle}
         * @default 0
         */
        this._boundRect = _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle.Empty;
        // semi protected: not public API but modified by other classes
        /**
         * Storage for the StageGL counter positioning matrix used on the object being cached
         * @property _counterMatrix
         * @type {Matrix2D}
         */
        this._counterMatrix = null;
        /**
         * One of the major render buffers used in composite blending and filter drawing. Do not expect this to always be the same object.
         * "What you're drawing to", object occasionally swaps with concat.
         * @property _bufferTextureOutput
         * @type {WebGLTexture}
         */
        this._bufferTextureOutput = null;
        /**
         * One of the major render buffers used in composite blending and filter drawing. Do not expect this to always be the same object.
         * "What you've draw before now", object occasionally swaps with output.
         * @property _bufferTextureConcat
         * @type {WebGLTexture}
         */
        this._bufferTextureConcat = null;
        /**
         * One of the major render buffers used only for composite blending draws.
         * "Temporary mixing surface"
         * @property _bufferTextureTemp
         * @type {WebGLTexture}
         */
        this._bufferTextureTemp = null;
    }
    /**
     * Returns the bounds that surround all applied filters, relies on each filter to describe how it changes bounds.
     * @param {easeljs.DisplayObject} target The object to check the filter bounds for.
     * @param {easeljs.Rectangle} [output=easeljs.Rectangle] Calculated bounds are applied to this rect
     * @return {easeljs.Rectangle} bounds object representing the bounds with filters.
     */
    BitmapCache.getFilterBounds = function (target, output) {
        if (output === void 0) { output = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGRectangle(); }
        var filters = target.filters;
        var filterCount = filters && filters.length;
        if (!!filterCount <= 0) {
            return output;
        }
        for (var i = 0; i < filterCount; i++) {
            var f = filters[i];
            if (!f || !f.getBounds) {
                continue;
            }
            var test = f.getBounds();
            if (!test) {
                continue;
            }
            if (i === 0) {
                output.setValues(test.x, test.y, test.width, test.height);
            }
            else {
                output.extend(test.x, test.y, test.width, test.height);
            }
        }
        return output;
    };
    /**
     * Utility function, use with `displayObject.filters.reduce(BitmapCache.filterCounter, 0);`
     * @param acc {Number}
     * @param o {Object}
     * @return {Number}
     */
    BitmapCache.filterCounter = function (acc, o) {
        var out = 1;
        while (o._multiPass) {
            o = o._multiPass;
            out++;
        }
        return acc + out;
    };
    Object.defineProperty(BitmapCache.prototype, "disabled", {
        /**
         * Disable or enable the BitmapCache from displaying. Does not cause or block cache or cache updates when toggled.
         * Best used if the cached state is always identical, but the object will need temporary uncaching.
         * @type {Boolean}
         * @default false
         */
        get: function () {
            return this._disabled;
        },
        set: function (value) {
            this._disabled = !!value;
            if (this.target) {
                this.target.cacheCanvas = (this._disabled || this._autoGenerated) ? null : this._cacheCanvas;
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns a string representation of this object.
     * @return {String}
     */
    BitmapCache.prototype.toString = function () {
        return "[BitmapCache]";
    };
    /**
     * Actually create the correct cache surface and properties associated with it. Caching and it's benefits are discussed
     * by the {@link easeljs.DisplayObject#cache} function and this class description. Here are the detailed
     * specifics of how to use the options object.
     *
     * - If useGL is set to "new" a StageGL is created and contained on this for use when rendering the cache.
     * - If useGL is set to "stage" if the current stage is a StageGL it will be used. Must be added to a stage first to work.
     * - If useGL is a StageGL instance then it will use it to cache. Warning, caches made on one StageGL will not render on any other StageGL.
     * - If useGL is undefined a Context 2D cache will be performed.
     *
     * This means you can use any combination of StageGL and 2D with either, neither, or both the stage and cache being
     * WebGL. Using "new" with a StageGL display list is highly unrecommended, but still an option. It should be avoided
     * due to negative performance reasons and the Image loading limitation noted in the class complications above.
     *
     * When `useGL` is set to the parent stage of the target and WebGL, performance is increased by using
     * "RenderTextures" instead of canvas elements. These are internal Textures on the graphics card stored in the GPU.
     * Because they are no longer canvases you cannot perform operations you could with a regular canvas. The benefit
     * is that this avoids the slowdown of copying the texture back and forth from the GPU to a Canvas element.
     * This means "stage" is the recommended option when available.
     *
     * A StageGL cache does not infer the ability to draw objects a StageGL cannot currently draw, i.e. do not use a
     * WebGL context cache when caching a Shape, Text, etc.
     *
     * @example <caption>WebGL cache with a 2D context</caption>
     * const stage = new Stage();
     * const bmp = new Bitmap(src);
     * bmp.cache(0, 0, bmp.width, bmp.height, 1, {gl: "new"}); // no StageGL to use, so make one
     *
     * const shape = new Shape();
     * shape.graphics.clear().fill("red").drawRect(0, 0, 20, 20);
     * shape.cache(0, 0, 20, 20, 1); // cannot use WebGL cache
     *
     * @example <caption>WebGL cache with a WebGL context</caption>
     * const stageGL = new StageGL();
     * const bmp = new Bitmap(src);
     *
     * // option 1
     * stageGL.addChild(bmp);
     * bmp.cache(0, 0, bmp.width, bmp.height, 1, {gl: "stage"}); // when added to the display list we can look it up
     * // option 2
     * bmp.cache(0, 0, bmp.width, bmp.height, 1, {gl: stageGL}); // we can specify it explicitly if we add it later
     * stageGL.addChild(bmp);
     *
     * const shape = new Shape();
     * shape.graphics.clear().fill("red").drawRect(0, 0, 20, 20);
     * shape.cache(0, 0, 20, 20, 1); // cannot use WebGL cache
     *
     * You may wish to create your own StageGL instance to control factors like clear color, transparency, AA, and
     * others. If the specified stage is not rendering content and just the cache set {@link easeljs.StageGL#isCacheControlled}
     * to true on your instance. This will trigger it to behave correctly for rendering your output.
     *
     * @param {Number} x The x coordinate origin for the cache region.
     * @param {Number} y The y coordinate origin for the cache region.
     * @param {Number} width The width of the cache region.
     * @param {Number} height The height of the cache region.
     * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape
     * using myShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and
     * rotate cached elements with greater fidelity. Default is 1.
     * @param {Object} [options] Specify additional parameters for the cache logic
     * @param {String|StageGL} [options.useGL] Select whether to use context 2D, or WebGL rendering, and
     * whether to make a new stage instance or use an existing one. See above for extensive details on use.
     */
    BitmapCache.prototype.define = function (target, x, y, width, height, scale, options) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (width === void 0) { width = 1; }
        if (height === void 0) { height = 1; }
        if (scale === void 0) { scale = 1; }
        if (!target) {
            throw "No symbol to cache";
        }
        this._options = options;
        this.target = target;
        this.width = Math.max(width, 1);
        this.height = Math.max(height, 1);
        this.x = x;
        this.y = y;
        this.scale = scale;
        this.update();
    };
    /**
     * Directly called via {@link easeljs.DisplayObject#updateCache}, but also internally. This
     * has the dual responsibility of making sure the surface is ready to be drawn to, and performing the draw. For
     * full details of each behaviour, check the protected functions {@link easeljs.BitmapCache#_updateSurface}
     * and {@link easeljs.BitmapCache#_drawToCache} respectively.
     * @param {String} [compositeOperation]
     */
    BitmapCache.prototype.update = function (compositeOperation) {
        if (!this.target) {
            throw "define() must be called before update()";
        }
        var filterBounds = BitmapCache.getFilterBounds(this.target);
        var surface = this._cacheCanvas;
        this._drawWidth = Math.ceil(this.width * this.scale) + filterBounds.Width;
        this._drawHeight = Math.ceil(this.height * this.scale) + filterBounds.Height;
        this._filterCount = this.target.filters && this.target.filters.reduce(BitmapCache.filterCounter, 0);
        if (!surface || this._drawWidth !== surface.Width || this._drawHeight !== surface.Height) {
            this._updateSurface();
        }
        if (this._stageGL) {
            if (this._bufferTextureOutput === null) {
                this._bufferTextureOutput = this._stageGL.getRenderBufferTexture(this._drawWidth, this._drawHeight);
            }
            else {
                this._stageGL.resizeTexture(this._bufferTextureOutput, this._drawWidth, this._drawHeight);
            }
            if (this._cacheCanvas === null) {
                this._cacheCanvas = this._bufferTextureOutput;
                this.disabled = this._disabled;
            }
            if (this._filterCount >= 1) {
                if (this._bufferTextureConcat === null) {
                    this._bufferTextureConcat = this._stageGL.getRenderBufferTexture(this._drawWidth, this._drawHeight);
                }
                else {
                    this._stageGL.resizeTexture(this._bufferTextureConcat, this._drawWidth, this._drawHeight);
                }
            }
        }
        this._filterOffX = filterBounds.X;
        this._filterOffY = filterBounds.Y;
        this.offX = this.x * this.scale + this._filterOffX;
        this.offY = this.y * this.scale + this._filterOffY;
        this._drawToCache(compositeOperation);
        this.cacheID = this.cacheID ? this.cacheID + 1 : 1;
    };
    /**
     * Reset and release all the properties and memory associated with this cache.
     */
    BitmapCache.prototype.release = function () {
        if (this._stageGL) {
            if (this._bufferTextureOutput !== null) {
                this._stageGL._killTextureObject(this._bufferTextureOutput);
            }
            if (this._bufferTextureConcat !== null) {
                this._stageGL._killTextureObject(this._bufferTextureConcat);
            }
            if (this._bufferTextureTemp !== null) {
                this._stageGL._killTextureObject(this._bufferTextureTemp);
            }
            // set the context to none and let the garbage collector get the rest when the canvas itself gets removed
            this._stageGL = false;
        }
        else {
            var stage = this.target.stage;
            if (stage instanceof _display_StageGL__WEBPACK_IMPORTED_MODULE_1__.StageGL) {
                stage.releaseTexture(this._cacheCanvas);
            }
        }
        this.disabled = true;
        this.target = this._cacheCanvas = null;
        this.cacheID = this._cacheDataURLID = this._cacheDataURL = undefined;
        this.width = this.height = this.x = this.y = this.offX = this.offY = 0;
        this.scale = 1;
    };
    /**
     * Returns a data URL for the cache, or `null` if this display object is not cached.
     * Uses {@link easeljs.BitmapCache#cacheID} to ensure a new data URL is not generated if the
     * cache has not changed.
     * @param {} type
     * @parap {} encoderOptions
     * @return {String} The image data url for the cache.
     */
    BitmapCache.prototype.getCacheDataURL = function (type, encoderOptions) {
        var cacheCanvas = this.target && this._cacheCanvas;
        if (!cacheCanvas) {
            return null;
        }
        if (this.cacheID !== this._cacheDataURLID) {
            this._cacheDataURLID = this.cacheID;
            this._cacheDataURL = cacheCanvas.toDataURL ? cacheCanvas.toDataURL(type, encoderOptions) : null;
        }
        return this._cacheDataURL;
    };
    /**
     * Use context2D drawing commands to display the cache canvas being used.
     * @param {CanvasRenderingContext2D} ctx The context to draw into.
     * @return {Boolean} Whether the draw was handled successfully.
     */
    BitmapCache.prototype.draw = function (ctx) {
        if (!this.target) {
            return false;
        }
        ctx.drawImage(this._cacheCanvas, this.x + (this._filterOffX / this.scale), this.y + (this._filterOffY / this.scale), this._drawWidth / this.scale, this._drawHeight / this.scale);
        return true;
    };
    /**
     * Determine the bounds of the shape in local space.
     * @method getBounds
     * @return {easeljs.Rectangle}
     */
    BitmapCache.prototype.getBounds = function () {
        var scale = this.scale;
        return this._boundRect.setValues(this.x, this.y, this.width / scale, this.height / scale);
    };
    /**
     * Fetch the correct filter in order, complicated by multipass filtering.
     * @param {Number} lookup The filter in the list to return
     */
    BitmapCache.prototype._getGLFilter = function (lookup) {
        if (this.target.filters === null || lookup < 0) {
            return;
        }
        var i = 0;
        var result = this.target.filters[i];
        while (result && --lookup >= 0) {
            result = result._multiPass ? result._multiPass : this.target.filters[++i];
        }
        return result;
    };
    /**
     * Create or resize the invisible canvas/surface that is needed for the display object(s) to draw to,
     * and in turn be used in their stead when drawing. The surface is resized to the size defined
     * by the width and height, factoring in scaling and filters. Adjust them to adjust the output size.
     * @protected
     */
    BitmapCache.prototype._updateSurface = function () {
        var surface;
        if (!this._options || !this._options.useGL) {
            surface = this._cacheCanvas;
            // create it if it's missing
            if (!surface) {
                surface = this._cacheCanvas = (0,_utils_Canvas__WEBPACK_IMPORTED_MODULE_2__.createCanvas)();
                this.disabled = this._disabled;
            }
            // now size it
            surface.width = this._drawWidth;
            surface.height = this._drawHeight;
            return;
        }
        // create it if it's missing
        if (!this._stageGL) {
            var useGL = this._options.useGL;
            if (useGL === "stage") {
                var targetStage = this.target.stage;
                // use the stage that this object belongs on as the WebGL context
                if (!(targetStage && targetStage.isWebGL)) {
                    throw "Cannot use 'stage' for cache because the object's parent stage is " + (targetStage ? "non WebGL." : "not set, please addChild to the correct stage.");
                }
                this._stageGL = targetStage;
            }
            else if (useGL === "new") {
                // create a new WebGL context to run this cache
                this._cacheCanvas = (0,_utils_Canvas__WEBPACK_IMPORTED_MODULE_2__.createCanvas)();
                // low autopurge in case of filter swapping and low texture count
                this._stageGL = new _display_StageGL__WEBPACK_IMPORTED_MODULE_1__.StageGL(this._cacheCanvas, { antialias: true, transparent: true, autoPurge: 10 });
                if (!this._stageGL._webGLContext) {
                    throw "GL cache asked for but unavailable";
                }
                this._stageGL.isCacheControlled = true; // use this flag to control stage sizing and final output
            }
            else if (useGL instanceof _display_StageGL__WEBPACK_IMPORTED_MODULE_1__.StageGL) {
                // use the provided WebGL context to run this cache, trust the user it works and is configured.
                this._stageGL = useGL;
            }
            else {
                throw "Invalid option provided to useGL, expected ['stage', 'new', StageGL], got '" + useGL + "'";
            }
        }
        this.disabled = this._disabled;
        // if we have a dedicated stage we've got to size it
        var stageGL = this._stageGL;
        if (stageGL.isCacheControlled) {
            surface = this._cacheCanvas;
            surface.width = this._drawWidth;
            surface.height = this._drawHeight;
            stageGL.updateViewport(this._drawWidth, this._drawHeight);
        }
    };
    /**
     * Perform the cache draw out for context 2D now that the setup properties have been performed.
     * @protected
     * @param {String} compositeOperation
     */
    BitmapCache.prototype._drawToCache = function (compositeOperation) {
        var surface = this._cacheCanvas;
        var target = this.target;
        var webGL = this._stageGL;
        if (webGL) {
            webGL.cacheDraw(target, this);
        }
        else {
            var ctx = surface.getContext("2d");
            if (!compositeOperation) {
                ctx.clearRect(0, 0, this._drawWidth + 1, this._drawHeight + 1);
            }
            ctx.save();
            ctx.globalCompositeOperation = compositeOperation;
            ctx.setTransform(this.scale, 0, 0, this.scale, -this._filterOffX, -this._filterOffY);
            ctx.translate(-this.x, -this.y);
            target.draw(ctx, true);
            ctx.restore();
            if (target.filters && target.filters.length) {
                this._applyFilters(ctx);
            }
        }
        surface._invalid = true;
    };
    /**
     * Work through every filter and apply its individual visual transformation.
     * @protected
     * @param {} ctx
     */
    BitmapCache.prototype._applyFilters = function (ctx) {
        var filters = this.target.filters;
        var w = this._drawWidth;
        var h = this._drawHeight;
        var data;
        var i = 0, filter = filters[i];
        do {
            // this is safe because we wouldn't be in apply filters without a filter count of at least 1
            if (filter.usesContext) {
                if (data) {
                    ctx.putImageData(data, 0, 0);
                    data = null;
                }
                filter.applyFilter(ctx, 0, 0, w, h);
            }
            else {
                if (!data) {
                    data = ctx.getImageData(0, 0, w, h);
                }
                filter._applyFilter(data);
            }
            // work through the multipass if it's there, otherwise move on
            filter = filter._multiPass !== null ? filter._multiPass : filters[++i];
        } while (filter);
        // done
        if (data) {
            ctx.putImageData(data, 0, 0);
        }
    };
    return BitmapCache;
}());



/***/ }),

/***/ "./src/drawing/scene/geom/DisplayProps.ts":
/*!************************************************!*\
  !*** ./src/drawing/scene/geom/DisplayProps.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DisplayProps": () => (/* binding */ DisplayProps)
/* harmony export */ });
/* harmony import */ var _Matrix2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix2D */ "./src/drawing/scene/geom/Matrix2D.ts");

/**
 * Used for calculating and encapsulating display related properties.
 * @memberof easeljs
 * @param {Number} [visible] Visible value.
 * @param {Number} [alpha] Alpha value.
 * @param {Number} [shadow] A Shadow instance or null.
 * @param {Number} [compositeOperation] A compositeOperation value or null.
 * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.
 */
var DisplayProps = /** @class */ (function () {
    function DisplayProps(visible, alpha, shadow, compositeOperation, matrix) {
        if (visible === void 0) { visible = true; }
        if (alpha === void 0) { alpha = 1; }
        this.visible = false;
        this.alpha = 0;
        this.shadow = undefined;
        this.compositeOperation = null;
        this.matrix = undefined;
        this.setValues(visible, alpha, shadow, compositeOperation, matrix);
        // assigned in the setValues method.
        /**
         * Property representing the alpha that will be applied to a display object.
         * @property alpha
         * @type {Number}
         */
        /**
         * Property representing the shadow that will be applied to a display object.
         * @property shadow
         * @type {easeljs.Shadow}
         */
        /**
         * Property representing the compositeOperation that will be applied to a display object.
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing}
         * @property compositeOperation
         * @type {String}
         */
        /**
         * Property representing the value for visible that will be applied to a display object.
         * @property visible
         * @type {Boolean}
         */
        /**
         * The transformation matrix that will be applied to a display object.
         * @property matrix
         * @type {easeljs.Matrix2D}
         */
    }
    /**
     * Reinitializes the instance with the specified values.
     * @param {Number} [visible=true] Visible value.
     * @param {Number} [alpha=1] Alpha value.
     * @param {Number} [shadow] A Shadow instance or null.
     * @param {Number} [compositeOperation] A compositeOperation value or null.
     * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.
     * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.
     * @chainable
    */
    DisplayProps.prototype.setValues = function (visible, alpha, shadow, compositeOperation, matrix) {
        if (visible === void 0) { visible = true; }
        if (alpha === void 0) { alpha = 1; }
        this.visible = visible;
        this.alpha = alpha;
        this.shadow = shadow;
        this.compositeOperation = compositeOperation;
        this.matrix = matrix || (this.matrix && this.matrix.identity()) || new _Matrix2D__WEBPACK_IMPORTED_MODULE_0__.Matrix2D();
        return this;
    };
    /**
     * Appends the specified display properties. This is generally used to apply a child's properties its parent's.
     * @param {Boolean} visible desired visible value
     * @param {Number} alpha desired alpha value
     * @param {easeljs.Shadow} shadow desired shadow value
     * @param {String} compositeOperation desired composite operation value
     * @param {easeljs.Matrix2D} [matrix] a Matrix2D instance
     * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.
     * @chainable
    */
    DisplayProps.prototype.append = function (visible, alpha, shadow, compositeOperation, matrix) {
        this.alpha *= alpha;
        this.shadow = shadow || this.shadow;
        this.compositeOperation = compositeOperation || this.compositeOperation;
        this.visible = this.visible && visible;
        matrix && this.matrix.appendMatrix(matrix);
        return this;
    };
    /**
     * Prepends the specified display properties. This is generally used to apply a parent's properties to a child's.
     * For example, to get the combined display properties that would be applied to a child, you could use:
     *
     * @example
     * let o = displayObject;
     * let props = new DisplayProps();
     * do {
     * 	 // prepend each parent's props in turn:
     * 	 props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());
     * } while (o = o.parent);
     *
     * @param {Boolean} visible desired visible value
     * @param {Number} alpha desired alpha value
     * @param {easeljs.Shadow} shadow desired shadow value
     * @param {String} compositeOperation desired composite operation value
     * @param {easeljs.Matrix2D} [matrix] a Matrix2D instance
     * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.
     * @chainable
    */
    DisplayProps.prototype.prepend = function (visible, alpha, shadow, compositeOperation, matrix) {
        this.alpha *= alpha;
        this.shadow = this.shadow || shadow;
        this.compositeOperation = this.compositeOperation || compositeOperation;
        this.visible = this.visible && visible;
        matrix && this.matrix.prependMatrix(matrix);
        return this;
    };
    /**
     * Resets this instance and its matrix to default values.
     * @return {easeljs.DisplayProps} This instance. Useful for chaining method calls.
     * @chainable
    */
    DisplayProps.prototype.identity = function () {
        this.visible = true;
        this.alpha = 1;
        this.shadow = this.compositeOperation = null;
        this.matrix.identity();
        return this;
    };
    /**
     * Returns a clone of the DisplayProps instance. Clones the associated matrix.
     * @return {easeljs.DisplayProps} a clone of the DisplayProps instance.
     */
    DisplayProps.prototype.clone = function () {
        return new DisplayProps(this.visible, this.alpha, this.shadow, this.compositeOperation, this.matrix.clone());
    };
    return DisplayProps;
}());



/***/ }),

/***/ "./src/drawing/scene/geom/Matrix2D.ts":
/*!********************************************!*\
  !*** ./src/drawing/scene/geom/Matrix2D.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Matrix2D": () => (/* binding */ Matrix2D)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.
 *
 * <pre>
 * This matrix can be visualized as:
 *
 * 	[ a  c  tx
 * 	 b  d  ty
 * 	0  0  1  ]
 *
 * Note the locations of b and c.
 * </pre>
 *
 * @param {Number} [a] Specifies the a property for the new matrix.
 * @param {Number} [b] Specifies the b property for the new matrix.
 * @param {Number} [c] Specifies the c property for the new matrix.
 * @param {Number} [d] Specifies the d property for the new matrix.
 * @param {Number} [tx] Specifies the tx property for the new matrix.
 * @param {Number} [ty] Specifies the ty property for the new matrix.
 */
var Matrix2D = /** @class */ (function () {
    function Matrix2D(a, b, c, d, tx, ty) {
        if (a === void 0) { a = 1; }
        if (b === void 0) { b = 0; }
        if (c === void 0) { c = 0; }
        if (d === void 0) { d = 1; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        this.a = 0;
        this.b = 0;
        this.c = 0;
        this.d = 0;
        this.tx = 0;
        this.ty = 0;
        this.setValues(a, b, c, d, tx, ty);
        // assigned in the setValues method.
        /**
         * Position (0, 0) in a 3x3 affine transformation matrix.
         * @property a
         * @type {Number}
         */
        /**
         * Position (0, 1) in a 3x3 affine transformation matrix.
         * @property b
         * @type {Number}
         */
        /**
         * Position (1, 0) in a 3x3 affine transformation matrix.
         * @property c
         * @type {Number}
         */
        /**
         * Position (1, 1) in a 3x3 affine transformation matrix.
         * @property d
         * @type {Number}
         */
        /**
         * Position (2, 0) in a 3x3 affine transformation matrix.
         * @property tx
         * @type {Number}
         */
        /**
         * Position (2, 1) in a 3x3 affine transformation matrix.
         * @property ty
         * @type {Number}
         */
    }
    /**
     * Sets the specified values on this instance.
     * @param {Number} [a=1] Specifies the a property for the new matrix.
     * @param {Number} [b=0] Specifies the b property for the new matrix.
     * @param {Number} [c=0] Specifies the c property for the new matrix.
     * @param {Number} [d=1] Specifies the d property for the new matrix.
     * @param {Number} [tx=0] Specifies the tx property for the new matrix.
     * @param {Number} [ty=0] Specifies the ty property for the new matrix.
     * @return {Matrix2D} This instance. Useful for chaining method calls.
     * @chainable
    */
    Matrix2D.prototype.setValues = function (a, b, c, d, tx, ty) {
        // don't forget to update docs in the constructor if these change:
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
    };
    /**
     * Appends the specified matrix properties to this matrix. All parameters are required.
     * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
     * @param {Number} a
     * @param {Number} b
     * @param {Number} c
     * @param {Number} d
     * @param {Number} tx
     * @param {Number} ty
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
     */
    Matrix2D.prototype.append = function (a, b, c, d, tx, ty) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        if (a !== 1 || b !== 0 || c !== 0 || d !== 1) {
            this.a = a1 * a + c1 * b;
            this.b = b1 * a + d1 * b;
            this.c = a1 * c + c1 * d;
            this.d = b1 * c + d1 * d;
        }
        this.tx = a1 * tx + c1 * ty + this.tx;
        this.ty = b1 * tx + d1 * ty + this.ty;
        return this;
    };
    ;
    /**
     * Prepends the specified matrix properties to this matrix.
     * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
     * @param {Number} a
     * @param {Number} b
     * @param {Number} c
     * @param {Number} d
     * @param {Number} tx
     * @param {Number} ty
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
     */
    Matrix2D.prototype.prepend = function (a, b, c, d, tx, ty) {
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = a * a1 + c * this.b;
        this.b = b * a1 + d * this.b;
        this.c = a * c1 + c * this.d;
        this.d = b * c1 + d * this.d;
        this.tx = a * tx1 + c * this.ty + tx;
        this.ty = b * tx1 + d * this.ty + ty;
        return this;
    };
    /**
     * Appends the specified matrix to this matrix.
     * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
     * @param {Matrix2D} matrix
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
     */
    Matrix2D.prototype.appendMatrix = function (matrix) {
        return this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
    };
    /**
     * Prepends the specified matrix to this matrix.
     * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
     *
     * @example <caption>Calculate the combined transformation for a child object</caption>
     * let o = displayObject;
     * let mtx = o.getMatrix();
     * while (o = o.parent) {
     * 	 // prepend each parent's transformation in turn:
     * 	 o.prependMatrix(o.getMatrix());
     * }
     *
     * @param {Matrix2D} matrix
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
     */
    Matrix2D.prototype.prependMatrix = function (matrix) {
        return this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
    };
    /**
     * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.
     *
     * @example <caption>Generate a matrix representing the transformations of a display object</caption>
     * let mtx = new Matrix2D();
     * mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
     *
     * @param {Number} x
     * @param {Number} y
     * @param {Number} scaleX
     * @param {Number} scaleY
     * @param {Number} rotation
     * @param {Number} skewX
     * @param {Number} skewY
     * @param {Number} [regX]
     * @param {Number} [regY]
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
     */
    Matrix2D.prototype.appendTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
        var r, cos, sin;
        if (rotation % 360) {
            r = rotation * Matrix2D.DEG_TO_RAD;
            cos = Math.cos(r);
            sin = Math.sin(r);
        }
        else {
            cos = 1;
            sin = 0;
        }
        if (skewX || skewY) {
            // TODO: can this be combined into a single append operation?
            skewX *= Matrix2D.DEG_TO_RAD;
            skewY *= Matrix2D.DEG_TO_RAD;
            this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
            this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);
        }
        else {
            this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);
        }
        if (regX || regY) {
            // append the registration offset:
            this.tx -= regX * this.a + regY * this.c;
            this.ty -= regX * this.b + regY * this.d;
        }
        return this;
    };
    /**
     * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.
     *
     * Note that the above example would not account for {@link DisplayObject#transformMatrix} values.
     * See {@link Matrix2D#prependMatrix} for an example that does.
     *
     * @example <caption>Calculate the combined transformation for a child object</caption>
     * let o = displayObject;
     * let mtx = new Matrix2D();
     * do  {
     * 	 // prepend each parent's transformation in turn:
     * 	 mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
     * } while (o = o.parent);
     *
     * @param {Number} x
     * @param {Number} y
     * @param {Number} scaleX
     * @param {Number} scaleY
     * @param {Number} rotation
     * @param {Number} skewX
     * @param {Number} skewY
     * @param {Number} [regX]
     * @param {Number} [regY]
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     */
    Matrix2D.prototype.prependTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
        var r, cos, sin;
        if (rotation % 360) {
            r = rotation * Matrix2D.DEG_TO_RAD;
            cos = Math.cos(r);
            sin = Math.sin(r);
        }
        else {
            cos = 1;
            sin = 0;
        }
        if (regX || regY) {
            // prepend the registration offset:
            this.tx -= regX;
            this.ty -= regY;
        }
        if (skewX || skewY) {
            // TODO: can this be combined into a single prepend operation?
            skewX *= Matrix2D.DEG_TO_RAD;
            skewY *= Matrix2D.DEG_TO_RAD;
            this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);
            this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
        }
        else {
            this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);
        }
        return this;
    };
    /**
     * Applies a clockwise rotation transformation to the matrix.
     * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `Math.PI/180`.
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
     */
    Matrix2D.prototype.rotate = function (angle) {
        angle *= Matrix2D.DEG_TO_RAD;
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var b1 = this.b;
        this.a = a1 * cos + this.c * sin;
        this.b = b1 * cos + this.d * sin;
        this.c = -a1 * sin + this.c * cos;
        this.d = -b1 * sin + this.d * cos;
        return this;
    };
    /**
     * Applies a skew transformation to the matrix.
     * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `Math.PI/180`.
     * @param {Number} skewY The amount to skew vertically in degrees.
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
    */
    Matrix2D.prototype.skew = function (skewX, skewY) {
        skewX *= Matrix2D.DEG_TO_RAD;
        skewY *= Matrix2D.DEG_TO_RAD;
        this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
        return this;
    };
    /**
     * Applies a scale transformation to the matrix.
     * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.
     * @param {Number} y The amount to scale vertically.
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
     */
    Matrix2D.prototype.scale = function (x, y) {
        this.a *= x;
        this.b *= x;
        this.c *= y;
        this.d *= y;
        //this.tx *= x;
        //this.ty *= y;
        return this;
    };
    /**
     * Translates the matrix on the x and y axes.
     * @param {Number} x
     * @param {Number} y
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
     */
    Matrix2D.prototype.translate = function (x, y) {
        this.tx += this.a * x + this.c * y;
        this.ty += this.b * x + this.d * y;
        return this;
    };
    /**
     * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
     */
    Matrix2D.prototype.identity = function () {
        this.a = this.d = 1;
        this.b = this.c = this.tx = this.ty = 0;
        return this;
    };
    /**
     * Inverts the matrix, causing it to perform the opposite transformation.
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
     */
    Matrix2D.prototype.invert = function () {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = a1 * d1 - b1 * c1;
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = (c1 * this.ty - d1 * tx1) / n;
        this.ty = -(a1 * this.ty - b1 * tx1) / n;
        return this;
    };
    /**
     * Returns true if the matrix is an identity matrix.
     * @return {Boolean}
     */
    Matrix2D.prototype.isIdentity = function () {
        return this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;
    };
    /**
     * Returns true if this matrix is equal to the specified matrix (all property values are equal).
     * @param {Matrix2D} matrix The matrix to compare.
     * @return {Boolean}
     */
    Matrix2D.prototype.equals = function (matrix) {
        return this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;
    };
    /**
     * Transforms a point according to this matrix.
     * @param {Number} x The x component of the point to transform.
     * @param {Number} y The y component of the point to transform.
     * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.
     * @return {Point} This matrix. Useful for chaining method calls.
     */
    Matrix2D.prototype.transformPoint = function (x, y, pt) {
        if (pt === void 0) { pt = new _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGPoint(); }
        pt.X = x * this.a + y * this.c + this.tx;
        pt.Y = x * this.b + y * this.d + this.ty;
        return pt;
    };
    /**
     * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values
     * may not match the transform properties you used to generate the matrix, though they will produce the same visual
     * results.
     * @param {Object} [target] The object to apply the transform properties to. If null, then a new object will be returned.
     * @return {Object} The target, or a new generic object with the transform properties applied.
    */
    Matrix2D.prototype.decompose = function (target) {
        if (target === void 0) { target = {}; }
        // TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative
        target.x = this.tx;
        target.y = this.ty;
        target.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
        target.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);
        var skewX = Math.atan2(-this.c, this.d);
        var skewY = Math.atan2(this.b, this.a);
        var delta = Math.abs(1 - skewX / skewY);
        if (delta < 0.00001) { // effectively identical, can use rotation:
            target.rotation = skewY / Matrix2D.DEG_TO_RAD;
            if (this.a < 0 && this.d >= 0) {
                target.rotation += (target.rotation <= 0) ? 180 : -180;
            }
            target.skewX = target.skewY = 0;
        }
        else {
            target.skewX = skewX / Matrix2D.DEG_TO_RAD;
            target.skewY = skewY / Matrix2D.DEG_TO_RAD;
        }
        return target;
    };
    /**
     * Copies all properties from the specified matrix to this matrix.
     * @param {Matrix2D} matrix The matrix to copy properties from.
     * @return {Matrix2D} This matrix. Useful for chaining method calls.
     * @chainable
    */
    Matrix2D.prototype.copy = function (matrix) {
        return this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
    };
    /**
     * Returns a clone of the Matrix2D instance.
     * @return {Matrix2D} a clone of the Matrix2D instance.
     */
    Matrix2D.prototype.clone = function () {
        return new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);
    };
    /**
     * Returns a string representation of this object.
     * @return {String} a string representation of the instance.
     */
    Matrix2D.prototype.toString = function () {
        return "[" + this.constructor.name + " (a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + ")]";
    };
    /**
     * Multiplier for converting degrees to radians. Used internally by Matrix2D.
     * @static
     * @type {Number}
     * @readonly
     */
    Matrix2D.DEG_TO_RAD = Math.PI / 180;
    /**
     * An identity matrix, representing a null transformation.
     * @static
     * @type {Matrix2D}
     * @readonly
     */
    Matrix2D.identity = new Matrix2D();
    return Matrix2D;
}());



/***/ }),

/***/ "./src/drawing/scene/index.ts":
/*!************************************!*\
  !*** ./src/drawing/scene/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Matrix2D": () => (/* reexport safe */ _geom_Matrix2D__WEBPACK_IMPORTED_MODULE_0__.Matrix2D),
/* harmony export */   "DisplayProps": () => (/* reexport safe */ _geom_DisplayProps__WEBPACK_IMPORTED_MODULE_1__.DisplayProps),
/* harmony export */   "Stage": () => (/* reexport safe */ _display_Stage__WEBPACK_IMPORTED_MODULE_2__.Stage),
/* harmony export */   "Container": () => (/* reexport safe */ _display_Container__WEBPACK_IMPORTED_MODULE_3__.Container),
/* harmony export */   "DisplayObject": () => (/* reexport safe */ _display_DisplayObject__WEBPACK_IMPORTED_MODULE_4__.DisplayObject),
/* harmony export */   "VGraphics": () => (/* reexport safe */ _display_Graphics__WEBPACK_IMPORTED_MODULE_5__.Graphics),
/* harmony export */   "Shape": () => (/* reexport safe */ _display_Shape__WEBPACK_IMPORTED_MODULE_6__.Shape),
/* harmony export */   "Text": () => (/* reexport safe */ _display_Text__WEBPACK_IMPORTED_MODULE_7__.Text),
/* harmony export */   "SceneBitmap": () => (/* reexport safe */ _display_Bitmap__WEBPACK_IMPORTED_MODULE_8__.SceneBitmap),
/* harmony export */   "uid": () => (/* reexport safe */ _utils_uid__WEBPACK_IMPORTED_MODULE_9__.uid),
/* harmony export */   "createCanvas": () => (/* reexport safe */ _utils_Canvas__WEBPACK_IMPORTED_MODULE_10__.createCanvas),
/* harmony export */   "VideoBuffer": () => (/* reexport safe */ _utils_VideoBuffer__WEBPACK_IMPORTED_MODULE_11__.VideoBuffer),
/* harmony export */   "Ease": () => (/* reexport safe */ _tween__WEBPACK_IMPORTED_MODULE_12__.Ease),
/* harmony export */   "Tween": () => (/* reexport safe */ _tween__WEBPACK_IMPORTED_MODULE_12__.Tween)
/* harmony export */ });
/* harmony import */ var _geom_Matrix2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geom/Matrix2D */ "./src/drawing/scene/geom/Matrix2D.ts");
/* harmony import */ var _geom_DisplayProps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geom/DisplayProps */ "./src/drawing/scene/geom/DisplayProps.ts");
/* harmony import */ var _display_Stage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./display/Stage */ "./src/drawing/scene/display/Stage.ts");
/* harmony import */ var _display_Container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./display/Container */ "./src/drawing/scene/display/Container.ts");
/* harmony import */ var _display_DisplayObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./display/DisplayObject */ "./src/drawing/scene/display/DisplayObject.ts");
/* harmony import */ var _display_Graphics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./display/Graphics */ "./src/drawing/scene/display/Graphics.ts");
/* harmony import */ var _display_Shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./display/Shape */ "./src/drawing/scene/display/Shape.ts");
/* harmony import */ var _display_Text__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./display/Text */ "./src/drawing/scene/display/Text.ts");
/* harmony import */ var _display_Bitmap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./display/Bitmap */ "./src/drawing/scene/display/Bitmap.ts");
/* harmony import */ var _utils_uid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/uid */ "./src/drawing/scene/utils/uid.ts");
/* harmony import */ var _utils_Canvas__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/Canvas */ "./src/drawing/scene/utils/Canvas.ts");
/* harmony import */ var _utils_VideoBuffer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/VideoBuffer */ "./src/drawing/scene/utils/VideoBuffer.ts");
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tween */ "./src/drawing/scene/tween/index.ts");


// display







//utils






/***/ }),

/***/ "./src/drawing/scene/tween/AbstractTween.ts":
/*!**************************************************!*\
  !*** ./src/drawing/scene/tween/AbstractTween.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractTween": () => (/* binding */ AbstractTween)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Tween__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Tween */ "./src/drawing/scene/tween/Tween.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var AbstractTween = /** @class */ (function (_super) {
    __extends(AbstractTween, _super);
    function AbstractTween(props) {
        var _this = _super.call(this) || this;
        _this.tweens = undefined;
        /**
         * Causes this tween to continue playing when a global pause is active. For example, if TweenJS is using {@link core.Ticker},
         * then setting this to false (the default) will cause this tween to be paused when `Ticker.setPaused(true)`
         * is called. See the {@link tweenjs.Tween#tick} method for more info. Can be set via the `props` parameter.
         * @type {Boolean}
         * @default false
         */
        _this.ignoreGlobalPause = false;
        /**
         * Indicates the number of times to loop. If set to -1, the tween will loop continuously.
         * @type {Number}
         * @default 0
         */
        _this.loop = 0;
        /**
         * Uses ticks for all durations instead of milliseconds. This also changes the behaviour of some actions (such as `call`).
         * Changing this value on a running tween could have unexpected results.
         * @type {Boolean}
         * @default false
         * @readonly
         */
        _this.useTicks = false;
        /**
         * Causes the tween to play in reverse.
         * @type {Boolean}
         * @default false
         */
        _this.reversed = false;
        /**
         * Causes the tween to reverse direction at the end of each loop.
         * @type {Boolean}
         * @default false
         */
        _this.bounce = false;
        /**
         * Changes the rate at which the tween advances. For example, a `timeScale` value of `2` will double the
         * playback speed, a value of `0.5` would halve it.
         * @type {Number}
         * @default 1
         */
        _this.timeScale = 1;
        /**
         * Indicates the duration of this tween in milliseconds (or ticks if `useTicks` is true), irrespective of `loops`.
         * This value is automatically updated as you modify the tween. Changing it directly could result in unexpected
         * behaviour.
         * @type {Number}
         * @default 0
         * @readonly
         */
        _this.duration = 0;
        /**
         * The current normalized position of the tween. This will always be a value between 0 and `duration`.
         * Changing this property directly will have unexpected results, use {@link tweenjs.Tween#setPosition}.
         * @type {Object}
         * @default 0
         * @readonly
         */
        _this.position = 0;
        /**
         * The raw tween position. This value will be between `0` and `loops * duration` while the tween is active, or -1 before it activates.
         * @type {Number}
         * @default -1
         * @readonly
         */
        _this.rawPosition = -1;
        /**
         * @private
         * @default false
         */
        _this._paused = true;
        /**
         * @private
         * @type {Tween}
         * @default null
         */
        _this._next = null;
        /**
         * @private
         * @type {Tween}
         * @default null
         */
        _this._prev = null;
        /**
         * @private
         * @type {Object}
         * @default null
         */
        _this._parent = null;
        /**
         * @private
         * @type {Object}
         */
        _this._labels = null;
        /**
         * @private
         * @type {Object[]}
         */
        _this._labelList = null;
        /**
         * Status in tick list:
         * 0 = in list
         * 1 = added to list in the current tick stack
         * -1 = remvoed from list (or to be removed in this tick stack)
         * @type {Number}
         * @default -1
         * @protected
         */
        _this._status = -1;
        /**
         * Tick id compared to Tween._inTick when removing tweens from the tick list in a tick stack.
         * @type {Number}
         * @default 0
         * @protected
         */
        _this._lastTick = 0;
        if (props) {
            _this.useTicks = !!props.useTicks;
            _this.ignoreGlobalPause = !!props.ignoreGlobalPause;
            _this.loop = props.loop === true ? -1 : (props.loop || 0);
            _this.reversed = !!props.reversed;
            _this.bounce = !!props.bounce;
            _this.timeScale = props.timeScale || 1;
            props.onChange && _this.addEventListener("change", props.onChange);
            props.onComplete && _this.addEventListener("complete", props.onComplete);
        }
        return _this;
        // while `position` is shared, it needs to happen after ALL props are set, so it's handled in _init()
    }
    Object.defineProperty(AbstractTween.prototype, "labels", {
        /**
         * Returns a list of the labels defined on this tween sorted by position.
         * @type {Object[]}
         */
        get: function () {
            var list = this._labelList;
            if (!list) {
                list = this._labelList = [];
                var labels = this._labels;
                for (var label in labels) {
                    list.push({ label: label, position: labels[label] });
                }
                list.sort(function (a, b) { return a.position - b.position; });
            }
            return list;
        },
        set: function (labels) {
            this._labels = labels;
            this._labelList = null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractTween.prototype, "currentLabel", {
        /**
         * Returns the name of the label on or immediately before the current position. For example, given a tween with
         * two labels, "first" on frame index 4, and "second" on frame 8, currentLabel would return:
         * <ul>
         *   <li>null if the current position is 2.</li>
         *   <li>"first" if the current position is 4.</li>
         *   <li>"first" if the current position is 7.</li>
         *   <li>"second" if the current position is 15.</li>
         * </ul>
         * @type {String}
         * @readonly
         */
        get: function () {
            var labels = this.labels;
            var pos = this.position;
            var i = 0;
            for (var l = labels.length; i < l; i++) {
                if (pos < labels[i].position) {
                    break;
                }
            }
            return (i === 0) ? null : labels[i - 1].label;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractTween.prototype, "paused", {
        /**
         * Pauses or unpauses the tween. A paused tween is removed from the global registry and is eligible for garbage collection
         * if no other references to it exist.
         * @type {Boolean}
           */
        get: function () {
            return this._paused;
        },
        set: function (paused) {
            _Tween__WEBPACK_IMPORTED_MODULE_1__.Tween._register(this, paused);
            this._paused = paused;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Advances the tween by a specified amount.	 *
     * @param {Number} delta The amount to advance in milliseconds (or ticks if useTicks is true). Negative values are supported.
     * @param {Boolean} [ignoreActions=false] If true, actions will not be executed due to this change in position.
     */
    AbstractTween.prototype.advance = function (delta, ignoreActions) {
        if (ignoreActions === void 0) { ignoreActions = false; }
        this.setPosition(this.rawPosition + delta * this.timeScale, ignoreActions);
    };
    /**
     * Advances the tween to a specified position.
     *
     * @emits tweenjs.AbstractTween#event:change
     * @emits tweenjs.AbstractTween#event:complete
     *
     * @param {Number} rawPosition The raw position to seek to in milliseconds (or ticks if useTicks is true).
     * @param {Boolean} [ignoreActions=false] If true, do not run any actions that would be triggered by this operation.
     * @param {Boolean} [jump=false] If true, only actions at the new position will be run. If false, actions between the old and new position are run.
     * @param {Function} [callback] Primarily for use with MovieClip, this callback is called after properties are updated, but before actions are run.
     */
    AbstractTween.prototype.setPosition = function (rawPosition, ignoreActions, jump, callback) {
        if (ignoreActions === void 0) { ignoreActions = false; }
        if (jump === void 0) { jump = false; }
        var d = this.duration, loopCount = this.loop, prevRawPos = this.rawPosition;
        var loop = 0, t = 0, end = false;
        // normalize position:
        if (rawPosition < 0) {
            rawPosition = 0;
        }
        if (d === 0) {
            // deal with 0 length tweens.
            end = true;
            if (prevRawPos !== -1) {
                return end;
            } // we can avoid doing anything else if we're already at 0.
        }
        else {
            loop = rawPosition / d | 0;
            t = rawPosition - loop * d;
            end = (loopCount !== -1 && rawPosition >= loopCount * d + d);
            if (end) {
                rawPosition = (t = d) * (loop = loopCount) + d;
            }
            if (rawPosition === prevRawPos) {
                return end;
            } // no need to update
            // current loop is reversed
            if (!this.reversed !== !(this.bounce && loop % 2)) {
                t = d - t;
            }
        }
        // set this in advance in case an action modifies position:
        this.position = t;
        this.rawPosition = rawPosition;
        this._updatePosition(jump, end);
        if (end) {
            this.paused = true;
        }
        callback && callback(this);
        if (!ignoreActions) {
            this._runActions(prevRawPos, rawPosition, jump, !jump && prevRawPos === -1);
        }
        this.dispatchEvent("change");
        if (end) {
            this.dispatchEvent("complete");
        }
    };
    /**
     * Calculates a normalized position based on a raw position.
     *
     * @example
     * // given a tween with a duration of 3000ms set to loop:
     * console.log(myTween.calculatePosition(3700); // 700
     *
     * @param {Number} rawPosition A raw position.
     */
    AbstractTween.prototype.calculatePosition = function (rawPosition) {
        // largely duplicated from setPosition, but necessary to avoid having to instantiate generic objects to pass values (end, loop, position) back.
        var d = this.duration, loopCount = this.loop;
        var loop = 0, t = 0;
        if (d === 0) {
            return 0;
        }
        if (loopCount !== -1 && rawPosition >= loopCount * d + d) {
            t = d;
            loop = loopCount;
        }
        else if (rawPosition < 0) {
            t = 0;
        }
        else {
            loop = rawPosition / d | 0;
            t = rawPosition - loop * d;
        }
        return (!this.reversed !== !(this.bounce && loop % 2)) ? d - t : t;
    };
    /**
     * Adds a label that can be used with {@link tweenjs.Timeline#gotoAndPlay}/{@link tweenjs.Timeline#gotoAndStop}.
     *
     * @param {String} label The label name.
     * @param {Number} position The position this label represents.
     */
    AbstractTween.prototype.addLabel = function (label, position) {
        if (!this._labels) {
            this._labels = {};
        }
        this._labels[label] = position;
        var list = this._labelList;
        if (list) {
            var i = 0;
            for (var l = list.length; i < l; i++) {
                if (position < list[i].position) {
                    break;
                }
            }
            list.splice(i, 0, { label: label, position: position });
        }
    };
    /**
     * Unpauses this timeline and jumps to the specified position or label.
     *
     * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)
     * or label to jump to.
     */
    AbstractTween.prototype.gotoAndPlay = function (positionOrLabel) {
        this.paused = false;
        this._goto(positionOrLabel);
    };
    /**
     * Pauses this timeline and jumps to the specified position or label.
     *
     * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label
     * to jump to.
     */
    AbstractTween.prototype.gotoAndStop = function (positionOrLabel) {
        this.paused = true;
        this._goto(positionOrLabel);
    };
    /**
     * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the
     * corresponding frame label will be returned, or `null` if a matching label is not defined.
     *
     * @param {String|Number} positionOrLabel A numeric position value or label String.
     */
    AbstractTween.prototype.resolve = function (positionOrLabel) {
        var pos = Number(positionOrLabel);
        return isNaN(pos) ? this._labels && this._labels[positionOrLabel] : pos;
    };
    /**
     * Returns a string representation of this object.
     *
     * @return {String} a string representation of the instance.
     */
    AbstractTween.prototype.toString = function () {
        return "[" + this.constructor.name + (this.name ? " (name=" + this.name + ")" : "") + "]";
    };
    /**
     * @throws AbstractTween cannot be cloned.
     */
    AbstractTween.prototype.clone = function () {
        throw "AbstractTween cannot be cloned.";
    };
    /**
     * Shared logic that executes at the end of the subclass constructor.
     *
     * @private
     *
     * @param {Object} [props]
     */
    AbstractTween.prototype._init = function (props) {
        if (!props || !props.paused) {
            this.paused = false;
        }
        if (props && props.position != null) {
            this.setPosition(props.position);
        }
    };
    /**
     * @private
     * @param {String|Number} positionOrLabel
     */
    AbstractTween.prototype._goto = function (positionOrLabel) {
        var pos = this.resolve(positionOrLabel);
        if (pos != null) {
            this.setPosition(pos, false, true);
        }
    };
    /**
   * Runs actions between startPos & endPos. Separated to support action deferral.
   *
     * @private
     *
     * @param {Number} startRawPos
     * @param {Number} endRawPos
     * @param {Boolean} jump
     * @param {Boolean} includeStart
     */
    AbstractTween.prototype._runActions = function (startRawPos, endRawPos, jump, includeStart) {
        // console.log(this.passive === false ? " > Tween" : "Timeline", "run", startRawPos, endRawPos, jump, includeStart);
        // if we don't have any actions, and we're not a Timeline, then return:
        // TODO: a cleaner way to handle this would be to override this method in Tween, but I'm not sure it's worth the overhead.
        if (!this._actionHead && !this.tweens) {
            return;
        }
        var d = this.duration, loopCount = this.loop;
        var reversed = this.reversed, bounce = this.bounce;
        var loop0, loop1, t0, t1;
        if (d === 0) {
            // deal with 0 length tweens:
            loop0 = loop1 = t0 = t1 = 0;
            reversed = bounce = false;
        }
        else {
            loop0 = startRawPos / d | 0;
            loop1 = endRawPos / d | 0;
            t0 = startRawPos - loop0 * d;
            t1 = endRawPos - loop1 * d;
        }
        // catch positions that are past the end:
        if (loopCount !== -1) {
            if (loop1 > loopCount) {
                t1 = d;
                loop1 = loopCount;
            }
            if (loop0 > loopCount) {
                t0 = d;
                loop0 = loopCount;
            }
        }
        // special cases:
        if (jump) {
            return this._runActionsRange(t1, t1, jump, includeStart);
        } // jump.
        else if (loop0 === loop1 && t0 === t1 && !jump && !includeStart) {
            return;
        } // no actions if the position is identical and we aren't including the start
        else if (loop0 === -1) {
            loop0 = t0 = 0;
        } // correct the -1 value for first advance, important with useTicks.
        var dir = (startRawPos <= endRawPos);
        var loop = loop0;
        do {
            var rev = !reversed !== !(bounce && loop % 2);
            var start = (loop === loop0) ? t0 : dir ? 0 : d;
            var end = (loop === loop1) ? t1 : dir ? d : 0;
            if (rev) {
                start = d - start;
                end = d - end;
            }
            if (bounce && loop !== loop0 && start === end) { /* bounced onto the same time/frame, don't re-execute end actions */ }
            else if (this._runActionsRange(start, end, jump, includeStart || (loop !== loop0 && !bounce))) {
                return true;
            }
            includeStart = false;
        } while ((dir && ++loop <= loop1) || (!dir && --loop >= loop1));
    };
    /**
     * @private
     * @abstract
     * @throws Must be overridden by a subclass.
       */
    AbstractTween.prototype._runActionsRange = function (startPos, endPos, jump, includeStart) {
        throw "_runActionsRange is abstract and must be overridden by a subclass.";
    };
    /**
       * @private
     * @abstract
     * @throws Must be overridden by a subclass.
       */
    AbstractTween.prototype._updatePosition = function (jump, end) {
        throw "_updatePosition is abstract and must be overridden by a subclass.";
    };
    return AbstractTween;
}(_tuval_core__WEBPACK_IMPORTED_MODULE_0__.EventDispatcher));

/**
 * Dispatched whenever the tween's position changes. It occurs after all tweened properties are updated and actions
 * are executed.
 * @event tweenjs.AbstractTween#change
 */
/**
 * Dispatched when the tween reaches its end and has paused itself. This does not fire until all loops are complete;
 * tweens that loop continuously will never fire a complete event.
 * @event tweenjs.AbstractTween#complete
 */ 


/***/ }),

/***/ "./src/drawing/scene/tween/Ease.ts":
/*!*****************************************!*\
  !*** ./src/drawing/scene/tween/Ease.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ease": () => (/* binding */ Ease)
/* harmony export */ });
var Ease = /** @class */ (function () {
    function Ease() {
    }
    Ease.linear = function (t) {
        return t;
    };
    /**
     * Mimics the simple -100 to 100 easing in Flash Pro.
     * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.
     * @return {Function}
     */
    Ease.get = function (amount) {
        if (amount < -1) {
            amount = -1;
        }
        else if (amount > 1) {
            amount = 1;
        }
        return function (t) {
            if (amount == 0) {
                return t;
            }
            if (amount < 0) {
                return t * (t * -amount + 1 + amount);
            }
            return t * ((2 - t) * amount + (1 - amount));
        };
    };
    /**
     * Configurable exponential ease.
     * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
     * @return {Function}
     */
    Ease.getPowIn = function (pow) {
        return function (t) {
            return Math.pow(t, pow);
        };
    };
    /**
     * Configurable exponential ease.
     * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
     * @return {Function}
     */
    Ease.getPowOut = function (pow) {
        return function (t) {
            return 1 - Math.pow(1 - t, pow);
        };
    };
    /**
     * Configurable exponential ease.
     * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
     * @return {Function}
     */
    Ease.getPowInOut = function (pow) {
        return function (t) {
            if ((t *= 2) < 1)
                return 0.5 * Math.pow(t, pow);
            return 1 - 0.5 * Math.abs(Math.pow(2 - t, pow));
        };
    };
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.sineIn = function (t) {
        return 1 - Math.cos(t * Math.PI / 2);
    };
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.sineOut = function (t) {
        return Math.sin(t * Math.PI / 2);
    };
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.sineInOut = function (t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
    };
    /**
     * Configurable "back in" ease.
     * @param {Number} amount The strength of the ease.
     * @return {Function}
     */
    Ease.getBackIn = function (amount) {
        return function (t) {
            return t * t * ((amount + 1) * t - amount);
        };
    };
    /**
     * Configurable "back out" ease.
     * @param {Number} amount The strength of the ease.
     * @return {Function}
     */
    Ease.getBackOut = function (amount) {
        return function (t) {
            return (--t * t * ((amount + 1) * t + amount) + 1);
        };
    };
    /**
     * Configurable "back in out" ease.
     * @param {Number} amount The strength of the ease.
     * @return {Function}
     */
    Ease.getBackInOut = function (amount) {
        amount *= 1.525;
        return function (t) {
            if ((t *= 2) < 1)
                return 0.5 * (t * t * ((amount + 1) * t - amount));
            return 0.5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
        };
    };
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.circIn = function (t) {
        return -(Math.sqrt(1 - t * t) - 1);
    };
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.circOut = function (t) {
        return Math.sqrt(1 - --t * t);
    };
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.circInOut = function (t) {
        if ((t *= 2) < 1)
            return -0.5 * (Math.sqrt(1 - t * t) - 1);
        return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    };
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.bounceIn = function (t) {
        return 1 - Ease.bounceOut(1 - t);
    };
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.bounceOut = function (t) {
        if (t < 1 / 2.75) {
            return 7.5625 * t * t;
        }
        else if (t < 2 / 2.75) {
            return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        }
        else if (t < 2.5 / 2.75) {
            return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        }
        else {
            return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
        }
    };
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.bounceInOut = function (t) {
        if (t < 0.5)
            return Ease.bounceIn(t * 2) * 0.5;
        return Ease.bounceOut(t * 2 - 1) * 0.5 + 0.5;
    };
    /**
     * Configurable elastic ease.
     * @param {Number} amplitude
     * @param {Number} period
     * @return {Function}
     */
    Ease.getElasticIn = function (amplitude, period) {
        var pi2 = Math.PI * 2;
        return function (t) {
            if (t === 0 || t === 1)
                return t;
            var s = period / pi2 * Math.asin(1 / amplitude);
            return -(amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));
        };
    };
    /**
     * Configurable elastic ease.
     * @param {Number} amplitude
     * @param {Number} period
     * @return {Function}
     */
    Ease.getElasticOut = function (amplitude, period) {
        var pi2 = Math.PI * 2;
        return function (t) {
            if (t === 0 || t === 1)
                return t;
            var s = period / pi2 * Math.asin(1 / amplitude);
            return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1;
        };
    };
    /**
     * Configurable elastic ease.
     * @param {Number} amplitude
     * @param {Number} period
     * @return {Function}
     */
    Ease.getElasticInOut = function (amplitude, period) {
        var pi2 = Math.PI * 2;
        return function (t) {
            var s = period / pi2 * Math.asin(1 / amplitude);
            if ((t *= 2) < 1)
                return -0.5 * (amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));
            return amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * 0.5 + 1;
        };
    };
    /**
     * Identical to linear.
     * @param {Number} t
     * @return {Number}
     */
    Ease.none = Ease.linear;
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.quadIn = Ease.getPowIn(2);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.quadOut = Ease.getPowOut(2);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.quadInOut = Ease.getPowInOut(2);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.cubicIn = Ease.getPowIn(3);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.cubicOut = Ease.getPowOut(3);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.cubicInOut = Ease.getPowInOut(3);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.quartIn = Ease.getPowIn(4);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.quartOut = Ease.getPowOut(4);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.quartInOut = Ease.getPowInOut(4);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.quintIn = Ease.getPowIn(5);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.quintOut = Ease.getPowOut(5);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.quintInOut = Ease.getPowInOut(5);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.backIn = Ease.getBackIn(1.7);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.backOut = Ease.getBackOut(1.7);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.backInOut = Ease.getBackInOut(1.7);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.elasticIn = Ease.getElasticIn(1, 0.3);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.elasticOut = Ease.getElasticOut(1, 0.3);
    /**
     * @param {Number} t
     * @return {Number}
     */
    Ease.elasticInOut = Ease.getElasticInOut(1, 0.3 * 1.5);
    return Ease;
}());



/***/ }),

/***/ "./src/drawing/scene/tween/Tween.ts":
/*!******************************************!*\
  !*** ./src/drawing/scene/tween/Tween.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tween": () => (/* binding */ Tween)
/* harmony export */ });
/* harmony import */ var _AbstractTween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractTween */ "./src/drawing/scene/tween/AbstractTween.ts");
/* harmony import */ var _Ease__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Ease */ "./src/drawing/scene/tween/Ease.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Tween = /** @class */ (function (_super) {
    __extends(Tween, _super);
    function Tween(target, props) {
        var _this = _super.call(this, props) || this;
        _this.duration = 0;
        _this.position = 0;
        /**
         * Allows you to specify data that will be used by installed plugins. Each plugin uses this differently, but in general
         * you specify data by assigning it to a property of `pluginData` with the same name as the plugin.
         * Note that in many cases, this data is used as soon as the plugin initializes itself for the tween.
         * As such, this data should be set before the first `to` call in most cases.
         *
         * Some plugins also store working data in this object, usually in a property named `_PluginClassName`.
         * See the documentation for individual plugins for more details.
         *
         * @example
         * myTween.pluginData.SmartRotation = data;
         * myTween.pluginData.SmartRotation_disabled = true;
         *
         *
         * @default null
         * @type {Object}
         */
        _this.pluginData = null;
        /**
         * The target of this tween. This is the object on which the tweened properties will be changed.
         * @type {Object}
         * @readonly
         */
        _this.target = target;
        /**
         * Indicates the tween's current position is within a passive wait.
         * @type {Boolean}
         * @default false
         * @readonly
         */
        _this.passive = false;
        /**
         * @private
         * @type {TweenStep}
         */
        _this._stepHead = new TweenStep(null, 0, 0, {}, null, true);
        /**
         * @private
         * @type {TweenStep}
         */
        _this._stepTail = _this._stepHead;
        /**
         * The position within the current step. Used by MovieClip.
         * @private
         * @type {Number}
         * @default 0
         */
        _this._stepPosition = 0;
        /**
         * @private
         * @type {TweenAction}
         * @default null
         */
        _this._actionHead = null;
        /**
         * @private
         * @type {TweenAction}
         * @default null
         */
        _this._actionTail = null;
        /**
         * Plugins added to this tween instance.
         * @private
         * @type {Object[]}
         * @default null
         */
        _this._plugins = null;
        /**
         * Hash for quickly looking up added plugins. Null until a plugin is added.
         * @private
         * @type {Object}
         * @default null
         */
        _this._pluginIds = null;
        /**
         * Used by plugins to inject new properties.
         * @private
         * @type {Object}
         * @default null
         */
        _this._injected = null;
        if (props) {
            _this.pluginData = props.pluginData;
            if (props.override) {
                Tween.removeTweens(target);
            }
        }
        if (!_this.pluginData) {
            _this.pluginData = {};
        }
        _this._init(props);
        return _this;
    }
    /**
     * Returns a new tween instance. This is functionally identical to using `new Tween(...)`, but may look cleaner
     * with the chained syntax of TweenJS.
     *
     * @static
     * @example
     * let tween = Tween.get(target).to({ x: 100 }, 500);
     * // equivalent to:
     * let tween = new Tween(target).to({ x: 100 }, 500);
     *
     * @param {Object} target The target object that will have its properties tweened.
     * @param {Object} [props] The configuration properties to apply to this instance (ex. `{loop:-1, paused:true}`).
     * @param {Boolean} [props.useTicks]
     * @param {Boolean} [props.ignoreGlobalPause]
     * @param {Number|Boolean} [props.loop]
     * @param {Boolean} [props.reversed]
     * @param {Boolean} [props.bounce]
     * @param {Number} [props.timeScale]
     * @param {Object} [props.pluginData]
     * @param {Boolean} [props.paused]
     * @param {*} [props.position] indicates the initial position for this tween
     * @param {*} [props.onChange] adds the specified function as a listener to the `change` event
     * @param {*} [props.onComplete] adds the specified function as a listener to the `complete` event
     * @param {*} [props.override] if true, removes all existing tweens for the target
     * @return {Tween} A reference to the created tween.
     */
    Tween.get = function (target, props) {
        return new Tween(target, props);
    };
    /**
     * Advances all tweens. This typically uses the {{#crossLink "Ticker"}}{{/crossLink}} class, but you can call it
     * manually if you prefer to use your own "heartbeat" implementation.
     *
     * @static
     *
     * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have
     * `useTicks` set to true.
     * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {@link tweenjs.Tween#ignoreGlobalPause}
     * will ignore this, but all others will pause if this is `true`.
     */
    Tween.tick = function (delta, paused) {
        var tween = Tween._tweenHead;
        var t = Tween._inTick = Date.now();
        while (tween) {
            var next = tween._next, status_1 = tween._status;
            tween._lastTick = t;
            if (status_1 === 1) {
                tween._status = 0;
            } // new, ignore
            else if (status_1 === -1) {
                Tween._delist(tween);
            } // removed, delist
            else if ((paused && !tween.ignoreGlobalPause) || tween._paused) {
                /* paused */
            }
            else {
                tween.advance(tween.useTicks ? 1 : delta);
            }
            tween = next;
        }
        Tween._inTick = 0;
    };
    /**
     * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle
     * {@link tweenjs.Ticker#event:tick} events from the {@link tweenjs.Ticker}.
     * No other events are handled in Tween.
     *
     * @static
     * @since 0.4.2
     *
     * @param {Object} event An event object passed in by the {@link core.EventDispatcher}. Will
     * usually be of type "tick".
     */
    Tween.handleEvent = function (event) {
        if (event.type === "tick") {
            this.tick(event.delta, event.paused);
        }
    };
    /**
     * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`
     * property is `true`.
     *
     * @static
     *
     * @param {Object} target The target object to remove existing tweens from.=
     */
    Tween.removeTweens = function (target) {
        if (!target.tweenjs_count) {
            return;
        }
        var tween = Tween._tweenHead;
        while (tween) {
            var next = tween._next;
            if (tween.target === target) {
                tween.paused = true;
            }
            tween = next;
        }
        target.tweenjs_count = 0;
    };
    /**
     * Stop and remove all existing tweens.
     *
     * @static
     * @since 0.4.1
     */
    Tween.removeAllTweens = function () {
        var tween = Tween._tweenHead;
        while (tween) {
            var next = tween._next;
            tween._paused = true;
            tween.target && (tween.target.tweenjs_count = 0);
            tween._next = tween._prev = null;
            tween = next;
        }
        Tween._tweenHead = Tween._tweenTail = null;
    };
    /**
     * Indicates whether there are any active tweens on the target object (if specified) or in general.
     *
     * @static
     *
     * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate
     * if there are any active tweens on any target.
     * @return {Boolean} Indicates if there are active tweens.
     */
    Tween.hasActiveTweens = function (target) {
        if (target) {
            return !!target.tweenjs_count;
        }
        return !!Tween._tweenHead;
    };
    /**
     * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink "SamplePlugin"}}{{/crossLink}}
     * for an example of how to write TweenJS plugins. Plugins should generally be installed via their own `install` method, in order to provide
     * the plugin with an opportunity to configure itself.
     *
     * @static
     *
     * @param {Object} plugin The plugin to install
     * @param {Object} props The props to pass to the plugin
     */
    Tween.installPlugin = function (plugin, props) {
        plugin.install(props);
        var priority = (plugin.priority = plugin.priority || 0), arr = (Tween._plugins = Tween._plugins || []);
        var i = 0;
        for (var l = arr.length; i < l; i++) {
            if (priority < arr[i].priority) {
                break;
            }
        }
        arr.splice(i, 0, plugin);
    };
    /**
     * Registers or unregisters a tween with the ticking system.
     *
     * @private
     * @static
     *
     * @param {Tween} tween The tween instance to register or unregister.
     * @param {Boolean} paused If `false`, the tween is registered. If `true` the tween is unregistered.
     */
    Tween._register = function (tween, paused) {
        var target = tween.target;
        if (!paused && tween._paused) {
            // TODO: this approach might fail if a dev is using sealed objects
            if (target) {
                target.tweenjs_count = target.tweenjs_count ? target.tweenjs_count + 1 : 1;
            }
            var tail = Tween._tweenTail;
            if (!tail) {
                Tween._tweenHead = Tween._tweenTail = tween;
            }
            else {
                Tween._tweenTail = tail._next = tween;
                tween._prev = tail;
            }
            tween._status = Tween._inTick ? 1 : 0;
            if (!Tween._inited) {
                if (Tween._ticker == null) {
                    //Ticker.addEventListener("tick", Tween);
                    Tween._inited = true;
                }
                else {
                    //Tween._ticker.addEventListener("tick", Tween);
                    Tween._inited = true;
                }
            }
        }
        else if (paused && !tween._paused) {
            if (target) {
                target.tweenjs_count--;
            }
            // tick handles delist if we're in a tick stack and the tween hasn't advanced yet:
            if (!Tween._inTick || tween._lastTick === Tween._inTick) {
                Tween._delist(tween);
            }
            tween._status = -1;
        }
        tween._paused = paused;
    };
    /**
     * @param {tweenjs.Tween} tween
     */
    Tween._delist = function (tween) {
        var next = tween._next, prev = tween._prev;
        if (next) {
            next._prev = prev;
        }
        else {
            Tween._tweenTail = prev;
        } // was tail
        if (prev) {
            prev._next = next;
        }
        else {
            Tween._tweenHead = next;
        } // was head.
        tween._next = tween._prev = null;
    };
    /**
     * Adds a wait (essentially an empty tween).
     *
     * @example
     * // This tween will wait 1s before alpha is faded to 0.
     * Tween.get(target)
     *   .wait(1000)
     *   .to({ alpha: 0 }, 1000);
     *
     * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).
     * @param {Boolean} [passive=false] Tween properties will not be updated during a passive wait. This
     * is mostly useful for use with {@link tweenjs.Timeline} instances that contain multiple tweens
     * affecting the same target at different times.
     * @chainable
     */
    Tween.prototype.wait = function (duration, passive) {
        if (passive === void 0) { passive = false; }
        if (duration > 0) {
            this._addStep(+duration, this._stepTail.props, null, passive);
        }
        return this;
    };
    /**
     * Adds a tween from the current values to the specified properties. Set duration to 0 to jump to these value.
     * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric
     * properties will be set at the end of the specified duration.
     *
     * @example
     * Tween.get(target)
     *   .to({ alpha: 0, visible: false }, 1000);
     *
     * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x
     * property of the target to 300).
     * @param {Number} [duration=0] The duration of the tween in milliseconds (or in ticks if `useTicks` is true).
     * @param {Function} [ease=Ease.linear] The easing function to use for this tween. See the {@link tweenjs.Ease}
     * class for a list of built-in ease functions.
     * @chainable
     */
    Tween.prototype.to = function (props, duration, ease) {
        if (duration === void 0) { duration = 0; }
        if (ease === void 0) { ease = _Ease__WEBPACK_IMPORTED_MODULE_1__.Ease.linear; }
        if (duration < 0) {
            duration = 0;
        }
        var step = this._addStep(+duration, null, ease);
        this._appendProps(props, step);
        return this;
    };
    /**
     * Adds a label that can be used with {@link tweenjs.Tween#gotoAndPlay}/{@link tweenjs.Tween#gotoAndStop}
     * at the current point in the tween.
     *
     * @example
     * let tween = Tween.get(foo)
     *   .to({ x: 100 }, 1000)
     *   .label("myLabel")
     *   .to({ x: 200 }, 1000);
     * // ...
     * tween.gotoAndPlay("myLabel"); // would play from 1000ms in.
     *
     * @param {String} label The label name.
     * @chainable
     */
    Tween.prototype.label = function (name) {
        this.addLabel(name, this.duration);
        return this;
    };
    /**
     * Adds an action to call the specified function.
     *
     * @example
     * // would call myFunction() after 1 second.
     * Tween.get()
     *   .wait(1000)
     *   .call(myFunction);
     *
     * @param {Function} callback The function to call.
     * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function
     * will be called with a single param pointing to this tween.
     * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target's scope.
     * @chainable
     */
    Tween.prototype.call = function (callback, params, scope) {
        return this._addAction(scope || this.target, callback, params || [this]);
    };
    /**
     * Adds an action to set the specified props on the specified target. If `target` is null, it will use this tween's
     * target. Note that for properties on the target object, you should consider using a zero duration {@link tweenjs.Tween#to}
     * operation instead so the values are registered as tweened props.
     *
     * @example
     * tween.wait(1000)
     *   .set({ visible: false }, foo);
     *
     * @param {Object} props The properties to set (ex. `{ visible: false }`).
     * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween's target.
     * @chainable
     */
    Tween.prototype.set = function (props, target) {
        return this._addAction(target || this.target, this._set, [props]);
    };
    /**
     * Adds an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.
     *
     * @example
     * tween.to({ x: 100 }, 500)
     *   .play(otherTween);
     *
     * @param {Tween} [tween] The tween to play. Defaults to this tween.
     * @chainable
     */
    Tween.prototype.play = function (tween) {
        return this._addAction(tween || this, this._set, [{ paused: false }]);
    };
    /**
     * Adds an action to pause the specified tween.
     * At 60fps the tween will advance by ~16ms per tick, if the tween above was at 999ms prior to the current tick, it
   * will advance to 1015ms (15ms into the second "step") and then pause.
     *
     * @example
     * tween.pause(otherTween)
     *   .to({ alpha: 1 }, 1000)
     *   .play(otherTween);
     *
     * // Note that this executes at the end of a tween update,
     * // so the tween may advance beyond the time the pause action was inserted at.
   *
   * tween.to({ foo: 0 }, 1000)
   *   .pause()
   *   .to({ foo: 1 }, 1000);
     *
     * @param {Tween} [tween] The tween to pause. Defaults to this tween.
     * @chainable
     */
    Tween.prototype.pause = function (tween) {
        return this._addAction(tween || this, this._set, [{ paused: false }]);
    };
    /**
     * @throws Tween cannot be cloned.
     */
    Tween.prototype.clone = function () {
        throw "Tween can not be cloned.";
    };
    /**
     * @private
     * @param {Object} plugin
     */
    Tween.prototype._addPlugin = function (plugin) {
        var ids = this._pluginIds || (this._pluginIds = {}), id = plugin.id;
        if (!id || ids[id]) {
            return;
        } // already added
        ids[id] = true;
        var plugins = this._plugins || (this._plugins = []), priority = plugin.priority || 0;
        for (var i = 0, l = plugins.length; i < l; i++) {
            if (priority < plugins[i].priority) {
                plugins.splice(i, 0, plugin);
                return;
            }
        }
        plugins.push(plugin);
    };
    /**
     * @private
     * @param {} jump
     * @param {Boolean} end
   */
    Tween.prototype._updatePosition = function (jump, end) {
        var step = this._stepHead.next, t = this.position, d = this.duration;
        if (this.target && step) {
            // find our new step index:
            var stepNext = step.next;
            while (stepNext && stepNext.t <= t) {
                step = step.next;
                stepNext = step.next;
            }
            var ratio = end ? d === 0 ? 1 : t / d : (t - step.t) / step.d; // TODO: revisit this.
            this._updateTargetProps(step, ratio, end);
        }
        this._stepPosition = step ? t - step.t : 0;
    };
    /**
     * @private
     * @param {Object} step
     * @param {Number} ratio
     * @param {Boolean} end Indicates to plugins that the full tween has ended.
     */
    Tween.prototype._updateTargetProps = function (step, ratio, end) {
        if (this.passive = !!step.passive) {
            return;
        } // don't update props.
        var v, v0, v1, ease;
        var p0 = step.prev.props;
        var p1 = step.props;
        if (ease = step.ease) {
            ratio = ease(ratio, 0, 1, 1);
        }
        var plugins = this._plugins;
        proploop: for (var n in p0) {
            v0 = p0[n];
            v1 = p1[n];
            // values are different & it is numeric then interpolate:
            if (v0 !== v1 && (typeof (v0) === "number")) {
                v = v0 + (v1 - v0) * ratio;
            }
            else {
                v = ratio >= 1 ? v1 : v0;
            }
            if (plugins) {
                for (var i = 0, l = plugins.length; i < l; i++) {
                    var value = plugins[i].change(this, step, n, v, ratio, end);
                    if (value === Tween.IGNORE) {
                        continue proploop;
                    }
                    if (value !== undefined) {
                        v = value;
                    }
                }
            }
            this.target[n] = v;
        }
    };
    /**
     * @private
     * @param {Number} startPos
     * @param {Number} endPos
     * @param {Boolean} includeStart
     */
    Tween.prototype._runActionsRange = function (startPos, endPos, jump, includeStart) {
        var rev = startPos > endPos;
        var action = rev ? this._actionTail : this._actionHead;
        var ePos = endPos, sPos = startPos;
        if (rev) {
            ePos = startPos;
            sPos = endPos;
        }
        var t = this.position;
        while (action) {
            var pos = action.t;
            if (pos === endPos || (pos > sPos && pos < ePos) || (includeStart && pos === startPos)) {
                action.funct.apply(action.scope, action.params);
                if (t !== this.position) {
                    return true;
                }
            }
            action = rev ? action.prev : action.next;
        }
        return false;
    };
    /**
     * @private
     * @param {Object} props
     */
    Tween.prototype._appendProps = function (props, step, stepPlugins) {
        var initProps = this._stepHead.props, target = this.target, plugins = Tween._plugins;
        var n, i, l, value, initValue, inject;
        var oldStep = step.prev, oldProps = oldStep.props;
        var stepProps = step.props || (step.props = this._cloneProps(oldProps));
        var cleanProps = {};
        for (n in props) {
            if (!props.hasOwnProperty(n)) {
                continue;
            }
            cleanProps[n] = stepProps[n] = props[n];
            if (initProps[n] !== undefined) {
                continue;
            }
            initValue = undefined; // accessing missing properties on DOMElements when using CSSPlugin is INSANELY expensive, so we let the plugin take a first swing at it.
            if (plugins) {
                for (i = plugins.length - 1; i >= 0; i--) {
                    value = plugins[i].init(this, n, initValue);
                    if (value !== undefined) {
                        initValue = value;
                    }
                    if (initValue === Tween.IGNORE) {
                        // (ignored = ignored || {})[n] = true; // fix
                        delete (stepProps[n]);
                        delete (cleanProps[n]);
                        break;
                    }
                }
            }
            if (initValue !== Tween.IGNORE) {
                if (initValue === undefined) {
                    initValue = target[n];
                }
                oldProps[n] = (initValue === undefined) ? null : initValue;
            }
        }
        for (n in cleanProps) {
            value = props[n];
            // propagate old value to previous steps:
            var o = void 0, prev = oldStep;
            while ((o = prev) && (prev = o.prev)) {
                if (prev.props === o.props) {
                    continue;
                } // wait step
                if (prev.props[n] !== undefined) {
                    break;
                } // already has a value, we're done.
                prev.props[n] = oldProps[n];
            }
        }
        if (stepPlugins && (plugins = this._plugins)) {
            for (i = plugins.length - 1; i >= 0; i--) {
                plugins[i].step(this, step, cleanProps);
            }
        }
        if (inject = this._injected) {
            this._injected = null;
            this._appendProps(inject, step, false);
        }
    };
    /**
     * Used by plugins to inject properties onto the current step. Called from within `Plugin.step` calls.
     * For example, a plugin dealing with color, could read a hex color, and inject red, green, and blue props into the tween.
     * See the SamplePlugin for more info.
     * @see tweenjs.SamplePlugin
     * @private
     * @param {String} name
     * @param {Object} value
     */
    Tween.prototype._injectProp = function (name, value) {
        var o = this._injected || (this._injected = {});
        o[name] = value;
    };
    /**
     * @private
     * @param {Number} duration
     * @param {Object} props
     * @param {Function} ease
     * @param {Boolean} [passive=false]
     */
    Tween.prototype._addStep = function (duration, props, ease, passive) {
        if (passive === void 0) { passive = false; }
        var step = new TweenStep(this._stepTail, this.duration, duration, props, ease, passive);
        this.duration += duration;
        return this._stepTail = (this._stepTail.next = step);
    };
    /**
     * @private
     * @param {Object} scope
     * @param {Function} funct
     * @param {Array} params
     */
    Tween.prototype._addAction = function (scope, funct, params) {
        var action = new TweenAction(this._actionTail, this.duration, scope, funct, params);
        if (this._actionTail) {
            this._actionTail.next = action;
        }
        else {
            this._actionHead = action;
        }
        this._actionTail = action;
        return this;
    };
    /**
     * @private
     * @param {Object} props
     */
    Tween.prototype._set = function (props) {
        for (var n in props) {
            this[n] = props[n];
        }
    };
    /**
     * @private
     * @param {Object} props
     */
    Tween.prototype._cloneProps = function (props) {
        var o = {};
        for (var n in props) {
            o[n] = props[n];
        }
        return o;
    };
    Tween._ticker = undefined;
    return Tween;
}(_AbstractTween__WEBPACK_IMPORTED_MODULE_0__.AbstractTween));

// tiny api (primarily for tool output):
{
    var p = Tween.prototype;
    p.w = p.wait;
    p.t = p.to;
    p.c = p.call;
    p.s = p.set;
}
// static properties
/**
 * Constant returned by plugins to tell the tween not to use default assignment.
 * @property IGNORE
 * @type {Object}
 * @static
 */
Tween.IGNORE = {};
/**
 * @property _listeners
 * @type {Tween[]}
 * @static
 * @private
 */
Tween._tweens = [];
/**
 * @property _plugins
 * @type {Object}
 * @static
 * @private
 */
Tween._plugins = null;
/**
 * @property _tweenHead
 * @type {Tween}
 * @static
 * @private
 */
Tween._tweenHead = null;
/**
 * @property _tweenTail
 * @type {Tween}
 * @static
 * @private
 */
Tween._tweenTail = null;
/**
 * 0 if not in tick, otherwise a tick ID (currently just a timestamp).
 * @property _inTick
 * @type {Number}
 * @static
 * @protected
 */
Tween._inTick = 0;
// helpers:
/**
 * @private
 * @param {*} prev
 * @param {*} t
 * @param {*} d
 * @param {*} props
 * @param {*} ease
 * @param {*} passive
 */
var TweenStep = /** @class */ (function () {
    function TweenStep(prev, t, d, props, ease, passive) {
        this.next = null;
        this.prev = prev;
        this.t = t;
        this.d = d;
        this.props = props;
        this.ease = ease;
        this.passive = passive;
        this.index = prev ? prev.index + 1 : 0;
    }
    ;
    ;
    ;
    ;
    ;
    return TweenStep;
}());
/**
 * @private
 * @param {*} prev
 * @param {*} t
 * @param {*} scope
 * @param {*} funct
 * @param {*} params
 */
var TweenAction = /** @class */ (function () {
    function TweenAction(prev, t, scope, funct, params) {
        this.next = null;
        this.d = 0;
        this.prev = prev;
        this.t = t;
        this.scope = scope;
        this.funct = funct;
        this.params = params;
    }
    return TweenAction;
}());


/***/ }),

/***/ "./src/drawing/scene/tween/index.ts":
/*!******************************************!*\
  !*** ./src/drawing/scene/tween/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tween": () => (/* reexport safe */ _Tween__WEBPACK_IMPORTED_MODULE_0__.Tween),
/* harmony export */   "Ease": () => (/* reexport safe */ _Ease__WEBPACK_IMPORTED_MODULE_1__.Ease)
/* harmony export */ });
/* harmony import */ var _Tween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tween */ "./src/drawing/scene/tween/Tween.ts");
/* harmony import */ var _Ease__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Ease */ "./src/drawing/scene/tween/Ease.ts");




/***/ }),

/***/ "./src/drawing/scene/utils/Canvas.ts":
/*!*******************************************!*\
  !*** ./src/drawing/scene/utils/Canvas.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCanvas": () => (/* binding */ createCanvas)
/* harmony export */ });
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_0__);

function createCanvas(width, height) {
    if (width === void 0) { width = 1; }
    if (height === void 0) { height = 1; }
    var c;
    if (_tuval_core__WEBPACK_IMPORTED_MODULE_0__.is.workerContext()) {
        return new OffscreenCanvas(width, height);
    }
    else {
        if (window.Tuval !== undefined && window.Tuval.createCanvas !== undefined) {
            c = window.Tuval.createCanvas();
        }
        if (window.document !== undefined && window.document.createElement !== undefined) {
            c = document.createElement("canvas");
        }
        if (c !== undefined) {
            c.width = width;
            c.height = height;
            return c;
        }
    }
    throw "Canvas not supported in this environment.";
}


/***/ }),

/***/ "./src/drawing/scene/utils/VideoBuffer.ts":
/*!************************************************!*\
  !*** ./src/drawing/scene/utils/VideoBuffer.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VideoBuffer": () => (/* binding */ VideoBuffer)
/* harmony export */ });
/* harmony import */ var _Canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Canvas */ "./src/drawing/scene/utils/Canvas.ts");

/**
 * When an HTML video seeks, including when looping, there is an indeterminate period before a new frame is available.
 * This can result in the video blinking or flashing when it is drawn to a canvas. The VideoBuffer class resolves
 * this issue by drawing each frame to an off-screen canvas and preserving the prior frame during a seek.
 *
 * @example
 * let buffer = new VideoBuffer(video);
 * let bitmap = new Bitmap(buffer);
 *
 * @param {HTMLVideoElement} video The HTML video element to buffer.
 */
var VideoBuffer = /** @class */ (function () {
    function VideoBuffer(video) {
        this.readyState = video.readyState;
        this._video = video;
        this._canvas = null;
        this._lastTime = -1;
        if (this.readyState < 2) {
            video.addEventListener("canplaythrough", this._videoReady.bind(this));
        }
        // {once: true} isn't supported everywhere, but its a non-critical optimization here.
    }
    /**
     * Gets an HTML canvas element showing the current video frame, or the previous frame if in a seek / loop.
     * Primarily for use by {@link easeljs.Bitmap}.
     */
    VideoBuffer.prototype.getImage = function () {
        if (this.readyState < 2) {
            return undefined;
        }
        var canvas = this._canvas, video = this._video;
        if (!canvas) {
            canvas = this._canvas = (0,_Canvas__WEBPACK_IMPORTED_MODULE_0__.createCanvas)();
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        }
        if (video.readyState >= 2 && video.currentTime !== this._lastTime) {
            var ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            this._lastTime = video.currentTime;
        }
        return canvas;
    };
    /**
     * @protected
     */
    VideoBuffer.prototype._videoReady = function () {
        this.readyState = 2;
    };
    return VideoBuffer;
}());



/***/ }),

/***/ "./src/drawing/scene/utils/uid.ts":
/*!****************************************!*\
  !*** ./src/drawing/scene/utils/uid.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "uid": () => (/* binding */ uid)
/* harmony export */ });
var _nextId = 0;
/**
 * Global utility for generating sequential unique ID numbers.
 *
 * @memberof easeljs
 * @name easeljs.uid
 * @example
 * import { uid } from "@createjs/easeljs";
 * var ids = [];
 * while (ids.length <= 3) {
 *   ids.push(uid());
 * }
 * // ids == [0, 1, 2, 3]
 */
function uid() {
    return _nextId++;
}


/***/ }),

/***/ "./src/drawing/sketch/SketchBatch.ts":
/*!*******************************************!*\
  !*** ./src/drawing/sketch/SketchBatch.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SketchBatch": () => (/* binding */ SketchBatch)
/* harmony export */ });
var SketchBatch = /** @class */ (function () {
    function SketchBatch() {
        this.m_instructions = [];
        this.command = undefined;
        this.m_dirty = false;
    }
    SketchBatch.prototype.append = function (command, clean) {
        this.m_instructions.push(command);
        this.command = command;
        if (!clean) {
            this.m_dirty = true;
        }
    };
    SketchBatch.prototype.fill = function (color) {
        this.append(new Fill(color));
    };
    SketchBatch.prototype.rect = function (x, y, w, h) {
        this.append(new Rect(x, y, w, h));
    };
    SketchBatch.prototype.translate = function (x, y) {
        this.append(new Translate(x, y));
    };
    SketchBatch.prototype.draw = function (sg, data) {
        var instr = this.m_instructions;
        //const l = instr.length;
        for (var i = 0; i < instr.length; i++) {
            instr[i].exec(sg, data);
        }
    };
    SketchBatch.prototype.clear = function () {
        this.m_instructions.length = 0;
        this.m_dirty = false;
    };
    return SketchBatch;
}());

var Fill = /** @class */ (function () {
    function Fill(color) {
        this.m_color = color;
        this.exec = function (sg) {
            sg.fill(color);
        };
    }
    return Fill;
}());
var Rect = /** @class */ (function () {
    function Rect(x, y, w, h) {
        this.exec = function (sg) {
            sg.rect(x, y, w, h);
        };
    }
    return Rect;
}());
var Translate = /** @class */ (function () {
    function Translate(x, y) {
        this.exec = function (sg) {
            sg.translate(x, y);
        };
    }
    return Translate;
}());


/***/ }),

/***/ "./src/drawing/sketch/SketchCanvasRenderer2D.ts":
/*!******************************************************!*\
  !*** ./src/drawing/sketch/SketchCanvasRenderer2D.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SketchCanvasRenderer2D": () => (/* binding */ SketchCanvasRenderer2D)
/* harmony export */ });
/* harmony import */ var _core_Constanst__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Constanst */ "./src/drawing/sketch/core/Constanst.ts");
/* harmony import */ var _image_SketchImage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./image/SketchImage */ "./src/drawing/sketch/image/SketchImage.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _math_Vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math/Vector */ "./src/drawing/sketch/math/Vector.ts");
/* harmony import */ var _image_filters__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./image/filters */ "./src/drawing/sketch/image/filters.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var styleEmpty = 'rgba(0,0,0,0)';
var SketchCanvasRenderer2D = /** @class */ (function (_super) {
    __extends(SketchCanvasRenderer2D, _super);
    function SketchCanvasRenderer2D(context, pinst) {
        var _this = _super.call(this, context) || this;
        _this._cachedFillStyle = undefined;
        _this._cachedStrokeStyle = undefined;
        _this._textSize = 12;
        _this._textLeading = 15;
        _this._textFont = 'sans-serif';
        _this._textStyle = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.NORMAL;
        _this._textAscent = null;
        _this._textDescent = null;
        _this._textAlign = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.LEFT;
        _this._textBaseline = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BASELINE;
        _this._rectMode = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CORNER;
        _this._ellipseMode = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CENTER;
        _this._curveTightness = 0;
        _this._imageMode = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CORNER;
        _this._tint = null;
        _this._doStroke = true;
        _this._doFill = true;
        _this._strokeSet = false;
        _this._fillSet = false;
        _this.isP3D = false;
        _this._pInst = pinst;
        return _this;
    }
    SketchCanvasRenderer2D.prototype._applyDefaults = function () {
        this._cachedFillStyle = this._cachedStrokeStyle = undefined;
        this._setFill(_core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants._DEFAULT_FILL);
        this._setStroke(_core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants._DEFAULT_STROKE);
        this.drawingContext.lineCap = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.ROUND;
        this.drawingContext.font = 'normal 12px sans-serif';
    };
    SketchCanvasRenderer2D.prototype.background = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.drawingContext.save();
        this.resetMatrix();
        if (args[0] instanceof _image_SketchImage__WEBPACK_IMPORTED_MODULE_1__.SketchImage) {
            this.image(args[0], 0, 0, this._pInst.width, this._pInst.height);
        }
        else {
            var curFill = this._getFill();
            // create background rect
            //const color = this._pInst.color(...args);
            var color = undefined;
            if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGColor)) {
                color = args[0];
            }
            else if (args.length === 1 && (_tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) || _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.string(args[0]))) {
                color = this._pInst.color(args[0]);
            }
            else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.array(args[0])) {
                color = this._pInst.color(args[1][0], args[1][1], args[1][2], args[1][3]);
            }
            else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[1])) {
                color = this._pInst.color(args[1], args[2]);
            }
            else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[2])) {
                color = this._pInst.color(args[0], args[1], args[1]);
            }
            else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[2]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[3])) {
                color = this._pInst.color(args[0], args[1], args[2], args[3]);
            }
            if (color != null) {
                var newFill = color.toString();
                this._setFill(newFill);
                this.drawingContext.fillRect(0, 0, this._pInst.width, this._pInst.height);
                // reset fill
                this._setFill(curFill);
            }
        }
        this.drawingContext.restore();
        this._pInst._pixelsDirty = true;
    };
    SketchCanvasRenderer2D.prototype.clear = function () {
        this.drawingContext.save();
        this.resetMatrix();
        this.drawingContext.clearRect(0, 0, this._pInst.width, this._pInst.height);
        this.drawingContext.restore();
        this._pInst._pixelsDirty = true;
    };
    SketchCanvasRenderer2D.prototype.fill = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var color = undefined;
        if (args.length === 1 && args[0].maxes != null /* is.typeof<SketchColor>(args[0], GraphicTypes.SketchColor) */) {
            color = args[0];
        }
        else if (args.length === 1 && (_tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) || _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.string(args[0]))) {
            color = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGColor.FromSketchColor(args[0]);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.array(args[0])) {
            color = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGColor.FromSketchColor(args[1][0], args[1][1], args[1][2], args[1][3]);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[1])) {
            color = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGColor.FromSketchColor(args[1], args[2]);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[2])) {
            color = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGColor.FromSketchColor(args[0], args[1], args[1]);
        }
        else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[2]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[3])) {
            color = _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGColor.FromSketchColor(args[0], args[1], args[2], args[3]);
        }
        if (color != null) {
            this._setFill(color.toString(), true);
        }
    };
    SketchCanvasRenderer2D.prototype.stroke = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var color = undefined;
        if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CoreGraphicTypes.CGColor)) {
            color = args[0];
        }
        else if (args.length === 1 && (_tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) || _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.string(args[0]))) {
            color = this._pInst.color(args[0]);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.array(args[0])) {
            color = this._pInst.color(args[1][0], args[1][1], args[1][2], args[1][3]);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[1])) {
            color = this._pInst.color(args[1], args[2]);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[2])) {
            color = this._pInst.color(args[0], args[1], args[2]);
        }
        else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[2]) && _tuval_core__WEBPACK_IMPORTED_MODULE_2__.is.number(args[3])) {
            color = this._pInst.color(args[0], args[1], args[2], args[3]);
        }
        if (color != null) {
            this._setStroke(color.toString());
        }
    };
    //////////////////////////////////////////////
    // IMAGE | Loading & Displaying
    //////////////////////////////////////////////
    SketchCanvasRenderer2D.prototype.image = function (img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
        var cnv;
        if (img.gifProperties) {
            img._animateGif(this._pInst);
        }
        try {
            if (this._tint) {
                /*  if (p5.MediaElement && img instanceof p5.MediaElement) {
                     img.loadPixels();
                 } */
                if (img.canvas) {
                    cnv = this._getTintedImageCanvas(img);
                }
            }
            if (!cnv) {
                cnv = img.canvas || img.elt;
            }
            var s = 1;
            if (img.width && img.width > 0) {
                s = cnv.width / img.width;
            }
            this.drawingContext.drawImage(cnv, s * sx, s * sy, s * sWidth, s * sHeight, dx, dy, dWidth, dHeight);
        }
        catch (e) {
            if (e.name !== 'NS_ERROR_NOT_AVAILABLE') {
                throw e;
            }
        }
        this._pInst._pixelsDirty = true;
    };
    SketchCanvasRenderer2D.prototype._getTintedImageCanvas = function (img) {
        if (!img.canvas) {
            return img;
        }
        var pixels = _image_filters__WEBPACK_IMPORTED_MODULE_5__.Filters._toPixels(img.canvas);
        var tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = img.canvas.width;
        tmpCanvas.height = img.canvas.height;
        var tmpCtx = tmpCanvas.getContext('2d');
        var id = tmpCtx.createImageData(img.canvas.width, img.canvas.height);
        var newPixels = id.data;
        for (var i = 0; i < pixels.length; i += 4) {
            var r = pixels[i];
            var g = pixels[i + 1];
            var b = pixels[i + 2];
            var a = pixels[i + 3];
            newPixels[i] = r * this._tint[0] / 255;
            newPixels[i + 1] = g * this._tint[1] / 255;
            newPixels[i + 2] = b * this._tint[2] / 255;
            newPixels[i + 3] = a * this._tint[3] / 255;
        }
        tmpCtx.putImageData(id, 0, 0);
        return tmpCanvas;
    };
    ;
    //////////////////////////////////////////////
    // IMAGE | Pixels
    //////////////////////////////////////////////
    SketchCanvasRenderer2D.prototype.blendMode = function (mode) {
        if (mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.SUBTRACT) {
            console.warn('blendMode(SUBTRACT) only works in WEBGL mode.');
        }
        else if (mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BLEND ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.DARKEST ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.LIGHTEST ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.DIFFERENCE ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.MULTIPLY ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.EXCLUSION ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.SCREEN ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.REPLACE ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.OVERLAY ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.HARD_LIGHT ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.SOFT_LIGHT ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.DODGE ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BURN ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.ADD) {
            this.drawingContext.globalCompositeOperation = mode;
        }
        else {
            throw new Error("Mode " + mode + " not recognized.");
        }
    };
    SketchCanvasRenderer2D.prototype.blend = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var currBlend = this.drawingContext.globalCompositeOperation;
        var blendMode = args[args.length - 1];
        var copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);
        this.drawingContext.globalCompositeOperation = blendMode;
        if (this._pInst) {
            (_a = this._pInst).copy.apply(_a, copyArgs);
        }
        else {
            this.copy.apply(this, copyArgs);
        }
        this.drawingContext.globalCompositeOperation = currBlend;
    };
    SketchCanvasRenderer2D.prototype.copy = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
        if (args.length === 9) {
            srcImage = args[0];
            sx = args[1];
            sy = args[2];
            sw = args[3];
            sh = args[4];
            dx = args[5];
            dy = args[6];
            dw = args[7];
            dh = args[8];
        }
        else if (args.length === 8) {
            srcImage = this._pInst;
            sx = args[0];
            sy = args[1];
            sw = args[2];
            sh = args[3];
            dx = args[4];
            dy = args[5];
            dw = args[6];
            dh = args[7];
        }
        else {
            throw new Error('Signature not supported');
        }
        SketchCanvasRenderer2D._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
        this._pInst._pixelsDirty = true;
    };
    SketchCanvasRenderer2D._copyHelper = function (dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) {
        srcImage.loadPixels();
        var s = srcImage.canvas.width / srcImage.width;
        dstImage.drawingContext.drawImage(srcImage.canvas, s * sx, s * sy, s * sw, s * sh, dx, dy, dw, dh);
    };
    SketchCanvasRenderer2D.prototype._getPixel = function (x, y) {
        var imageData, index;
        if (this._pInst._pixelsDirty) {
            imageData = this.drawingContext.getImageData(x, y, 1, 1).data;
            index = 0;
        }
        else {
            imageData = this._pInst.pixels;
            index = (Math.floor(x) + Math.floor(y) * this.drawingContext.canvas.width) * 4;
        }
        return [
            imageData[index + 0],
            imageData[index + 1],
            imageData[index + 2],
            imageData[index + 3]
        ];
    };
    SketchCanvasRenderer2D.prototype.loadPixels = function () {
        if (!this._pInst._pixelsDirty)
            return;
        this._pInst._pixelsDirty = false;
        var pd = this._pInst._pixelDensity;
        var w = this._pInst.width * pd;
        var h = this._pInst.height * pd;
        var imageData = this.drawingContext.getImageData(0, 0, w, h);
        // @todo this should actually set pixels per object, so diff buffers can
        // have diff pixel arrays.
        this._pInst.imageData = imageData;
        this._pInst.pixels = imageData.data;
    };
    SketchCanvasRenderer2D.prototype.set = function (x, y, imgOrCol) {
        // round down to get integer numbers
        x = Math.floor(x);
        y = Math.floor(y);
        if (imgOrCol instanceof _image_SketchImage__WEBPACK_IMPORTED_MODULE_1__.SketchImage) {
            this.drawingContext.save();
            this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
            this.drawingContext.scale(this._pInst._pixelDensity, this._pInst._pixelDensity);
            this.drawingContext.drawImage(imgOrCol.canvas, x, y);
            this.drawingContext.restore();
            this._pInst._pixelsDirty = true;
        }
        else {
            var r = 0, g = 0, b = 0, a = 0;
            var idx = 4 *
                (y *
                    this._pInst._pixelDensity *
                    (this._pInst.width * this._pInst._pixelDensity) +
                    x * this._pInst._pixelDensity);
            if (!this._pInst.imageData || this._pInst._pixelsDirty) {
                this._pInst.loadPixels.call(this._pInst);
            }
            if (typeof imgOrCol === 'number') {
                if (idx < this._pInst.pixels.length) {
                    r = imgOrCol;
                    g = imgOrCol;
                    b = imgOrCol;
                    a = 255;
                    //this.updatePixels.call(this);
                }
            }
            else if (imgOrCol instanceof Array) {
                if (imgOrCol.length < 4) {
                    throw new Error('pixel array must be of the form [R, G, B, A]');
                }
                if (idx < this._pInst.pixels.length) {
                    r = imgOrCol[0];
                    g = imgOrCol[1];
                    b = imgOrCol[2];
                    a = imgOrCol[3];
                    //this.updatePixels.call(this);
                }
            }
            else if (imgOrCol instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGColor) {
                if (idx < this._pInst.pixels.length) {
                    r = imgOrCol.Levels[0];
                    g = imgOrCol.Levels[1];
                    b = imgOrCol.Levels[2];
                    a = imgOrCol.Levels[3];
                    //this.updatePixels.call(this);
                }
            }
            // loop over pixelDensity * pixelDensity
            for (var i = 0; i < this._pInst._pixelDensity; i++) {
                for (var j = 0; j < this._pInst._pixelDensity; j++) {
                    // loop over
                    idx =
                        4 *
                            ((y * this._pInst._pixelDensity + j) *
                                this._pInst.width *
                                this._pInst._pixelDensity +
                                (x * this._pInst._pixelDensity + i));
                    this._pInst.pixels[idx] = r;
                    this._pInst.pixels[idx + 1] = g;
                    this._pInst.pixels[idx + 2] = b;
                    this._pInst.pixels[idx + 3] = a;
                }
            }
        }
    };
    SketchCanvasRenderer2D.prototype.updatePixels = function (x, y, w, h) {
        var pd = this._pInst._pixelDensity;
        if (x === undefined &&
            y === undefined &&
            w === undefined &&
            h === undefined) {
            x = 0;
            y = 0;
            w = this._pInst.width;
            h = this._pInst.height;
        }
        x *= pd;
        y *= pd;
        w *= pd;
        h *= pd;
        if (this.gifProperties) {
            this.gifProperties.frames[this.gifProperties.displayIndex] =
                this._pInst.imageData;
        }
        this.drawingContext.putImageData(this._pInst.imageData, x, y, 0, 0, w, h);
        if (x !== 0 || y !== 0 || w !== this._pInst.width || h !== this._pInst.height) {
            this._pInst._pixelsDirty = true;
        }
    };
    SketchCanvasRenderer2D.prototype._acuteArcToBezier = function (start, size) {
        // Evaluate constants.
        var alpha = size / 2.0, cos_alpha = Math.cos(alpha), sin_alpha = Math.sin(alpha), cot_alpha = 1.0 / Math.tan(alpha), phi = start + alpha, // This is how far the arc needs to be rotated.
        cos_phi = Math.cos(phi), sin_phi = Math.sin(phi), lambda = (4.0 - cos_alpha) / 3.0, mu = sin_alpha + (cos_alpha - lambda) * cot_alpha;
        // Return rotated waypoints.
        return {
            ax: Math.cos(start).toFixed(7),
            ay: Math.sin(start).toFixed(7),
            bx: (lambda * cos_phi + mu * sin_phi).toFixed(7),
            by: (lambda * sin_phi - mu * cos_phi).toFixed(7),
            cx: (lambda * cos_phi - mu * sin_phi).toFixed(7),
            cy: (lambda * sin_phi + mu * cos_phi).toFixed(7),
            dx: Math.cos(start + size).toFixed(7),
            dy: Math.sin(start + size).toFixed(7)
        };
    };
    SketchCanvasRenderer2D.prototype.arc = function (x, y, w, h, start, stop, mode, detail) {
        var ctx = this.drawingContext;
        var rx = w / 2.0;
        var ry = h / 2.0;
        var epsilon = 0.00001; // Smallest visible angle on displays up to 4K.
        var arcToDraw = 0;
        var curves = [];
        x += rx;
        y += ry;
        // Create curves
        while (stop - start >= epsilon) {
            arcToDraw = Math.min(stop - start, _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.HALF_PI);
            curves.push(this._acuteArcToBezier(start, arcToDraw));
            start += arcToDraw;
        }
        // Fill curves
        if (this._doFill) {
            ctx.beginPath();
            curves.forEach(function (curve, index) {
                if (index === 0) {
                    ctx.moveTo(x + curve.ax * rx, y + curve.ay * ry);
                }
                // prettier-ignore
                ctx.bezierCurveTo(x + curve.bx * rx, y + curve.by * ry, x + curve.cx * rx, y + curve.cy * ry, x + curve.dx * rx, y + curve.dy * ry);
            });
            if (mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.PIE || mode == null) {
                ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            this._pInst._pixelsDirty = true;
        }
        // Stroke curves
        if (this._doStroke) {
            ctx.beginPath();
            curves.forEach(function (curve, index) {
                if (index === 0) {
                    ctx.moveTo(x + curve.ax * rx, y + curve.ay * ry);
                }
                // prettier-ignore
                ctx.bezierCurveTo(x + curve.bx * rx, y + curve.by * ry, x + curve.cx * rx, y + curve.cy * ry, x + curve.dx * rx, y + curve.dy * ry);
            });
            if (mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.PIE) {
                ctx.lineTo(x, y);
                ctx.closePath();
            }
            else if (mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CHORD) {
                ctx.closePath();
            }
            ctx.stroke();
            this._pInst._pixelsDirty = true;
        }
    };
    SketchCanvasRenderer2D.prototype.ellipse = function (args) {
        var ctx = this.drawingContext;
        var doFill = this._doFill, doStroke = this._doStroke;
        var x = args[0], y = args[1], w = args[2], h = args[3];
        if (doFill && !doStroke) {
            if (this._getFill() === styleEmpty) {
                return this;
            }
        }
        else if (!doFill && doStroke) {
            if (this._getStroke() === styleEmpty) {
                return this;
            }
        }
        var kappa = 0.5522847498, 
        // control point offset horizontal
        ox = w / 2 * kappa, 
        // control point offset vertical
        oy = h / 2 * kappa, 
        // x-end
        xe = x + w, 
        // y-end
        ye = y + h, 
        // x-middle
        xm = x + w / 2, ym = y + h / 2; // y-middle
        ctx.beginPath();
        ctx.moveTo(x, ym);
        ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
        ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
        ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
        ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
        ctx.closePath();
        if (doFill) {
            ctx.fill();
            this._pInst._pixelsDirty = true;
        }
        if (doStroke) {
            ctx.stroke();
            this._pInst._pixelsDirty = true;
        }
    };
    SketchCanvasRenderer2D.prototype.line = function (x1, y1, x2, y2) {
        var ctx = this.drawingContext;
        if (!this._doStroke) {
            return this;
        }
        else if (this._getStroke() === styleEmpty) {
            return this;
        }
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        this._pInst._pixelsDirty = true;
        return this;
    };
    SketchCanvasRenderer2D.prototype.point = function (x, y) {
        var ctx = this.drawingContext;
        if (!this._doStroke) {
            return this;
        }
        else if (this._getStroke() === styleEmpty) {
            return this;
        }
        var s = this._getStroke();
        var f = this._getFill();
        x = Math.round(x);
        y = Math.round(y);
        // swapping fill color to stroke and back after for correct point rendering
        this._setFill(s);
        if (ctx.lineWidth > 1) {
            ctx.beginPath();
            ctx.arc(x, y, ctx.lineWidth / 2, 0, _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.TWO_PI, false);
            ctx.fill();
        }
        else {
            ctx.fillRect(x, y, 1, 1);
        }
        this._setFill(f);
        this._pInst._pixelsDirty = true;
    };
    SketchCanvasRenderer2D.prototype.quad = function (x1, y1, x2, y2, x3, y3, x4, y4) {
        var ctx = this.drawingContext;
        var doFill = this._doFill, doStroke = this._doStroke;
        if (doFill && !doStroke) {
            if (this._getFill() === styleEmpty) {
                return this;
            }
        }
        else if (!doFill && doStroke) {
            if (this._getStroke() === styleEmpty) {
                return this;
            }
        }
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.lineTo(x4, y4);
        ctx.closePath();
        if (doFill) {
            ctx.fill();
        }
        if (doStroke) {
            ctx.stroke();
        }
        this._pInst._pixelsDirty = true;
        return this;
    };
    SketchCanvasRenderer2D.prototype.rect = function (args) {
        var x = args[0];
        var y = args[1];
        var w = args[2];
        var h = args[3];
        var tl = args[4];
        var tr = args[5];
        var br = args[6];
        var bl = args[7];
        var ctx = this.drawingContext;
        var doFill = this._doFill, doStroke = this._doStroke;
        if (doFill && !doStroke) {
            if (this._getFill() === styleEmpty) {
                return this;
            }
        }
        else if (!doFill && doStroke) {
            if (this._getStroke() === styleEmpty) {
                return this;
            }
        }
        ctx.beginPath();
        if (typeof tl === 'undefined') {
            // No rounded corners
            ctx.rect(x, y, w, h);
        }
        else {
            // At least one rounded corner
            // Set defaults when not specified
            if (typeof tr === 'undefined') {
                tr = tl;
            }
            if (typeof br === 'undefined') {
                br = tr;
            }
            if (typeof bl === 'undefined') {
                bl = br;
            }
            // corner rounding must always be positive
            var absW = Math.abs(w);
            var absH = Math.abs(h);
            var hw = absW / 2;
            var hh = absH / 2;
            // Clip radii
            if (absW < 2 * tl) {
                tl = hw;
            }
            if (absH < 2 * tl) {
                tl = hh;
            }
            if (absW < 2 * tr) {
                tr = hw;
            }
            if (absH < 2 * tr) {
                tr = hh;
            }
            if (absW < 2 * br) {
                br = hw;
            }
            if (absH < 2 * br) {
                br = hh;
            }
            if (absW < 2 * bl) {
                bl = hw;
            }
            if (absH < 2 * bl) {
                bl = hh;
            }
            // Draw shape
            ctx.beginPath();
            ctx.moveTo(x + tl, y);
            ctx.arcTo(x + w, y, x + w, y + h, tr);
            ctx.arcTo(x + w, y + h, x, y + h, br);
            ctx.arcTo(x, y + h, x, y, bl);
            ctx.arcTo(x, y, x + w, y, tl);
            ctx.closePath();
        }
        if (this._doFill) {
            ctx.fill();
        }
        if (this._doStroke) {
            ctx.stroke();
        }
        this._pInst._pixelsDirty = true;
        return this;
    };
    SketchCanvasRenderer2D.prototype.triangle = function (args) {
        var ctx = this.drawingContext;
        var doFill = this._doFill, doStroke = this._doStroke;
        var x1 = args[0], y1 = args[1];
        var x2 = args[2], y2 = args[3];
        var x3 = args[4], y3 = args[5];
        if (doFill && !doStroke) {
            if (this._getFill() === styleEmpty) {
                return this;
            }
        }
        else if (!doFill && doStroke) {
            if (this._getStroke() === styleEmpty) {
                return this;
            }
        }
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.closePath();
        if (doFill) {
            ctx.fill();
            this._pInst._pixelsDirty = true;
        }
        if (doStroke) {
            ctx.stroke();
            this._pInst._pixelsDirty = true;
        }
    };
    SketchCanvasRenderer2D.prototype.endShape = function (mode, vertices, isCurve, isBezier, isQuadratic, isContour, shapeKind) {
        if (vertices.length === 0) {
            return this;
        }
        if (!this._doStroke && !this._doFill) {
            return this;
        }
        var closeShape = mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CLOSE;
        var v;
        if (closeShape && !isContour) {
            vertices.push(vertices[0]);
        }
        var i, j;
        var numVerts = vertices.length;
        if (isCurve && (shapeKind === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.POLYGON || shapeKind === null)) {
            if (numVerts > 3) {
                var b = [], s = 1 - this._curveTightness;
                this.drawingContext.beginPath();
                this.drawingContext.moveTo(vertices[1][0], vertices[1][1]);
                for (i = 1; i + 2 < numVerts; i++) {
                    v = vertices[i];
                    b[0] = [v[0], v[1]];
                    b[1] = [
                        v[0] + (s * vertices[i + 1][0] - s * vertices[i - 1][0]) / 6,
                        v[1] + (s * vertices[i + 1][1] - s * vertices[i - 1][1]) / 6
                    ];
                    b[2] = [
                        vertices[i + 1][0] +
                            (s * vertices[i][0] - s * vertices[i + 2][0]) / 6,
                        vertices[i + 1][1] + (s * vertices[i][1] - s * vertices[i + 2][1]) / 6
                    ];
                    b[3] = [vertices[i + 1][0], vertices[i + 1][1]];
                    this.drawingContext.bezierCurveTo(b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);
                }
                if (closeShape) {
                    this.drawingContext.lineTo(vertices[i + 1][0], vertices[i + 1][1]);
                }
                this._doFillStrokeClose(closeShape);
            }
        }
        else if (isBezier &&
            (shapeKind === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.POLYGON || shapeKind === null)) {
            this.drawingContext.beginPath();
            for (i = 0; i < numVerts; i++) {
                if (vertices[i].isVert) {
                    if (vertices[i].moveTo) {
                        this.drawingContext.moveTo(vertices[i][0], vertices[i][1]);
                    }
                    else {
                        this.drawingContext.lineTo(vertices[i][0], vertices[i][1]);
                    }
                }
                else {
                    this.drawingContext.bezierCurveTo(vertices[i][0], vertices[i][1], vertices[i][2], vertices[i][3], vertices[i][4], vertices[i][5]);
                }
            }
            this._doFillStrokeClose(closeShape);
        }
        else if (isQuadratic &&
            (shapeKind === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.POLYGON || shapeKind === null)) {
            this.drawingContext.beginPath();
            for (i = 0; i < numVerts; i++) {
                if (vertices[i].isVert) {
                    if (vertices[i].moveTo) {
                        this.drawingContext.moveTo(vertices[i][0], vertices[i][1]);
                    }
                    else {
                        this.drawingContext.lineTo(vertices[i][0], vertices[i][1]);
                    }
                }
                else {
                    this.drawingContext.quadraticCurveTo(vertices[i][0], vertices[i][1], vertices[i][2], vertices[i][3]);
                }
            }
            this._doFillStrokeClose(closeShape);
        }
        else {
            if (shapeKind === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.POINTS) {
                for (i = 0; i < numVerts; i++) {
                    v = vertices[i];
                    if (this._doStroke) {
                        this._pInst.stroke(v[6]);
                    }
                    this._pInst.point(v[0], v[1]);
                }
            }
            else if (shapeKind === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.LINES) {
                for (i = 0; i + 1 < numVerts; i += 2) {
                    v = vertices[i];
                    if (this._doStroke) {
                        this._pInst.stroke(vertices[i + 1][6]);
                    }
                    this._pInst.line(v[0], v[1], vertices[i + 1][0], vertices[i + 1][1]);
                }
            }
            else if (shapeKind === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.TRIANGLES) {
                for (i = 0; i + 2 < numVerts; i += 3) {
                    v = vertices[i];
                    this.drawingContext.beginPath();
                    this.drawingContext.moveTo(v[0], v[1]);
                    this.drawingContext.lineTo(vertices[i + 1][0], vertices[i + 1][1]);
                    this.drawingContext.lineTo(vertices[i + 2][0], vertices[i + 2][1]);
                    this.drawingContext.closePath();
                    if (this._doFill) {
                        this._pInst.fill(vertices[i + 2][5]);
                        this.drawingContext.fill();
                    }
                    if (this._doStroke) {
                        this._pInst.stroke(vertices[i + 2][6]);
                        this.drawingContext.stroke();
                    }
                }
            }
            else if (shapeKind === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.TRIANGLE_STRIP) {
                for (i = 0; i + 1 < numVerts; i++) {
                    v = vertices[i];
                    this.drawingContext.beginPath();
                    this.drawingContext.moveTo(vertices[i + 1][0], vertices[i + 1][1]);
                    this.drawingContext.lineTo(v[0], v[1]);
                    if (this._doStroke) {
                        this._pInst.stroke(vertices[i + 1][6]);
                    }
                    if (this._doFill) {
                        this._pInst.fill(vertices[i + 1][5]);
                    }
                    if (i + 2 < numVerts) {
                        this.drawingContext.lineTo(vertices[i + 2][0], vertices[i + 2][1]);
                        if (this._doStroke) {
                            this._pInst.stroke(vertices[i + 2][6]);
                        }
                        if (this._doFill) {
                            this._pInst.fill(vertices[i + 2][5]);
                        }
                    }
                    this._doFillStrokeClose(closeShape);
                }
            }
            else if (shapeKind === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.TRIANGLE_FAN) {
                if (numVerts > 2) {
                    // For performance reasons, try to batch as many of the
                    // fill and stroke calls as possible.
                    this.drawingContext.beginPath();
                    for (i = 2; i < numVerts; i++) {
                        v = vertices[i];
                        this.drawingContext.moveTo(vertices[0][0], vertices[0][1]);
                        this.drawingContext.lineTo(vertices[i - 1][0], vertices[i - 1][1]);
                        this.drawingContext.lineTo(v[0], v[1]);
                        this.drawingContext.lineTo(vertices[0][0], vertices[0][1]);
                        // If the next colour is going to be different, stroke / fill now
                        if (i < numVerts - 1) {
                            if ((this._doFill && v[5] !== vertices[i + 1][5]) ||
                                (this._doStroke && v[6] !== vertices[i + 1][6])) {
                                if (this._doFill) {
                                    this._pInst.fill(v[5]);
                                    this.drawingContext.fill();
                                    this._pInst.fill(vertices[i + 1][5]);
                                }
                                if (this._doStroke) {
                                    this._pInst.stroke(v[6]);
                                    this.drawingContext.stroke();
                                    this._pInst.stroke(vertices[i + 1][6]);
                                }
                                this.drawingContext.closePath();
                                this.drawingContext.beginPath(); // Begin the next one
                            }
                        }
                    }
                    this._doFillStrokeClose(closeShape);
                }
            }
            else if (shapeKind === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.QUADS) {
                for (i = 0; i + 3 < numVerts; i += 4) {
                    v = vertices[i];
                    this.drawingContext.beginPath();
                    this.drawingContext.moveTo(v[0], v[1]);
                    for (j = 1; j < 4; j++) {
                        this.drawingContext.lineTo(vertices[i + j][0], vertices[i + j][1]);
                    }
                    this.drawingContext.lineTo(v[0], v[1]);
                    if (this._doFill) {
                        this._pInst.fill(vertices[i + 3][5]);
                    }
                    if (this._doStroke) {
                        this._pInst.stroke(vertices[i + 3][6]);
                    }
                    this._doFillStrokeClose(closeShape);
                }
            }
            else if (shapeKind === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.QUAD_STRIP) {
                if (numVerts > 3) {
                    for (i = 0; i + 1 < numVerts; i += 2) {
                        v = vertices[i];
                        this.drawingContext.beginPath();
                        if (i + 3 < numVerts) {
                            this.drawingContext.moveTo(vertices[i + 2][0], vertices[i + 2][1]);
                            this.drawingContext.lineTo(v[0], v[1]);
                            this.drawingContext.lineTo(vertices[i + 1][0], vertices[i + 1][1]);
                            this.drawingContext.lineTo(vertices[i + 3][0], vertices[i + 3][1]);
                            if (this._doFill) {
                                this._pInst.fill(vertices[i + 3][5]);
                            }
                            if (this._doStroke) {
                                this._pInst.stroke(vertices[i + 3][6]);
                            }
                        }
                        else {
                            this.drawingContext.moveTo(v[0], v[1]);
                            this.drawingContext.lineTo(vertices[i + 1][0], vertices[i + 1][1]);
                        }
                        this._doFillStrokeClose(closeShape);
                    }
                }
            }
            else {
                this.drawingContext.beginPath();
                this.drawingContext.moveTo(vertices[0][0], vertices[0][1]);
                for (i = 1; i < numVerts; i++) {
                    v = vertices[i];
                    if (v.isVert) {
                        if (v.moveTo) {
                            this.drawingContext.moveTo(v[0], v[1]);
                        }
                        else {
                            this.drawingContext.lineTo(v[0], v[1]);
                        }
                    }
                }
                this._doFillStrokeClose(closeShape);
            }
        }
        isCurve = false;
        isBezier = false;
        isQuadratic = false;
        isContour = false;
        if (closeShape) {
            vertices.pop();
        }
        this._pInst._pixelsDirty = true;
        return this;
    };
    SketchCanvasRenderer2D.prototype.strokeCap = function (cap) {
        if (cap === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.ROUND ||
            cap === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.SQUARE ||
            cap === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.PROJECT) {
            this.drawingContext.lineCap = cap;
        }
        return this;
    };
    SketchCanvasRenderer2D.prototype.strokeJoin = function (join) {
        if (join === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.ROUND ||
            join === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BEVEL ||
            join === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.MITER) {
            this.drawingContext.lineJoin = join;
        }
        return this;
    };
    SketchCanvasRenderer2D.prototype.strokeWeight = function (w) {
        if (typeof w === 'undefined' || w === 0) {
            // hack because lineWidth 0 doesn't work
            this.drawingContext.lineWidth = 0.0001;
        }
        else {
            this.drawingContext.lineWidth = w;
        }
        return this;
    };
    SketchCanvasRenderer2D.prototype._getFill = function () {
        if (!this._cachedFillStyle) {
            this._cachedFillStyle = this.drawingContext.fillStyle;
        }
        return this._cachedFillStyle;
    };
    SketchCanvasRenderer2D.prototype._setFill = function (fillStyle, force) {
        if (force === void 0) { force = false; }
        if (fillStyle !== this._cachedFillStyle || force) {
            this.drawingContext.fillStyle = fillStyle;
            this._cachedFillStyle = fillStyle;
        }
    };
    SketchCanvasRenderer2D.prototype._getStroke = function () {
        if (!this._cachedStrokeStyle) {
            this._cachedStrokeStyle = this.drawingContext.strokeStyle;
        }
        return this._cachedStrokeStyle;
    };
    SketchCanvasRenderer2D.prototype._setStroke = function (strokeStyle, force) {
        if (force === void 0) { force = false; }
        if (strokeStyle !== this._cachedStrokeStyle || force) {
            this.drawingContext.strokeStyle = strokeStyle;
            this._cachedStrokeStyle = strokeStyle;
        }
    };
    //////////////////////////////////////////////
    // SHAPE | Curves
    //////////////////////////////////////////////
    SketchCanvasRenderer2D.prototype.bezier = function (x1, y1, x2, y2, x3, y3, x4, y4) {
        this._pInst.beginShape();
        this._pInst.vertex(x1, y1);
        this._pInst.bezierVertex(x2, y2, x3, y3, x4, y4);
        this._pInst.endShape();
        return this;
    };
    SketchCanvasRenderer2D.prototype.curve = function (x1, y1, x2, y2, x3, y3, x4, y4) {
        this._pInst.beginShape();
        this._pInst.curveVertex(x1, y1);
        this._pInst.curveVertex(x2, y2);
        this._pInst.curveVertex(x3, y3);
        this._pInst.curveVertex(x4, y4);
        this._pInst.endShape();
        return this;
    };
    //////////////////////////////////////////////
    // SHAPE | Vertex
    //////////////////////////////////////////////
    SketchCanvasRenderer2D.prototype._doFillStrokeClose = function (closeShape) {
        if (closeShape) {
            this.drawingContext.closePath();
        }
        if (this._doFill) {
            this.drawingContext.fill();
        }
        if (this._doStroke) {
            this.drawingContext.stroke();
        }
        this._pInst._pixelsDirty = true;
    };
    //////////////////////////////////////////////
    // TRANSFORM
    //////////////////////////////////////////////
    SketchCanvasRenderer2D.prototype.applyMatrix = function (a, b, c, d, e, f) {
        this.drawingContext.transform(a, b, c, d, e, f);
    };
    SketchCanvasRenderer2D.prototype.resetMatrix = function () {
        this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
        this.drawingContext.scale(this._pInst._pixelDensity, this._pInst._pixelDensity);
        return this;
    };
    SketchCanvasRenderer2D.prototype.rotate = function (rad, axis) {
        this.drawingContext.rotate(rad);
    };
    SketchCanvasRenderer2D.prototype.scale = function (x, y) {
        this.drawingContext.scale(x, y);
        return this;
    };
    SketchCanvasRenderer2D.prototype.translate = function (x, y) {
        // support passing a vector as the 1st parameter
        if (x instanceof _math_Vector__WEBPACK_IMPORTED_MODULE_4__.Vector) {
            y = x.y;
            x = x.x;
        }
        this.drawingContext.translate(x, y);
        return this;
    };
    SketchCanvasRenderer2D.prototype._text = function (str, x, y, maxWidth, maxHeight) {
        var p = this._pInst;
        var cars;
        var n;
        var ii;
        var jj;
        var line;
        var testLine;
        var testWidth;
        var words;
        var totalHeight;
        var finalMaxHeight = Number.MAX_VALUE;
        if (!(this._doFill || this._doStroke)) {
            return;
        }
        if (typeof str === 'undefined') {
            return;
        }
        else if (typeof str !== 'string') {
            str = str.toString();
        }
        str = str.replace(/(\t)/g, '  ');
        cars = str.split('\n');
        if (typeof maxWidth !== 'undefined') {
            totalHeight = 0;
            for (ii = 0; ii < cars.length; ii++) {
                line = '';
                words = cars[ii].split(' ');
                for (n = 0; n < words.length; n++) {
                    testLine = line + words[n] + " ";
                    testWidth = this.textWidth(testLine);
                    if (testWidth > maxWidth) {
                        line = words[n] + " ";
                        totalHeight += p.textLeading();
                    }
                    else {
                        line = testLine;
                    }
                }
            }
            if (this._rectMode === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CENTER) {
                x -= maxWidth / 2;
                y -= maxHeight / 2;
            }
            switch (this._textAlign) {
                case _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CENTER:
                    x += maxWidth / 2;
                    break;
                case _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.RIGHT:
                    x += maxWidth;
                    break;
            }
            var baselineHacked = false;
            if (typeof maxHeight !== 'undefined') {
                switch (this._textBaseline) {
                    case _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BOTTOM:
                        y += maxHeight - totalHeight;
                        break;
                    case _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CENTER:
                        y += (maxHeight - totalHeight) / 2;
                        break;
                    case _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BASELINE:
                        baselineHacked = true;
                        this._textBaseline = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.TOP;
                        break;
                }
                // remember the max-allowed y-position for any line (fix to #928)
                finalMaxHeight = y + maxHeight - p.textAscent();
            }
            for (ii = 0; ii < cars.length; ii++) {
                line = '';
                words = cars[ii].split(' ');
                for (n = 0; n < words.length; n++) {
                    testLine = line + words[n] + " ";
                    testWidth = this.textWidth(testLine);
                    if (testWidth > maxWidth && line.length > 0) {
                        this._renderText(p, line, x, y, finalMaxHeight);
                        line = words[n] + " ";
                        y += p.textLeading();
                    }
                    else {
                        line = testLine;
                    }
                }
                this._renderText(p, line, x, y, finalMaxHeight);
                y += p.textLeading();
                if (baselineHacked) {
                    this._textBaseline = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BASELINE;
                }
            }
        }
        else {
            // Offset to account for vertically centering multiple lines of text - no
            // need to adjust anything for vertical align top or baseline
            var offset = 0;
            var vAlign = p.textAlign().vertical;
            if (vAlign === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CENTER) {
                offset = (cars.length - 1) * p.textLeading() / 2;
            }
            else if (vAlign === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BOTTOM) {
                offset = (cars.length - 1) * p.textLeading();
            }
            for (jj = 0; jj < cars.length; jj++) {
                this._renderText(p, cars[jj], x, y - offset, finalMaxHeight);
                y += p.textLeading();
            }
        }
        return p;
    };
    SketchCanvasRenderer2D.prototype.text = function (str, x, y, maxWidth, maxHeight) {
        var baselineHacked;
        // baselineHacked: (HACK)
        // A temporary fix to conform to Processing's implementation
        // of BASELINE vertical alignment in a bounding box
        if (typeof maxWidth !== 'undefined') {
            if (this.drawingContext.textBaseline === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BASELINE) {
                baselineHacked = true;
                this.drawingContext.textBaseline = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.TOP;
            }
        }
        var p = this._text(str, x, y, maxWidth, maxHeight);
        if (baselineHacked) {
            this.drawingContext.textBaseline = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BASELINE;
        }
        return p;
    };
    SketchCanvasRenderer2D.prototype._renderText = function (p, line, x, y, maxY) {
        if (y >= maxY) {
            return; // don't render lines beyond our maxY position
        }
        p.push(); // fix to #803
        if (!this._isOpenType()) {
            // a system/browser font
            // no stroke unless specified by user
            if (this._doStroke && this._strokeSet) {
                this.drawingContext.strokeText(line, x, y);
            }
            if (this._doFill) {
                // if fill hasn't been set by user, use default text fill
                if (!this._fillSet) {
                    this._setFill(_core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants._DEFAULT_TEXT_FILL);
                }
                this.drawingContext.fillText(line, x, y);
            }
        }
        else {
            // an opentype font, let it handle the rendering
            this._textFont._renderPath(line, x, y, { renderer: this });
        }
        p.pop();
        this._pInst._pixelsDirty = true;
        return p;
    };
    SketchCanvasRenderer2D.prototype.textLeading = function (l) {
        if (typeof l === 'number') {
            this._textLeading = l;
            // return this._pInst;
        }
        return this._textLeading;
    };
    SketchCanvasRenderer2D.prototype.textSize = function (s) {
        if (typeof s === 'number') {
            this._textSize = s;
            this._textLeading = s * _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants._DEFAULT_LEADMULT;
            this._applyTextProperties();
        }
        return this._textSize;
    };
    SketchCanvasRenderer2D.prototype.textStyle = function (s) {
        if (s) {
            if (s === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.NORMAL ||
                s === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.ITALIC ||
                s === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BOLD ||
                s === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BOLDITALIC) {
                this._textStyle = s;
            }
            return this._applyTextProperties();
        }
        return this._textStyle;
    };
    SketchCanvasRenderer2D.prototype.textAscent = function () {
        if (this._textAscent === null) {
            this._updateTextMetrics();
        }
        return this._textAscent;
    };
    /**
     * Helper fxn to check font type (system or otf)
     */
    SketchCanvasRenderer2D.prototype._isOpenType = function (f) {
        if (f === void 0) { f = this._textFont; }
        return typeof f === 'object' && f.font && f.font.supported;
    };
    SketchCanvasRenderer2D.prototype._updateTextMetrics = function () {
        if (this._isOpenType()) {
            this._textAscent = this._textFont._textAscent();
            this._textDescent = this._textFont._textDescent();
            return this;
        }
        // Adapted from http://stackoverflow.com/a/25355178
        var text = document.createElement('span');
        text.style.fontFamily = this._textFont;
        text.style.fontSize = this._textSize + "px";
        text.innerHTML = 'ABCjgq|';
        var block = document.createElement('div');
        block.style.display = 'inline-block';
        block.style.width = '1px';
        block.style.height = '0px';
        var container = document.createElement('div');
        container.appendChild(text);
        container.appendChild(block);
        container.style.height = '0px';
        container.style.overflow = 'hidden';
        document.body.appendChild(container);
        block.style.verticalAlign = 'baseline';
        var blockOffset = this._calculateOffset(block);
        var textOffset = this._calculateOffset(text);
        var ascent = blockOffset[1] - textOffset[1];
        block.style.verticalAlign = 'bottom';
        blockOffset = this._calculateOffset(block);
        textOffset = this._calculateOffset(text);
        var height = blockOffset[1] - textOffset[1];
        var descent = height - ascent;
        document.body.removeChild(container);
        this._textAscent = ascent;
        this._textDescent = descent;
        return this;
    };
    SketchCanvasRenderer2D.prototype._calculateOffset = function (object) {
        var currentLeft = 0, currentTop = 0;
        if (object.offsetParent) {
            do {
                currentLeft += object.offsetLeft;
                currentTop += object.offsetTop;
            } while ((object = object.offsetParent));
        }
        else {
            currentLeft += object.offsetLeft;
            currentTop += object.offsetTop;
        }
        return [currentLeft, currentTop];
    };
    SketchCanvasRenderer2D.prototype.textDescent = function () {
        if (this._textDescent === null) {
            this._updateTextMetrics();
        }
        return this._textDescent;
    };
    SketchCanvasRenderer2D.prototype.textAlign = function (h, v) {
        if (typeof h !== 'undefined') {
            this._textAlign = h;
            if (typeof v !== 'undefined') {
                this._textBaseline = v;
            }
            this._applyTextProperties();
        }
        else {
            return {
                horizontal: this._textAlign,
                vertical: this._textBaseline
            };
        }
    };
    SketchCanvasRenderer2D.prototype.textWidth = function (s) {
        if (this._isOpenType()) {
            return this._textFont._textWidth(s, this._textSize);
        }
        return this.drawingContext.measureText(s).width;
    };
    SketchCanvasRenderer2D.prototype._applyTextProperties = function () {
        var font;
        var p = this._pInst;
        this._textAscent = null;
        this._textDescent = null;
        font = this._textFont;
        if (this._isOpenType()) {
            font = this._textFont.font.familyName;
            this._textStyle = this._textFont.font.styleName;
        }
        this.drawingContext.font = (this._textStyle || 'normal') + " " + (this._textSize ||
            12) + "px " + (font || 'sans-serif');
        this.drawingContext.textAlign = this._textAlign;
        if (this._textBaseline === _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CENTER) {
            this.drawingContext.textBaseline = _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants._CTX_MIDDLE;
        }
        else {
            this.drawingContext.textBaseline = this._textBaseline;
        }
        return p;
    };
    //////////////////////////////////////////////
    // STRUCTURE
    //////////////////////////////////////////////
    // a push() operation is in progress.
    // the renderer should return a 'style' object that it wishes to
    // store on the push stack.
    // derived renderers should call the base class' push() method
    // to fetch the base style object.
    SketchCanvasRenderer2D.prototype.push = function () {
        this.drawingContext.save();
        // get the base renderer style
        return {
            properties: {
                _doStroke: this._doStroke,
                _strokeSet: this._strokeSet,
                _doFill: this._doFill,
                _fillSet: this._fillSet,
                _tint: this._tint,
                _imageMode: this._imageMode,
                _rectMode: this._rectMode,
                _ellipseMode: this._ellipseMode,
                _textFont: this._textFont,
                _textLeading: this._textLeading,
                _textSize: this._textSize,
                _textAlign: this._textAlign,
                _textBaseline: this._textBaseline,
                _textStyle: this._textStyle
            }
        };
    };
    // a pop() operation is in progress
    // the renderer is passed the 'style' object that it returned
    // from its push() method.
    // derived renderers should pass this object to their base
    // class' pop method
    SketchCanvasRenderer2D.prototype.pop = function (style) {
        this.drawingContext.restore();
        // Re-cache the fill / stroke state
        this._cachedFillStyle = this.drawingContext.fillStyle;
        this._cachedStrokeStyle = this.drawingContext.strokeStyle;
        if (style.properties) {
            // copy the style properties back into the renderer
            Object.assign(this, style.properties);
        }
    };
    SketchCanvasRenderer2D.prototype.get = function (x, y, w, h) {
        var pd = this._pInst._pixelDensity;
        var canvas = this.drawingContext.canvas;
        if (typeof x === 'undefined' && typeof y === 'undefined') {
            // get()
            x = y = 0;
            w = this._pInst.width;
            h = this._pInst.height;
        }
        else {
            x *= pd;
            y *= pd;
            if (typeof w === 'undefined' && typeof h === 'undefined') {
                // get(x,y)
                if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
                    return [0, 0, 0, 0];
                }
                return this._getPixel(x, y);
            }
            // get(x,y,w,h)
        }
        var region = new _image_SketchImage__WEBPACK_IMPORTED_MODULE_1__.SketchImage(w, h);
        region.canvas.getContext('2d').drawImage(canvas, x, y, w * pd, h * pd, 0, 0, w, h);
        return region;
    };
    SketchCanvasRenderer2D.prototype.resize = function (w, h) {
        var canvas = this._pInst.getCanvas();
        canvas.width = w * this._pInst._pixelDensity;
        canvas.height = h * this._pInst._pixelDensity;
        canvas.style.width = w + "px";
        canvas.style.height = h + "px";
        this._pInst.width = w;
        this._pInst.height = h;
    };
    return SketchCanvasRenderer2D;
}(_tuval_cg__WEBPACK_IMPORTED_MODULE_3__.CGContext2D));



/***/ }),

/***/ "./src/drawing/sketch/SketchGraphics.ts":
/*!**********************************************!*\
  !*** ./src/drawing/sketch/SketchGraphics.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SketchGraphics": () => (/* binding */ SketchGraphics)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _UI_DraggablePoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../../UI/DraggablePoint */ "./src/UI/DraggablePoint.ts");
/* harmony import */ var _Graphics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Graphics */ "./src/drawing/Graphics.ts");
/* harmony import */ var _SketchCanvasRenderer2D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SketchCanvasRenderer2D */ "./src/drawing/sketch/SketchCanvasRenderer2D.ts");
/* harmony import */ var _core_Constanst__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/Constanst */ "./src/drawing/sketch/core/Constanst.ts");
/* harmony import */ var _image_SketchImage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./image/SketchImage */ "./src/drawing/sketch/image/SketchImage.ts");
/* harmony import */ var _image_filters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./image/filters */ "./src/drawing/sketch/image/filters.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _math_Vector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./math/Vector */ "./src/drawing/sketch/math/Vector.ts");
/* harmony import */ var _typography_SketchFont__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./typography/SketchFont */ "./src/drawing/sketch/typography/SketchFont.ts");
/* harmony import */ var _SolidBrush__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _Pen__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Pen */ "./src/drawing/Pen.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};












function modeAdjust(a, b, c, d, mode) {
    if (mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CORNER) {
        return { x: a, y: b, w: c, h: d };
    }
    else if (mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CORNERS) {
        return { x: a, y: b, w: c - a, h: d - b };
    }
    else if (mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RADIUS) {
        return { x: a - c, y: b - d, w: 2 * c, h: 2 * d };
    }
    else if (mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CENTER) {
        return { x: a - c * 0.5, y: b - d * 0.5, w: c, h: d };
    }
}
var randomStateProp = '_lcg_random_state';
// Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes
// m is basically chosen to be large (as it is the max period)
// and for its relationships to a and c
var m = 4294967296;
// a - 1 should be divisible by m's prime factors
var a = 1664525;
// c and m should be co-prime
var c = 1013904223;
var y2 = 0;
var shapeKind = null;
var vertices = [];
var contourVertices = [];
var isBezier = false;
var isCurve = false;
var isQuadratic = false;
var isContour = false;
var isFirstContour = true;
var PERLIN_YWRAPB = 4;
var PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
var PERLIN_ZWRAPB = 8;
var PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
var PERLIN_SIZE = 4095;
var perlin_octaves = 4; // default to medium smooth
var perlin_amp_falloff = 0.5; // 50% reduction/octave
var scaled_cosine = function (i) { return 0.5 * (1.0 - Math.cos(i * Math.PI)); };
var perlin; // will be initialized lazily by noise() or noiseSeed()
function getWindowWidth() {
    return (window.innerWidth ||
        (document.documentElement && document.documentElement.clientWidth) ||
        (document.body && document.body.clientWidth) ||
        0);
}
function getWindowHeight() {
    return (window.innerHeight ||
        (document.documentElement && document.documentElement.clientHeight) ||
        (document.body && document.body.clientHeight) ||
        0);
}
var SketchGraphics = /** @class */ (function (_super) {
    __extends(SketchGraphics, _super);
    function SketchGraphics() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._collideDebug = false;
        _this._pixelsDirty = true;
        _this.antialias = false;
        _this._contourInited = false;
        _this._contourVertices = [];
        _this._pixelDensity = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.workerContext() ? 1 : Math.ceil(window.devicePixelRatio) || 1;
        _this._gaussian_previous = false;
        _this._colorMode = _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RGB;
        _this._angleMode = _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RADIANS;
        _this._colorMaxes = {
            rgb: [255, 255, 255, 255],
            hsb: [360, 100, 100, 1],
            hsl: [360, 100, 100, 1]
        };
        _this._styles = [];
        _this.pixels = undefined;
        _this.imageData = undefined;
        _this._hasMouseInteracted = false;
        _this.mouseX = 0;
        _this.mouseY = 0;
        _this.pmouseX = 0;
        _this.pmouseY = 0;
        _this.winMouseX = 0;
        _this.winMouseY = 0;
        _this.pwinMouseX = 0;
        _this.pwinMouseY = 0;
        _this.movedX = 0;
        _this.movedY = 0;
        _this.mouseButton = undefined;
        _this.mouseIsPressed = false;
        _this._mouseWheelDeltaY = 0;
        _this._pmouseWheelDeltaY = 0;
        _this.mouseMoved = undefined;
        _this.mouseDragged = undefined;
        _this.touchMoved = undefined;
        _this.mousePressed = undefined;
        _this.touchStarted = undefined;
        _this.mouseReleased = undefined;
        _this.touchEnded = undefined;
        _this.mouseClicked = undefined;
        _this.doubleClicked = undefined;
        _this.mouseWheel = undefined;
        _this.windowResized = undefined;
        _this.isKeyPressed = false;
        _this.keyIsPressed = false;
        _this.key = '';
        _this.keyCode = 0;
        _this._downKeys = {};
        _this._lastKeyCodeTyped = 0;
        _this.keyPressed = undefined;
        _this.keyReleased = undefined;
        _this.keyTyped = undefined;
        return _this;
    }
    Object.defineProperty(SketchGraphics.prototype, "windowWidth", {
        get: function () {
            return getWindowWidth();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SketchGraphics.prototype, "windowHeight", {
        get: function () {
            return getWindowHeight();
        },
        enumerable: false,
        configurable: true
    });
    SketchGraphics.prototype.provideRenderer2D = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var canvasContext = args[0];
            return new _SketchCanvasRenderer2D__WEBPACK_IMPORTED_MODULE_3__.SketchCanvasRenderer2D(canvasContext, this);
        }
        else {
            throw new _tuval_core__WEBPACK_IMPORTED_MODULE_7__.ArgumentException('');
        }
    };
    /*   public provideRenderer3D(canvasContext: CanvasRenderingContext2D): SketchCanvasRenderer2D {
          return new WebGLRenderer(canvasContext, this);
      } */
    SketchGraphics.prototype.init = function () {
        this.renderer._applyDefaults();
        //const _elt = this.renderer.drawingContext.canvas;
        if (!_tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.workerContext()) {
            window.addEventListener('mousemove', this._onmousemove.bind(this), { passive: false });
            window.addEventListener('mousedown', this._onmousedown.bind(this), { passive: false });
            window.addEventListener('mouseup', this._onmouseup.bind(this), { passive: false });
            window.addEventListener('dragend', this._ondragend.bind(this), { passive: false });
            window.addEventListener('dragover', this._ondragover.bind(this), { passive: false });
            window.addEventListener('click', this._onclick.bind(this), { passive: false });
            window.addEventListener('dblclick', this._ondblclick.bind(this), { passive: false });
            //window.addEventListener('mouseover', this._onmou.bind(this), { passive: false });
            //window.addEventListener('mouseout', this._onmou.bind(this), { passive: false });
            window.addEventListener('keydown', this._onkeydown.bind(this), { passive: false });
            window.addEventListener('keyup', this._onkeyup.bind(this), { passive: false });
            window.addEventListener('keypress', this._onkeypress.bind(this), { passive: false });
            window.addEventListener('resize', this._onresize.bind(this), { passive: false });
        }
    };
    SketchGraphics.prototype._normalizeArcAngles = function (start, stop, width, height, correctForScaling) {
        var epsilon = 0.00001; // Smallest visible angle on displays up to 4K.
        var separation;
        // The order of the steps is important here: each one builds upon the
        // adjustments made in the steps that precede it.
        // Constrain both start and stop to [0,TWO_PI).
        start = start - _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.TWO_PI * Math.floor(start / _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.TWO_PI);
        stop = stop - _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.TWO_PI * Math.floor(stop / _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.TWO_PI);
        // Get the angular separation between the requested start and stop points.
        //
        // Technically this separation only matches what gets drawn if
        // correctForScaling is enabled.  We could add a more complicated calculation
        // for when the scaling is uncorrected (in which case the drawn points could
        // end up pushed together or pulled apart quite dramatically relative to what
        // was requested), but it would make things more opaque for little practical
        // benefit.
        //
        // (If you do disable correctForScaling and find that correspondToSamePoint
        // is set too aggressively, the easiest thing to do is probably to just make
        // epsilon smaller...)
        separation = Math.min(Math.abs(start - stop), _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.TWO_PI - Math.abs(start - stop));
        // Optionally adjust the angles to counter linear scaling.
        if (correctForScaling) {
            if (start <= _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.HALF_PI) {
                start = Math.atan(width / height * Math.tan(start));
            }
            else if (start > _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.HALF_PI && start <= 3 * _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.HALF_PI) {
                start = Math.atan(width / height * Math.tan(start)) + _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.PI;
            }
            else {
                start = Math.atan(width / height * Math.tan(start)) + _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.TWO_PI;
            }
            if (stop <= _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.HALF_PI) {
                stop = Math.atan(width / height * Math.tan(stop));
            }
            else if (stop > _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.HALF_PI && stop <= 3 * _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.HALF_PI) {
                stop = Math.atan(width / height * Math.tan(stop)) + _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.PI;
            }
            else {
                stop = Math.atan(width / height * Math.tan(stop)) + _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.TWO_PI;
            }
        }
        // Ensure that start <= stop < start + TWO_PI.
        if (start > stop) {
            stop += _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.TWO_PI;
        }
        return {
            start: start,
            stop: stop,
            correspondToSamePoint: separation < epsilon
        };
    };
    SketchGraphics.prototype.arc = function (x, y, w, h, start, stop, mode, detail) {
        // if the current stroke and fill settings wouldn't result in something
        // visible, exit immediately
        if (!this.renderer._doStroke && !this.renderer._doFill) {
            return;
        }
        start = this._toRadians(start);
        stop = this._toRadians(stop);
        // p5 supports negative width and heights for ellipses
        w = Math.abs(w);
        h = Math.abs(h);
        var vals = modeAdjust(x, y, w, h, this.renderer._ellipseMode);
        var angles = this._normalizeArcAngles(start, stop, vals.w, vals.h, true);
        if (angles.correspondToSamePoint) {
            // If the arc starts and ends at (near enough) the same place, we choose to
            // draw an ellipse instead.  This is preferable to faking an ellipse (by
            // making stop ever-so-slightly less than start + TWO_PI) because the ends
            // join up to each other rather than at a vertex at the centre (leaving
            // an unwanted spike in the stroke/fill).
            this.renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detail]);
        }
        else {
            this.renderer.arc(vals.x, vals.y, vals.w, vals.h, angles.start, // [0, TWO_PI)
            angles.stop, // [start, start + TWO_PI)
            mode, detail);
        }
    };
    SketchGraphics.prototype.ellipse = function (x, y, w, h, detailX) {
        // if the current stroke and fill settings wouldn't result in something
        // visible, exit immediately
        if (!this.renderer._doStroke && !this.renderer._doFill) {
            return this;
        }
        // supports negative width and heights for rects
        if (w < 0) {
            w = Math.abs(w);
        }
        if (typeof h === 'undefined') {
            // Duplicate 3rd argument if only 3 given.
            h = w;
        }
        else if (h < 0) {
            h = Math.abs(h);
        }
        var vals = modeAdjust(x, y, w, h, this.renderer._ellipseMode);
        this.renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detailX]);
        return this;
    };
    SketchGraphics.prototype.circle = function (x, y, d) {
        var args = Array.prototype.slice.call(arguments, 0, 2);
        args.push(arguments[2]);
        args.push(arguments[2]);
        return this.ellipse.apply(this, args);
    };
    SketchGraphics.prototype.line = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.renderer._doStroke) {
            this.renderer.line.apply(this.renderer, args);
        }
        return this;
    };
    SketchGraphics.prototype.point = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.renderer._doStroke) {
            this.renderer.point.apply(this.renderer, args);
        }
        return this;
    };
    SketchGraphics.prototype.quad = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.renderer._doStroke || this.renderer._doFill) {
            if (this.renderer.isP3D && args.length !== 12) {
                // if 3D and we weren't passed 12 args, assume Z is 0
                // prettier-ignore
                this.renderer.quad.call(this.renderer, args[0], args[1], 0, args[2], args[3], 0, args[4], args[5], 0, args[6], args[7], 0);
            }
            else {
                this.renderer.quad.apply(this.renderer, args);
            }
        }
        return this;
    };
    SketchGraphics.prototype.rect = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var rect = args[0];
            this.rect(rect.X, rect.Y, rect.Width, rect.Height);
        }
        else {
            if (this.renderer._doStroke || this.renderer._doFill) {
                var vals = modeAdjust(arguments[0], arguments[1], arguments[2], arguments[3], this.renderer._rectMode);
                var args_1 = [vals.x, vals.y, vals.w, vals.h];
                // append the additional arguments (either cornder radii, or
                // segment details) to the argument list
                for (var i = 4; i < arguments.length; i++) {
                    args_1[i] = arguments[i];
                }
                this.renderer.rect(args_1);
            }
        }
    };
    SketchGraphics.prototype.square = function (x, y, s, tl, tr, br, bl) {
        return this.rect(x, y, s, s, tl, tr, br, bl);
    };
    SketchGraphics.prototype.triangle = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.renderer._doStroke || this.renderer._doFill) {
            this.renderer.triangle(args);
        }
        return this;
    };
    SketchGraphics.prototype.ellipseMode = function (m) {
        if (m === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CORNER ||
            m === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CORNERS ||
            m === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RADIUS ||
            m === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CENTER) {
            this.renderer._ellipseMode = m;
        }
        return this;
    };
    SketchGraphics.prototype.noSmooth = function () {
        this.antialias = false;
        if (!this.renderer.isP3D) {
            if ('imageSmoothingEnabled' in this.renderer.drawingContext) {
                this.renderer.drawingContext.imageSmoothingEnabled = false;
            }
        }
        return this;
    };
    SketchGraphics.prototype.rectMode = function (m) {
        if (m === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CORNER ||
            m === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CORNERS ||
            m === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RADIUS ||
            m === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CENTER) {
            this.renderer._rectMode = m;
        }
        return this;
    };
    SketchGraphics.prototype.smooth = function () {
        this.antialias = true;
        if (!this.renderer.isP3D) {
            if ('imageSmoothingEnabled' in this.renderer.drawingContext) {
                this.renderer.drawingContext.imageSmoothingEnabled = true;
            }
        }
        return this;
    };
    SketchGraphics.prototype.strokeCap = function (cap) {
        if (cap === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.ROUND ||
            cap === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.SQUARE ||
            cap === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.PROJECT) {
            this.renderer.strokeCap(cap);
        }
        return this;
    };
    SketchGraphics.prototype.strokeJoin = function (join) {
        if (join === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.ROUND ||
            join === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.BEVEL ||
            join === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.MITER) {
            this.renderer.strokeJoin(join);
        }
        return this;
    };
    SketchGraphics.prototype.strokeWeight = function (w) {
        this.renderer.strokeWeight(w);
        return this;
    };
    SketchGraphics.prototype.bezier = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this.renderer._doStroke && !this.renderer._doFill) {
            return this;
        }
        this.renderer.bezier.apply(this.renderer, args);
        return this;
    };
    SketchGraphics.prototype.bezierDetail = function (d) {
        this._bezierDetail = d;
        return this;
    };
    SketchGraphics.prototype.bezierPoint = function (a, b, c, d, t) {
        var adjustedT = 1 - t;
        return (Math.pow(adjustedT, 3) * a +
            3 * Math.pow(adjustedT, 2) * t * b +
            3 * adjustedT * Math.pow(t, 2) * c +
            Math.pow(t, 3) * d);
    };
    SketchGraphics.prototype.bezierTangent = function (a, b, c, d, t) {
        var adjustedT = 1 - t;
        return (3 * d * Math.pow(t, 2) -
            3 * c * Math.pow(t, 2) +
            6 * c * adjustedT * t -
            6 * b * adjustedT * t +
            3 * b * Math.pow(adjustedT, 2) -
            3 * a * Math.pow(adjustedT, 2));
    };
    SketchGraphics.prototype.curve = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.renderer._doStroke) {
            this.renderer.curve.apply(this.renderer, args);
        }
        return this;
    };
    SketchGraphics.prototype.curveDetail = function (d) {
        if (d < 3) {
            this._curveDetail = 3;
        }
        else {
            this._curveDetail = d;
        }
        return this;
    };
    SketchGraphics.prototype.curveTightness = function (t) {
        this.renderer._curveTightness = t;
        return this;
    };
    SketchGraphics.prototype.curvePoint = function (a, b, c, d, t) {
        var t3 = t * t * t, t2 = t * t, f1 = -0.5 * t3 + t2 - 0.5 * t, f2 = 1.5 * t3 - 2.5 * t2 + 1.0, f3 = -1.5 * t3 + 2.0 * t2 + 0.5 * t, f4 = 0.5 * t3 - 0.5 * t2;
        return a * f1 + b * f2 + c * f3 + d * f4;
    };
    SketchGraphics.prototype.curveTangent = function (a, b, c, d, t) {
        var t2 = t * t, f1 = -3 * t2 / 2 + 2 * t - 0.5, f2 = 9 * t2 / 2 - 5 * t, f3 = -9 * t2 / 2 + 4 * t + 0.5, f4 = 3 * t2 / 2 - t;
        return a * f1 + b * f2 + c * f3 + d * f4;
    };
    SketchGraphics.prototype.beginContour = function () {
        contourVertices = [];
        isContour = true;
        return this;
    };
    SketchGraphics.prototype.beginShape = function (kind) {
        if (this.renderer.isP3D) {
            this.renderer.beginShape(kind);
        }
        else {
            if (kind === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.POINTS ||
                kind === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.LINES ||
                kind === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.TRIANGLES ||
                kind === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.TRIANGLE_FAN ||
                kind === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.TRIANGLE_STRIP ||
                kind === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.QUADS ||
                kind === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.QUAD_STRIP) {
                shapeKind = kind;
            }
            else {
                shapeKind = null;
            }
            vertices = [];
            contourVertices = [];
        }
        return this;
    };
    SketchGraphics.prototype.bezierVertex = function () {
        var _b;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.renderer.isP3D) {
            (_b = this.renderer).bezierVertex.apply(_b, args);
        }
        else {
            if (vertices.length === 0) {
                console.error('vertex() must be used once before calling bezierVertex()', 'bezierVertex');
            }
            else {
                isBezier = true;
                var vert = [];
                for (var i = 0; i < args.length; i++) {
                    vert[i] = args[i];
                }
                vert.isVert = false;
                if (isContour) {
                    contourVertices.push(vert);
                }
                else {
                    vertices.push(vert);
                }
            }
        }
        return this;
    };
    SketchGraphics.prototype.curveVertex = function () {
        var _b;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.renderer.isP3D) {
            (_b = this.renderer).curveVertex.apply(_b, args);
        }
        else {
            isCurve = true;
            this.vertex(args[0], args[1]);
        }
        return this;
    };
    SketchGraphics.prototype.endContour = function () {
        var vert = contourVertices[0].slice(); // copy all data
        vert.isVert = contourVertices[0].isVert;
        vert.moveTo = false;
        contourVertices.push(vert);
        // prevent stray lines with multiple contours
        if (isFirstContour) {
            vertices.push(vertices[0]);
            isFirstContour = false;
        }
        for (var i = 0; i < contourVertices.length; i++) {
            vertices.push(contourVertices[i]);
        }
        return this;
    };
    SketchGraphics.prototype.endShape = function (mode) {
        if (this.renderer.isP3D) {
            this.renderer.endShape(mode, isCurve, isBezier, isQuadratic, isContour, shapeKind);
        }
        else {
            if (vertices.length === 0) {
                return this;
            }
            if (!this.renderer._doStroke && !this.renderer._doFill) {
                return this;
            }
            var closeShape = mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CLOSE;
            // if the shape is closed, the first element is also the last element
            if (closeShape && !isContour) {
                vertices.push(vertices[0]);
            }
            this.renderer.endShape(mode, vertices, isCurve, isBezier, isQuadratic, isContour, shapeKind);
            // Reset some settings
            isCurve = false;
            isBezier = false;
            isQuadratic = false;
            isContour = false;
            isFirstContour = true;
            // If the shape is closed, the first element was added as last element.
            // We must remove it again to prevent the list of vertices from growing
            // over successive calls to endShape(CLOSE)
            if (closeShape) {
                vertices.pop();
            }
        }
        return this;
    };
    SketchGraphics.prototype.quadraticVertex = function () {
        var _b;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.renderer.isP3D) {
            (_b = this.renderer).quadraticVertex.apply(_b, args);
        }
        else {
            //if we're drawing a contour, put the points into an
            // array for inside drawing
            if (this._contourInited) {
                var pt = {};
                pt.x = args[0];
                pt.y = args[1];
                pt.x3 = args[2];
                pt.y3 = args[3];
                pt.type = _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.QUADRATIC;
                this._contourVertices.push(pt);
                return this;
            }
            if (vertices.length > 0) {
                isQuadratic = true;
                var vert = [];
                for (var i = 0; i < args.length; i++) {
                    vert[i] = args[i];
                }
                vert.isVert = false;
                if (isContour) {
                    contourVertices.push(vert);
                }
                else {
                    vertices.push(vert);
                }
            }
            else {
                console.error('vertex() must be used once before calling quadraticVertex()', 'quadraticVertex');
            }
        }
        return this;
    };
    SketchGraphics.prototype.vertex = function (x, y, moveTo, u, v) {
        if (this.renderer.isP3D) {
            this.renderer.vertex(x, y, moveTo, u, v);
        }
        else {
            var vert = [];
            vert.isVert = true;
            vert[0] = x;
            vert[1] = y;
            vert[2] = 0;
            vert[3] = 0;
            vert[4] = 0;
            vert[5] = this.renderer._getFill();
            vert[6] = this.renderer._getStroke();
            if (moveTo) {
                vert.moveTo = moveTo;
            }
            if (isContour) {
                if (contourVertices.length === 0) {
                    vert.moveTo = true;
                }
                contourVertices.push(vert);
            }
            else {
                vertices.push(vert);
            }
        }
        return this;
    };
    SketchGraphics.prototype.alpha = function (c) {
        return this.color(c).A;
    };
    SketchGraphics.prototype.blue = function (c) {
        return this.color(c).B;
    };
    SketchGraphics.prototype.brightness = function (c) {
        return this.color(c).getBrightness();
    };
    SketchGraphics.prototype.color = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CoreGraphicTypes.CGColor)) {
            return args[0];
        }
        else if (args.length === 1 && (_tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) || _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.string(args[0]))) {
            return _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromSketchColor(args[0]);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.array(args[0])) {
            return _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromSketchColor(args[1][0], args[1][1], args[1][2], args[1][3]);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1])) {
            return _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromSketchColor(args[1], args[2]);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[2])) {
            return _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromSketchColor(args[0], args[1], args[2]);
        }
        else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[2]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[3])) {
            return _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromSketchColor(args[0], args[1], args[2], args[3]);
        }
        return undefined;
    };
    SketchGraphics.prototype.green = function (c) {
        return this.color(c).G;
    };
    SketchGraphics.prototype.hue = function (c) {
        return this.color(c).getHue();
    };
    SketchGraphics.prototype.lerpBrush = function (b1, b2, amt) {
        var c1 = this.color(b1.Color.R, b1.Color.G, b1.Color.B);
        var c2 = this.color(b2.Color.R, b2.Color.G, b2.Color.B);
        var color = this.lerpColor(c1, c2, amt);
        return new _SolidBrush__WEBPACK_IMPORTED_MODULE_10__.SolidBrush(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromRgba(color.R, color.G, color.B, color.A));
    };
    SketchGraphics.prototype.lerpPen = function (p1, p2, amt) {
        var c1 = this.color(p1.Color.R, p1.Color.G, p1.Color.B);
        var c2 = this.color(p2.Color.R, p2.Color.G, p2.Color.B);
        var color = this.lerpColor(c1, c2, amt);
        var size = this.lerp(p1.Width, p2.Width, amt);
        return new _Pen__WEBPACK_IMPORTED_MODULE_11__.Pen(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.FromRgba(color.R, color.G, color.B, color.A), size);
    };
    SketchGraphics.prototype.lerpColor = function (c1, c2, amt) {
        return _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor.Lerp(c1, c2, amt);
    };
    SketchGraphics.prototype.lightness = function (c) {
        return this.color(c).getLightness();
    };
    SketchGraphics.prototype.red = function (c) {
        return this.color(c).R;
    };
    SketchGraphics.prototype.saturation = function (c) {
        return this.color(c).getSaturation();
    };
    SketchGraphics.prototype.background = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CoreGraphicTypes.CGColor)) {
            this.renderer.background(args[0]);
        }
        else if (args.length === 1 && (_tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) || _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.string(args[0]))) {
            this.renderer.background(args[0]);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.array(args[0])) {
            this.renderer.background(args[1][0], args[1][1], args[1][2], args[1][3]);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1])) {
            this.renderer.background(args[1], args[2]);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[2])) {
            this.renderer.background(args[0], args[1], args[1]);
        }
        else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[2]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[3])) {
            this.renderer.background(args[0], args[1], args[2], args[3]);
        }
        return this;
    };
    SketchGraphics.prototype.clear = function () {
        this.renderer.clear();
        return this;
    };
    SketchGraphics.prototype.colorMode = function (mode, max1, max2, max3, maxA) {
        if (mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RGB ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.HSB ||
            mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.HSL) {
            // Set color mode.
            this._colorMode = mode;
            // Set color maxes.
            var maxes = this._colorMaxes[mode];
            if (arguments.length === 2) {
                maxes[0] = max1; // Red
                maxes[1] = max1; // Green
                maxes[2] = max1; // Blue
                maxes[3] = max1; // Alpha
            }
            else if (arguments.length === 4) {
                maxes[0] = max1; // Red
                maxes[1] = max2; // Green
                maxes[2] = max3; // Blue
            }
            else if (arguments.length === 5) {
                maxes[0] = max1; // Red
                maxes[1] = max2; // Green
                maxes[2] = max3; // Blue
                maxes[3] = maxA; // Alpha
            }
        }
        return this;
    };
    SketchGraphics.prototype.fill = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.renderer._fillSet = true;
        this.renderer._doFill = true;
        if (args.length === 1 && args[0].maxes != null /* is.typeof<SketchColor>(args[0], GraphicTypes.SketchColor) */) {
            this.renderer.fill(args[0]);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.string(args[0])) {
            this.renderer.fill(args[0]);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0])) {
            var gray = args[0];
            var max = this._colorMaxes[this._colorMode];
            gray = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(gray, 0, max[0], 0, 255);
            this.renderer.fill(gray);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.array(args[0])) {
            var max = this._colorMaxes[this._colorMode];
            var r = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0][0], 0, max[0], 0, 255);
            var g = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0][1], 0, max[1], 0, 255);
            var b = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0][2], 0, max[2], 0, 255);
            var _a = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0][3], 0, max[3], 0, 255);
            this.renderer.fill(r, g, b, a);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1])) {
            var max = this._colorMaxes[this._colorMode];
            var gray = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0], 0, max[0], 0, 255);
            var alpha = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[3], 0, max[1], 0, 255);
            this.renderer.fill(gray, alpha);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[2])) {
            var max = this._colorMaxes[this._colorMode];
            var r = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0], 0, max[0], 0, 255);
            var g = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[1], 0, max[1], 0, 255);
            var b = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[2], 0, max[2], 0, 255);
            this.renderer.fill(r, g, b);
        }
        else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[2]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[3])) {
            var max = this._colorMaxes[this._colorMode];
            var r = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0], 0, max[0], 0, 255);
            var g = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[1], 0, max[1], 0, 255);
            var b = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[2], 0, max[2], 0, 255);
            var _a = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[3], 0, max[3], 0, 255);
            this.renderer.fill(r, g, b, _a);
        }
        return this;
    };
    SketchGraphics.prototype.noFill = function () {
        this.renderer._doFill = false;
        return this;
    };
    SketchGraphics.prototype.noStroke = function () {
        this.renderer._doStroke = false;
        return this;
    };
    SketchGraphics.prototype.stroke = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.renderer._strokeSet = true;
        this.renderer._doStroke = true;
        if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CoreGraphicTypes.CGColor)) {
            this.renderer.stroke(args[0]);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.string(args[0])) {
            this.renderer.stroke(args[0]);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0])) {
            var max = this._colorMaxes[this._colorMode];
            this.renderer.stroke(_tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0], 0, max[0], 0, 255));
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.array(args[0])) {
            var max = this._colorMaxes[this._colorMode];
            var r = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0][0], 0, max[0], 0, 255);
            var g = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0][1], 0, max[1], 0, 255);
            var b = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0][2], 0, max[2], 0, 255);
            var _a = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0][3], 0, max[3], 0, 255);
            this.renderer.stroke(r, g, b, _a);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1])) {
            var max = this._colorMaxes[this._colorMode];
            var gray = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0], 0, max[0], 0, 255);
            var alpha = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[3], 0, max[1], 0, 255);
            this.renderer.stroke(gray, alpha);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[2])) {
            var max = this._colorMaxes[this._colorMode];
            var r = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0], 0, max[0], 0, 255);
            var g = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[1], 0, max[1], 0, 255);
            var b = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[2], 0, max[2], 0, 255);
            this.renderer.stroke(r, g, b);
        }
        else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[2]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[3])) {
            var max = this._colorMaxes[this._colorMode];
            var r = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[0], 0, max[0], 0, 255);
            var g = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[1], 0, max[1], 0, 255);
            var b = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[2], 0, max[2], 0, 255);
            var _a = _tuval_core__WEBPACK_IMPORTED_MODULE_7__.TMath.map(args[3], 0, max[3], 0, 255);
            this.renderer.stroke(r, g, b, _a);
        }
        return this;
    };
    SketchGraphics.prototype.createImage = function (width, height) {
        return new _image_SketchImage__WEBPACK_IMPORTED_MODULE_5__.SketchImage(width, height);
    };
    SketchGraphics.prototype.saveCanvas = function () {
        // copy arguments to array
        var args = [].slice.call(arguments);
        var htmlCanvas, filename, extension;
        if (arguments[0] instanceof HTMLCanvasElement) {
            htmlCanvas = arguments[0];
            args.shift();
        } /* else if (arguments[0] instanceof p5.Element) {
            htmlCanvas = arguments[0].elt;
            args.shift();
        } */
        else {
            htmlCanvas = this.renderer.drawingContext.canvas;
        }
        if (args.length >= 1) {
            filename = args[0];
        }
        if (args.length >= 2) {
            extension = args[1];
        }
        extension =
            extension ||
                this._checkFileExtension(filename, extension)[1] ||
                'png';
        var mimeType;
        switch (extension) {
            case 'jpeg':
            case 'jpg':
                mimeType = 'image/jpeg';
                break;
            default:
                //case 'png':
                mimeType = 'image/png';
                break;
        }
        htmlCanvas.toBlob(function (blob) {
            // this.downloadFile(blob, filename, extension);
        }, mimeType);
    };
    SketchGraphics.prototype.saveGif = function (pImg, filename) {
    };
    SketchGraphics.prototype.saveFrames = function (fName, ext, _duration, _fps, callback) {
    };
    SketchGraphics.prototype._makeFrame = function (filename, extension, _cnv) {
    };
    SketchGraphics.prototype.loadImage = function (path, successCallback, failureCallback) {
        var _this = this;
        var pImg = new _image_SketchImage__WEBPACK_IMPORTED_MODULE_5__.SketchImage(1, 1);
        var self = this;
        var req = new Request(path, {
            method: 'GET',
            mode: 'cors'
        });
        fetch(path, req).then(function (response) {
            // GIF section
            if (response.headers.get('content-type').includes('image/gif')) {
                response.arrayBuffer().then(function (arrayBuffer) {
                    if (arrayBuffer) {
                        var byteArray = new Uint8Array(arrayBuffer);
                        _this._createGif(byteArray, pImg, successCallback, failureCallback, (function (pImg) {
                            //self._decrementPreload();
                        }).bind(self));
                    }
                }, function (e) {
                    if (typeof failureCallback === 'function') {
                        failureCallback(e);
                    }
                    else {
                        console.error(e);
                    }
                });
            }
            else {
                // Non-GIF Section
                var img_1 = new Image();
                img_1.onload = function () {
                    pImg.width = pImg.canvas.width = img_1.width;
                    pImg.height = pImg.canvas.height = img_1.height;
                    // Draw the image into the backing canvas of the p5.Image
                    pImg.drawingContext.drawImage(img_1, 0, 0);
                    pImg.modified = true;
                    if (typeof successCallback === 'function') {
                        successCallback(pImg);
                    }
                    //self._decrementPreload();
                };
                img_1.onerror = function (e) {
                    // _friendlyFileLoadError(0, img.src);
                    if (typeof failureCallback === 'function') {
                        failureCallback(e);
                    }
                    else {
                        console.error(e);
                    }
                };
                // Set crossOrigin in case image is served with CORS headers.
                // This will let us draw to the canvas without tainting it.
                // See https://developer.mozilla.org/en-US/docs/HTML/CORS_Enabled_Image
                // When using data-uris the file will be loaded locally
                // so we don't need to worry about crossOrigin with base64 file types.
                if (path.indexOf('data:image/') !== 0) {
                    img_1.crossOrigin = 'Anonymous';
                }
                // start loading the image
                img_1.src = path;
            }
            pImg.modified = true;
        });
        return pImg;
    };
    SketchGraphics.prototype._createGif = function (arrayBuffer, pImg, successCallback, failureCallback, finishCallback) {
    };
    SketchGraphics.prototype._sAssign = function (sVal, iVal) {
        if (sVal > 0 && sVal < iVal) {
            return sVal;
        }
        else {
            return iVal;
        }
    };
    SketchGraphics.prototype.image = function (img, dx, dy, dWidth, dHeight, sx, sy, sWidth, sHeight) {
        // set defaults per spec: https://goo.gl/3ykfOq
        var defW = img.width;
        var defH = img.height;
        if (img.canvas) {
            defW = img.canvas.width;
            defH = img.canvas.height;
        }
        else if (img.elt && img.elt.videoWidth && !img.canvas) {
            // video no canvas
            defW = img.elt.videoWidth;
            defH = img.elt.videoHeight;
        }
        var _dx = dx;
        var _dy = dy;
        var _dw = dWidth || defW;
        var _dh = dHeight || defH;
        var _sx = sx || 0;
        var _sy = sy || 0;
        var _sw = sWidth || defW;
        var _sh = sHeight || defH;
        _sw = this._sAssign(_sw, defW);
        _sh = this._sAssign(_sh, defH);
        // This part needs cleanup and unit tests
        // see issues https://github.com/processing/p5.js/issues/1741
        // and https://github.com/processing/p5.js/issues/1673
        var pd = 1;
        if (img.elt && !img.canvas && img.elt.style.width) {
            //if img is video and img.elt.size() has been used and
            //no width passed to image()
            if (img.elt.videoWidth && !dWidth) {
                pd = img.elt.videoWidth;
            }
            else {
                //all other cases
                pd = img.elt.width;
            }
            pd /= parseInt(img.elt.style.width, 10);
        }
        _sx *= pd;
        _sy *= pd;
        _sh *= pd;
        _sw *= pd;
        var vals = modeAdjust(_dx, _dy, _dw, _dh, this.renderer._imageMode);
        // tint the image if there is a tint
        this.renderer.image(img, _sx, _sy, _sw, _sh, vals.x, vals.y, vals.w, vals.h);
    };
    SketchGraphics.prototype.tint = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var color = undefined;
        if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is["typeof"](args[0], _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CoreGraphicTypes.CGColor)) {
            color = args[0];
        }
        else if (args.length === 1 && (_tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) || _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.string(args[0]))) {
            color = this.color(args[0]);
        }
        else if (args.length === 1 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.array(args[0])) {
            color = this.color(args[1][0], args[1][1], args[1][2], args[1][3]);
        }
        else if (args.length === 2 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1])) {
            color = this.color(args[1], args[2]);
        }
        else if (args.length === 3 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[2])) {
            color = this.color(args[0], args[1], args[1]);
        }
        else if (args.length === 4 && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[0]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[1]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[2]) && _tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.number(args[3])) {
            color = this.color(args[0], args[1], args[2], args[3]);
        }
        if (color != null) {
            this.renderer._tint = color.Levels;
        }
    };
    SketchGraphics.prototype.noTint = function () {
        this.renderer._tint = null;
    };
    SketchGraphics.prototype._getTintedImageCanvas = function (img) {
        if (!img.canvas) {
            return img;
        }
        var pixels = _image_filters__WEBPACK_IMPORTED_MODULE_6__.Filters._toPixels(img.canvas);
        var tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = img.canvas.width;
        tmpCanvas.height = img.canvas.height;
        var tmpCtx = tmpCanvas.getContext('2d');
        var id = tmpCtx.createImageData(img.canvas.width, img.canvas.height);
        var newPixels = id.data;
        for (var i = 0; i < pixels.length; i += 4) {
            var r = pixels[i];
            var g = pixels[i + 1];
            var b = pixels[i + 2];
            var a_1 = pixels[i + 3];
            newPixels[i] = r * this.renderer._tint[0] / 255;
            newPixels[i + 1] = g * this.renderer._tint[1] / 255;
            newPixels[i + 2] = b * this.renderer._tint[2] / 255;
            newPixels[i + 3] = a_1 * this.renderer._tint[3] / 255;
        }
        tmpCtx.putImageData(id, 0, 0);
        return tmpCanvas;
    };
    SketchGraphics.prototype.imageMode = function (m) {
        if (m === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CORNER ||
            m === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CORNERS ||
            m === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CENTER) {
            this.renderer._imageMode = m;
        }
    };
    SketchGraphics.prototype.blend = function () {
        var _b;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.renderer) {
            (_b = this.renderer).blend.apply(_b, args);
        }
    };
    SketchGraphics.prototype.copy = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.renderer.copy.apply(this.renderer, args);
    };
    SketchGraphics.prototype.filter = function (operation, value) {
        _image_filters__WEBPACK_IMPORTED_MODULE_6__.Filters.apply(this.renderer.drawingContext.canvas, _image_filters__WEBPACK_IMPORTED_MODULE_6__.Filters[operation], value);
    };
    SketchGraphics.prototype.get = function () {
        var _b;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_b = this.renderer.get).apply.apply(_b, __spreadArray([this.renderer], args, false));
    };
    SketchGraphics.prototype.loadPixels = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.renderer.loadPixels();
    };
    SketchGraphics.prototype.set = function (x, y, imgOrCol) {
        this.renderer.set(x, y, imgOrCol);
    };
    SketchGraphics.prototype.updatePixels = function (x, y, w, h) {
        // graceful fail - if loadPixels() or set() has not been called, pixel
        // array will be empty, ignore call to updatePixels()
        if (this.pixels.length === 0) {
            return;
        }
        this.renderer.updatePixels(x, y, w, h);
    };
    SketchGraphics.prototype.abs = function (x) {
        return Math.abs(x);
    };
    SketchGraphics.prototype.ceil = function (x) {
        return Math.ceil(x);
    };
    SketchGraphics.prototype.constrain = function (n, low, high) {
        return Math.max(Math.min(n, high), low);
    };
    SketchGraphics.prototype.dist = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 4) {
            //2D
            return this.hypot(args[2] - args[0], args[3] - args[1]);
        }
        else if (args.length === 6) {
            //3D
            return this.hypot(args[3] - args[0], args[4] - args[1], args[5] - args[2]);
        }
        return -1;
    };
    SketchGraphics.prototype.exp = function (x) {
        return Math.exp(x);
    };
    SketchGraphics.prototype.floor = function (x) {
        return Math.floor(x);
    };
    SketchGraphics.prototype.lerp = function (start, stop, amt) {
        return amt * (stop - start) + start;
    };
    SketchGraphics.prototype.log = function (x) {
        return Math.log(x);
    };
    SketchGraphics.prototype.mag = function (x, y) {
        return this.hypot(x, y);
    };
    SketchGraphics.prototype.map = function (n, start1, stop1, start2, stop2, withinBounds) {
        var newval = (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;
        if (!withinBounds) {
            return newval;
        }
        if (start2 < stop2) {
            return this.constrain(newval, start2, stop2);
        }
        else {
            return this.constrain(newval, stop2, start2);
        }
    };
    SketchGraphics.prototype.max = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args[0] instanceof Array) {
            return Math.max.apply(null, args[0]);
        }
        else {
            return Math.max.apply(null, args);
        }
    };
    SketchGraphics.prototype.min = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args[0] instanceof Array) {
            return Math.min.apply(null, args[0]);
        }
        else {
            return Math.min.apply(null, args);
        }
    };
    SketchGraphics.prototype.norm = function (n, start, stop) {
        return this.map(n, start, stop, 0, 1);
    };
    SketchGraphics.prototype.pow = function (x, y) {
        return Math.pow(x, y);
    };
    SketchGraphics.prototype.round = function (x) {
        return Math.round(x);
    };
    SketchGraphics.prototype.sq = function (n) {
        return n * n;
    };
    SketchGraphics.prototype.sqrt = function (x) {
        return Math.sqrt(x);
    };
    SketchGraphics.prototype.hypot = function (x, y, z) {
        // Use the native implementation if it's available
        if (typeof Math.hypot === 'function') {
            return Math.hypot.apply(null, arguments);
        }
        // Otherwise use the V8 implementation
        // https://github.com/v8/v8/blob/8cd3cf297287e581a49e487067f5cbd991b27123/src/js/math.js#L217
        var length = arguments.length;
        var args = [];
        var max = 0;
        for (var i = 0; i < length; i++) {
            var n = arguments[i];
            n = +n;
            if (n === Infinity || n === -Infinity) {
                return Infinity;
            }
            n = Math.abs(n);
            if (n > max) {
                max = n;
            }
            args[i] = n;
        }
        if (max === 0) {
            max = 1;
        }
        var sum = 0;
        var compensation = 0;
        for (var j = 0; j < length; j++) {
            var m_1 = args[j] / max;
            var summand = m_1 * m_1 - compensation;
            var preliminary = sum + summand;
            compensation = preliminary - sum - summand;
            sum = preliminary;
        }
        return Math.sqrt(sum) * max;
    };
    SketchGraphics.prototype.createVector = function (x, y, z) {
        return new _math_Vector__WEBPACK_IMPORTED_MODULE_8__.Vector(x, y, z);
    };
    SketchGraphics.prototype.noise = function (x, y, z) {
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (perlin == null) {
            perlin = new Array(PERLIN_SIZE + 1);
            for (var i = 0; i < PERLIN_SIZE + 1; i++) {
                perlin[i] = Math.random();
            }
        }
        if (x < 0) {
            x = -x;
        }
        if (y < 0) {
            y = -y;
        }
        if (z < 0) {
            z = -z;
        }
        var xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
        var xf = x - xi;
        var yf = y - yi;
        var zf = z - zi;
        var rxf, ryf;
        var r = 0;
        var ampl = 0.5;
        var n1, n2, n3;
        for (var o = 0; o < perlin_octaves; o++) {
            var of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);
            rxf = scaled_cosine(xf);
            ryf = scaled_cosine(yf);
            n1 = perlin[of & PERLIN_SIZE];
            n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);
            n2 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];
            n2 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);
            n1 += ryf * (n2 - n1);
            of += PERLIN_ZWRAP;
            n2 = perlin[of & PERLIN_SIZE];
            n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);
            n3 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];
            n3 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);
            n2 += ryf * (n3 - n2);
            n1 += scaled_cosine(zf) * (n2 - n1);
            r += n1 * ampl;
            ampl *= perlin_amp_falloff;
            xi <<= 1;
            xf *= 2;
            yi <<= 1;
            yf *= 2;
            zi <<= 1;
            zf *= 2;
            if (xf >= 1.0) {
                xi++;
                xf--;
            }
            if (yf >= 1.0) {
                yi++;
                yf--;
            }
            if (zf >= 1.0) {
                zi++;
                zf--;
            }
        }
        return r;
    };
    SketchGraphics.prototype.noiseDetail = function (lod, falloff) {
        if (lod > 0) {
            perlin_octaves = lod;
        }
        if (falloff > 0) {
            perlin_amp_falloff = falloff;
        }
    };
    SketchGraphics.prototype.noiseSeed = function (seed) {
        // Linear Congruential Generator
        // Variant of a Lehman Generator
        var lcg = (function () {
            // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes
            // m is basically chosen to be large (as it is the max period)
            // and for its relationships to a and c
            var m = 4294967296;
            // a - 1 should be divisible by m's prime factors
            var a = 1664525;
            // c and m should be co-prime
            var c = 1013904223;
            var seed, z;
            return {
                setSeed: function (val) {
                    // pick a random seed if val is undefined or null
                    // the >>> 0 casts the seed to an unsigned 32-bit integer
                    z = seed = (val == null ? Math.random() * m : val) >>> 0;
                },
                getSeed: function () {
                    return seed;
                },
                rand: function () {
                    // define the recurrence relationship
                    z = (a * z + c) % m;
                    // return a float in [0, 1)
                    // if z = m then z / m = 0 therefore (z % m) / m < 1 always
                    return z / m;
                }
            };
        })();
        lcg.setSeed(seed);
        perlin = new Array(PERLIN_SIZE + 1);
        for (var i = 0; i < PERLIN_SIZE + 1; i++) {
            perlin[i] = lcg.rand();
        }
    };
    SketchGraphics.prototype._lcg = function (stateProperty) {
        // define the recurrence relationship
        this[stateProperty] = (a * this[stateProperty] + c) % m;
        // return a float in [0, 1)
        // we've just used % m, so / m is always < 1
        return this[stateProperty] / m;
    };
    SketchGraphics.prototype._lcgSetSeed = function (stateProperty, val) {
        // pick a random seed if val is undefined or null
        // the >>> 0 casts the seed to an unsigned 32-bit integer
        this[stateProperty] = (val == null ? Math.random() * m : val) >>> 0;
    };
    SketchGraphics.prototype.randomSeed = function (seed) {
        this._lcgSetSeed(randomStateProp, seed);
        this._gaussian_previous = false;
    };
    SketchGraphics.prototype.random = function (min, max) {
        var rand;
        if (this[randomStateProp] != null) {
            rand = this._lcg(randomStateProp);
        }
        else {
            rand = Math.random();
        }
        if (typeof min === 'undefined') {
            return rand;
        }
        else if (typeof max === 'undefined') {
            if (min instanceof Array) {
                return min[Math.floor(rand * min.length)];
            }
            else {
                return rand * min;
            }
        }
        else {
            if (min > max) {
                var tmp = min;
                min = max;
                max = tmp;
            }
            return rand * (max - min) + min;
        }
    };
    SketchGraphics.prototype.randomGaussian = function (mean, sd) {
        var y1, x1, x2, w;
        if (this._gaussian_previous) {
            y1 = y2;
            this._gaussian_previous = false;
        }
        else {
            do {
                x1 = this.random(2) - 1;
                x2 = this.random(2) - 1;
                w = x1 * x1 + x2 * x2;
            } while (w >= 1);
            w = Math.sqrt(-2 * Math.log(w) / w);
            y1 = x1 * w;
            y2 = x2 * w;
            this._gaussian_previous = true;
        }
        var m = mean || 0;
        var s = sd || 1;
        return y1 * s + m;
    };
    SketchGraphics.prototype.acos = function (ratio) {
        return this._fromRadians(Math.acos(ratio));
    };
    SketchGraphics.prototype.asin = function (ratio) {
        return this._fromRadians(Math.asin(ratio));
    };
    SketchGraphics.prototype.atan = function (ratio) {
        return this._fromRadians(Math.atan(ratio));
    };
    SketchGraphics.prototype.atan2 = function (y, x) {
        return this._fromRadians(Math.atan2(y, x));
    };
    SketchGraphics.prototype.cos = function (angle) {
        return Math.cos(this._toRadians(angle));
    };
    SketchGraphics.prototype.sin = function (angle) {
        return Math.sin(this._toRadians(angle));
    };
    SketchGraphics.prototype.tan = function (angle) {
        return Math.tan(this._toRadians(angle));
    };
    SketchGraphics.prototype.degrees = function (angle) {
        angle * _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RAD_TO_DEG;
    };
    SketchGraphics.prototype.radians = function (angle) {
        return angle * _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.DEG_TO_RAD;
    };
    SketchGraphics.prototype.angleMode = function (mode) {
        if (mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.DEGREES || mode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RADIANS) {
            this._angleMode = mode;
        }
    };
    SketchGraphics.prototype._toRadians = function (angle) {
        if (this._angleMode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.DEGREES) {
            return angle * _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.DEG_TO_RAD;
        }
        return angle;
    };
    SketchGraphics.prototype._toDegrees = function (angle) {
        if (this._angleMode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RADIANS) {
            return angle * _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RAD_TO_DEG;
        }
        return angle;
    };
    SketchGraphics.prototype._fromRadians = function (angle) {
        if (this._angleMode === _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.DEGREES) {
            return angle * _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RAD_TO_DEG;
        }
        return angle;
    };
    SketchGraphics.prototype.textAlign = function (horizAlign, vertAlign) {
        return this.renderer.textAlign(horizAlign, vertAlign);
    };
    SketchGraphics.prototype.textLeading = function (theLeading) {
        return this.renderer.textLeading(theLeading);
    };
    SketchGraphics.prototype.textSize = function (theSize) {
        return this.renderer.textSize(theSize);
    };
    SketchGraphics.prototype.textStyle = function (theStyle) {
        return this.renderer.textStyle(theStyle);
    };
    SketchGraphics.prototype.textWidth = function () {
        var _b;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        args[0] += '';
        if (args[0].length === 0) {
            return 0;
        }
        return (_b = this.renderer).textWidth.apply(_b, args);
    };
    SketchGraphics.prototype.textAscent = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return this.renderer.textAscent();
    };
    SketchGraphics.prototype.textDescent = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return this.renderer.textDescent();
    };
    SketchGraphics.prototype._updateTextMetrics = function () {
        return this.renderer._updateTextMetrics();
    };
    SketchGraphics.prototype.loadFont = function (path, onSuccess, onError) {
        var p5Font = new _typography_SketchFont__WEBPACK_IMPORTED_MODULE_9__.SketchFont(this);
        var self = this;
        return p5Font;
    };
    SketchGraphics.prototype.text = function (str, x, y, maxWidth, maxHeight) {
        return !(this.renderer._doFill || this.renderer._doStroke)
            ? this
            : this.renderer.text(str, x, y, maxWidth, maxHeight);
    };
    SketchGraphics.prototype.textFont = function (theFont, theSize) {
        if (arguments.length) {
            if (!theFont) {
                throw new Error('null font passed to textFont');
            }
            this.renderer._textFont = theFont;
            if (theSize) {
                this.renderer._textSize = theSize;
                this.renderer._textLeading = theSize * _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants._DEFAULT_LEADMULT;
            }
            return this.renderer._applyTextProperties();
        }
        return this.renderer._textFont;
    };
    SketchGraphics.prototype.push = function () {
        this._styles.push({
            props: {
                _colorMode: this._colorMode
            },
            renderer: this.renderer.push()
        });
    };
    SketchGraphics.prototype.pop = function () {
        var style = this._styles.pop();
        if (style) {
            this.renderer.pop(style.renderer);
            Object.assign(this, style.props);
        }
        else {
            console.warn('pop() was called without matching push()');
        }
    };
    SketchGraphics.prototype._updateNextMouseCoords = function (e) {
        if (this.renderer.drawingContext.canvas !== null && (!e.touches || e.touches.length > 0)) {
            var mousePos = this.getMousePos(this.renderer.drawingContext.canvas, this.width, this.height, e);
            this.movedX = e.movementX;
            this.movedY = e.movementY;
            this.mouseX = mousePos.x;
            this.mouseY = mousePos.y;
            this.winMouseX = mousePos.winX;
            this.winMouseY = mousePos.winY;
        }
        if (!this._hasMouseInteracted) {
            // For first draw, make previous and next equal
            this._updateMouseCoords();
            this._hasMouseInteracted = true;
        }
    };
    SketchGraphics.prototype._updateMouseCoords = function () {
        this.pmouseX = this.mouseX;
        this.pmouseY = this.mouseY;
        this.pwinMouseX = this.winMouseX;
        this.pwinMouseY = this.winMouseY;
        this._pmouseWheelDeltaY = this._mouseWheelDeltaY;
    };
    SketchGraphics.prototype.getMousePos = function (canvas, w, h, evt) {
        if (evt && !evt.clientX) {
            // use touches if touch and not mouse
            if (evt.touches) {
                evt = evt.touches[0];
            }
            else if (evt.changedTouches) {
                evt = evt.changedTouches[0];
            }
        }
        var rect = canvas.getBoundingClientRect();
        var sx = canvas.scrollWidth / w || 1;
        var sy = canvas.scrollHeight / h || 1;
        return {
            x: (evt.clientX - rect.left) / sx,
            y: (evt.clientY - rect.top) / sy,
            winX: evt.clientX,
            winY: evt.clientY,
            id: evt.identifier
        };
    };
    SketchGraphics.prototype._setMouseButton = function (e) {
        if (e.button === 1) {
            this.mouseButton = _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.CENTER;
        }
        else if (e.button === 2) {
            this.mouseButton = _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.RIGHT;
        }
        else {
            this.mouseButton = _core_Constanst__WEBPACK_IMPORTED_MODULE_4__.constants.LEFT;
        }
    };
    SketchGraphics.prototype._onmousemove = function (e) {
        var executeDefault;
        this._updateNextMouseCoords(e);
        if (!this.mouseIsPressed) {
            if (typeof this.mouseMoved === 'function') {
                executeDefault = this.mouseMoved(e);
                if (executeDefault === false) {
                    e.preventDefault();
                }
            }
        }
        else {
            if (typeof this.mouseDragged === 'function') {
                executeDefault = this.mouseDragged(e);
                if (executeDefault === false) {
                    e.preventDefault();
                }
            }
            else if (typeof this.touchMoved === 'function') {
                executeDefault = this.touchMoved(e);
                if (executeDefault === false) {
                    e.preventDefault();
                }
            }
        }
    };
    SketchGraphics.prototype._onmousedown = function (e) {
        var executeDefault;
        this.mouseIsPressed = true;
        this._setMouseButton(e);
        this._updateNextMouseCoords(e);
        if (typeof this.mousePressed === 'function') {
            executeDefault = this.mousePressed(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
            // only safari needs this manual fallback for consistency
        }
        else if (navigator.userAgent.toLowerCase().includes('safari') &&
            typeof this.touchStarted === 'function') {
            executeDefault = this.touchStarted(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    SketchGraphics.prototype._onmouseup = function (e) {
        var executeDefault;
        this.mouseIsPressed = false;
        if (typeof this.mouseReleased === 'function') {
            executeDefault = this.mouseReleased(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
        else if (typeof this.touchEnded === 'function') {
            executeDefault = this.touchEnded(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    SketchGraphics.prototype._ondragend = function (e) {
        this._onmouseup(e);
    };
    SketchGraphics.prototype._ondragover = function (e) {
        this._onmousemove(e);
    };
    SketchGraphics.prototype._onclick = function (e) {
        if (typeof this.mouseClicked === 'function') {
            var executeDefault = this.mouseClicked(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    SketchGraphics.prototype._ondblclick = function (e) {
        if (typeof this.doubleClicked === 'function') {
            var executeDefault = this.doubleClicked(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    SketchGraphics.prototype._onwheel = function (e) {
        this._mouseWheelDeltaY = e.deltaY;
        if (typeof this.mouseWheel === 'function') {
            e.delta = e.deltaY;
            var executeDefault = this.mouseWheel(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    SketchGraphics.prototype._onkeydown = function (e) {
        if (this._downKeys[e.which]) {
            // prevent multiple firings
            return;
        }
        this.isKeyPressed = true;
        this.keyIsPressed = true;
        this.keyCode = e.which;
        this._downKeys[e.which] = true;
        this.key = e.key || String.fromCharCode(e.which) || e.which;
        var keyPressed = this.keyPressed;
        if (typeof keyPressed === 'function' && !e.charCode) {
            var executeDefault = keyPressed(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    SketchGraphics.prototype._onkeyup = function (e) {
        var keyReleased = this.keyReleased;
        this._downKeys[e.which] = false;
        if (!this._areDownKeys()) {
            this.isKeyPressed = false;
            this.keyIsPressed = false;
        }
        this._lastKeyCodeTyped = null;
        this.key = e.key || String.fromCharCode(e.which) || e.which;
        this.keyCode = e.which;
        if (typeof keyReleased === 'function') {
            var executeDefault = keyReleased(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    SketchGraphics.prototype._onkeypress = function (e) {
        if (e.which === this._lastKeyCodeTyped) {
            // prevent multiple firings
            return;
        }
        this._lastKeyCodeTyped = e.which; // track last keyCode
        this.key = String.fromCharCode(e.which);
        var keyTyped = this.keyTyped;
        if (typeof keyTyped === 'function') {
            var executeDefault = keyTyped(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    SketchGraphics.prototype._onblur = function (e) {
        this._downKeys = {};
    };
    SketchGraphics.prototype.keyIsDown = function (code) {
        return this._downKeys[code] || false;
    };
    SketchGraphics.prototype._areDownKeys = function () {
        for (var key in this._downKeys) {
            if (this._downKeys.hasOwnProperty(key) && this._downKeys[key] === true) {
                return true;
            }
        }
        return false;
    };
    SketchGraphics.prototype._onresize = function (e) {
        var executeDefault;
        if (typeof this.windowResized === 'function') {
            executeDefault = this.windowResized(e);
            if (executeDefault !== undefined && !executeDefault) {
                e.preventDefault();
            }
        }
    };
    SketchGraphics.prototype.applyMatrix = function (a, b, c, d, e, f) {
        this.renderer.applyMatrix(a, b, c, d, e, f);
        return this;
    };
    SketchGraphics.prototype.resetMatrix = function () {
        this.renderer.resetMatrix();
        return this;
    };
    SketchGraphics.prototype.rotate = function (angle, axis) {
        this.renderer.rotate(this._toRadians(angle), axis);
        return this;
    };
    SketchGraphics.prototype.scale = function (x, y, z) {
        // Only check for Vector argument type if Vector is available
        if (x instanceof _math_Vector__WEBPACK_IMPORTED_MODULE_8__.Vector) {
            var v = x;
            x = v.x;
            y = v.y;
            z = v.z;
        }
        else if (x instanceof Array) {
            var rg = x;
            x = rg[0];
            y = rg[1];
            z = rg[2] || 1;
        }
        if (isNaN(y)) {
            y = z = x;
        }
        else if (isNaN(z)) {
            z = 1;
        }
        this.renderer.scale.call(this.renderer, x, y, z);
        return this;
    };
    SketchGraphics.prototype.shearX = function (angle) {
        var rad = this._toRadians(angle);
        this.renderer.applyMatrix(1, 0, Math.tan(rad), 1, 0, 0);
        return this;
    };
    SketchGraphics.prototype.shearY = function (angle) {
        var rad = this._toRadians(angle);
        this.renderer.applyMatrix(1, Math.tan(rad), 0, 1, 0, 0);
        return this;
    };
    SketchGraphics.prototype.translate = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1 && args[0] instanceof _math_Vector__WEBPACK_IMPORTED_MODULE_8__.Vector) {
            var vector = args[0];
            this.renderer.translate(vector);
        }
        else {
            var x = args[0];
            var y = args[1];
            this.renderer.translate(x, y);
        }
        return this;
    };
    SketchGraphics.prototype.collideRectRect = function (x, y, w, h, x2, y2, w2, h2) {
        //2d
        //add in a thing to detect rectMode CENTER
        if (x + w >= x2 && // r1 right edge past r2 left
            x <= x2 + w2 && // r1 left edge past r2 right
            y + h >= y2 && // r1 top edge past r2 bottom
            y <= y2 + h2) { // r1 bottom edge past r2 top
            return true;
        }
        return false;
    };
    SketchGraphics.prototype.collideRectCircle = function (rx, ry, rw, rh, cx, cy, diameter) {
        //2d
        // temporary variables to set edges for testing
        var testX = cx;
        var testY = cy;
        // which edge is closest?
        if (cx < rx) {
            testX = rx; // left edge
        }
        else if (cx > rx + rw) {
            testX = rx + rw;
        } // right edge
        if (cy < ry) {
            testY = ry; // top edge
        }
        else if (cy > ry + rh) {
            testY = ry + rh;
        } // bottom edge
        // // get distance from closest edges
        var distance = this.dist(cx, cy, testX, testY);
        // if the distance is less than the radius, collision!
        if (distance <= diameter / 2) {
            return true;
        }
        return false;
    };
    SketchGraphics.prototype.collideCircleCircle = function (x, y, d, x2, y2, d2) {
        //2d
        if (this.dist(x, y, x2, y2) <= (d / 2) + (d2 / 2)) {
            return true;
        }
        return false;
    };
    SketchGraphics.prototype.collidePointCircle = function (x, y, cx, cy, d) {
        //2d
        if (this.dist(x, y, cx, cy) <= d / 2) {
            return true;
        }
        return false;
    };
    SketchGraphics.prototype.collidePointEllipse = function (x, y, cx, cy, dx, dy) {
        //2d
        var rx = dx / 2, ry = dy / 2;
        // Discarding the points outside the bounding box
        if (x > cx + rx || x < cx - rx || y > cy + ry || y < cy - ry) {
            return false;
        }
        // Compare the point to its equivalent on the ellipse
        var xx = x - cx, yy = y - cy;
        var eyy = ry * this.sqrt(this.abs(rx * rx - xx * xx)) / rx;
        return yy <= eyy && yy >= -eyy;
    };
    SketchGraphics.prototype.collidePointRect = function (pointX, pointY, x, y, xW, yW) {
        //2d
        if (pointX >= x && // right of the left edge AND
            pointX <= x + xW && // left of the right edge AND
            pointY >= y && // below the top AND
            pointY <= y + yW) { // above the bottom
            return true;
        }
        return false;
    };
    SketchGraphics.prototype.collidePointLine = function (px, py, x1, y1, x2, y2, buffer) {
        // get distance from the point to the two ends of the line
        var d1 = this.dist(px, py, x1, y1);
        var d2 = this.dist(px, py, x2, y2);
        // get the length of the line
        var lineLen = this.dist(x1, y1, x2, y2);
        // since floats are so minutely accurate, add a little buffer zone that will give collision
        if (buffer === undefined) {
            buffer = 0.1;
        } // higher # = less accurate
        // if the two distances are equal to the line's length, the point is on the line!
        // note we use the buffer here to give a range, rather than one #
        if (d1 + d2 >= lineLen - buffer && d1 + d2 <= lineLen + buffer) {
            return true;
        }
        return false;
    };
    SketchGraphics.prototype.collideLineCircle = function (x1, y1, x2, y2, cx, cy, diameter) {
        // is either end INSIDE the circle?
        // if so, return true immediately
        var inside1 = this.collidePointCircle(x1, y1, cx, cy, diameter);
        var inside2 = this.collidePointCircle(x2, y2, cx, cy, diameter);
        if (inside1 || inside2)
            return true;
        // get length of the line
        var distX = x1 - x2;
        var distY = y1 - y2;
        var len = this.sqrt((distX * distX) + (distY * distY));
        // get dot product of the line and circle
        var dot = (((cx - x1) * (x2 - x1)) + ((cy - y1) * (y2 - y1))) / this.pow(len, 2);
        // find the closest point on the line
        var closestX = x1 + (dot * (x2 - x1));
        var closestY = y1 + (dot * (y2 - y1));
        // is this point actually on the line segment?
        // if so keep going, but if not, return false
        var onSegment = this.collidePointLine(closestX, closestY, x1, y1, x2, y2);
        if (!onSegment)
            return false;
        // draw a debug circle at the closest point on the line
        if (this._collideDebug) {
            this.ellipse(closestX, closestY, 10, 10);
        }
        // get distance to closest point
        distX = closestX - cx;
        distY = closestY - cy;
        var distance = this.sqrt((distX * distX) + (distY * distY));
        if (distance <= diameter / 2) {
            return true;
        }
        return false;
    };
    SketchGraphics.prototype.collideLineLine = function (x1, y1, x2, y2, x3, y3, x4, y4, calcIntersection) {
        var intersection;
        // calculate the distance to intersection point
        var uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
        var uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
        // if uA and uB are between 0-1, lines are colliding
        if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
            var intersectionX = void 0;
            var intersectionY = void 0;
            if (this._collideDebug || calcIntersection) {
                // calc the point where the lines meet
                intersectionX = x1 + (uA * (x2 - x1));
                intersectionY = y1 + (uA * (y2 - y1));
            }
            if (this._collideDebug) {
                this.ellipse(intersectionX, intersectionY, 10, 10);
            }
            if (calcIntersection) {
                intersection = {
                    "x": intersectionX,
                    "y": intersectionY
                };
                return intersection;
            }
            else {
                return true;
            }
        }
        if (calcIntersection) {
            intersection = {
                "x": false,
                "y": false
            };
            return intersection;
        }
        return false;
    };
    SketchGraphics.prototype.collideLineRect = function (x1, y1, x2, y2, rx, ry, rw, rh, calcIntersection) {
        // check if the line has hit any of the rectangle's sides. uses the collideLineLine function above
        var left, right, top, bottom, intersection;
        if (calcIntersection) {
            left = this.collideLineLine(x1, y1, x2, y2, rx, ry, rx, ry + rh, true);
            right = this.collideLineLine(x1, y1, x2, y2, rx + rw, ry, rx + rw, ry + rh, true);
            top = this.collideLineLine(x1, y1, x2, y2, rx, ry, rx + rw, ry, true);
            bottom = this.collideLineLine(x1, y1, x2, y2, rx, ry + rh, rx + rw, ry + rh, true);
            intersection = {
                "left": left,
                "right": right,
                "top": top,
                "bottom": bottom
            };
        }
        else {
            //return booleans
            left = this.collideLineLine(x1, y1, x2, y2, rx, ry, rx, ry + rh);
            right = this.collideLineLine(x1, y1, x2, y2, rx + rw, ry, rx + rw, ry + rh);
            top = this.collideLineLine(x1, y1, x2, y2, rx, ry, rx + rw, ry);
            bottom = this.collideLineLine(x1, y1, x2, y2, rx, ry + rh, rx + rw, ry + rh);
        }
        // if ANY of the above are true, the line has hit the rectangle
        if (left || right || top || bottom) {
            if (calcIntersection) {
                return intersection;
            }
            return true;
        }
        return false;
    };
    SketchGraphics.prototype.collidePointPoly = function (px, py, vertices) {
        var collision = false;
        // go through each of the vertices, plus the next vertex in the list
        var next = 0;
        for (var current = 0; current < vertices.length; current++) {
            // get next vertex in list if we've hit the end, wrap around to 0
            next = current + 1;
            if (next == vertices.length)
                next = 0;
            // get the PVectors at our current position this makes our if statement a little cleaner
            var vc = vertices[current]; // c for "current"
            var vn = vertices[next]; // n for "next"
            // compare position, flip 'collision' variable back and forth
            if (((vc.y > py && vn.y < py) || (vc.y < py && vn.y > py)) &&
                (px < (vn.x - vc.x) * (py - vc.y) / (vn.y - vc.y) + vc.x)) {
                collision = !collision;
            }
        }
        return collision;
    };
    // POLYGON/CIRCLE
    SketchGraphics.prototype.collideCirclePoly = function (cx, cy, diameter, vertices, interior) {
        if (interior == undefined) {
            interior = false;
        }
        // go through each of the vertices, plus the next vertex in the list
        var next = 0;
        for (var current = 0; current < vertices.length; current++) {
            // get next vertex in list if we've hit the end, wrap around to 0
            next = current + 1;
            if (next === vertices.length) {
                next = 0;
            }
            // get the PVectors at our current position this makes our if statement a little cleaner
            var vc = vertices[current]; // c for "current"
            var vn = vertices[next]; // n for "next"
            // check for collision between the circle and a line formed between the two vertices
            var collision = this.collideLineCircle(vc.x, vc.y, vn.x, vn.y, cx, cy, diameter);
            if (collision) {
                return true;
            }
        }
        // test if the center of the circle is inside the polygon
        if (interior == true) {
            var centerInside = this.collidePointPoly(cx, cy, vertices);
            if (centerInside)
                return true;
        }
        // otherwise, after all that, return false
        return false;
    };
    SketchGraphics.prototype.collideRectPoly = function (rx, ry, rw, rh, vertices, interior) {
        if (interior == undefined) {
            interior = false;
        }
        // go through each of the vertices, plus the next vertex in the list
        var next = 0;
        for (var current = 0; current < vertices.length; current++) {
            // get next vertex in list if we've hit the end, wrap around to 0
            next = current + 1;
            if (next == vertices.length) {
                next = 0;
            }
            // get the PVectors at our current position this makes our if statement a little cleaner
            var vc = vertices[current]; // c for "current"
            var vn = vertices[next]; // n for "next"
            // check against all four sides of the rectangle
            var collision = this.collideLineRect(vc.x, vc.y, vn.x, vn.y, rx, ry, rw, rh);
            if (collision) {
                return true;
            }
            // optional: test if the rectangle is INSIDE the polygon note that this iterates all sides of the polygon again, so only use this if you need to
            if (interior == true) {
                var inside = this.collidePointPoly(rx, ry, vertices);
                if (inside)
                    return true;
            }
        }
        return false;
    };
    SketchGraphics.prototype.collideLinePoly = function (x1, y1, x2, y2, vertices) {
        // go through each of the vertices, plus the next vertex in the list
        var next = 0;
        for (var current = 0; current < vertices.length; current++) {
            // get next vertex in list if we've hit the end, wrap around to 0
            next = current + 1;
            if (next == vertices.length)
                next = 0;
            // get the PVectors at our current position extract X/Y coordinates from each
            var x3 = vertices[current].x;
            var y3 = vertices[current].y;
            var x4 = vertices[next].x;
            var y4 = vertices[next].y;
            // do a Line/Line comparison if true, return 'true' immediately and stop testing (faster)
            var hit = this.collideLineLine(x1, y1, x2, y2, x3, y3, x4, y4);
            if (hit) {
                return true;
            }
        }
        // never got a hit
        return false;
    };
    SketchGraphics.prototype.collidePolyPoly = function (p1, p2, interior) {
        if (interior == undefined) {
            interior = false;
        }
        // go through each of the vertices, plus the next vertex in the list
        var next = 0;
        for (var current = 0; current < p1.length; current++) {
            // get next vertex in list, if we've hit the end, wrap around to 0
            next = current + 1;
            if (next == p1.length) {
                next = 0;
            }
            // get the PVectors at our current position this makes our if statement a little cleaner
            var vc = p1[current]; // c for "current"
            var vn = p1[next]; // n for "next"
            //use these two points (a line) to compare to the other polygon's vertices using polyLine()
            var collision = this.collideLinePoly(vc.x, vc.y, vn.x, vn.y, p2);
            if (collision)
                return true;
            //check if the 2nd polygon is INSIDE the first
            if (interior == true) {
                collision = this.collidePointPoly(p2[0].x, p2[0].y, p1);
                if (collision)
                    return true;
            }
        }
        return false;
    };
    SketchGraphics.prototype.collidePointTriangle = function (px, py, x1, y1, x2, y2, x3, y3) {
        // get the area of the triangle
        var areaOrig = this.abs((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1));
        // get the area of 3 triangles made between the point and the corners of the triangle
        var area1 = this.abs((x1 - px) * (y2 - py) - (x2 - px) * (y1 - py));
        var area2 = this.abs((x2 - px) * (y3 - py) - (x3 - px) * (y2 - py));
        var area3 = this.abs((x3 - px) * (y1 - py) - (x1 - px) * (y3 - py));
        // if the sum of the three areas equals the original, we're inside the triangle!
        if (area1 + area2 + area3 == areaOrig) {
            return true;
        }
        return false;
    };
    SketchGraphics.prototype.collidePointPoint = function (x, y, x2, y2, buffer) {
        if (buffer == undefined) {
            buffer = 0;
        }
        if (this.dist(x, y, x2, y2) <= buffer) {
            return true;
        }
        return false;
    };
    ;
    SketchGraphics.prototype.collidePointArc = function (px, py, ax, ay, arcRadius, arcHeading, arcAngle, buffer) {
        if (buffer == undefined) {
            buffer = 0;
        }
        // point
        var point = this.createVector(px, py);
        // arc center point
        var arcPos = this.createVector(ax, ay);
        // arc radius vector
        var radius = this.createVector(arcRadius, 0).rotate(arcHeading);
        var pointToArc = point.copy().sub(arcPos);
        if (point.dist(arcPos) <= (arcRadius + buffer)) {
            var dot = radius.dot(pointToArc);
            var angle = radius.angleBetween(pointToArc);
            if (dot > 0 && angle <= arcAngle / 2 && angle >= -arcAngle / 2) {
                return true;
            }
        }
        return false;
    };
    SketchGraphics.prototype.cursor = function (type, x, y) {
        var standardCursors = ['arrow', 'cross', 'hand', 'move', 'text', 'wait'];
        var cursor = 'auto';
        var canvas = this.renderer.drawingContext.canvas;
        if (standardCursors.indexOf(type) > -1) {
            // Standard css cursor
            cursor = type;
        }
        else if (typeof type === 'string') {
            var coords = '';
            if (x && y && (typeof x === 'number' && typeof y === 'number')) {
                // Note that x and y values must be unit-less positive integers < 32
                // https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
                coords = x + ' ' + y;
            }
            if (type.substring(0, 7) === 'http://' ||
                type.substring(0, 8) === 'https://') {
                // Image (absolute url)
                cursor = 'url(' + type + ') ' + coords + ', auto';
            }
            else if (/\.(cur|jpg|jpeg|gif|png|CUR|JPG|JPEG|GIF|PNG)$/.test(type)) {
                // Image file (relative path) - Separated for performance reasons
                cursor = 'url(' + type + ') ' + coords + ', auto';
            }
            else {
                // Any valid string for the css cursor property
                cursor = type;
            }
        }
        if (!_tuval_core__WEBPACK_IMPORTED_MODULE_7__.is.workerContext()) {
            canvas.style.cursor = cursor;
        }
    };
    SketchGraphics.prototype.createDraggablePoint = function (x, y) {
        return new _UI_DraggablePoint__WEBPACK_IMPORTED_MODULE_1__.DraggablePoint(x, y);
    };
    SketchGraphics.prototype.pixelDensity = function (val) {
        var returnValue;
        if (typeof val === 'number') {
            if (val !== this._pixelDensity) {
                this._pixelDensity = val;
            }
            returnValue = this;
            this.resizeCanvas(this.width, this.height, true); // as a side effect, it will clear the canvas
        }
        else {
            returnValue = this._pixelDensity;
        }
        return returnValue;
    };
    SketchGraphics.prototype.resizeCanvas = function (w, h, noRedraw) {
        if (this.renderer) {
            this.renderer.resize(w, h);
            this.width = w;
            this.height = h;
        }
    };
    return SketchGraphics;
}(_Graphics__WEBPACK_IMPORTED_MODULE_2__.CanvasGraphics));



/***/ }),

/***/ "./src/drawing/sketch/core/Constanst.ts":
/*!**********************************************!*\
  !*** ./src/drawing/sketch/core/Constanst.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "constants": () => (/* binding */ constants)
/* harmony export */ });
/**
 * @module Constants
 * @submodule Constants
 * @for p5
 */

var PI = Math.PI;
var constants = {
    // GRAPHICS RENDERER
    /**
     * @property {String} P2D
     * @final
     */
    P2D: 'p2d',
    /**
     * @property {String} WEBGL
     * @final
     */
    WEBGL: 'webgl',
    // ENVIRONMENT
    /**
     * @property {String} ARROW
     * @final
     */
    ARROW: 'default',
    /**
     * @property {String} CROSS
     * @final
     */
    CROSS: 'crosshair',
    /**
     * @property {String} HAND
     * @final
     */
    HAND: 'pointer',
    /**
     * @property {String} MOVE
     * @final
     */
    MOVE: 'move',
    /**
     * @property {String} TEXT
     * @final
     */
    TEXT: 'text',
    /**
     * @property {String} WAIT
     * @final
     */
    WAIT: 'wait',
    // TRIGONOMETRY
    /**
     * HALF_PI is a mathematical constant with the value
     * 1.57079632679489661923. It is half the ratio of the
     * circumference of a circle to its diameter. It is useful in
     * combination with the trigonometric functions <a href="#/p5/sin">sin()</a> and <a href="#/p5/cos">cos()</a>.
     *
     * @property {Number} HALF_PI
     * @final
     *
     * @example
     * <div><code>
     * arc(50, 50, 80, 80, 0, HALF_PI);
     * </code></div>
     *
     * @alt
     * 80x80 white quarter-circle with curve toward bottom right of canvas.
     *
     */
    HALF_PI: PI / 2,
    /**
     * PI is a mathematical constant with the value
     * 3.14159265358979323846. It is the ratio of the circumference
     * of a circle to its diameter. It is useful in combination with
     * the trigonometric functions <a href="#/p5/sin">sin()</a> and <a href="#/p5/cos">cos()</a>.
     *
     * @property {Number} PI
     * @final
     *
     * @example
     * <div><code>
     * arc(50, 50, 80, 80, 0, PI);
     * </code></div>
     *
     * @alt
     * white half-circle with curve toward bottom of canvas.
     *
     */
    PI: PI,
    /**
     * QUARTER_PI is a mathematical constant with the value 0.7853982.
     * It is one quarter the ratio of the circumference of a circle to
     * its diameter. It is useful in combination with the trigonometric
     * functions <a href="#/p5/sin">sin()</a> and <a href="#/p5/cos">cos()</a>.
     *
     * @property {Number} QUARTER_PI
     * @final
     *
     * @example
     * <div><code>
     * arc(50, 50, 80, 80, 0, QUARTER_PI);
     * </code></div>
     *
     * @alt
     * white eighth-circle rotated about 40 degrees with curve bottom right canvas.
     *
     */
    QUARTER_PI: PI / 4,
    /**
     * TAU is an alias for TWO_PI, a mathematical constant with the
     * value 6.28318530717958647693. It is twice the ratio of the
     * circumference of a circle to its diameter. It is useful in
     * combination with the trigonometric functions <a href="#/p5/sin">sin()</a> and <a href="#/p5/cos">cos()</a>.
     *
     * @property {Number} TAU
     * @final
     *
     * @example
     * <div><code>
     * arc(50, 50, 80, 80, 0, TAU);
     * </code></div>
     *
     * @alt
     * 80x80 white ellipse shape in center of canvas.
     *
     */
    TAU: PI * 2,
    /**
     * TWO_PI is a mathematical constant with the value
     * 6.28318530717958647693. It is twice the ratio of the
     * circumference of a circle to its diameter. It is useful in
     * combination with the trigonometric functions <a href="#/p5/sin">sin()</a> and <a href="#/p5/cos">cos()</a>.
     *
     * @property {Number} TWO_PI
     * @final
     *
     * @example
     * <div><code>
     * arc(50, 50, 80, 80, 0, TWO_PI);
     * </code></div>
     *
     * @alt
     * 80x80 white ellipse shape in center of canvas.
     *
     */
    TWO_PI: PI * 2,
    /**
     * Constant to be used with <a href="#/p5/angleMode">angleMode()</a> function, to set the mode which
     * p5.js interprates and calculates angles (either DEGREES or RADIANS).
     * @property {String} DEGREES
     * @final
     *
     * @example
     * <div class='norender'><code>
     * function setup() {
     *   angleMode(DEGREES);
     * }
     * </code></div>
     */
    DEGREES: 'degrees',
    /**
     * Constant to be used with <a href="#/p5/angleMode">angleMode()</a> function, to set the mode which
     * p5.js interprates and calculates angles (either RADIANS or DEGREES).
     * @property {String} RADIANS
     * @final
     *
     * @example
     * <div class='norender'><code>
     * function setup() {
     *   angleMode(RADIANS);
     * }
     * </code></div>
     */
    RADIANS: 'radians',
    DEG_TO_RAD: PI / 180.0,
    RAD_TO_DEG: 180.0 / PI,
    // SHAPE
    /**
     * @property {String} CORNER
     * @final
     */
    CORNER: 'corner',
    /**
     * @property {String} CORNERS
     * @final
     */
    CORNERS: 'corners',
    /**
     * @property {String} RADIUS
     * @final
     */
    RADIUS: 'radius',
    /**
     * @property {String} RIGHT
     * @final
     */
    RIGHT: 'right',
    /**
     * @property {String} LEFT
     * @final
     */
    LEFT: 'left',
    /**
     * @property {String} CENTER
     * @final
     */
    CENTER: 'center',
    /**
     * @property {String} TOP
     * @final
     */
    TOP: 'top',
    /**
     * @property {String} BOTTOM
     * @final
     */
    BOTTOM: 'bottom',
    /**
     * @property {String} BASELINE
     * @final
     * @default alphabetic
     */
    BASELINE: 'alphabetic',
    /**
     * @property {Number} POINTS
     * @final
     * @default 0x0000
     */
    POINTS: 0x0000,
    /**
     * @property {Number} LINES
     * @final
     * @default 0x0001
     */
    LINES: 0x0001,
    /**
     * @property {Number} LINE_STRIP
     * @final
     * @default 0x0003
     */
    LINE_STRIP: 0x0003,
    /**
     * @property {Number} LINE_LOOP
     * @final
     * @default 0x0002
     */
    LINE_LOOP: 0x0002,
    /**
     * @property {Number} TRIANGLES
     * @final
     * @default 0x0004
     */
    TRIANGLES: 0x0004,
    /**
     * @property {Number} TRIANGLE_FAN
     * @final
     * @default 0x0006
     */
    TRIANGLE_FAN: 0x0006,
    /**
     * @property {Number} TRIANGLE_STRIP
     * @final
     * @default 0x0005
     */
    TRIANGLE_STRIP: 0x0005,
    /**
     * @property {String} QUADS
     * @final
     */
    QUADS: 'quads',
    /**
     * @property {String} QUAD_STRIP
     * @final
     * @default quad_strip
     */
    QUAD_STRIP: 'quad_strip',
    /**
     * @property {String} CLOSE
     * @final
     */
    CLOSE: 'close',
    /**
     * @property {String} OPEN
     * @final
     */
    OPEN: 'open',
    /**
     * @property {String} CHORD
     * @final
     */
    CHORD: 'chord',
    /**
     * @property {String} PIE
     * @final
     */
    PIE: 'pie',
    /**
     * @property {String} PROJECT
     * @final
     * @default square
     */
    PROJECT: 'square',
    /**
     * @property {String} SQUARE
     * @final
     * @default butt
     */
    SQUARE: 'butt',
    /**
     * @property {String} ROUND
     * @final
     */
    ROUND: 'round',
    /**
     * @property {String} BEVEL
     * @final
     */
    BEVEL: 'bevel',
    /**
     * @property {String} MITER
     * @final
     */
    MITER: 'miter',
    // COLOR
    /**
     * @property {String} RGB
     * @final
     */
    RGB: 'rgb',
    /**
     * @property {String} HSB
     * @final
     */
    HSB: 'hsb',
    /**
     * @property {String} HSL
     * @final
     */
    HSL: 'hsl',
    // DOM EXTENSION
    /**
     * @property {String} AUTO
     * @final
     */
    AUTO: 'auto',
    // INPUT
    ALT: 18,
    BACKSPACE: 8,
    CONTROL: 17,
    DELETE: 46,
    DOWN_ARROW: 40,
    ENTER: 13,
    ESCAPE: 27,
    LEFT_ARROW: 37,
    OPTION: 18,
    RETURN: 13,
    RIGHT_ARROW: 39,
    SHIFT: 16,
    TAB: 9,
    UP_ARROW: 38,
    // RENDERING
    /**
     * @property {String} BLEND
     * @final
     * @default source-over
     */
    BLEND: 'source-over',
    /**
     * @property {String} ADD
     * @final
     * @default lighter
     */
    ADD: 'lighter',
    //ADD: 'add', //
    //SUBTRACT: 'subtract', //
    /**
     * @property {String} DARKEST
     * @final
     */
    DARKEST: 'darken',
    /**
     * @property {String} LIGHTEST
     * @final
     * @default lighten
     */
    LIGHTEST: 'lighten',
    /**
     * @property {String} DIFFERENCE
     * @final
     */
    DIFFERENCE: 'difference',
    SUBTRACT: 'subtract',
    /**
     * @property {String} EXCLUSION
     * @final
     */
    EXCLUSION: 'exclusion',
    /**
     * @property {String} MULTIPLY
     * @final
     */
    MULTIPLY: 'multiply',
    /**
     * @property {String} SCREEN
     * @final
     */
    SCREEN: 'screen',
    /**
     * @property {String} REPLACE
     * @final
     * @default copy
     */
    REPLACE: 'copy',
    /**
     * @property {String} OVERLAY
     * @final
     */
    OVERLAY: 'overlay',
    /**
     * @property {String} HARD_LIGHT
     * @final
     */
    HARD_LIGHT: 'hard-light',
    /**
     * @property {String} SOFT_LIGHT
     * @final
     */
    SOFT_LIGHT: 'soft-light',
    /**
     * @property {String} DODGE
     * @final
     * @default color-dodge
     */
    DODGE: 'color-dodge',
    /**
     * @property {String} BURN
     * @final
     * @default color-burn
     */
    BURN: 'color-burn',
    // FILTERS
    /**
     * @property {String} THRESHOLD
     * @final
     */
    THRESHOLD: 'threshold',
    /**
     * @property {String} GRAY
     * @final
     */
    GRAY: 'gray',
    /**
     * @property {String} OPAQUE
     * @final
     */
    OPAQUE: 'opaque',
    /**
     * @property {String} INVERT
     * @final
     */
    INVERT: 'invert',
    /**
     * @property {String} POSTERIZE
     * @final
     */
    POSTERIZE: 'posterize',
    /**
     * @property {String} DILATE
     * @final
     */
    DILATE: 'dilate',
    /**
     * @property {String} ERODE
     * @final
     */
    ERODE: 'erode',
    /**
     * @property {String} BLUR
     * @final
     */
    BLUR: 'blur',
    // TYPOGRAPHY
    /**
     * @property {String} NORMAL
     * @final
     */
    NORMAL: 'normal',
    /**
     * @property {String} ITALIC
     * @final
     */
    ITALIC: 'italic',
    /**
     * @property {String} BOLD
     * @final
     */
    BOLD: 'bold',
    // TYPOGRAPHY-INTERNAL
    _DEFAULT_TEXT_FILL: '#000000',
    _DEFAULT_LEADMULT: 1.25,
    _CTX_MIDDLE: 'middle',
    // VERTICES
    LINEAR: 'linear',
    QUADRATIC: 'quadratic',
    BEZIER: 'bezier',
    CURVE: 'curve',
    // WEBGL DRAWMODES
    STROKE: 'stroke',
    FILL: 'fill',
    TEXTURE: 'texture',
    IMMEDIATE: 'immediate',
    //WEBGL TEXTURE WRAP AND FILTERING
    // LINEAR already exists above
    NEAREST: 'nearest',
    REPEAT: 'repeat',
    CLAMP: 'clamp',
    MIRROR: 'mirror',
    // DEVICE-ORIENTATION
    /**
     * @property {String} LANDSCAPE
     * @final
     */
    LANDSCAPE: 'landscape',
    /**
     * @property {String} PORTRAIT
     * @final
     */
    PORTRAIT: 'portrait',
    POLYGON: 'polygon',
    BOLDITALIC: 'bold italic',
    // DEFAULTS
    _DEFAULT_STROKE: '#000000',
    _DEFAULT_FILL: '#FFFFFF'
};


/***/ }),

/***/ "./src/drawing/sketch/image/SketchImage.ts":
/*!*************************************************!*\
  !*** ./src/drawing/sketch/image/SketchImage.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SketchImage": () => (/* binding */ SketchImage)
/* harmony export */ });
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tuval/cg */ "@tuval/cg");
/* harmony import */ var _tuval_cg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tuval_cg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _SketchCanvasRenderer2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../SketchCanvasRenderer2D */ "./src/drawing/sketch/SketchCanvasRenderer2D.ts");
/* harmony import */ var _filters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filters */ "./src/drawing/sketch/image/filters.ts");



var SketchImage = /** @class */ (function () {
    function SketchImage(width, height, inst) {
        this.drawingContext = undefined;
        this.setModified = function (val) {
            this._modified = val; //enforce boolean?
        };
        this.width = width;
        this.height = height;
        this.canvas = document.createElement('canvas');
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.drawingContext = this.canvas.getContext('2d');
        this._pixelDensity = 1;
        //used for webgl texturing only
        this._modified = false;
        this._pixelsDirty = true;
        this.pixels = [];
    }
    SketchImage.prototype._setProperty = function (prop, value) {
        this[prop] = value;
        this.setModified(true);
    };
    SketchImage.prototype.loadPixels = function () {
        if (!this._pixelsDirty) {
            return;
        }
        this._pixelsDirty = false;
        var pd = this._pixelDensity;
        var w = this.width * pd;
        var h = this.height * pd;
        var imageData = this.drawingContext.getImageData(0, 0, w, h);
        // @todo this should actually set pixels per object, so diff buffers can
        // have diff pixel arrays.
        this.imageData = imageData;
        this.pixels = imageData.data;
        this.setModified(true);
    };
    SketchImage.prototype.updatePixels = function (x, y, w, h) {
        var pixelsState = this;
        var pd = pixelsState._pixelDensity;
        if (x === undefined &&
            y === undefined &&
            w === undefined &&
            h === undefined) {
            x = 0;
            y = 0;
            w = this.width;
            h = this.height;
        }
        x *= pd;
        y *= pd;
        w *= pd;
        h *= pd;
        this.drawingContext.putImageData(pixelsState.imageData, x, y, 0, 0, w, h);
        if (x !== 0 || y !== 0 || w !== this.width || h !== this.height) {
            pixelsState._pixelsDirty = true;
        }
        this.setModified(true);
    };
    SketchImage.prototype.get = function (x, y, w, h) {
        var pixelsState = this;
        var pd = pixelsState._pixelDensity;
        var canvas = this.canvas;
        if (typeof x === 'undefined' && typeof y === 'undefined') {
            // get()
            x = y = 0;
            w = pixelsState.width;
            h = pixelsState.height;
        }
        else {
            x *= pd;
            y *= pd;
            if (typeof w === 'undefined' && typeof h === 'undefined') {
                // get(x,y)
                if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
                    return [0, 0, 0, 0];
                }
                return this._getPixel(x, y);
            }
            // get(x,y,w,h)
        }
        var region = new SketchImage(w, h);
        region.canvas.getContext('2d').drawImage(canvas, x, y, w * pd, h * pd, 0, 0, w, h);
        return region;
    };
    SketchImage.prototype._getPixel = function (x, y) {
        var imageData, index;
        imageData = this.drawingContext.getImageData(x, y, 1, 1).data;
        index = 0;
        return [
            imageData[index + 0],
            imageData[index + 1],
            imageData[index + 2],
            imageData[index + 3]
        ];
    };
    SketchImage.prototype.set = function (x, y, imgOrCol) {
        // round down to get integer numbers
        x = Math.floor(x);
        y = Math.floor(y);
        var pixelsState = this;
        if (imgOrCol instanceof SketchImage) {
            this.drawingContext.save();
            this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
            this.drawingContext.scale(pixelsState._pixelDensity, pixelsState._pixelDensity);
            this.drawingContext.drawImage(imgOrCol.canvas, x, y);
            this.drawingContext.restore();
        }
        else {
            var r = 0, g = 0, b = 0, a = 0;
            var idx = 4 *
                (y *
                    pixelsState._pixelDensity *
                    (this.width * pixelsState._pixelDensity) +
                    x * pixelsState._pixelDensity);
            if (!pixelsState.imageData) {
                pixelsState.loadPixels.call(pixelsState);
            }
            if (typeof imgOrCol === 'number') {
                if (idx < pixelsState.pixels.length) {
                    r = imgOrCol;
                    g = imgOrCol;
                    b = imgOrCol;
                    a = 255;
                    //this.updatePixels.call(this);
                }
            }
            else if (imgOrCol instanceof Array) {
                if (imgOrCol.length < 4) {
                    throw new Error('pixel array must be of the form [R, G, B, A]');
                }
                if (idx < pixelsState.pixels.length) {
                    r = imgOrCol[0];
                    g = imgOrCol[1];
                    b = imgOrCol[2];
                    a = imgOrCol[3];
                    //this.updatePixels.call(this);
                }
            }
            else if (imgOrCol instanceof _tuval_cg__WEBPACK_IMPORTED_MODULE_0__.CGColor) {
                if (idx < pixelsState.pixels.length) {
                    r = imgOrCol.Levels[0];
                    g = imgOrCol.Levels[1];
                    b = imgOrCol.Levels[2];
                    a = imgOrCol.Levels[3];
                    //this.updatePixels.call(this);
                }
            }
            // loop over pixelDensity * pixelDensity
            for (var i = 0; i < pixelsState._pixelDensity; i++) {
                for (var j = 0; j < pixelsState._pixelDensity; j++) {
                    // loop over
                    idx =
                        4 *
                            ((y * pixelsState._pixelDensity + j) *
                                this.width *
                                pixelsState._pixelDensity +
                                (x * pixelsState._pixelDensity + i));
                    pixelsState.pixels[idx] = r;
                    pixelsState.pixels[idx + 1] = g;
                    pixelsState.pixels[idx + 2] = b;
                    pixelsState.pixels[idx + 3] = a;
                }
            }
        }
        this.setModified(true);
    };
    SketchImage.prototype.resize = function (width, height) {
        // Copy contents to a temporary canvas, resize the original
        // and then copy back.
        //
        // There is a faster approach that involves just one copy and swapping the
        // this.canvas reference. We could switch to that approach if (as i think
        // is the case) there an expectation that the user would not hold a
        // reference to the backing canvas of a p5.Image. But since we do not
        // enforce that at the moment, I am leaving in the slower, but safer
        // implementation.
        // auto-resize
        if (width === 0 && height === 0) {
            width = this.canvas.width;
            height = this.canvas.height;
        }
        else if (width === 0) {
            width = this.canvas.width * height / this.canvas.height;
        }
        else if (height === 0) {
            height = this.canvas.height * width / this.canvas.width;
        }
        width = Math.floor(width);
        height = Math.floor(height);
        var tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        // prettier-ignore
        tempCanvas.getContext('2d').drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, tempCanvas.width, tempCanvas.height);
        // Resize the original canvas, which will clear its contents
        this.canvas.width = this.width = width;
        this.canvas.height = this.height = height;
        //Copy the image back
        // prettier-ignore
        this.drawingContext.drawImage(tempCanvas, 0, 0, width, height, 0, 0, width, height);
        if (this.pixels.length > 0) {
            this.loadPixels();
        }
        this.setModified(true);
        this._pixelsDirty = true;
    };
    SketchImage.prototype.copy = function () {
        var srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
        if (arguments.length === 9) {
            srcImage = arguments[0];
            sx = arguments[1];
            sy = arguments[2];
            sw = arguments[3];
            sh = arguments[4];
            dx = arguments[5];
            dy = arguments[6];
            dw = arguments[7];
            dh = arguments[8];
        }
        else if (arguments.length === 8) {
            srcImage = this;
            sx = arguments[0];
            sy = arguments[1];
            sw = arguments[2];
            sh = arguments[3];
            dx = arguments[4];
            dy = arguments[5];
            dw = arguments[6];
            dh = arguments[7];
        }
        else {
            throw new Error('Signature not supported');
        }
        SketchImage._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
        this._pixelsDirty = true;
    };
    SketchImage._copyHelper = function (dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) {
        srcImage.loadPixels();
        var s = srcImage.canvas.width / srcImage.width;
        dstImage.drawingContext.drawImage(srcImage.canvas, s * sx, s * sy, s * sw, s * sh, dx, dy, dw, dh);
    };
    SketchImage.prototype.mask = function (p5Image) {
        if (p5Image === undefined) {
            p5Image = this;
        }
        var currBlend = this.drawingContext.globalCompositeOperation;
        var scaleFactor = 1;
        if (p5Image instanceof _SketchCanvasRenderer2D__WEBPACK_IMPORTED_MODULE_1__.SketchCanvasRenderer2D) {
            scaleFactor = p5Image._pixelDensity;
        }
        var copyArgs = [
            p5Image,
            0,
            0,
            scaleFactor * p5Image.width,
            scaleFactor * p5Image.height,
            0,
            0,
            this.width,
            this.height
        ];
        this.drawingContext.globalCompositeOperation = 'destination-in';
        SketchImage.prototype.copy.apply(this, copyArgs);
        this.drawingContext.globalCompositeOperation = currBlend;
        this.setModified(true);
    };
    SketchImage.prototype.filter = function (operation, value) {
        _filters__WEBPACK_IMPORTED_MODULE_2__.Filters.apply(this.canvas, _filters__WEBPACK_IMPORTED_MODULE_2__.Filters[operation.toLowerCase()], value);
        this.setModified(true);
    };
    SketchImage.prototype.blend = function () {
        //Sketch.prototype.blend.apply(this, arguments);
        this.setModified(true);
    };
    SketchImage.prototype.isModified = function () {
        return this._modified;
    };
    SketchImage.prototype.save = function (filename, extension) {
        //Sketch.prototype.saveCanvas(this.canvas, filename, extension);
    };
    return SketchImage;
}());



/***/ }),

/***/ "./src/drawing/sketch/image/filters.ts":
/*!*********************************************!*\
  !*** ./src/drawing/sketch/image/filters.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Filters": () => (/* binding */ Filters)
/* harmony export */ });
var Filters = {};
/*
 * Helper functions
 */
/**
 * Returns the pixel buffer for a canvas
 *
 * @private
 *
 * @param  {Canvas|ImageData} canvas the canvas to get pixels from
 * @return {Uint8ClampedArray}       a one-dimensional array containing
 *                                   the data in thc RGBA order, with integer
 *                                   values between 0 and 255
 */
Filters._toPixels = function (canvas) {
    if (canvas instanceof ImageData) {
        return canvas.data;
    }
    else {
        return canvas
            .getContext('2d')
            .getImageData(0, 0, canvas.width, canvas.height).data;
    }
};
/**
 * Returns a 32 bit number containing ARGB data at ith pixel in the
 * 1D array containing pixels data.
 *
 * @private
 *
 * @param  {Uint8ClampedArray} data array returned by _toPixels()
 * @param  {Integer}           i    index of a 1D Image Array
 * @return {Integer}                32 bit integer value representing
 *                                  ARGB value.
 */
Filters._getARGB = function (data, i) {
    var offset = i * 4;
    return (((data[offset + 3] << 24) & 0xff000000) |
        ((data[offset] << 16) & 0x00ff0000) |
        ((data[offset + 1] << 8) & 0x0000ff00) |
        (data[offset + 2] & 0x000000ff));
};
/**
 * Modifies pixels RGBA values to values contained in the data object.
 *
 * @private
 *
 * @param {Uint8ClampedArray} pixels array returned by _toPixels()
 * @param {Int32Array}        data   source 1D array where each value
 *                                   represents ARGB values
 */
Filters._setPixels = function (pixels, data) {
    var offset = 0;
    for (var i = 0, al = pixels.length; i < al; i++) {
        offset = i * 4;
        pixels[offset + 0] = (data[i] & 0x00ff0000) >>> 16;
        pixels[offset + 1] = (data[i] & 0x0000ff00) >>> 8;
        pixels[offset + 2] = data[i] & 0x000000ff;
        pixels[offset + 3] = (data[i] & 0xff000000) >>> 24;
    }
};
/**
 * Returns the ImageData object for a canvas
 * https://developer.mozilla.org/en-US/docs/Web/API/ImageData
 *
 * @private
 *
 * @param  {Canvas|ImageData} canvas canvas to get image data from
 * @return {ImageData}               Holder of pixel data (and width and
 *                                   height) for a canvas
 */
Filters._toImageData = function (canvas) {
    if (canvas instanceof ImageData) {
        return canvas;
    }
    else {
        return canvas
            .getContext('2d')
            .getImageData(0, 0, canvas.width, canvas.height);
    }
};
/**
 * Returns a blank ImageData object.
 *
 * @private
 *
 * @param  {Integer} width
 * @param  {Integer} height
 * @return {ImageData}
 */
Filters._createImageData = function (width, height) {
    Filters._tmpCanvas = document.createElement('canvas');
    Filters._tmpCtx = Filters._tmpCanvas.getContext('2d');
    return this._tmpCtx.createImageData(width, height);
};
/**
 * Applys a filter function to a canvas.
 *
 * The difference between this and the actual filter functions defined below
 * is that the filter functions generally modify the pixel buffer but do
 * not actually put that data back to the canvas (where it would actually
 * update what is visible). By contrast this method does make the changes
 * actually visible in the canvas.
 *
 * The apply method is the method that callers of this module would generally
 * use. It has been separated from the actual filters to support an advanced
 * use case of creating a filter chain that executes without actually updating
 * the canvas in between everystep.
 *
 * @private
 * @param  {HTMLCanvasElement} canvas [description]
 * @param  {function(ImageData,Object)} func   [description]
 * @param  {Object} filterParam  [description]
 */
Filters.apply = function (canvas, func, filterParam) {
    var ctx = canvas.getContext('2d');
    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    //Filters can either return a new ImageData object, or just modify
    //the one they received.
    var newImageData = func(imageData, filterParam);
    if (newImageData instanceof ImageData) {
        ctx.putImageData(newImageData, 0, 0, 0, 0, canvas.width, canvas.height);
    }
    else {
        ctx.putImageData(imageData, 0, 0, 0, 0, canvas.width, canvas.height);
    }
};
/*
 * Filters
 */
/**
 * Converts the image to black and white pixels depending if they are above or
 * below the threshold defined by the level parameter. The parameter must be
 * between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.
 *
 * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
 *
 * @private
 * @param  {Canvas} canvas
 * @param  {Float} level
 */
Filters.threshold = function (canvas, level) {
    var pixels = Filters._toPixels(canvas);
    if (level === undefined) {
        level = 0.5;
    }
    var thresh = Math.floor(level * 255);
    for (var i = 0; i < pixels.length; i += 4) {
        var r = pixels[i];
        var g = pixels[i + 1];
        var b = pixels[i + 2];
        var gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        var val;
        if (gray >= thresh) {
            val = 255;
        }
        else {
            val = 0;
        }
        pixels[i] = pixels[i + 1] = pixels[i + 2] = val;
    }
};
/**
 * Converts any colors in the image to grayscale equivalents.
 * No parameter is used.
 *
 * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
 *
 * @private
 * @param {Canvas} canvas
 */
Filters.gray = function (canvas) {
    var pixels = Filters._toPixels(canvas);
    for (var i = 0; i < pixels.length; i += 4) {
        var r = pixels[i];
        var g = pixels[i + 1];
        var b = pixels[i + 2];
        // CIE luminance for RGB
        var gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        pixels[i] = pixels[i + 1] = pixels[i + 2] = gray;
    }
};
/**
 * Sets the alpha channel to entirely opaque. No parameter is used.
 *
 * @private
 * @param {Canvas} canvas
 */
Filters.opaque = function (canvas) {
    var pixels = Filters._toPixels(canvas);
    for (var i = 0; i < pixels.length; i += 4) {
        pixels[i + 3] = 255;
    }
    return pixels;
};
/**
 * Sets each pixel to its inverse value. No parameter is used.
 * @private
 * @param  {Canvas} canvas
 */
Filters.invert = function (canvas) {
    var pixels = Filters._toPixels(canvas);
    for (var i = 0; i < pixels.length; i += 4) {
        pixels[i] = 255 - pixels[i];
        pixels[i + 1] = 255 - pixels[i + 1];
        pixels[i + 2] = 255 - pixels[i + 2];
    }
};
/**
 * Limits each channel of the image to the number of colors specified as
 * the parameter. The parameter can be set to values between 2 and 255, but
 * results are most noticeable in the lower ranges.
 *
 * Adapted from java based processing implementation
 *
 * @private
 * @param  {Canvas} canvas
 * @param  {Integer} level
 */
Filters.posterize = function (canvas, level) {
    var pixels = Filters._toPixels(canvas);
    if (level < 2 || level > 255) {
        throw new Error('Level must be greater than 2 and less than 255 for posterize');
    }
    var levels1 = level - 1;
    for (var i = 0; i < pixels.length; i += 4) {
        var rlevel = pixels[i];
        var glevel = pixels[i + 1];
        var blevel = pixels[i + 2];
        pixels[i] = ((rlevel * level) >> 8) * 255 / levels1;
        pixels[i + 1] = ((glevel * level) >> 8) * 255 / levels1;
        pixels[i + 2] = ((blevel * level) >> 8) * 255 / levels1;
    }
};
/**
 * reduces the bright areas in an image
 * @private
 * @param  {Canvas} canvas
 *
 */
Filters.dilate = function (canvas) {
    var pixels = Filters._toPixels(canvas);
    var currIdx = 0;
    var maxIdx = pixels.length ? pixels.length / 4 : 0;
    var out = new Int32Array(maxIdx);
    var currRowIdx, maxRowIdx, colOrig, colOut, currLum;
    var idxRight, idxLeft, idxUp, idxDown;
    var colRight, colLeft, colUp, colDown;
    var lumRight, lumLeft, lumUp, lumDown;
    while (currIdx < maxIdx) {
        currRowIdx = currIdx;
        maxRowIdx = currIdx + canvas.width;
        while (currIdx < maxRowIdx) {
            colOrig = colOut = Filters._getARGB(pixels, currIdx);
            idxLeft = currIdx - 1;
            idxRight = currIdx + 1;
            idxUp = currIdx - canvas.width;
            idxDown = currIdx + canvas.width;
            if (idxLeft < currRowIdx) {
                idxLeft = currIdx;
            }
            if (idxRight >= maxRowIdx) {
                idxRight = currIdx;
            }
            if (idxUp < 0) {
                idxUp = 0;
            }
            if (idxDown >= maxIdx) {
                idxDown = currIdx;
            }
            colUp = Filters._getARGB(pixels, idxUp);
            colLeft = Filters._getARGB(pixels, idxLeft);
            colDown = Filters._getARGB(pixels, idxDown);
            colRight = Filters._getARGB(pixels, idxRight);
            //compute luminance
            currLum =
                77 * ((colOrig >> 16) & 0xff) +
                    151 * ((colOrig >> 8) & 0xff) +
                    28 * (colOrig & 0xff);
            lumLeft =
                77 * ((colLeft >> 16) & 0xff) +
                    151 * ((colLeft >> 8) & 0xff) +
                    28 * (colLeft & 0xff);
            lumRight =
                77 * ((colRight >> 16) & 0xff) +
                    151 * ((colRight >> 8) & 0xff) +
                    28 * (colRight & 0xff);
            lumUp =
                77 * ((colUp >> 16) & 0xff) +
                    151 * ((colUp >> 8) & 0xff) +
                    28 * (colUp & 0xff);
            lumDown =
                77 * ((colDown >> 16) & 0xff) +
                    151 * ((colDown >> 8) & 0xff) +
                    28 * (colDown & 0xff);
            if (lumLeft > currLum) {
                colOut = colLeft;
                currLum = lumLeft;
            }
            if (lumRight > currLum) {
                colOut = colRight;
                currLum = lumRight;
            }
            if (lumUp > currLum) {
                colOut = colUp;
                currLum = lumUp;
            }
            if (lumDown > currLum) {
                colOut = colDown;
                currLum = lumDown;
            }
            out[currIdx++] = colOut;
        }
    }
    Filters._setPixels(pixels, out);
};
/**
 * increases the bright areas in an image
 * @private
 * @param  {Canvas} canvas
 *
 */
Filters.erode = function (canvas) {
    var pixels = Filters._toPixels(canvas);
    var currIdx = 0;
    var maxIdx = pixels.length ? pixels.length / 4 : 0;
    var out = new Int32Array(maxIdx);
    var currRowIdx, maxRowIdx, colOrig, colOut, currLum;
    var idxRight, idxLeft, idxUp, idxDown;
    var colRight, colLeft, colUp, colDown;
    var lumRight, lumLeft, lumUp, lumDown;
    while (currIdx < maxIdx) {
        currRowIdx = currIdx;
        maxRowIdx = currIdx + canvas.width;
        while (currIdx < maxRowIdx) {
            colOrig = colOut = Filters._getARGB(pixels, currIdx);
            idxLeft = currIdx - 1;
            idxRight = currIdx + 1;
            idxUp = currIdx - canvas.width;
            idxDown = currIdx + canvas.width;
            if (idxLeft < currRowIdx) {
                idxLeft = currIdx;
            }
            if (idxRight >= maxRowIdx) {
                idxRight = currIdx;
            }
            if (idxUp < 0) {
                idxUp = 0;
            }
            if (idxDown >= maxIdx) {
                idxDown = currIdx;
            }
            colUp = Filters._getARGB(pixels, idxUp);
            colLeft = Filters._getARGB(pixels, idxLeft);
            colDown = Filters._getARGB(pixels, idxDown);
            colRight = Filters._getARGB(pixels, idxRight);
            //compute luminance
            currLum =
                77 * ((colOrig >> 16) & 0xff) +
                    151 * ((colOrig >> 8) & 0xff) +
                    28 * (colOrig & 0xff);
            lumLeft =
                77 * ((colLeft >> 16) & 0xff) +
                    151 * ((colLeft >> 8) & 0xff) +
                    28 * (colLeft & 0xff);
            lumRight =
                77 * ((colRight >> 16) & 0xff) +
                    151 * ((colRight >> 8) & 0xff) +
                    28 * (colRight & 0xff);
            lumUp =
                77 * ((colUp >> 16) & 0xff) +
                    151 * ((colUp >> 8) & 0xff) +
                    28 * (colUp & 0xff);
            lumDown =
                77 * ((colDown >> 16) & 0xff) +
                    151 * ((colDown >> 8) & 0xff) +
                    28 * (colDown & 0xff);
            if (lumLeft < currLum) {
                colOut = colLeft;
                currLum = lumLeft;
            }
            if (lumRight < currLum) {
                colOut = colRight;
                currLum = lumRight;
            }
            if (lumUp < currLum) {
                colOut = colUp;
                currLum = lumUp;
            }
            if (lumDown < currLum) {
                colOut = colDown;
                currLum = lumDown;
            }
            out[currIdx++] = colOut;
        }
    }
    Filters._setPixels(pixels, out);
};
// BLUR
// internal kernel stuff for the gaussian blur filter
var blurRadius;
var blurKernelSize;
var blurKernel;
var blurMult;
/*
 * Port of https://github.com/processing/processing/blob/
 * master/core/src/processing/core/PImage.java#L1250
 *
 * Optimized code for building the blur kernel.
 * further optimized blur code (approx. 15% for radius=20)
 * bigger speed gains for larger radii (~30%)
 * added support for various image types (ALPHA, RGB, ARGB)
 * [toxi 050728]
 */
function buildBlurKernel(r) {
    var radius = (r * 3.5) | 0;
    radius = radius < 1 ? 1 : radius < 248 ? radius : 248;
    if (blurRadius !== radius) {
        blurRadius = radius;
        blurKernelSize = (1 + blurRadius) << 1;
        blurKernel = new Int32Array(blurKernelSize);
        blurMult = new Array(blurKernelSize);
        for (var l = 0; l < blurKernelSize; l++) {
            blurMult[l] = new Int32Array(256);
        }
        var bk, bki;
        var bm, bmi;
        for (var i = 1, radiusi = radius - 1; i < radius; i++) {
            blurKernel[radius + i] = blurKernel[radiusi] = bki = radiusi * radiusi;
            bm = blurMult[radius + i];
            bmi = blurMult[radiusi--];
            for (var j = 0; j < 256; j++) {
                bm[j] = bmi[j] = bki * j;
            }
        }
        bk = blurKernel[radius] = radius * radius;
        bm = blurMult[radius];
        for (var k = 0; k < 256; k++) {
            bm[k] = bk * k;
        }
    }
}
// Port of https://github.com/processing/processing/blob/
// master/core/src/processing/core/PImage.java#L1433
function blurARGB(canvas, radius) {
    var pixels = Filters._toPixels(canvas);
    var width = canvas.width;
    var height = canvas.height;
    var numPackedPixels = width * height;
    var argb = new Int32Array(numPackedPixels);
    for (var j = 0; j < numPackedPixels; j++) {
        argb[j] = Filters._getARGB(pixels, j);
    }
    var sum, cr, cg, cb, ca;
    var read, ri, ym, ymi, bk0;
    var a2 = new Int32Array(numPackedPixels);
    var r2 = new Int32Array(numPackedPixels);
    var g2 = new Int32Array(numPackedPixels);
    var b2 = new Int32Array(numPackedPixels);
    var yi = 0;
    buildBlurKernel(radius);
    var x, y, i;
    var bm;
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            cb = cg = cr = ca = sum = 0;
            read = x - blurRadius;
            if (read < 0) {
                bk0 = -read;
                read = 0;
            }
            else {
                if (read >= width) {
                    break;
                }
                bk0 = 0;
            }
            for (i = bk0; i < blurKernelSize; i++) {
                if (read >= width) {
                    break;
                }
                var c = argb[read + yi];
                bm = blurMult[i];
                ca += bm[(c & -16777216) >>> 24];
                cr += bm[(c & 16711680) >> 16];
                cg += bm[(c & 65280) >> 8];
                cb += bm[c & 255];
                sum += blurKernel[i];
                read++;
            }
            ri = yi + x;
            a2[ri] = ca / sum;
            r2[ri] = cr / sum;
            g2[ri] = cg / sum;
            b2[ri] = cb / sum;
        }
        yi += width;
    }
    yi = 0;
    ym = -blurRadius;
    ymi = ym * width;
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            cb = cg = cr = ca = sum = 0;
            if (ym < 0) {
                bk0 = ri = -ym;
                read = x;
            }
            else {
                if (ym >= height) {
                    break;
                }
                bk0 = 0;
                ri = ym;
                read = x + ymi;
            }
            for (i = bk0; i < blurKernelSize; i++) {
                if (ri >= height) {
                    break;
                }
                bm = blurMult[i];
                ca += bm[a2[read]];
                cr += bm[r2[read]];
                cg += bm[g2[read]];
                cb += bm[b2[read]];
                sum += blurKernel[i];
                ri++;
                read += width;
            }
            argb[x + yi] =
                ((ca / sum) << 24) |
                    ((cr / sum) << 16) |
                    ((cg / sum) << 8) |
                    (cb / sum);
        }
        yi += width;
        ymi += width;
        ym++;
    }
    Filters._setPixels(pixels, argb);
}
Filters.blur = function (canvas, radius) {
    blurARGB(canvas, radius);
};


/***/ }),

/***/ "./src/drawing/sketch/index.ts":
/*!*************************************!*\
  !*** ./src/drawing/sketch/index.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SketchGraphics": () => (/* reexport safe */ _SketchGraphics__WEBPACK_IMPORTED_MODULE_0__.SketchGraphics),
/* harmony export */   "SketchBatch": () => (/* reexport safe */ _SketchBatch__WEBPACK_IMPORTED_MODULE_1__.SketchBatch)
/* harmony export */ });
/* harmony import */ var _SketchGraphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SketchGraphics */ "./src/drawing/sketch/SketchGraphics.ts");
/* harmony import */ var _SketchBatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SketchBatch */ "./src/drawing/sketch/SketchBatch.ts");
/*
import './Core/Shim';
import './Core/Rendering';
import './Core/Init';
import './Core/Environment';
import './Core/Legacy';
import './Core/Structure';
import './Core/Transform';
import './Core/Shape/2d_primitives';
import './Core/Shape/Attributes';
import './Core/Shape/curves';
import './Core/Shape/Vertex';

export * from './Core/Constanst';
export * from './Core/Element';
export * from './Core/ErrorHelper';
export * from './Core/Graphics';
export * from './Core/Helper';
export * from './Core/Renderer';
export * from './Core/Renderer2D';
export * from './Core/Sketch';

import './Math/Calculation';
import './Math/Math';
import './Math/Noise';
export * from './Math/Polargeometry';
import './Math/Random';
import './Math/Trigonometry';
export * from './Math/Vector';


import './Color/color_conversion';
import './Color/creating_reading';
import './Color/setting';

export * from './Image/SketchImage';
import './Image/Pixels';
import './Image/filters';
import './Image/image';
import './Image/loading_displaying';

export * from './Typography/SketchFont';
import './Typography/Attributes';
import './Typography/Loading_displaying'; */
//export * from './math/Vector';




/***/ }),

/***/ "./src/drawing/sketch/math/Vector.ts":
/*!*******************************************!*\
  !*** ./src/drawing/sketch/math/Vector.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Vector": () => (/* binding */ Vector)
/* harmony export */ });
/* harmony import */ var _core_Constanst__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Constanst */ "./src/drawing/sketch/core/Constanst.ts");
/* harmony import */ var _SketchGraphics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../SketchGraphics */ "./src/drawing/sketch/SketchGraphics.ts");


var Vector = /** @class */ (function () {
    function Vector(x, y, z) {
        this.sketch = undefined;
        var _x, _y, _z;
        // This is how it comes in with createVector()
        if (arguments[0] instanceof _SketchGraphics__WEBPACK_IMPORTED_MODULE_1__.SketchGraphics) {
            // save reference to p5 if passed in
            this.sketch = arguments[0];
            _x = arguments[1][0] || 0;
            _y = arguments[1][1] || 0;
            _z = arguments[1][2] || 0;
            // This is what we'll get with new p5.Vector()
        }
        else {
            _x = arguments[0] || 0;
            _y = arguments[1] || 0;
            _z = arguments[2] || 0;
        }
        /**
         * The x component of the vector
         * @property x {Number}
         */
        this.x = _x;
        /**
         * The y component of the vector
         * @property y {Number}
         */
        this.y = _y;
        /**
         * The z component of the vector
         * @property z {Number}
         */
        this.z = _z;
    }
    Vector.prototype.toString = function () {
        return 'Vector Object : [' + this.x + ', ' + this.y + ', ' + this.z + ']';
    };
    Vector.prototype.set = function (x, y, z) {
        if (x instanceof Vector) {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
            return this;
        }
        if (x instanceof Array) {
            this.x = x[0] || 0;
            this.y = x[1] || 0;
            this.z = x[2] || 0;
            return this;
        }
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        return this;
    };
    Vector.prototype.copy = function () {
        if (this.sketch) {
            return new Vector(this.sketch, [this.x, this.y, this.z]);
        }
        else {
            return new Vector(this.x, this.y, this.z);
        }
    };
    Vector.prototype.add = function (x, y, z) {
        if (x instanceof Vector) {
            this.x += x.x || 0;
            this.y += x.y || 0;
            this.z += x.z || 0;
            return this;
        }
        if (x instanceof Array) {
            this.x += x[0] || 0;
            this.y += x[1] || 0;
            this.z += x[2] || 0;
            return this;
        }
        this.x += x || 0;
        this.y += y || 0;
        this.z += z || 0;
        return this;
    };
    Vector.prototype.sub = function (x, y, z) {
        if (x instanceof Vector) {
            this.x -= x.x || 0;
            this.y -= x.y || 0;
            this.z -= x.z || 0;
            return this;
        }
        if (x instanceof Array) {
            this.x -= x[0] || 0;
            this.y -= x[1] || 0;
            this.z -= x[2] || 0;
            return this;
        }
        this.x -= x || 0;
        this.y -= y || 0;
        this.z -= z || 0;
        return this;
    };
    Vector.prototype.mult = function (n) {
        if (!(typeof n === 'number' && isFinite(n))) {
            console.warn('Vector.prototype.mult:', 'n is undefined or not a finite number');
            return this;
        }
        this.x *= n;
        this.y *= n;
        this.z *= n;
        return this;
    };
    Vector.prototype.div = function (n) {
        if (!(typeof n === 'number' && isFinite(n))) {
            console.warn('Vector.prototype.div:', 'n is undefined or not a finite number');
            return this;
        }
        if (n === 0) {
            console.warn('Vector.prototype.div:', 'divide by 0');
            return this;
        }
        this.x /= n;
        this.y /= n;
        this.z /= n;
        return this;
    };
    Vector.prototype.mag = function () {
        return Math.sqrt(this.magSq());
    };
    Vector.prototype.magSq = function () {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        return x * x + y * y + z * z;
    };
    Vector.prototype.dot = function (x, y, z) {
        if (x instanceof Vector) {
            return this.dot(x.x, x.y, x.z);
        }
        return this.x * (x || 0) + this.y * (y || 0) + this.z * (z || 0);
    };
    Vector.prototype.cross = function (v) {
        var x = this.y * v.z - this.z * v.y;
        var y = this.z * v.x - this.x * v.z;
        var z = this.x * v.y - this.y * v.x;
        if (this.sketch) {
            return new Vector(this.sketch, [x, y, z]);
        }
        else {
            return new Vector(x, y, z);
        }
    };
    Vector.prototype.dist = function (v) {
        return v
            .copy()
            .sub(this)
            .mag();
    };
    Vector.prototype.normalize = function () {
        var len = this.mag();
        // here we multiply by the reciprocal instead of calling 'div()'
        // since div duplicates this zero check.
        if (len !== 0)
            this.mult(1 / len);
        return this;
    };
    Vector.prototype.limit = function (max) {
        var mSq = this.magSq();
        if (mSq > max * max) {
            this.div(Math.sqrt(mSq)) //normalize it
                .mult(max);
        }
        return this;
    };
    Vector.prototype.setMag = function (len) {
        return this.normalize().mult(len);
    };
    Vector.prototype.heading = function () {
        var h = Math.atan2(this.y, this.x);
        if (this.sketch)
            return this.sketch._fromRadians(h);
        return h;
    };
    Vector.prototype.rotate = function (angle) {
        var newHeading = this.heading() + angle;
        if (this.sketch) {
            newHeading = this.sketch._toRadians(newHeading);
        }
        var mag = this.mag();
        this.x = Math.cos(newHeading) * mag;
        this.y = Math.sin(newHeading) * mag;
        return this;
    };
    Vector.prototype.angleBetween = function (v) {
        var dotmagmag = this.dot(v) / (this.mag() * v.mag());
        // Mathematically speaking: the dotmagmag variable will be between -1 and 1
        // inclusive. Practically though it could be slightly outside this range due
        // to floating-point rounding issues. This can make Math.acos return NaN.
        //
        // Solution: we'll clamp the value to the -1,1 range
        var angle = Math.acos(Math.min(1, Math.max(-1, dotmagmag)));
        if (this.sketch)
            return this.sketch._fromRadians(angle);
        return angle;
    };
    Vector.prototype.lerp = function (x, y, z, amt) {
        if (x instanceof Vector) {
            return this.lerp(x.x, x.y, x.z, y);
        }
        if (amt) {
            this.x += (x - this.x) * amt || 0;
            this.y += (y - this.y) * amt || 0;
            this.z += (z - this.z) * amt || 0;
        }
        return this;
    };
    Vector.prototype.array = function () {
        return [this.x || 0, this.y || 0, this.z || 0];
    };
    Vector.prototype.equals = function (x, y, z) {
        var a, b, c;
        if (x instanceof Vector) {
            a = x.x || 0;
            b = x.y || 0;
            c = x.z || 0;
        }
        else if (x instanceof Array) {
            a = x[0] || 0;
            b = x[1] || 0;
            c = x[2] || 0;
        }
        else {
            a = x || 0;
            b = y || 0;
            c = z || 0;
        }
        return this.x === a && this.y === b && this.z === c;
    };
    Vector.fromAngle = function (angle, length) {
        if (typeof length === 'undefined') {
            length = 1;
        }
        return new Vector(length * Math.cos(angle), length * Math.sin(angle), 0);
    };
    Vector.fromAngles = function (theta, phi, length) {
        if (typeof length === 'undefined') {
            length = 1;
        }
        var cosPhi = Math.cos(phi);
        var sinPhi = Math.sin(phi);
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        return new Vector(length * sinTheta * sinPhi, -length * cosTheta, length * sinTheta * cosPhi);
    };
    Vector.random2D = function () {
        return this.fromAngle(Math.random() * _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.TWO_PI);
    };
    Vector.random3D = function () {
        var angle = Math.random() * _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.TWO_PI;
        var vz = Math.random() * 2 - 1;
        var vzBase = Math.sqrt(1 - vz * vz);
        var vx = vzBase * Math.cos(angle);
        var vy = vzBase * Math.sin(angle);
        return new Vector(vx, vy, vz);
    };
    Vector.add = function (v1, v2, target) {
        if (!target) {
            target = v1.copy();
        }
        else {
            target.set(v1);
        }
        target.add(v2);
        return target;
    };
    Vector.sub = function (v1, v2, target) {
        if (!target) {
            target = v1.copy();
        }
        else {
            target.set(v1);
        }
        target.sub(v2);
        return target;
    };
    Vector.mult = function (v, n, target) {
        if (!target) {
            target = v.copy();
        }
        else {
            target.set(v);
        }
        target.mult(n);
        return target;
    };
    Vector.div = function (v, n, target) {
        if (!target) {
            target = v.copy();
        }
        else {
            target.set(v);
        }
        target.div(n);
        return target;
    };
    Vector.dot = function (v1, v2) {
        return v1.dot(v2);
    };
    Vector.cross = function (v1, v2) {
        return v1.cross(v2);
    };
    Vector.dist = function (v1, v2) {
        return v1.dist(v2);
    };
    Vector.lerp = function (v1, v2, amt, target) {
        if (!target) {
            target = v1.copy();
        }
        else {
            target.set(v1);
        }
        target.lerp(v2, amt);
        return target;
    };
    Vector.mag = function (vecT) {
        var x = vecT.x, y = vecT.y, z = vecT.z;
        var magSq = x * x + y * y + z * z;
        return Math.sqrt(magSq);
    };
    return Vector;
}());



/***/ }),

/***/ "./src/drawing/sketch/typography/SketchFont.ts":
/*!*****************************************************!*\
  !*** ./src/drawing/sketch/typography/SketchFont.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SketchFont": () => (/* binding */ SketchFont)
/* harmony export */ });
/* harmony import */ var _core_Constanst__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Constanst */ "./src/drawing/sketch/core/Constanst.ts");

var SketchFont = /** @class */ (function () {
    function SketchFont(p) {
        this.parent = p;
        this.cache = {};
        /**
         * Underlying opentype font implementation
         * @property font
         */
        this.font = undefined;
    }
    SketchFont.prototype.list = function () {
        // TODO
        throw new Error('not yet implemented');
    };
    SketchFont.prototype.textBounds = function (str, x, y, fontSize, options) {
        x = x !== undefined ? x : 0;
        y = y !== undefined ? y : 0;
        fontSize = fontSize || this.parent.renderer._textSize;
        // Check cache for existing bounds. Take into consideration the text alignment
        // settings. Default alignment should match opentype's origin: left-aligned &
        // alphabetic baseline.
        var p = (options && options.renderer && options.renderer._pInst) || this.parent, renderer = p._renderer, alignment = renderer._textAlign || _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.LEFT, baseline = renderer._textBaseline || _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BASELINE, key = cacheKey('textBounds', str, x, y, fontSize, alignment, baseline), result = this.cache[key];
        if (!result) {
            var minX, minY, maxX, maxY, pos, xCoords = [], yCoords = [], scale = this._scale(fontSize);
            this.font.forEachGlyph(str, x, y, fontSize, options, function (glyph, gX, gY, gFontSize) {
                var gm = glyph.getMetrics();
                xCoords.push(gX + gm.xMin * scale);
                xCoords.push(gX + gm.xMax * scale);
                yCoords.push(gY + -gm.yMin * scale);
                yCoords.push(gY + -gm.yMax * scale);
            });
            minX = Math.min.apply(null, xCoords);
            minY = Math.min.apply(null, yCoords);
            maxX = Math.max.apply(null, xCoords);
            maxY = Math.max.apply(null, yCoords);
            result = {
                x: minX,
                y: minY,
                h: maxY - minY,
                w: maxX - minX,
                advance: minX - x
            };
            // Bounds are now calculated, so shift the x & y to match alignment settings
            pos = this._handleAlignment(renderer, str, result.x, result.y, result.w + result.advance);
            result.x = pos.x;
            result.y = pos.y;
            this.cache[cacheKey('textBounds', str, x, y, fontSize, alignment, baseline)] = result;
        }
        return result;
    };
    SketchFont.prototype.textToPoints = function (txt, x, y, fontSize, options) {
        var xoff = 0, result = [], glyphs = this._getGlyphs(txt);
        function isSpace(i) {
            return ((glyphs[i].name && glyphs[i].name === 'space') ||
                (txt.length === glyphs.length && txt[i] === ' ') ||
                (glyphs[i].index && glyphs[i].index === 3));
        }
        fontSize = fontSize || this.parent.renderer._textSize;
        for (var i = 0; i < glyphs.length; i++) {
            if (!isSpace(i)) {
                // fix to #1817, #2069
                var gpath = glyphs[i].getPath(x, y, fontSize), paths = splitPaths(gpath.commands);
                for (var j = 0; j < paths.length; j++) {
                    var pts = pathToPoints(paths[j], options);
                    for (var k = 0; k < pts.length; k++) {
                        pts[k].x += xoff;
                        result.push(pts[k]);
                    }
                }
            }
            xoff += glyphs[i].advanceWidth * this._scale(fontSize);
        }
        return result;
    };
    SketchFont.prototype._getGlyphs = function (str) {
        return this.font.stringToGlyphs(str);
    };
    SketchFont.prototype._getPath = function (line, x, y, options) {
        var p = (options && options.renderer && options.renderer._pInst) || this.parent, renderer = p._renderer, pos = this._handleAlignment(renderer, line, x, y);
        return this.font.getPath(line, pos.x, pos.y, renderer._textSize, options);
    };
    SketchFont.prototype._getPathData = function (line, x, y, options) {
        var decimals = 3;
        // create path from string/position
        if (typeof line === 'string' && arguments.length > 2) {
            line = this._getPath(line, x, y, options);
        }
        else if (typeof x === 'object') {
            // handle options specified in 2nd arg
            options = x;
        }
        // handle svg arguments
        if (options && typeof options.decimals === 'number') {
            decimals = options.decimals;
        }
        return line.toPathData(decimals);
    };
    SketchFont.prototype._getSVG = function (line, x, y, options) {
        var decimals = 3;
        // create path from string/position
        if (typeof line === 'string' && arguments.length > 2) {
            line = this._getPath(line, x, y, options);
        }
        else if (typeof x === 'object') {
            // handle options specified in 2nd arg
            options = x;
        }
        // handle svg arguments
        if (options) {
            if (typeof options.decimals === 'number') {
                decimals = options.decimals;
            }
            if (typeof options.strokeWidth === 'number') {
                line.strokeWidth = options.strokeWidth;
            }
            if (typeof options.fill !== 'undefined') {
                line.fill = options.fill;
            }
            if (typeof options.stroke !== 'undefined') {
                line.stroke = options.stroke;
            }
        }
        return line.toSVG(decimals);
    };
    SketchFont.prototype._renderPath = function (line, x, y, options) {
        var pdata, pg = (options && options.renderer) || this.parent.renderer, ctx = pg.drawingContext;
        if (typeof line === 'object' && line.commands) {
            pdata = line.commands;
        }
        else {
            //pos = handleAlignment(p, ctx, line, x, y);
            pdata = this._getPath(line, x, y, options).commands;
        }
        ctx.beginPath();
        for (var i = 0; i < pdata.length; i += 1) {
            var cmd = pdata[i];
            if (cmd.type === 'M') {
                ctx.moveTo(cmd.x, cmd.y);
            }
            else if (cmd.type === 'L') {
                ctx.lineTo(cmd.x, cmd.y);
            }
            else if (cmd.type === 'C') {
                ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
            }
            else if (cmd.type === 'Q') {
                ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
            }
            else if (cmd.type === 'Z') {
                ctx.closePath();
            }
        }
        // only draw stroke if manually set by user
        if (pg._doStroke && pg._strokeSet) {
            ctx.stroke();
        }
        if (pg._doFill) {
            // if fill hasn't been set by user, use default-text-fill
            if (!pg._fillSet) {
                pg._setFill(_core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants._DEFAULT_TEXT_FILL);
            }
            ctx.fill();
        }
        return this;
    };
    SketchFont.prototype._textWidth = function (str, fontSize) {
        return this.font.getAdvanceWidth(str, fontSize);
    };
    SketchFont.prototype._textAscent = function (fontSize) {
        return this.font.ascender * this._scale(fontSize);
    };
    SketchFont.prototype._textDescent = function (fontSize) {
        return -this.font.descender * this._scale(fontSize);
    };
    SketchFont.prototype._scale = function (fontSize) {
        return (1 / this.font.unitsPerEm * (fontSize || this.parent.renderer._textSize));
    };
    SketchFont.prototype._handleAlignment = function (renderer, line, x, y, textWidth) {
        var fontSize = renderer._textSize;
        if (typeof textWidth === 'undefined') {
            textWidth = this._textWidth(line, fontSize);
        }
        switch (renderer._textAlign) {
            case _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CENTER:
                x -= textWidth / 2;
                break;
            case _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.RIGHT:
                x -= textWidth;
                break;
        }
        switch (renderer._textBaseline) {
            case _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.TOP:
                y += this._textAscent(fontSize);
                break;
            case _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.CENTER:
                y += this._textAscent(fontSize) / 2;
                break;
            case _core_Constanst__WEBPACK_IMPORTED_MODULE_0__.constants.BOTTOM:
                y -= this._textDescent(fontSize);
                break;
        }
        return { x: x, y: y };
    };
    return SketchFont;
}());

// path-utils
function pathToPoints(cmds, options) {
    var opts = parseOpts(options, {
        sampleFactor: 0.1,
        simplifyThreshold: 0
    });
    var len = pointAtLength(cmds, 0, 1), // total-length
    t = len / (len * opts.sampleFactor), pts = [];
    for (var i = 0; i < len; i += t) {
        pts.push(pointAtLength(cmds, i));
    }
    if (opts.simplifyThreshold) {
        /*var count = */ simplify(pts, opts.simplifyThreshold);
        //console.log('Simplify: removed ' + count + ' pts');
    }
    return pts;
}
function simplify(pts, angle) {
    angle = typeof angle === 'undefined' ? 0 : angle;
    var num = 0;
    for (var i = pts.length - 1; pts.length > 3 && i >= 0; --i) {
        if (collinear(at(pts, i - 1), at(pts, i), at(pts, i + 1), angle)) {
            // Remove the middle point
            pts.splice(i % pts.length, 1);
            num++;
        }
    }
    return num;
}
function splitPaths(cmds) {
    var paths = [];
    var current;
    for (var i = 0; i < cmds.length; i++) {
        if (cmds[i].type === 'M') {
            if (current) {
                paths.push(current);
            }
            current = [];
        }
        current.push(cmdToArr(cmds[i]));
    }
    paths.push(current);
    return paths;
}
function cmdToArr(cmd) {
    var arr = [cmd.type];
    if (cmd.type === 'M' || cmd.type === 'L') {
        // moveto or lineto
        arr.push(cmd.x, cmd.y);
    }
    else if (cmd.type === 'C') {
        arr.push(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
    }
    else if (cmd.type === 'Q') {
        arr.push(cmd.x1, cmd.y1, cmd.x, cmd.y);
    }
    // else if (cmd.type === 'Z') { /* no-op */ }
    return arr;
}
function parseOpts(options, defaults) {
    if (typeof options !== 'object') {
        options = defaults;
    }
    else {
        for (var key in defaults) {
            if (typeof options[key] === 'undefined') {
                options[key] = defaults[key];
            }
        }
    }
    return options;
}
//////////////////////// Helpers ////////////////////////////
function at(v, i) {
    var s = v.length;
    return v[i < 0 ? i % s + s : i % s];
}
function collinear(a, b, c, thresholdAngle) {
    if (!thresholdAngle) {
        return areaTriangle(a, b, c) === 0;
    }
    if (typeof collinear.tmpPoint1 === 'undefined') {
        collinear.tmpPoint1 = [];
        collinear.tmpPoint2 = [];
    }
    var ab = collinear.tmpPoint1, bc = collinear.tmpPoint2;
    ab.x = b.x - a.x;
    ab.y = b.y - a.y;
    bc.x = c.x - b.x;
    bc.y = c.y - b.y;
    var dot = ab.x * bc.x + ab.y * bc.y, magA = Math.sqrt(ab.x * ab.x + ab.y * ab.y), magB = Math.sqrt(bc.x * bc.x + bc.y * bc.y), angle = Math.acos(dot / (magA * magB));
    return angle < thresholdAngle;
}
function areaTriangle(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
}
// Portions of below code copyright 2008 Dmitry Baranovskiy (via MIT license)
function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t, t13 = Math.pow(t1, 3), t12 = Math.pow(t1, 2), t2 = t * t, t3 = t2 * t, x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x, y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y, mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x), my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y), nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x), ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y), ax = t1 * p1x + t * c1x, ay = t1 * p1y + t * c1y, cx = t1 * c2x + t * p2x, cy = t1 * c2y + t * p2y, alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
    if (mx > nx || my < ny) {
        alpha += 180;
    }
    return {
        x: x,
        y: y,
        m: { x: mx, y: my },
        n: { x: nx, y: ny },
        start: { x: ax, y: ay },
        end: { x: cx, y: cy },
        alpha: alpha
    };
}
function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
    return length == null
        ? bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y)
        : findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
}
function pointAtLength(path, length, istotal) {
    path = path2curve(path);
    var x, y, p, l, sp = '', subpaths = {}, point, len = 0;
    for (var i = 0, ii = path.length; i < ii; i++) {
        p = path[i];
        if (p[0] === 'M') {
            x = +p[1];
            y = +p[2];
        }
        else {
            l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
            if (len + l > length) {
                if (!istotal) {
                    point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                    return { x: point.x, y: point.y, alpha: point.alpha };
                }
            }
            len += l;
            x = +p[5];
            y = +p[6];
        }
        sp += p.shift() + p;
    }
    subpaths.end = sp;
    point = istotal
        ? len
        : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
    if (point.alpha) {
        point = { x: point.x, y: point.y, alpha: point.alpha };
    }
    return point;
}
function pathToAbsolute(pathArray) {
    var res = [], x = 0, y = 0, mx = 0, my = 0, start = 0;
    if (!pathArray) {
        // console.warn("Unexpected state: undefined pathArray"); // shouldn't happen
        return res;
    }
    if (pathArray[0][0] === 'M') {
        x = +pathArray[0][1];
        y = +pathArray[0][2];
        mx = x;
        my = y;
        start++;
        res[0] = ['M', x, y];
    }
    var dots, crz = pathArray.length === 3 &&
        pathArray[0][0] === 'M' &&
        pathArray[1][0].toUpperCase() === 'R' &&
        pathArray[2][0].toUpperCase() === 'Z';
    for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
        res.push((r = []));
        pa = pathArray[i];
        if (pa[0] !== String.prototype.toUpperCase.call(pa[0])) {
            r[0] = String.prototype.toUpperCase.call(pa[0]);
            switch (r[0]) {
                case 'A':
                    r[1] = pa[1];
                    r[2] = pa[2];
                    r[3] = pa[3];
                    r[4] = pa[4];
                    r[5] = pa[5];
                    r[6] = +(pa[6] + x);
                    r[7] = +(pa[7] + y);
                    break;
                case 'V':
                    r[1] = +pa[1] + y;
                    break;
                case 'H':
                    r[1] = +pa[1] + x;
                    break;
                case 'R':
                    dots = [x, y].concat(pa.slice(1));
                    for (var j = 2, jj = dots.length; j < jj; j++) {
                        dots[j] = +dots[j] + x;
                        dots[++j] = +dots[j] + y;
                    }
                    res.pop();
                    res = res.concat(catmullRom2bezier(dots, crz));
                    break;
                case 'M':
                    mx = +pa[1] + x;
                    my = +pa[2] + y;
                    break;
                default:
                    for (j = 1, jj = pa.length; j < jj; j++) {
                        r[j] = +pa[j] + (j % 2 ? x : y);
                    }
            }
        }
        else if (pa[0] === 'R') {
            dots = [x, y].concat(pa.slice(1));
            res.pop();
            res = res.concat(catmullRom2bezier(dots, crz));
            r = ['R'].concat(pa.slice(-2));
        }
        else {
            for (var k = 0, kk = pa.length; k < kk; k++) {
                r[k] = pa[k];
            }
        }
        switch (r[0]) {
            case 'Z':
                x = mx;
                y = my;
                break;
            case 'H':
                x = r[1];
                break;
            case 'V':
                y = r[1];
                break;
            case 'M':
                mx = r[r.length - 2];
                my = r[r.length - 1];
                break;
            default:
                x = r[r.length - 2];
                y = r[r.length - 1];
        }
    }
    return res;
}
function path2curve(path, path2) {
    var p = pathToAbsolute(path), p2 = path2 && pathToAbsolute(path2);
    var attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
    var attrs2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
    var pcoms1 = []; // path commands of original path p
    var pcoms2 = []; // path commands of original path p2
    var ii;
    var processPath = function (path, d, pcom) {
        var nx, ny, tq = { T: 1, Q: 1 };
        if (!path) {
            return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
        }
        if (!(path[0] in tq)) {
            d.qx = d.qy = null;
        }
        switch (path[0]) {
            case 'M':
                d.X = path[1];
                d.Y = path[2];
                break;
            case 'A':
                path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                break;
            case 'S':
                if (pcom === 'C' || pcom === 'S') {
                    nx = d.x * 2 - d.bx;
                    ny = d.y * 2 - d.by;
                }
                else {
                    nx = d.x;
                    ny = d.y;
                }
                path = ['C', nx, ny].concat(path.slice(1));
                break;
            case 'T':
                if (pcom === 'Q' || pcom === 'T') {
                    d.qx = d.x * 2 - d.qx;
                    d.qy = d.y * 2 - d.qy;
                }
                else {
                    d.qx = d.x;
                    d.qy = d.y;
                }
                path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                break;
            case 'Q':
                d.qx = path[1];
                d.qy = path[2];
                path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                break;
            case 'L':
                path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));
                break;
            case 'H':
                path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));
                break;
            case 'V':
                path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));
                break;
            case 'Z':
                path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));
                break;
        }
        return path;
    }, fixArc = function (pp, i) {
        if (pp[i].length > 7) {
            pp[i].shift();
            var pi = pp[i];
            while (pi.length) {
                pcoms1[i] = 'A';
                if (p2) {
                    pcoms2[i] = 'A';
                }
                pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
            }
            pp.splice(i, 1);
            ii = Math.max(p.length, (p2 && p2.length) || 0);
        }
    }, fixM = function (path1, path2, a1, a2, i) {
        if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {
            path2.splice(i, 0, ['M', a2.x, a2.y]);
            a1.bx = 0;
            a1.by = 0;
            a1.x = path1[i][1];
            a1.y = path1[i][2];
            ii = Math.max(p.length, (p2 && p2.length) || 0);
        }
    };
    var pfirst = ''; // temporary holder for original path command
    var pcom = ''; // holder for previous path command of original path
    ii = Math.max(p.length, (p2 && p2.length) || 0);
    for (var i = 0; i < ii; i++) {
        if (p[i]) {
            pfirst = p[i][0];
        } // save current path command
        if (pfirst !== 'C') {
            pcoms1[i] = pfirst; // Save current path command
            if (i) {
                pcom = pcoms1[i - 1];
            } // Get previous path command pcom
        }
        p[i] = processPath(p[i], attrs, pcom);
        if (pcoms1[i] !== 'A' && pfirst === 'C') {
            pcoms1[i] = 'C';
        }
        fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1
        if (p2) {
            // the same procedures is done to p2
            if (p2[i]) {
                pfirst = p2[i][0];
            }
            if (pfirst !== 'C') {
                pcoms2[i] = pfirst;
                if (i) {
                    pcom = pcoms2[i - 1];
                }
            }
            p2[i] = processPath(p2[i], attrs2, pcom);
            if (pcoms2[i] !== 'A' && pfirst === 'C') {
                pcoms2[i] = 'C';
            }
            fixArc(p2, i);
        }
        fixM(p, p2, attrs, attrs2, i);
        fixM(p2, p, attrs2, attrs, i);
        var seg = p[i], seg2 = p2 && p2[i], seglen = seg.length, seg2len = p2 && seg2.length;
        attrs.x = seg[seglen - 2];
        attrs.y = seg[seglen - 1];
        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
        attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
        attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
        attrs2.x = p2 && seg2[seg2len - 2];
        attrs2.y = p2 && seg2[seg2len - 1];
    }
    return p2 ? [p, p2] : p;
}
function a2c(x1, y1, rx, ry, angle, lac, sweep_flag, x2, y2, recursive) {
    // for more information of where this Math came from visit:
    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
    var PI = Math.PI, _120 = PI * 120 / 180, f1, f2, cx, cy, rad = PI / 180 * (+angle || 0), res = [], xy, rotate = function (x, y, rad) {
        var X = x * Math.cos(rad) - y * Math.sin(rad), Y = x * Math.sin(rad) + y * Math.cos(rad);
        return { x: X, y: Y };
    };
    if (!recursive) {
        xy = rotate(x1, y1, -rad);
        x1 = xy.x;
        y1 = xy.y;
        xy = rotate(x2, y2, -rad);
        x2 = xy.x;
        y2 = xy.y;
        var x = (x1 - x2) / 2, y = (y1 - y2) / 2, h = x * x / (rx * rx) + y * y / (ry * ry);
        if (h > 1) {
            h = Math.sqrt(h);
            rx = h * rx;
            ry = h * ry;
        }
        var rx2 = rx * rx, ry2 = ry * ry;
        var k = (lac === sweep_flag ? -1 : 1) *
            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
        cx = k * rx * y / ry + (x1 + x2) / 2;
        cy = k * -ry * x / rx + (y1 + y2) / 2;
        f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
        f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
        f1 = x1 < cx ? PI - f1 : f1;
        f2 = x2 < cx ? PI - f2 : f2;
        if (f1 < 0) {
            f1 = PI * 2 + f1;
        }
        if (f2 < 0) {
            f2 = PI * 2 + f2;
        }
        if (sweep_flag && f1 > f2) {
            f1 = f1 - PI * 2;
        }
        if (!sweep_flag && f2 > f1) {
            f2 = f2 - PI * 2;
        }
    }
    else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
    }
    var df = f2 - f1;
    if (Math.abs(df) > _120) {
        var f2old = f2, x2old = x2, y2old = y2;
        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
        x2 = cx + rx * Math.cos(f2);
        y2 = cy + ry * Math.sin(f2);
        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
            f2,
            f2old,
            cx,
            cy
        ]);
    }
    df = f2 - f1;
    var c1 = Math.cos(f1), s1 = Math.sin(f1), c2 = Math.cos(f2), s2 = Math.sin(f2), t = Math.tan(df / 4), hx = 4 / 3 * rx * t, hy = 4 / 3 * ry * t, m1 = [x1, y1], m2 = [x1 + hx * s1, y1 - hy * c1], m3 = [x2 + hx * s2, y2 - hy * c2], m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];
    if (recursive) {
        return [m2, m3, m4].concat(res);
    }
    else {
        res = [m2, m3, m4]
            .concat(res)
            .join()
            .split(',');
        var newres = [];
        for (var i = 0, ii = res.length; i < ii; i++) {
            newres[i] =
                i % 2
                    ? rotate(res[i - 1], res[i], rad).y
                    : rotate(res[i], res[i + 1], rad).x;
        }
        return newres;
    }
}
// http://schepers.cc/getting-to-the-point
function catmullRom2bezier(crp, z) {
    var d = [];
    for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
        var p = [
            {
                x: +crp[i - 2],
                y: +crp[i - 1]
            },
            {
                x: +crp[i],
                y: +crp[i + 1]
            },
            {
                x: +crp[i + 2],
                y: +crp[i + 3]
            },
            {
                x: +crp[i + 4],
                y: +crp[i + 5]
            }
        ];
        if (z) {
            if (!i) {
                p[0] = {
                    x: +crp[iLen - 2],
                    y: +crp[iLen - 1]
                };
            }
            else if (iLen - 4 === i) {
                p[3] = {
                    x: +crp[0],
                    y: +crp[1]
                };
            }
            else if (iLen - 2 === i) {
                p[2] = {
                    x: +crp[0],
                    y: +crp[1]
                };
                p[3] = {
                    x: +crp[2],
                    y: +crp[3]
                };
            }
        }
        else {
            if (iLen - 4 === i) {
                p[3] = p[2];
            }
            else if (!i) {
                p[0] = {
                    x: +crp[i],
                    y: +crp[i + 1]
                };
            }
        }
        d.push([
            'C',
            (-p[0].x + 6 * p[1].x + p[2].x) / 6,
            (-p[0].y + 6 * p[1].y + p[2].y) / 6,
            (p[1].x + 6 * p[2].x - p[3].x) / 6,
            (p[1].y + 6 * p[2].y - p[3].y) / 6,
            p[2].x,
            p[2].y
        ]);
    }
    return d;
}
function l2c(x1, y1, x2, y2) {
    return [x1, y1, x2, y2, x2, y2];
}
function q2c(x1, y1, ax, ay, x2, y2) {
    var _13 = 1 / 3, _23 = 2 / 3;
    return [
        _13 * x1 + _23 * ax,
        _13 * y1 + _23 * ay,
        _13 * x2 + _23 * ax,
        _13 * y2 + _23 * ay,
        x2,
        y2
    ];
}
function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
    if (z == null) {
        z = 1;
    }
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    var z2 = z / 2;
    var n = 12;
    var Tvalues = [
        -0.1252,
        0.1252,
        -0.3678,
        0.3678,
        -0.5873,
        0.5873,
        -0.7699,
        0.7699,
        -0.9041,
        0.9041,
        -0.9816,
        0.9816
    ];
    var sum = 0;
    var Cvalues = [
        0.2491,
        0.2491,
        0.2335,
        0.2335,
        0.2032,
        0.2032,
        0.1601,
        0.1601,
        0.1069,
        0.1069,
        0.0472,
        0.0472
    ];
    for (var i = 0; i < n; i++) {
        var ct = z2 * Tvalues[i] + z2, xbase = base3(ct, x1, x2, x3, x4), ybase = base3(ct, y1, y2, y3, y4), comb = xbase * xbase + ybase * ybase;
        sum += Cvalues[i] * Math.sqrt(comb);
    }
    return z2 * sum;
}
function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
    if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
        return;
    }
    var t = 1, step = t / 2, t2 = t - step, l, e = 0.01;
    l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
    while (Math.abs(l - ll) > e) {
        step /= 2;
        t2 += (l < ll ? 1 : -1) * step;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
    }
    return t2;
}
function base3(t, p1, p2, p3, p4) {
    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4, t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t * t2 - 3 * p1 + 3 * p2;
}
function cacheKey() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var hash = '';
    for (var i = arguments.length - 1; i >= 0; --i) {
        var v = arguments[i];
        hash += v === Object(v) ? JSON.stringify(v) : v;
    }
    return hash;
}


/***/ }),

/***/ "./src/drawing/text/HotkeyPrefix.ts":
/*!******************************************!*\
  !*** ./src/drawing/text/HotkeyPrefix.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HotkeyPrefix": () => (/* binding */ HotkeyPrefix)
/* harmony export */ });
var HotkeyPrefix;
(function (HotkeyPrefix) {
    HotkeyPrefix[HotkeyPrefix["None"] = 0] = "None";
    HotkeyPrefix[HotkeyPrefix["Show"] = 1] = "Show";
    HotkeyPrefix[HotkeyPrefix["Hide"] = 2] = "Hide";
})(HotkeyPrefix || (HotkeyPrefix = {}));


/***/ }),

/***/ "./src/drawing/text/index.ts":
/*!***********************************!*\
  !*** ./src/drawing/text/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HotkeyPrefix": () => (/* reexport safe */ _HotkeyPrefix__WEBPACK_IMPORTED_MODULE_0__.HotkeyPrefix)
/* harmony export */ });
/* harmony import */ var _HotkeyPrefix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HotkeyPrefix */ "./src/drawing/text/HotkeyPrefix.ts");



/***/ }),

/***/ "./src/exports.ts":
/*!************************!*\
  !*** ./src/exports.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./src/index.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_1__);


var globalObject = undefined;
if (_tuval_core__WEBPACK_IMPORTED_MODULE_1__.is.workerContext()) {
    globalObject = self;
}
else {
    globalObject = window;
}
globalObject['tuval$graphics'] = _index__WEBPACK_IMPORTED_MODULE_0__;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AngleModes": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.AngleModes),
/* harmony export */   "ArcModes": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.ArcModes),
/* harmony export */   "CORNER": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.CORNER),
/* harmony export */   "CORNERS": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.CORNERS),
/* harmony export */   "CanvasGraphics": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.CanvasGraphics),
/* harmony export */   "CommandGraphics": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.CommandGraphics),
/* harmony export */   "CompositingMode": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.CompositingMode),
/* harmony export */   "DEG_TO_RAD": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.DEG_TO_RAD),
/* harmony export */   "EllipseModes": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.EllipseModes),
/* harmony export */   "Graphics": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.Graphics),
/* harmony export */   "GraphicsBase": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.GraphicsBase),
/* harmony export */   "HALF_PI": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.HALF_PI),
/* harmony export */   "OffScreenGraphics": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.OffScreenGraphics),
/* harmony export */   "PI": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.PI),
/* harmony export */   "QUARTER_PI": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.QUARTER_PI),
/* harmony export */   "RAD_TO_DEG": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.RAD_TO_DEG),
/* harmony export */   "RectangleModes": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.RectangleModes),
/* harmony export */   "TWO_PI": () => (/* reexport safe */ _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__.TWO_PI),
/* harmony export */   "CURVE_MAX_TERMS": () => (/* reexport safe */ _drawing_drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_1__.CURVE_MAX_TERMS),
/* harmony export */   "CURVE_MIN_TERMS": () => (/* reexport safe */ _drawing_drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_1__.CURVE_MIN_TERMS),
/* harmony export */   "CurveType": () => (/* reexport safe */ _drawing_drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_1__.CurveType),
/* harmony export */   "GraphicsPath": () => (/* reexport safe */ _drawing_drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_1__.GraphicsPath),
/* harmony export */   "Region": () => (/* reexport safe */ _drawing_Region__WEBPACK_IMPORTED_MODULE_2__.Region),
/* harmony export */   "RegionClipType": () => (/* reexport safe */ _drawing_Region__WEBPACK_IMPORTED_MODULE_2__.RegionClipType),
/* harmony export */   "RegionType": () => (/* reexport safe */ _drawing_Region__WEBPACK_IMPORTED_MODULE_2__.RegionType),
/* harmony export */   "Pen": () => (/* reexport safe */ _drawing_Pen__WEBPACK_IMPORTED_MODULE_3__.Pen),
/* harmony export */   "Brush": () => (/* reexport safe */ _drawing_Brush__WEBPACK_IMPORTED_MODULE_4__.Brush),
/* harmony export */   "Font": () => (/* reexport safe */ _drawing_Font__WEBPACK_IMPORTED_MODULE_5__.Font),
/* harmony export */   "Icon": () => (/* reexport safe */ _drawing_Icon__WEBPACK_IMPORTED_MODULE_6__.Icon),
/* harmony export */   "Bitmap": () => (/* reexport safe */ _drawing_Bitmap__WEBPACK_IMPORTED_MODULE_7__.Bitmap),
/* harmony export */   "GetThumbnailImageAbort": () => (/* reexport safe */ _drawing_Image__WEBPACK_IMPORTED_MODULE_8__.GetThumbnailImageAbort),
/* harmony export */   "Image": () => (/* reexport safe */ _drawing_Image__WEBPACK_IMPORTED_MODULE_8__.Image),
/* harmony export */   "SolidBrush": () => (/* reexport safe */ _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_9__.SolidBrush),
/* harmony export */   "Brushes": () => (/* reexport safe */ _drawing_Brushes__WEBPACK_IMPORTED_MODULE_10__.Brushes),
/* harmony export */   "Pens": () => (/* reexport safe */ _drawing_Pens__WEBPACK_IMPORTED_MODULE_11__.Pens),
/* harmony export */   "FillMode": () => (/* reexport safe */ _drawing_drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__.FillMode),
/* harmony export */   "PrintDocument": () => (/* reexport safe */ _drawing_printing_PrintDocument__WEBPACK_IMPORTED_MODULE_13__.PrintDocument),
/* harmony export */   "PageSettings": () => (/* reexport safe */ _drawing_printing_PageSettings__WEBPACK_IMPORTED_MODULE_14__.PageSettings),
/* harmony export */   "PrintPageEventArgs": () => (/* reexport safe */ _drawing_printing_PrintPageEventArgs__WEBPACK_IMPORTED_MODULE_15__.PrintPageEventArgs),
/* harmony export */   "PrintPageEventHandler": () => (/* reexport safe */ _drawing_printing_PrintPageEventHandler__WEBPACK_IMPORTED_MODULE_16__.PrintPageEventHandler),
/* harmony export */   "HitTester": () => (/* reexport safe */ _drawing_drawing2D_HitTester__WEBPACK_IMPORTED_MODULE_17__.HitTester),
/* harmony export */   "SketchBatch": () => (/* reexport safe */ _drawing_sketch_index__WEBPACK_IMPORTED_MODULE_18__.SketchBatch),
/* harmony export */   "SketchGraphics": () => (/* reexport safe */ _drawing_sketch_index__WEBPACK_IMPORTED_MODULE_18__.SketchGraphics),
/* harmony export */   "GeomUtilities": () => (/* reexport safe */ _drawing_GeomUtilities__WEBPACK_IMPORTED_MODULE_19__.GeomUtilities),
/* harmony export */   "GraphicTypes": () => (/* reexport safe */ _GDITypes__WEBPACK_IMPORTED_MODULE_20__.GraphicTypes),
/* harmony export */   "LineJoin": () => (/* reexport safe */ _drawing_drawing2D_LineJoin__WEBPACK_IMPORTED_MODULE_21__.LineJoin),
/* harmony export */   "LineCap": () => (/* reexport safe */ _drawing_drawing2D_LineCap__WEBPACK_IMPORTED_MODULE_22__.LineCap),
/* harmony export */   "DashStyle": () => (/* reexport safe */ _drawing_drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_23__.DashStyle),
/* harmony export */   "Matrix": () => (/* reexport safe */ _drawing_drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_24__.Matrix),
/* harmony export */   "MatrixOrder": () => (/* reexport safe */ _drawing_drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_24__.MatrixOrder),
/* harmony export */   "ImageList": () => (/* reexport safe */ _drawing_ImageList__WEBPACK_IMPORTED_MODULE_25__.ImageList),
/* harmony export */   "ColorMatrix": () => (/* reexport safe */ _drawing_ColorMatrix__WEBPACK_IMPORTED_MODULE_26__.ColorMatrix),
/* harmony export */   "GraphicsState": () => (/* reexport safe */ _drawing_drawing2D_GraphicsState__WEBPACK_IMPORTED_MODULE_27__.GraphicsState),
/* harmony export */   "CompositingQuality": () => (/* reexport safe */ _drawing_drawing2D_CompositingQuality__WEBPACK_IMPORTED_MODULE_28__.CompositingQuality),
/* harmony export */   "InterpolationMode": () => (/* reexport safe */ _drawing_InterpolationMode__WEBPACK_IMPORTED_MODULE_29__.InterpolationMode),
/* harmony export */   "SmoothingMode": () => (/* reexport safe */ _drawing_SmoothingMode__WEBPACK_IMPORTED_MODULE_30__.SmoothingMode),
/* harmony export */   "TextRenderingHint": () => (/* reexport safe */ _drawing_SmoothingMode__WEBPACK_IMPORTED_MODULE_30__.TextRenderingHint),
/* harmony export */   "PathGradientBrush": () => (/* reexport safe */ _drawing_drawing2D_PathGradientBrush__WEBPACK_IMPORTED_MODULE_31__.PathGradientBrush),
/* harmony export */   "HatchBrush": () => (/* reexport safe */ _drawing_drawing2D_HatchBrush__WEBPACK_IMPORTED_MODULE_32__.HatchBrush),
/* harmony export */   "HatchStyle": () => (/* reexport safe */ _drawing_drawing2D_HatchStyle__WEBPACK_IMPORTED_MODULE_33__.HatchStyle),
/* harmony export */   "LinearGradientBrush": () => (/* reexport safe */ _drawing_drawing2D_LinearGradientBrush__WEBPACK_IMPORTED_MODULE_34__.LinearGradientBrush),
/* harmony export */   "LinearGradientMode": () => (/* reexport safe */ _drawing_drawing2D_LinearGradientMode__WEBPACK_IMPORTED_MODULE_35__.LinearGradientMode),
/* harmony export */   "RadialGradientBrush": () => (/* reexport safe */ _drawing_drawing2D_RadialGradientBrush__WEBPACK_IMPORTED_MODULE_36__.RadialGradientBrush),
/* harmony export */   "ColorBlend": () => (/* reexport safe */ _drawing_drawing2D_ColorBlend__WEBPACK_IMPORTED_MODULE_37__.ColorBlend),
/* harmony export */   "Blend": () => (/* reexport safe */ _drawing_drawing2D_Blend__WEBPACK_IMPORTED_MODULE_38__.Blend),
/* harmony export */   "TextureBrush": () => (/* reexport safe */ _drawing_TextureBrush__WEBPACK_IMPORTED_MODULE_39__.TextureBrush),
/* harmony export */   "Shadow": () => (/* reexport safe */ _drawing_Shadow__WEBPACK_IMPORTED_MODULE_40__.Shadow),
/* harmony export */   "DashCap": () => (/* reexport safe */ _drawing_DashCap__WEBPACK_IMPORTED_MODULE_41__.DashCap),
/* harmony export */   "PenAlignment": () => (/* reexport safe */ _drawing_PenAlignment__WEBPACK_IMPORTED_MODULE_42__.PenAlignment),
/* harmony export */   "StringFormat": () => (/* reexport safe */ _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_43__.StringFormat),
/* harmony export */   "FontStyle": () => (/* reexport safe */ _drawing_FontStyle__WEBPACK_IMPORTED_MODULE_44__.FontStyle),
/* harmony export */   "StringTrimming": () => (/* reexport safe */ _drawing_StringTrimming__WEBPACK_IMPORTED_MODULE_45__.StringTrimming),
/* harmony export */   "FontFamily": () => (/* reexport safe */ _drawing_FontFamily__WEBPACK_IMPORTED_MODULE_46__.FontFamily),
/* harmony export */   "StringFormatFlags": () => (/* reexport safe */ _drawing_StringFormatFlags__WEBPACK_IMPORTED_MODULE_47__.StringFormatFlags),
/* harmony export */   "StringAlignment": () => (/* reexport safe */ _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_48__.StringAlignment),
/* harmony export */   "GraphicsUnit": () => (/* reexport safe */ _drawing_GraphicsUnit__WEBPACK_IMPORTED_MODULE_49__.GraphicsUnit),
/* harmony export */   "SystemColors": () => (/* reexport safe */ _drawing_SystemColors__WEBPACK_IMPORTED_MODULE_50__.SystemColors),
/* harmony export */   "KnownColor": () => (/* reexport safe */ _drawing_KnownColor__WEBPACK_IMPORTED_MODULE_51__.KnownColor),
/* harmony export */   "SystemPens": () => (/* reexport safe */ _drawing_SystemPens__WEBPACK_IMPORTED_MODULE_52__.SystemPens),
/* harmony export */   "SystemBrushes": () => (/* reexport safe */ _drawing_SystemBrushes__WEBPACK_IMPORTED_MODULE_53__.SystemBrushes),
/* harmony export */   "PrintRange": () => (/* reexport safe */ _drawing_printing_PrintRange__WEBPACK_IMPORTED_MODULE_54__.PrintRange),
/* harmony export */   "HotkeyPrefix": () => (/* reexport safe */ _drawing_text__WEBPACK_IMPORTED_MODULE_55__.HotkeyPrefix),
/* harmony export */   "Container": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.Container),
/* harmony export */   "DisplayObject": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.DisplayObject),
/* harmony export */   "DisplayProps": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.DisplayProps),
/* harmony export */   "Ease": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.Ease),
/* harmony export */   "Matrix2D": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.Matrix2D),
/* harmony export */   "SceneBitmap": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.SceneBitmap),
/* harmony export */   "Shape": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.Shape),
/* harmony export */   "Stage": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.Stage),
/* harmony export */   "Text": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.Text),
/* harmony export */   "Tween": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.Tween),
/* harmony export */   "VGraphics": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.VGraphics),
/* harmony export */   "VideoBuffer": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.VideoBuffer),
/* harmony export */   "createCanvas": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.createCanvas),
/* harmony export */   "uid": () => (/* reexport safe */ _drawing_scene__WEBPACK_IMPORTED_MODULE_56__.uid),
/* harmony export */   "RotateFlipType": () => (/* reexport safe */ _drawing_RotateFlipType__WEBPACK_IMPORTED_MODULE_57__.RotateFlipType),
/* harmony export */   "ContentAlignment": () => (/* reexport safe */ _drawing_ContentAlignment__WEBPACK_IMPORTED_MODULE_58__.ContentAlignment),
/* harmony export */   "ButtonComponent": () => (/* reexport safe */ _UI__WEBPACK_IMPORTED_MODULE_59__.ButtonComponent),
/* harmony export */   "CheckboxComponent": () => (/* reexport safe */ _UI__WEBPACK_IMPORTED_MODULE_59__.CheckboxComponent),
/* harmony export */   "DraggablePoint": () => (/* reexport safe */ _UI__WEBPACK_IMPORTED_MODULE_59__.DraggablePoint),
/* harmony export */   "GUIComponent": () => (/* reexport safe */ _UI__WEBPACK_IMPORTED_MODULE_59__.GUIComponent),
/* harmony export */   "ImageComponent": () => (/* reexport safe */ _UI__WEBPACK_IMPORTED_MODULE_59__.ImageComponent),
/* harmony export */   "LabelComponent": () => (/* reexport safe */ _UI__WEBPACK_IMPORTED_MODULE_59__.LabelComponent),
/* harmony export */   "RadioButtonComponent": () => (/* reexport safe */ _UI__WEBPACK_IMPORTED_MODULE_59__.RadioButtonComponent),
/* harmony export */   "SliderComponent": () => (/* reexport safe */ _UI__WEBPACK_IMPORTED_MODULE_59__.SliderComponent),
/* harmony export */   "ToolbarComponent": () => (/* reexport safe */ _UI__WEBPACK_IMPORTED_MODULE_59__.ToolbarComponent),
/* harmony export */   "createCanvasElement": () => (/* reexport safe */ _drawing_createCanvasElement__WEBPACK_IMPORTED_MODULE_60__.createCanvasElement),
/* harmony export */   "get2DCanvasContext": () => (/* reexport safe */ _drawing_createCanvasElement__WEBPACK_IMPORTED_MODULE_60__.get2DCanvasContext),
/* harmony export */   "Easing": () => (/* reexport safe */ _TTween__WEBPACK_IMPORTED_MODULE_62__.Easing),
/* harmony export */   "TWEEN": () => (/* reexport safe */ _TTween__WEBPACK_IMPORTED_MODULE_62__.TWEEN),
/* harmony export */   "SDLModule": () => (/* reexport safe */ _Modules__WEBPACK_IMPORTED_MODULE_63__.SDLModule),
/* harmony export */   "SDL_Palette": () => (/* reexport safe */ _Modules__WEBPACK_IMPORTED_MODULE_63__.SDL_Palette),
/* harmony export */   "SDL_PixelFormat": () => (/* reexport safe */ _Modules__WEBPACK_IMPORTED_MODULE_63__.SDL_PixelFormat),
/* harmony export */   "SDL_Surface": () => (/* reexport safe */ _Modules__WEBPACK_IMPORTED_MODULE_63__.SDL_Surface),
/* harmony export */   "GuiConsole": () => (/* reexport safe */ _GUIConsole__WEBPACK_IMPORTED_MODULE_64__.GuiConsole),
/* harmony export */   "PixelFormat": () => (/* reexport safe */ _drawing_imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_65__.PixelFormat),
/* harmony export */   "SystemFonts": () => (/* reexport safe */ _drawing_SystemFonts__WEBPACK_IMPORTED_MODULE_66__.SystemFonts),
/* harmony export */   "TDIModule": () => (/* binding */ TDIModule)
/* harmony export */ });
/* harmony import */ var _drawing_Graphics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawing/Graphics */ "./src/drawing/Graphics.ts");
/* harmony import */ var _drawing_drawing2D_GraphicsPath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawing/drawing2D/GraphicsPath */ "./src/drawing/drawing2D/GraphicsPath.ts");
/* harmony import */ var _drawing_Region__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drawing/Region */ "./src/drawing/Region.ts");
/* harmony import */ var _drawing_Pen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drawing/Pen */ "./src/drawing/Pen.ts");
/* harmony import */ var _drawing_Brush__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drawing/Brush */ "./src/drawing/Brush.ts");
/* harmony import */ var _drawing_Font__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./drawing/Font */ "./src/drawing/Font.ts");
/* harmony import */ var _drawing_Icon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./drawing/Icon */ "./src/drawing/Icon.ts");
/* harmony import */ var _drawing_Bitmap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./drawing/Bitmap */ "./src/drawing/Bitmap.ts");
/* harmony import */ var _drawing_Image__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./drawing/Image */ "./src/drawing/Image.ts");
/* harmony import */ var _drawing_SolidBrush__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./drawing/SolidBrush */ "./src/drawing/SolidBrush.ts");
/* harmony import */ var _drawing_Brushes__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./drawing/Brushes */ "./src/drawing/Brushes.ts");
/* harmony import */ var _drawing_Pens__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./drawing/Pens */ "./src/drawing/Pens.ts");
/* harmony import */ var _drawing_drawing2D_FillMode__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./drawing/drawing2D/FillMode */ "./src/drawing/drawing2D/FillMode.ts");
/* harmony import */ var _drawing_printing_PrintDocument__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./drawing/printing/PrintDocument */ "./src/drawing/printing/PrintDocument.ts");
/* harmony import */ var _drawing_printing_PageSettings__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./drawing/printing/PageSettings */ "./src/drawing/printing/PageSettings.ts");
/* harmony import */ var _drawing_printing_PrintPageEventArgs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./drawing/printing/PrintPageEventArgs */ "./src/drawing/printing/PrintPageEventArgs.ts");
/* harmony import */ var _drawing_printing_PrintPageEventHandler__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./drawing/printing/PrintPageEventHandler */ "./src/drawing/printing/PrintPageEventHandler.ts");
/* harmony import */ var _drawing_drawing2D_HitTester__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./drawing/drawing2D/HitTester */ "./src/drawing/drawing2D/HitTester.ts");
/* harmony import */ var _drawing_sketch_index__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./drawing/sketch/index */ "./src/drawing/sketch/index.ts");
/* harmony import */ var _drawing_GeomUtilities__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./drawing/GeomUtilities */ "./src/drawing/GeomUtilities.ts");
/* harmony import */ var _GDITypes__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./GDITypes */ "./src/GDITypes.ts");
/* harmony import */ var _drawing_drawing2D_LineJoin__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./drawing/drawing2D/LineJoin */ "./src/drawing/drawing2D/LineJoin.ts");
/* harmony import */ var _drawing_drawing2D_LineCap__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./drawing/drawing2D/LineCap */ "./src/drawing/drawing2D/LineCap.ts");
/* harmony import */ var _drawing_drawing2D_DashStyle__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./drawing/drawing2D/DashStyle */ "./src/drawing/drawing2D/DashStyle.ts");
/* harmony import */ var _drawing_drawing2D_Matrix__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./drawing/drawing2D/Matrix */ "./src/drawing/drawing2D/Matrix.ts");
/* harmony import */ var _drawing_ImageList__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./drawing/ImageList */ "./src/drawing/ImageList.ts");
/* harmony import */ var _drawing_ColorMatrix__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./drawing/ColorMatrix */ "./src/drawing/ColorMatrix.ts");
/* harmony import */ var _drawing_drawing2D_GraphicsState__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./drawing/drawing2D/GraphicsState */ "./src/drawing/drawing2D/GraphicsState.ts");
/* harmony import */ var _drawing_drawing2D_CompositingQuality__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./drawing/drawing2D/CompositingQuality */ "./src/drawing/drawing2D/CompositingQuality.ts");
/* harmony import */ var _drawing_InterpolationMode__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./drawing/InterpolationMode */ "./src/drawing/InterpolationMode.ts");
/* harmony import */ var _drawing_SmoothingMode__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./drawing/SmoothingMode */ "./src/drawing/SmoothingMode.ts");
/* harmony import */ var _drawing_drawing2D_PathGradientBrush__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./drawing/drawing2D/PathGradientBrush */ "./src/drawing/drawing2D/PathGradientBrush.ts");
/* harmony import */ var _drawing_drawing2D_HatchBrush__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./drawing/drawing2D/HatchBrush */ "./src/drawing/drawing2D/HatchBrush.ts");
/* harmony import */ var _drawing_drawing2D_HatchStyle__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./drawing/drawing2D/HatchStyle */ "./src/drawing/drawing2D/HatchStyle.ts");
/* harmony import */ var _drawing_drawing2D_LinearGradientBrush__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./drawing/drawing2D/LinearGradientBrush */ "./src/drawing/drawing2D/LinearGradientBrush.ts");
/* harmony import */ var _drawing_drawing2D_LinearGradientMode__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./drawing/drawing2D/LinearGradientMode */ "./src/drawing/drawing2D/LinearGradientMode.ts");
/* harmony import */ var _drawing_drawing2D_RadialGradientBrush__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./drawing/drawing2D/RadialGradientBrush */ "./src/drawing/drawing2D/RadialGradientBrush.ts");
/* harmony import */ var _drawing_drawing2D_ColorBlend__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./drawing/drawing2D/ColorBlend */ "./src/drawing/drawing2D/ColorBlend.ts");
/* harmony import */ var _drawing_drawing2D_Blend__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./drawing/drawing2D/Blend */ "./src/drawing/drawing2D/Blend.ts");
/* harmony import */ var _drawing_TextureBrush__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./drawing/TextureBrush */ "./src/drawing/TextureBrush.ts");
/* harmony import */ var _drawing_Shadow__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./drawing/Shadow */ "./src/drawing/Shadow.ts");
/* harmony import */ var _drawing_DashCap__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./drawing/DashCap */ "./src/drawing/DashCap.ts");
/* harmony import */ var _drawing_PenAlignment__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./drawing/PenAlignment */ "./src/drawing/PenAlignment.ts");
/* harmony import */ var _drawing_StringFormat__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./drawing/StringFormat */ "./src/drawing/StringFormat.ts");
/* harmony import */ var _drawing_FontStyle__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./drawing/FontStyle */ "./src/drawing/FontStyle.ts");
/* harmony import */ var _drawing_StringTrimming__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./drawing/StringTrimming */ "./src/drawing/StringTrimming.ts");
/* harmony import */ var _drawing_FontFamily__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./drawing/FontFamily */ "./src/drawing/FontFamily.ts");
/* harmony import */ var _drawing_StringFormatFlags__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./drawing/StringFormatFlags */ "./src/drawing/StringFormatFlags.ts");
/* harmony import */ var _drawing_StringAlignment__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./drawing/StringAlignment */ "./src/drawing/StringAlignment.ts");
/* harmony import */ var _drawing_GraphicsUnit__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./drawing/GraphicsUnit */ "./src/drawing/GraphicsUnit.ts");
/* harmony import */ var _drawing_SystemColors__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./drawing/SystemColors */ "./src/drawing/SystemColors.ts");
/* harmony import */ var _drawing_KnownColor__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./drawing/KnownColor */ "./src/drawing/KnownColor.ts");
/* harmony import */ var _drawing_SystemPens__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./drawing/SystemPens */ "./src/drawing/SystemPens.ts");
/* harmony import */ var _drawing_SystemBrushes__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./drawing/SystemBrushes */ "./src/drawing/SystemBrushes.ts");
/* harmony import */ var _drawing_printing_PrintRange__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./drawing/printing/PrintRange */ "./src/drawing/printing/PrintRange.ts");
/* harmony import */ var _drawing_text__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./drawing/text */ "./src/drawing/text/index.ts");
/* harmony import */ var _drawing_scene__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./drawing/scene */ "./src/drawing/scene/index.ts");
/* harmony import */ var _drawing_RotateFlipType__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./drawing/RotateFlipType */ "./src/drawing/RotateFlipType.ts");
/* harmony import */ var _drawing_ContentAlignment__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./drawing/ContentAlignment */ "./src/drawing/ContentAlignment.ts");
/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./UI */ "./src/UI/index.ts");
/* harmony import */ var _drawing_createCanvasElement__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./drawing/createCanvasElement */ "./src/drawing/createCanvasElement.ts");
/* harmony import */ var _services_IMouseEventService__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./services/IMouseEventService */ "./src/services/IMouseEventService.ts");
/* harmony import */ var _TTween__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./TTween */ "./src/TTween.ts");
/* harmony import */ var _Modules__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./Modules */ "./src/Modules/index.ts");
/* harmony import */ var _GUIConsole__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./GUIConsole */ "./src/GUIConsole/index.ts");
/* harmony import */ var _drawing_imaging_PixelFormat__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./drawing/imaging/PixelFormat */ "./src/drawing/imaging/PixelFormat.ts");
/* harmony import */ var _drawing_SystemFonts__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./drawing/SystemFonts */ "./src/drawing/SystemFonts.ts");
/* harmony import */ var _exports__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./exports */ "./src/exports.ts");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! @tuval/core */ "@tuval/core");
/* harmony import */ var _tuval_core__WEBPACK_IMPORTED_MODULE_68___default = /*#__PURE__*/__webpack_require__.n(_tuval_core__WEBPACK_IMPORTED_MODULE_68__);

//import './drawing/GraphicsSetting';
//import './drawing/Graphics2D';
//import './drawing/GraphicsAnimate';
//import './drawing/GraphicsText';
































//export * from './drawing/drawing2D/PixelOffsetMode';
//export * from './drawing/drawing2D/WrapMode';













//export * from './drawing/drawing2D/LineCap';
//export * from './drawing/drawing2D/LineJoin';

























//import './test';


var TDIModule = {
    /* __init__: ['eventBus',
        'global',
        'mouse',
        'input',
        'keyboardPP',
        'tickerPP',
        'timerPP',
        'routerPP'
    ], */
    Bitmap: ['value', _drawing_Bitmap__WEBPACK_IMPORTED_MODULE_7__.Bitmap]
};
_tuval_core__WEBPACK_IMPORTED_MODULE_68__.Context.Current.addModules([TDIModule]);


/***/ }),

/***/ "./src/services/IMouseEventService.ts":
/*!********************************************!*\
  !*** ./src/services/IMouseEventService.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "@tuval/cg":
/*!****************************!*\
  !*** external "@tuval/cg" ***!
  \****************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__tuval_cg__;

/***/ }),

/***/ "@tuval/core":
/*!******************************!*\
  !*** external "@tuval/core" ***!
  \******************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE__tuval_core__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*******************************!*\
  !*** ./src/tuval-graphics.ts ***!
  \*******************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AngleModes": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.AngleModes),
/* harmony export */   "ArcModes": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ArcModes),
/* harmony export */   "Bitmap": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Bitmap),
/* harmony export */   "Blend": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Blend),
/* harmony export */   "Brush": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Brush),
/* harmony export */   "Brushes": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Brushes),
/* harmony export */   "ButtonComponent": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ButtonComponent),
/* harmony export */   "CORNER": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.CORNER),
/* harmony export */   "CORNERS": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.CORNERS),
/* harmony export */   "CURVE_MAX_TERMS": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.CURVE_MAX_TERMS),
/* harmony export */   "CURVE_MIN_TERMS": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.CURVE_MIN_TERMS),
/* harmony export */   "CanvasGraphics": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.CanvasGraphics),
/* harmony export */   "CheckboxComponent": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.CheckboxComponent),
/* harmony export */   "ColorBlend": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ColorBlend),
/* harmony export */   "ColorMatrix": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ColorMatrix),
/* harmony export */   "CommandGraphics": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.CommandGraphics),
/* harmony export */   "CompositingMode": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.CompositingMode),
/* harmony export */   "CompositingQuality": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.CompositingQuality),
/* harmony export */   "Container": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Container),
/* harmony export */   "ContentAlignment": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ContentAlignment),
/* harmony export */   "CurveType": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.CurveType),
/* harmony export */   "DEG_TO_RAD": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.DEG_TO_RAD),
/* harmony export */   "DashCap": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.DashCap),
/* harmony export */   "DashStyle": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.DashStyle),
/* harmony export */   "DisplayObject": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.DisplayObject),
/* harmony export */   "DisplayProps": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.DisplayProps),
/* harmony export */   "DraggablePoint": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.DraggablePoint),
/* harmony export */   "Ease": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Ease),
/* harmony export */   "Easing": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Easing),
/* harmony export */   "EllipseModes": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.EllipseModes),
/* harmony export */   "FillMode": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.FillMode),
/* harmony export */   "Font": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Font),
/* harmony export */   "FontFamily": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.FontFamily),
/* harmony export */   "FontStyle": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.FontStyle),
/* harmony export */   "GUIComponent": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.GUIComponent),
/* harmony export */   "GeomUtilities": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.GeomUtilities),
/* harmony export */   "GetThumbnailImageAbort": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.GetThumbnailImageAbort),
/* harmony export */   "GraphicTypes": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.GraphicTypes),
/* harmony export */   "Graphics": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Graphics),
/* harmony export */   "GraphicsBase": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.GraphicsBase),
/* harmony export */   "GraphicsPath": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.GraphicsPath),
/* harmony export */   "GraphicsState": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.GraphicsState),
/* harmony export */   "GraphicsUnit": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.GraphicsUnit),
/* harmony export */   "GuiConsole": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.GuiConsole),
/* harmony export */   "HALF_PI": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.HALF_PI),
/* harmony export */   "HatchBrush": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.HatchBrush),
/* harmony export */   "HatchStyle": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.HatchStyle),
/* harmony export */   "HitTester": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.HitTester),
/* harmony export */   "HotkeyPrefix": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.HotkeyPrefix),
/* harmony export */   "Icon": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Icon),
/* harmony export */   "Image": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Image),
/* harmony export */   "ImageComponent": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ImageComponent),
/* harmony export */   "ImageList": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ImageList),
/* harmony export */   "InterpolationMode": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.InterpolationMode),
/* harmony export */   "KnownColor": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.KnownColor),
/* harmony export */   "LabelComponent": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.LabelComponent),
/* harmony export */   "LineCap": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.LineCap),
/* harmony export */   "LineJoin": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.LineJoin),
/* harmony export */   "LinearGradientBrush": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.LinearGradientBrush),
/* harmony export */   "LinearGradientMode": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.LinearGradientMode),
/* harmony export */   "Matrix": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Matrix),
/* harmony export */   "Matrix2D": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Matrix2D),
/* harmony export */   "MatrixOrder": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.MatrixOrder),
/* harmony export */   "OffScreenGraphics": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.OffScreenGraphics),
/* harmony export */   "PI": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.PI),
/* harmony export */   "PageSettings": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.PageSettings),
/* harmony export */   "PathGradientBrush": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.PathGradientBrush),
/* harmony export */   "Pen": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Pen),
/* harmony export */   "PenAlignment": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.PenAlignment),
/* harmony export */   "Pens": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Pens),
/* harmony export */   "PixelFormat": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.PixelFormat),
/* harmony export */   "PrintDocument": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.PrintDocument),
/* harmony export */   "PrintPageEventArgs": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.PrintPageEventArgs),
/* harmony export */   "PrintPageEventHandler": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.PrintPageEventHandler),
/* harmony export */   "PrintRange": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.PrintRange),
/* harmony export */   "QUARTER_PI": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.QUARTER_PI),
/* harmony export */   "RAD_TO_DEG": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.RAD_TO_DEG),
/* harmony export */   "RadialGradientBrush": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.RadialGradientBrush),
/* harmony export */   "RadioButtonComponent": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.RadioButtonComponent),
/* harmony export */   "RectangleModes": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.RectangleModes),
/* harmony export */   "Region": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Region),
/* harmony export */   "RegionClipType": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.RegionClipType),
/* harmony export */   "RegionType": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.RegionType),
/* harmony export */   "RotateFlipType": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.RotateFlipType),
/* harmony export */   "SDLModule": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SDLModule),
/* harmony export */   "SDL_Palette": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SDL_Palette),
/* harmony export */   "SDL_PixelFormat": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SDL_PixelFormat),
/* harmony export */   "SDL_Surface": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SDL_Surface),
/* harmony export */   "SceneBitmap": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SceneBitmap),
/* harmony export */   "Shadow": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Shadow),
/* harmony export */   "Shape": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Shape),
/* harmony export */   "SketchBatch": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SketchBatch),
/* harmony export */   "SketchGraphics": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SketchGraphics),
/* harmony export */   "SliderComponent": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SliderComponent),
/* harmony export */   "SmoothingMode": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SmoothingMode),
/* harmony export */   "SolidBrush": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SolidBrush),
/* harmony export */   "Stage": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Stage),
/* harmony export */   "StringAlignment": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.StringAlignment),
/* harmony export */   "StringFormat": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.StringFormat),
/* harmony export */   "StringFormatFlags": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.StringFormatFlags),
/* harmony export */   "StringTrimming": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.StringTrimming),
/* harmony export */   "SystemBrushes": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SystemBrushes),
/* harmony export */   "SystemColors": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SystemColors),
/* harmony export */   "SystemFonts": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SystemFonts),
/* harmony export */   "SystemPens": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.SystemPens),
/* harmony export */   "TDIModule": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.TDIModule),
/* harmony export */   "TWEEN": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.TWEEN),
/* harmony export */   "TWO_PI": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.TWO_PI),
/* harmony export */   "Text": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "TextRenderingHint": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.TextRenderingHint),
/* harmony export */   "TextureBrush": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.TextureBrush),
/* harmony export */   "ToolbarComponent": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.ToolbarComponent),
/* harmony export */   "Tween": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.Tween),
/* harmony export */   "VGraphics": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.VGraphics),
/* harmony export */   "VideoBuffer": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.VideoBuffer),
/* harmony export */   "createCanvas": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.createCanvas),
/* harmony export */   "createCanvasElement": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.createCanvasElement),
/* harmony export */   "get2DCanvasContext": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.get2DCanvasContext),
/* harmony export */   "uid": () => (/* reexport safe */ _index__WEBPACK_IMPORTED_MODULE_0__.uid)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./src/index.ts");


})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=index.js.map
tuval$core.EventBus.Default.on('error', (event) => {
   setTimeout(()=>console.error(event.error),1);
   return false;
});
tuval$core.EventBus.Default.fire('module.loaded.graphics', {});
