// Generated by dts-bundle-generator v5.9.0

/// <reference types="node" />

interface String {
	indexOfAny(array: string[], start?: number): number;
	lastIndexOfAny(array: string[], start?: number): number;
	startsWith(str: string | String): boolean;
	equals(str: string | String): boolean;
	toInt16Array(): Int16Array;
	contains(s: string): boolean;
	hashCode(): number;
	getChars(srcBegin: number, srcEnd: number, dst: Int16Array, dstBegin: number): void;
	getBytes(): Uint8Array;
	getBytes(encoding: string): Uint8Array;
	isEmpty(): boolean;
}
interface Object {
	getType(): any;
	getClass(): any;
	class: any;
	equals(o: any): any;
}
export declare class Delegate<TMethod extends Function = any> extends Function {
	private subjects;
	constructor(method?: TMethod);
	add(handler: TMethod): void;
	remove(handler: TMethod): void;
}
export declare class Event<TEventHandler extends Delegate<any>> extends Function {
	private subjects;
	constructor();
	constructor(addFunc: Function, removeFunc: Function);
	add(handler: TEventHandler | ((..._args: any[]) => void)): void;
	remove(handler: TEventHandler | ((..._args: any[]) => void)): void;
	hasHandler(): boolean;
}
export declare class FileSystemReadyDelegate extends Delegate<() => void> {
}
export declare class SystemEvents {
	static OnFileSystemReady: Event<FileSystemReadyDelegate>;
}
export declare type byte = number;
export declare class Byte {
	static MaxValue: number;
	static MinValue: number;
}
export declare type Out<T> = {
	value: T;
};
export declare type Ref<T> = {
	value: T;
};
export declare function newOutEmpty<T>(): Out<T>;
export declare function newOutEmpty<T>(defaultValue: T): Out<T>;
export declare function ref<T>(value: T): T;
export declare function out<T>(value: T): T;
declare class BigInteger {
	private value;
	private sign;
	private isSmall;
	constructor(value: any, sign: boolean);
	add(v: any): any;
	plus(v: any): any;
	subtract(v: any): any;
	sub(v: any): any;
	minus(v: any): any;
	negate(): any;
	neg(): any;
	abs(): any;
	multiply(v: any): any;
	mul(v: any): BigNumber;
	times(v: any): any;
	_multiplyBySmall(a: any): any;
	square(): any;
	divmod(a: any): any;
	divide(a: any): any;
	div(a: any): BigNumber;
	over(a: any): any;
	mod(a: any): BigNumber;
	remainder(a: any): any;
	pow(a: any): any;
	modPow(exp: any, mod: any): any;
	compareAbs(a: any): any;
	compare(a: any): any;
	compareTo(a: any): any;
	equals(a: any): any;
	eq(a: any): any;
	notEquals(a: any): any;
	neq(a: any): any;
	greater(a: any): any;
	greaterThan(a: any): any;
	gt(a: any): any;
	lesser(a: any): any;
	lessThan(a: any): any;
	lt(a: any): any;
	greaterOrEquals(a: any): any;
	greaterThanOrEqual(a: any): any;
	geq(a: any): any;
	lesserOrEquals(a: any): any;
	lessThanOrEqual(a: any): any;
	leq(a: any): any;
	isEven(): any;
	isOdd(): any;
	isPositive(): any;
	isNegative(): any;
	isUnit(): any;
	isZero(): any;
	isDivisibleBy(a: any): any;
	isPrime(a: any): any;
	isProbablePrime(iterations: any, rng: any): any;
	modInv(n: any): any;
	next(): any;
	prev(): any;
	shiftLeft(n: any): any;
	shl(n: any): any;
	shiftRight(n: any): any;
	shr(n: any): any;
	not(): any;
	and(n: any): any;
	or(n: any): any;
	xor(n: any): any;
	toArray(radix: any): any;
	toString(radix: any, alphabet: any): any;
	toJSON(): any;
	toJSNumber(): any;
	toNumber(): any;
	bitLength(): any;
}
declare class NativeBigInt {
	private value;
	constructor(value: any);
	add(v: any): any;
	plus(v: any): any;
	subtract(v: any): any;
	sub(v: any): any;
	minus(v: any): any;
	negate(): any;
	neg(): any;
	abs(): any;
	multiply(v: any): any;
	mul(v: any): BigNumber;
	times(v: any): any;
	square(v: any): any;
	divmod(a: any): any;
	divide(a: any): any;
	div(a: any): BigNumber;
	over(a: any): any;
	mod(a: any): BigNumber;
	remainder(a: any): any;
	pow(a: any): any;
	modPow(exp: any, mod: any): any;
	compareAbs(a: any): any;
	compare(a: any): any;
	compareTo(a: any): any;
	equals(a: any): any;
	eq(a: any): any;
	notEquals(a: any): any;
	neq(a: any): any;
	greater(a: any): any;
	greaterThan(a: any): any;
	gt(a: any): any;
	lesser(a: any): any;
	lessThan(a: any): any;
	lt(a: any): any;
	greaterOrEquals(a: any): any;
	greaterThanOrEqual(a: any): any;
	geq(a: any): any;
	lesserOrEquals(a: any): any;
	lessThanOrEqual(a: any): any;
	leq(a: any): any;
	isEven(): any;
	isOdd(): any;
	isPositive(): any;
	isNegative(): any;
	isUnit(): any;
	isZero(): any;
	isDivisibleBy(a: any): any;
	isPrime(a: any): any;
	isProbablePrime(iterations: any, rng: any): any;
	modInv(n: any): any;
	next(): any;
	prev(): any;
	shiftLeft(n: any): any;
	shl(n: any): any;
	shiftRight(n: any): any;
	shr(n: any): any;
	not(): any;
	and(n: any): any;
	or(n: any): any;
	xor(n: any): any;
	toArray(radix: any): any;
	toString(radix: any, alphabet: any): any;
	toJSON(): any;
	toJSNumber(): any;
	bitLength(): any;
	toNumber(): any;
}
declare type BigNumber = /* number | bigint | string | */ BigInteger | NativeBigInt;
export declare type float = number;
export declare type Integer = number;
export declare type int = number;
export declare type uint = number;
export declare type uint16 = number;
export declare type double = BigNumber;
export declare type decimal = BigNumber;
export declare type UInt64 = BigNumber;
export declare type Int64 = BigNumber;
export declare type long = BigNumber;
export declare type ulong = BigNumber;
export declare type short = number;
export declare type ushort = number;
export declare type char = number;
export declare type sbyte = number;
export declare const UInt64MaxValue: BigNumber;
export declare const UInt64MinValue: BigNumber;
export declare const Int64MaxValue: BigNumber;
export declare const Int64MinValue: BigNumber;
export declare const UInt32MaxValue: uint;
export declare const UInt32MinValue: uint;
export declare type CharArray = Uint16Array;
export declare type ByteArray = Uint8Array;
export declare type IntArray = Int32Array;
export declare type UIntArray = Uint32Array;
export declare type UInt16Array = Uint16Array;
export declare type ShortArray = Int16Array;
export declare type FloatArray = Float32Array;
export declare type DoubleArray = Float64Array;
export declare type LongArray = BigNumber[];
export declare type StringArray = Array<string>;
export declare type TypedArray = Uint8Array | Int8Array | Uint16Array | Int16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
export declare class New {
	static StringArray(l: int): string[];
	static StringArray(...params: string[]): string[];
	static IntArray(l: int | ArrayLike<byte>): IntArray;
	static UIntArray(l: int | ArrayLike<byte>): Uint32Array;
	static UInt16Array(l: int | ArrayLike<byte>): Uint16Array;
	static ShortArray(l: int | ArrayLike<byte>): ShortArray;
	static FloatArray(l: int | ArrayLike<byte>): FloatArray;
	static DoubleArray(l: int | ArrayLike<byte>): DoubleArray;
	static LongArray(l: int | ArrayLike<byte>): LongArray;
	static ByteArray(l: int | ArrayLike<byte>): ByteArray;
	static CharArray<T>(init: ArrayLike<T>): CharArray;
	static CharArray(l: int): CharArray;
	static Array<T>(length: int): T[];
	static Array2D<T>(rows: int, cols: int): T[][];
	static Out<T>(): Out<T>;
	static Out<T>(defaultValue: T): Out<T>;
}
interface ICustomAttributeProvider {
	GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
	GetCustomAttributes(inherit: boolean): any[];
	isDefined(attributeType: Type, inherit: boolean): boolean;
}
declare enum MemberTypes {
	Constructor = 1,
	Event = 2,
	Field = 4,
	Method = 8,
	Property = 16,
	TypeInfo = 32,
	Custom = 64,
	NestedType = 128,
	All = 191
}
declare abstract class MemberInfo implements ICustomAttributeProvider {
	protected constructor();
	isDefined(attributeType: Type, inherit: boolean): boolean;
	abstract Get_DeclaringType(): Type;
	get DeclaringType(): Type;
	protected abstract Get_MemberType(): MemberTypes;
	get MemberType(): MemberTypes;
	abstract Get_Name(): string;
	get Name(): string;
	protected abstract Get_ReflectedType(): Type;
	get ReflectedType(): Type;
	protected Get_Module(): any;
	get Module(): any;
	abstract IsDefined(attributeType: Type, inherit: boolean): boolean;
	abstract GetCustomAttributes(inherit: boolean): any[];
	abstract GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
	get MetadataToken(): int;
	Equals(obj: any): boolean;
	GetHashCode(): int;
	GetIDsOfNames(riid: string, rgszNames: any, cNames: uint, lcid: uint, rgDispId: any): void;
	GetTypeInfo(iTInfo: uint, lcid: uint, ppTInfo: any): void;
	GetTypeInfoCount(pcTInfo: any): void;
	Invoke_(dispIdMember: uint, riid: string, lcid: uint, wFlags: short, pDispParams: any, pVarResult: any, pExcepInfo: any, puArgErr: any): void;
}
export interface ICloneable<T> {
	Clone(): T;
}
export interface IFormatProvider {
	GetFormat(formatType: any): any;
}
declare enum CompareOptions {
	None = 0,
	IgnoreCase = 1,
	IgnoreNonSpace = 2,
	IgnoreSymbols = 4,
	IgnoreKanaType = 8,
	IgnoreWidth = 16,
	OrdinalIgnoreCase = 268435456,
	StringSort = 536870912,
	Ordinal = 1073741824
}
declare class CompareInfo {
	private static readonly ValidIndexMaskOffFlags;
	private static readonly ValidCompareMaskOffFlags;
	private static readonly ValidHashCodeOfStringMaskOffFlags;
	private m_name;
	private m_sortName;
	constructor(culture: CultureInfo);
	static CurrentCompareInfo: CompareInfo;
	static GetCompareInfo(name: string): CompareInfo;
	static GetCompareInfo(culture: int): CompareInfo;
	static GetCompareInfo(name: string, assembly: Assembly): CompareInfo;
	static GetCompareInfo(culture: int, assembly: Assembly): CompareInfo;
	static IsSortable(text: string): boolean;
	static IsSortable(ch: char): boolean;
	private win32LCID;
	private culture;
	get Name(): string;
	private static readonly LINGUISTIC_IGNORECASE;
	private static readonly NORM_IGNORECASE;
	private static readonly NORM_IGNOREKANATYPE;
	private static readonly LINGUISTIC_IGNOREDIACRITIC;
	private static readonly NORM_IGNORENONSPACE;
	private static readonly NORM_IGNORESYMBOLS;
	private static readonly NORM_IGNOREWIDTH;
	private static readonly SORT_STRINGSORT;
	private static readonly COMPARE_OPTIONS_ORDINAL;
	static readonly NORM_LINGUISTIC_CASING: int;
	private static readonly RESERVED_FIND_ASCII_STRING;
	static GetNativeCompareFlags(options: CompareOptions): int;
	Compare(string1: string, string2: string): int;
	Compare(string1: string, string2: string, options: CompareOptions): int;
	Compare(string1: string, offset1: int, length1: int, string2: string, offset2: int, length2: int): int;
	Compare(string1: String, offset1: int, string2: String, offset2: int, options: CompareOptions): int;
	Compare(string1: string, offset1: int, string2: string, offset2: int): int;
	Compare(string1: string, offset1: int, length1: int, string2: string, offset2: int, length2: int, options: CompareOptions): int;
	private static CompareOrdinal;
	IsPrefix(source: string, prefix: string): boolean;
	IsPrefix(source: string, prefix: string, options: CompareOptions): boolean;
	IsSuffix(source: string, suffix: string): boolean;
	IsSuffix(source: string, suffix: string, options: CompareOptions): boolean;
	IndexOf(source: string, value: char): int;
	IndexOf(source: string, value: string): int;
	IndexOf(source: string, value: char, options: CompareOptions): int;
	IndexOf(source: string, value: string, options: CompareOptions): int;
	IndexOf(source: string, value: char, startIndex: int): int;
	IndexOf(source: string, value: string, startIndex: int): int;
	IndexOf(source: string, value: char, startIndex: int, options: CompareOptions): int;
	IndexOf(source: string, value: string, startIndex: int, options: CompareOptions): int;
	IndexOf(source: string, value: char, startIndex: int, count: int): int;
	IndexOf(source: string, value: string, startIndex: int, count: int): int;
	IndexOf(source: string, value: char, startIndex: int, count: int, options: CompareOptions): int;
	IndexOf(source: string, value: string, startIndex: int, count: int, options: CompareOptions): int;
	LastIndexOf(source: string, value: char): int;
	LastIndexOf(source: string, value: string): int;
	LastIndexOf(source: string, value: char, options: CompareOptions): int;
	LastIndexOf(source: string, value: string, options: CompareOptions): int;
	LastIndexOf(source: string, value: char, startIndex: int): int;
	LastIndexOf(source: string, value: string, startIndex: int): int;
	LastIndexOf(source: int, value: char, startIndex: int, options: CompareOptions): int;
	LastIndexOf(source: string, value: string, startIndex: int, options: CompareOptions): int;
	LastIndexOf(source: string, value: char, startIndex: int, count: int): int;
	LastIndexOf(source: string, value: string, startIndex: int, count: int): int;
	LastIndexOf(source: string, value: char, startIndex: int, count: int, options: CompareOptions): int;
	LastIndexOf(source: string, value: string, startIndex: int, count: int, options: CompareOptions): int;
	Equals(value: CompareInfo): boolean;
	GetHashCode(): int;
	GetHashCode(source: string, options: CompareOptions): int;
	GetHashCodeOfString(source: string, options: CompareOptions): int;
	GetHashCodeOfString(source: string, options: CompareOptions, forceRandomizedHashing: boolean, additionalEntropy: number): int;
	ToString(): string;
	get LCID(): int;
	private m_SortVersion;
	get Version(): number;
}
export declare enum StringComparison {
	CurrentCulture = 0,
	CurrentCultureIgnoreCase = 1,
	InvariantCulture = 2,
	InvariantCultureIgnoreCase = 3,
	Ordinal = 4,
	OrdinalIgnoreCase = 5
}
export declare class TString {
	private static readonly regexNumber;
	private static readonly regexObject;
	static Empty: string;
	static IsNullOrWhiteSpace(value: string): boolean;
	static StringArrayFromCharArray(value: char[]): string[];
	static IndexOfAny(source: string, anyOf: string[], startIndex: number, count?: number): number;
	static InternalAllocateStr(length: int): CharArray;
	private static JoinUnchecked;
	static TrimEnd(value: string): string;
	private static CharCopy;
	private static memcpy4;
	private static memcpy2;
	static _Join(separator: string, value: string[], startIndex: int, count: int): string;
	static Join(delimiter: string, ...args: (string | object | Array<any>)[]): string;
	static Format1(format: string, ...args: any[]): string;
	static Format(format: string, ...args: any[]): string;
	private static _format;
	private static parsePattern;
	private static getDisplayDateFromString;
	private static getSortableDateFromString;
	private static formatNumber;
	private static join;
	static Concat(...args: any[]): string;
	private static IsBOMWhitespace;
	static Trim(str: string, ...trimChars: string[]): string;
	static GetHashCode(str: string): number;
	/**
	 * Extracts a string between left and right strings.
		*
		* Example:

		* S('<a>foo</a>').between('<a>', '</a>').s // => 'foo'
		* S('<a>foo</a></a>').between('<a>', '</a>').s // => 'foo'
		* S('<a><a>foo</a></a>').between('<a>', '</a>').s // => '<a>foo'
		* S('<a>foo').between('<a>', '</a>').s // => ''
		* S('Some strings } are very {weird}, dont you think?').between('{', '}').s // => 'weird'
		* S('This is a test string').between('test').s // => ' string'
		* S('This is a test string').between('', 'test').s // => 'This is a '
	 * @param s
	 * @param left
	 * @param right
	 */
	static Between(s: string, left: string, right: string): string;
	static Camelize(s: string): string;
	static Capitalize(s: string): string;
	static CharAt(s: string, index: int): string;
	static ChompLeft(s: string, prefix: string): string;
	static ChompRight(s: string, suffix: string): string;
	static CollapseWhitespace(s: string): string;
	static Contains(s: string, ss: string): boolean;
	static Count(s: string, ss: string): int;
	static Dasherize(s: string): string;
	static EqualsIgnoreCase(s: string, prefix: string): boolean;
	static Latinise(s: string): string;
	static DecodeHtmlEntities(s: string): string;
	static Clone(value: string[]): string[];
	static Clone(value: string): string;
	static Reverse(str: string): string;
	static EndsWith(s: string): boolean;
	static EscapeHTML(s: string): string;
	static EnsureLeft(s: string, prefix: string): string;
	static EnsureRight(s: string, suffix: string): string;
	static Humanize(s: string): string;
	static IsAlpha(s: string): boolean;
	static IsAlphaNumeric(s: string): boolean;
	IsEmpty(s: string): boolean;
	static IsLower(s: string): boolean;
	static IsNumeric(s: string): boolean;
	static IsUpper(s: string): boolean;
	static Left(s: string, N: int): string;
	static Lines(n: string): string[];
	static Pad(s: string, len: int, ch: string): string;
	static PadLeft(s: string, len: int, ch: string): string;
	static PadRight(s: string, len: int, ch: string): string;
	static ParseCSV(s: string, delimiter: string, qualifier: string, escape: string, lineDelimiter: string): string[] | string[][];
	static ReplaceAll(s: string, ss: string, r: string): string;
	static SplitLeft(s: string, sep: string, maxSplit: int, limit: int): any;
	static SplitRight(s: string, sep: string, maxSplit: int, limit: int): string;
	static Strip(s: string, ...args: string[]): string;
	static StripLeft(s: string, chars: string): string;
	static StripRight(s: string, chars: string): string;
	static Right(s: string, N: int): string;
	static StartsWith(s: string): boolean;
	static StripPunctuation(s: string): string;
	stripTags(s: string, ...args: string[]): string;
	static Template(s: string, values: any, opening: any, closing: any): string;
	static Times(s: string, n: int): string;
	static TitleCase(s: string): string;
	static ToBoolean(s: string): boolean;
	static ToFloat(s: string, precision: int): float;
	static ToInt(s: string): int;
	static TrimLeft(s: string): string;
	static TrimRight(s: string): string;
	static truncate(s: string, length: int, pruneStr: string): string;
	static ToCSV(s: string, ...args: any[]): void;
	static Underscore(s: string): string;
	static UnescapeHTML(s: string): string;
	static ValueOf(s: string): string;
	static WrapHTML(s: string, tagName: string, tagAttrs: any): string;
	static ToCharArray(s: string): CharArray;
	static IndexOfOrdinal(str: string, value: string, startIndex: int, count: int, options: CompareOptions): int;
	static IndexOfOrdinalUnchecked(str: string, value: string): int;
	static IndexOfOrdinalUnchecked(str: string, value: string, startIndex: int, count: int): int;
	static FromCharArrayToStringArray(ca: CharArray): string[];
	static FromCharArray(ca: CharArray): string;
	static FromCharArray(ca: CharArray, index: int, count: int): string;
	static CreateStringFromASCII(bytes: ByteArray, index: int, count: int): string;
	static CopyTo(s: string, sIndex: int, chars: CharArray, cIndex: int, length: int): void;
	static ToString(value: any, formatProvider?: IFormatProvider): string;
	static CopyToByteArray(src: string, charIndex: int, destination: ByteArray, byteIndex: int, charCount: int): void;
	static Equals(str1: string, str2: string, comp?: StringComparison): boolean;
	static Split(str: string, str1: char, str2: char): string[];
	static Compare(strA: string, strB: string, ignoreCase: boolean): int;
	static Compare(strA: string, strAIndex: int, strB: string, strBIndex: int, last: int): int;
	static Compare(strA: string, strB: string, cultureInfo: CultureInfo, compareOptions: CompareOptions): int;
	static Compare(strA: string, strB: string, stringComparison: StringComparison): int;
	static Compare(strA: string, indexA: int, strB: string, indexB: int, length: int, culture: any, options: any): int;
	static LastIndexOfAny(str: string, array: string[], start?: number): number;
	static IsNullOrEmpty(value: string): boolean;
	static Remove(source: string, startIndex: int, count: int): string;
}
declare class RegionInfo extends TObject {
	protected dispose(disposing: boolean): void;
	m_name: string;
	m_cultureData: CultureData;
	static s_currentRegionInfo: RegionInfo;
	constructor(name: string);
	constructor(culture: int);
	constructor(cultureData: CultureData);
	private SetName;
	static get CurrentRegion(): RegionInfo;
	get Name(): string;
	get EnglishName(): string;
	get DisplayName(): string;
	get NativeName(): string;
	get TwoLetterISORegionName(): string;
	get ThreeLetterISORegionName(): string;
	get ThreeLetterWindowsRegionName(): string;
	get IsMetric(): boolean;
	GeoId(): int;
	get CurrencyEnglishName(): string;
	get CurrencyNativeName(): string;
	get CurrencySymbol(): string;
	get ISOCurrencySymbol(): string;
	Equals<RegionInfo>(value: RegionInfo): boolean;
	GetHashCode(): int;
	ToString(): string;
}
declare class TextInfo extends TObject implements ICloneable<TextInfo> {
	protected dispose(disposing: boolean): void;
	private m_listSeparator;
	private m_isReadOnly;
	private m_cultureName;
	private m_cultureData;
	private m_textInfoName;
	private m_dataHandle;
	private m_handleOrigin;
	private m_IsAsciiCasingSameAsInvariant;
	static s_Invariant: TextInfo;
	static get Invariant(): TextInfo;
	constructor(cultureData: CultureData);
	static GetHashCodeOrdinalIgnoreCase(s: string): int;
	static GetHashCodeOrdinalIgnoreCase(s: string, forceRandomizedHashing: boolean, additionalEntropy: int): int;
	static TryFastFindStringOrdinalIgnoreCase(searchFlags: int, source: string, startIndex: int, value: string, count: int, foundIndex: Out<int>): boolean;
	static CompareOrdinalIgnoreCase(str1: string, str2: string): int;
	static CompareOrdinalIgnoreCaseEx(strA: string, indexA: int, strB: string, indexB: int, lengthA: int, lengthB: int): int;
	static IndexOfStringOrdinalIgnoreCase(source: string, value: string, startIndex: int, count: int): int;
	static LastIndexOfStringOrdinalIgnoreCase(source: string, value: string, startIndex: int, count: int): int;
	get LCID(): int;
	get CultureName(): string;
	get IsReadOnly(): boolean;
	Clone(): TextInfo;
	static ReadOnly(textInfo: TextInfo): TextInfo;
	private VerifyWritable;
	SetReadOnlyState(readOnly: boolean): void;
	get ListSeparator(): string;
	set ListSeparator(value: string);
	ToLower(c: char): char;
	ToLower(str: string): string;
	private static ToLowerAsciiInvariant;
	ToUpper(c: char): char;
	ToUpper(str: string): string;
	private static ToUpperAsciiInvariant;
	private static IsAscii;
	private get IsAsciiCasingSameAsInvariant();
	Equals<TextInfo>(that: TextInfo): boolean;
	GetHashCode(): int;
	ToString(): string;
	get IsRightToLeft(): boolean;
	GetCaseInsensitiveHashCode(str: string): int;
	GetCaseInsensitiveHashCode(str: string, forceRandomizedHashing: boolean, additionalEntropy: int): int;
	private static InternalChangeCaseChar;
	private static InternalChangeCaseString;
	private static InternalGetCaseInsHash;
	private static InternalCompareStringOrdinalIgnoreCase;
	private static InternalTryFindStringOrdinalIgnoreCase;
}
declare enum CultureTypes {
	NeutralCultures = 1,
	SpecificCultures = 2,
	InstalledWin32Cultures = 4,
	AllCultures = 7,
	UserCustomCulture = 8,
	ReplacementCultures = 16,
	WindowsOnlyCultures = 32,
	FrameworkCultures = 64
}
declare class CalendarData extends TObject {
	protected dispose(disposing: boolean): void;
	static readonly MAX_CALENDARS: int;
	sNativeName: string;
	saShortDates: string[];
	saYearMonths: string[];
	saLongDates: string[];
	sMonthDay: string;
	saEraNames: string[];
	saAbbrevEraNames: string[];
	saAbbrevEnglishEraNames: string[];
	saDayNames: string[];
	saAbbrevDayNames: string[];
	saSuperShortDayNames: string[];
	saMonthNames: string[];
	saAbbrevMonthNames: string[];
	saMonthGenitiveNames: string[];
	saAbbrevMonthGenitiveNames: string[];
	saLeapYearMonthNames: string[];
	iTwoDigitYearMax: int;
	iCurrentEra: int;
	bUseUserOverrides: boolean;
	static Invariant: CalendarData;
	constructor();
	constructor(localeName: string, calendarId: int, bUseUserOverrides: boolean);
	static StaticContructor(): void;
	private InitializeEraNames;
	private static GetJapaneseEraNames;
	private static GetJapaneseEnglishEraNames;
	private InitializeAbbreviatedEraNames;
	static GetCalendarData(calendarId: int): CalendarData;
	private static CalendarIdToCultureName;
	FixupWin7MonthDaySemicolonBug(): void;
	private static FindUnescapedCharacter;
	static nativeGetTwoDigitYearMax(calID: int): int;
	private static nativeGetCalendarData;
	static nativeGetCalendars(localeName: string, useUserOverride: boolean, calendars: IntArray): int;
}
declare enum NumberStyles {
	None = 0,
	AllowLeadingWhite = 1,
	AllowTrailingWhite = 2,
	AllowLeadingSign = 4,
	AllowTrailingSign = 8,
	AllowParentheses = 16,
	AllowDecimalPoint = 32,
	AllowThousands = 64,
	AllowExponent = 128,
	AllowCurrencySymbol = 256,
	AllowHexSpecifier = 512,
	Integer = 7,
	HexNumber = 515,
	Number = 111,
	Float = 167,
	Currency = 383,
	Any = 511
}
declare class NumberFormatInfo extends TObject implements ICloneable<NumberFormatInfo>, IFormatProvider {
	protected dispose(disposing: boolean): void;
	private static invariantInfo;
	numberGroupSizes: IntArray;
	currencyGroupSizes: IntArray;
	percentGroupSizes: IntArray;
	positiveSign: string;
	negativeSign: string;
	numberDecimalSeparator: string;
	numberGroupSeparator: string;
	currencyGroupSeparator: string;
	currencyDecimalSeparator: string;
	currencySymbol: string;
	ansiCurrencySymbol: string;
	nanSymbol: string;
	positiveInfinitySymbol: string;
	negativeInfinitySymbol: string;
	percentDecimalSeparator: string;
	percentGroupSeparator: string;
	percentSymbol: string;
	perMilleSymbol: string;
	nativeDigits: StringArray;
	m_dataItem: int;
	numberDecimalDigits: int;
	currencyDecimalDigits: int;
	currencyPositivePattern: int;
	currencyNegativePattern: int;
	numberNegativePattern: int;
	percentPositivePattern: int;
	percentNegativePattern: int;
	percentDecimalDigits: int;
	isReadOnly: boolean;
	m_useUserOverride: boolean;
	m_isInvariant: boolean;
	constructor();
	constructor(cultureData: CultureData);
	private static VerifyDecimalSeparator;
	private static VerifyGroupSeparator;
	private static VerifyNativeDigits;
	private VerifyWritable;
	static get InvariantInfo(): NumberFormatInfo;
	static GetInstance(formatProvider: IFormatProvider): NumberFormatInfo;
	Clone(): NumberFormatInfo;
	get CurrencyDecimalDigits(): int;
	set CurrencyDecimalDigits(value: int);
	get CurrencyDecimalSeparator(): string;
	set CurrencyDecimalSeparator(value: string);
	get IsReadOnly(): boolean;
	private static CheckGroupSize;
	get CurrencyGroupSizes(): IntArray;
	set CurrencyGroupSizes(value: IntArray);
	get NumberGroupSizes(): IntArray;
	set NumberGroupSizes(value: IntArray);
	get PercentGroupSizes(): IntArray;
	set PercentGroupSizes(value: IntArray);
	get CurrencyGroupSeparator(): string;
	set CurrencyGroupSeparator(value: string);
	get CurrencySymbol(): string;
	set CurrencySymbol(value: string);
	static get CurrentInfo(): NumberFormatInfo;
	get NaNSymbol(): string;
	set NaNSymbol(value: string);
	get CurrencyNegativePattern(): int;
	set CurrencyNegativePattern(value: int);
	get NumberNegativePattern(): int;
	set NumberNegativePattern(value: int);
	get PercentPositivePattern(): int;
	set PercentPositivePattern(value: int);
	get PercentNegativePattern(): int;
	set PercentNegativePattern(value: int);
	get NegativeInfinitySymbol(): string;
	set NegativeInfinitySymbol(value: string);
	get NegativeSign(): string;
	set NegativeSign(value: string);
	get NumberDecimalDigits(): int;
	set NumberDecimalDigits(value: int);
	get NumberDecimalSeparator(): string;
	set NumberDecimalSeparator(value: string);
	get NumberGroupSeparator(): string;
	set NumberGroupSeparator(value: string);
	get CurrencyPositivePattern(): int;
	set CurrencyPositivePattern(value: int);
	get PositiveInfinitySymbol(): string;
	set PositiveInfinitySymbol(value: string);
	get PositiveSign(): string;
	set PositiveSign(value: string);
	get PercentDecimalDigits(): int;
	set PercentDecimalDigits(value: int);
	get PercentDecimalSeparator(): string;
	set PercentDecimalSeparator(value: string);
	get PercentGroupSeparator(): string;
	set PercentGroupSeparator(value: string);
	get PercentSymbol(): string;
	set PercentSymbol(value: string);
	get PerMilleSymbol(): string;
	set PerMilleSymbol(value: string);
	get NativeDigits(): string[];
	set NativeDigits(value: string[]);
	GetFormat(formatType: Type): any;
	static ReadOnly(nfi: NumberFormatInfo): NumberFormatInfo;
	private static readonly InvalidNumberStyles;
	static ValidateParseStyleInteger(style: NumberStyles): void;
	static ValidateParseStyleFloatingPoint(style: NumberStyles): void;
}
declare enum CalendarAlgorithmType {
	Unknown = 0,
	SolarCalendar = 1,
	LunarCalendar = 2,
	LunisolarCalendar = 3
}
export declare enum DayOfWeek {
	Sunday = 0,
	Monday = 1,
	Tuesday = 2,
	Wednesday = 3,
	Thursday = 4,
	Friday = 5,
	Saturday = 6
}
declare enum CalendarWeekRule {
	FirstDay = 0,
	FirstFullWeek = 1,
	FirstFourDayWeek = 2
}
declare enum DateTimeKind {
	Unspecified = 0,
	Utc = 1,
	Local = 2
}
export declare type Primitive = string | number | boolean;
export interface IComparable<T> {
	CompareTo(other: T): number;
}
export declare type Comparable = Primitive | IComparable<any>;
export interface IEquatable<T> {
	Equals(other: T): boolean;
}
export interface IFormattable {
	ToString(format?: string, formatProvider?: IFormatProvider): string;
}
declare type TimeSpanStyles = any;
export declare class TimeSpan extends TObject implements IComparable<TimeSpan>, IEquatable<TimeSpan>, IFormattable {
	protected dispose(disposing: boolean): void;
	static readonly TicksPerMillisecond: long;
	private static readonly MillisecondsPerTick;
	static readonly TicksPerSecond: long;
	private static readonly SecondsPerTick;
	static readonly TicksPerMinute: long;
	private static readonly MinutesPerTick;
	static readonly TicksPerHour: long;
	private static readonly HoursPerTick;
	static readonly TicksPerDay: long;
	private static readonly DaysPerTick;
	private static readonly MillisPerSecond;
	private static readonly MillisPerMinute;
	private static readonly MillisPerHour;
	private static readonly MillisPerDay;
	static readonly MaxSeconds: long;
	static readonly MinSeconds: long;
	static readonly MaxMilliSeconds: long;
	static readonly MinMilliSeconds: long;
	static readonly TicksPerTenthSecond: long;
	static readonly Zero: TimeSpan;
	static readonly MaxValue: TimeSpan;
	static readonly MinValue: TimeSpan;
	_ticks: long;
	constructor();
	constructor(ticks: long);
	constructor(hours: int, minutes: int, seconds: int);
	constructor1(ticks: long): void;
	constructor2(hours: int, minutes: int, seconds: int): void;
	constructor3(days: int, hours: int, minutes: int, seconds: int): void;
	constructor4(days: int, hours: int, minutes: int, seconds: int, milliseconds: int): void;
	get Ticks(): long;
	get Days(): int;
	get Hours(): int;
	get Milliseconds(): int;
	get Minutes(): int;
	get Seconds(): int;
	get TotalDays(): double;
	get TotalHours(): double;
	get TotalMilliseconds(): double;
	get TotalMinutes(): double;
	get TotalSeconds(): double;
	Add(ts: TimeSpan): TimeSpan;
	static Compare(t1: TimeSpan, t2: TimeSpan): int;
	CompareTo(value: TimeSpan): int;
	static FromDays(value: double): TimeSpan;
	Duration(): TimeSpan;
	Equals<TimeSpan>(obj: TimeSpan): boolean;
	static Equals(t1: TimeSpan, t2: TimeSpan): boolean;
	GetHashCode(): int;
	static FromHours(value: double): TimeSpan;
	private static Interval;
	static FromMilliseconds(value: double): TimeSpan;
	static FromMinutes(value: double): TimeSpan;
	Negate(): TimeSpan;
	static FromSeconds(value: double): TimeSpan;
	Subtract(ts: TimeSpan): TimeSpan;
	static FromTicks(value: long): TimeSpan;
	static TimeToTicks(hour: int, minute: int, second: int): long;
	static Parse(input: string, formatProvider?: IFormatProvider): TimeSpan;
	static ParseExact(input: string, format: string, formatProvider: IFormatProvider): TimeSpan;
	static ParseExact(input: string, formats: string[], formatProvider: IFormatProvider): TimeSpan;
	static ParseExact(input: string, format: string, formatProvider: IFormatProvider, styles: TimeSpanStyles): TimeSpan;
	static ParseExact(input: string, formats: string[], formatProvider: IFormatProvider, styles: TimeSpanStyles): TimeSpan;
	static TryParse(s: string, result: Out<TimeSpan>): boolean;
	static TryParse(input: string, formatProvider: IFormatProvider, result: Out<TimeSpan>): boolean;
	static TryParseExact(input: string, format: string, formatProvider: IFormatProvider, result: Out<TimeSpan>): boolean;
	static TryParseExact(input: string, formats: string[], formatProvider: IFormatProvider, result: Out<TimeSpan>): boolean;
	static TryParseExact(input: string, format: string, formatProvider: IFormatProvider, styles: TimeSpanStyles, result: Out<TimeSpan>): boolean;
	ToString(): string;
	ToString(format: string): string;
	ToString(format: string, formatProvider: IFormatProvider): string;
	static Sub(t1: TimeSpan, t2: TimeSpan): TimeSpan;
	static Add(t1: TimeSpan, t2: TimeSpan): TimeSpan;
	static NotEquals(t1: TimeSpan, t2: TimeSpan): boolean;
	static LessThan(t1: TimeSpan, t2: TimeSpan): boolean;
	static LessThanOrEqual(t1: TimeSpan, t2: TimeSpan): boolean;
	static GreaterThan(t1: TimeSpan, t2: TimeSpan): boolean;
	static GreaterThanOrEqual(t1: TimeSpan, t2: TimeSpan): boolean;
	static Div(timeSpan: TimeSpan, divisor: double): TimeSpan;
	static Div(t1: TimeSpan, t2: TimeSpan): double;
	private static LegacyFormatMode;
	private static GetLegacyFormatMode;
	private static _legacyConfigChecked;
	private static _legacyMode;
	private static get LegacyMode();
}
declare enum DateTimeStyles {
	None = 0,
	AllowLeadingWhite = 1,
	AllowTrailingWhite = 2,
	AllowInnerWhite = 4,
	AllowWhiteSpaces = 7,
	NoCurrentDateDefault = 8,
	AdjustToUniversal = 16,
	AssumeLocal = 32,
	AssumeUniversal = 64,
	RoundtripKind = 128
}
declare enum TypeCode {
	Empty = 0,
	Object = 1,
	DBNull = 2,
	Boolean = 3,
	Char = 4,
	SByte = 5,
	Byte = 6,
	Int16 = 7,
	UInt16 = 8,
	Int32 = 9,
	UInt32 = 10,
	Int64 = 11,
	UInt64 = 12,
	Single = 13,
	Double = 14,
	Decimal = 15,
	DateTime = 16,
	String = 18
}
export declare class DateTime implements IComparable<DateTime>, /* IFormattable */ /* IConvertible */ /* ISerializable */ IEquatable<DateTime> {
	get Value(): DateTime;
	private static readonly TicksPerMillisecond;
	private static readonly TicksPerSecond;
	private static readonly TicksPerMinute;
	private static readonly TicksPerHour;
	private static readonly TicksPerDay;
	private static MillisPerSecond;
	private static MillisPerMinute;
	private static MillisPerHour;
	private static MillisPerDay;
	private static readonly DaysPerYear;
	private static readonly DaysPer4Years;
	private static readonly DaysPer100Years;
	private static readonly DaysPer400Years;
	private static readonly DaysTo1601;
	private static readonly DaysTo1899;
	static readonly DaysTo1970: int;
	private static readonly DaysTo10000;
	static readonly MinTicks: long;
	static readonly MaxTicks: long;
	private static readonly MaxMillis;
	private static readonly FileTimeOffset;
	private static readonly DoubleDateOffset;
	private static readonly OADateMinAsTicks;
	private static readonly OADateMinAsDouble;
	private static readonly OADateMaxAsDouble;
	private static readonly DatePartYear;
	private static readonly DatePartDayOfYear;
	private static readonly DatePartMonth;
	private static readonly DatePartDay;
	static readonly s_isLeapSecondsSupportedSystem: boolean;
	private static readonly DaysToMonth365;
	private static readonly DaysToMonth366;
	static readonly MinValue: DateTime;
	static readonly MaxValue: DateTime;
	private static readonly TicksMask;
	private static readonly FlagsMask;
	private static readonly LocalMask;
	private static readonly TicksCeiling;
	private static readonly KindUnspecified;
	private static readonly KindUtc;
	private static readonly KindLocal;
	private static readonly KindLocalAmbiguousDst;
	private static readonly KindShift;
	private static readonly TicksField;
	private static readonly DateDataField;
	private dateData;
	constructor(ticks: long);
	constructor(ticks: long, kind: DateTimeKind);
	constructor(ticks: long, kind: DateTimeKind, isAmbiguousDst: boolean);
	constructor(year: int, month: int, day: int);
	constructor(year: int, month: int, day: int, calendar: Calendar);
	constructor(year: int, month: int, day: int, hour: int, minute: int, second: int);
	constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int);
	constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, calendar: Calendar);
	constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, kind: DateTimeKind);
	constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: Calendar);
	constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: Calendar, kind: DateTimeKind);
	constructor1(ticks: long): void;
	private constructor2;
	constructor3(ticks: long, kind: DateTimeKind): void;
	constructor4(ticks: long, kind: DateTimeKind, isAmbiguousDst: boolean): void;
	constructor5(year: int, month: int, day: int): void;
	constructor6(year: int, month: int, day: int, calendar: Calendar): void;
	constructor7(year: int, month: int, day: int, hour: int, minute: int, second: int): void;
	constructor8(year: int, month: int, day: int, hour: int, minute: int, second: int, kind: DateTimeKind): void;
	constructor9(year: int, month: int, day: int, hour: int, minute: int, second: int, calendar: Calendar): void;
	constructor10(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): void;
	constructor11(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, kind: DateTimeKind): void;
	constructor12(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: Calendar): void;
	constructor13(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: Calendar, kind: DateTimeKind): void;
	get InternalTicks(): Int64;
	private get InternalKind();
	Add(value: TimeSpan): DateTime;
	private add;
	AddDays(value: double): DateTime;
	AddHours(value: double): DateTime;
	AddMilliseconds(value: double): DateTime;
	AddMilliseconds(value: int): DateTime;
	AddMinutes(value: double): DateTime;
	AddMonths(months: int): DateTime;
	AddSeconds(value: double): DateTime;
	AddTicks(value: long): DateTime;
	AddTicks(value: int): DateTime;
	AddYears(value: int): DateTime;
	static Compare(t1: DateTime, t2: DateTime): int;
	CompareTo(value: DateTime): int;
	private static DateToTicks;
	private static TimeToTicks;
	static DaysInMonth(year: int, month: int): int;
	static DoubleDateToTicks(value: double): long;
	Equals(value: DateTime): boolean;
	static FromBinary(dateData: Int64): DateTime;
	static FromBinaryRaw(dateData: Int64): DateTime;
	static FromFileTime(fileTime: long): DateTime;
	static FromFileTimeUtc(fileTime: long): DateTime;
	static FromOADate(d: double): DateTime;
	IsDaylightSavingTime(): boolean;
	static SpecifyKind(value: DateTime, kind: DateTimeKind): DateTime;
	ToBinary(): Int64;
	ToBinaryRaw(): Int64;
	get Date(): DateTime;
	private GetDatePart;
	get Day(): int;
	get DayOfWeek(): DayOfWeek;
	get DayOfYear(): int;
	GetHashCode(): int;
	get Hour(): int;
	IsAmbiguousDaylightSavingTime(): boolean;
	get Kind(): DateTimeKind;
	get Millisecond(): int;
	get Minute(): int;
	get Month(): int;
	static get Now(): DateTime;
	static get UtcNow(): DateTime;
	static GetSystemTimeAsFileTime(): long;
	get Second(): int;
	get Ticks(): long;
	get TimeOfDay(): TimeSpan;
	static get Today(): DateTime;
	get Year(): int;
	static IsLeapYear(year: int): boolean;
	static Parse(s: string): DateTime;
	static Parse(s: string, provider: IFormatProvider): DateTime;
	static Parse(s: string, provider: IFormatProvider, styles: DateTimeStyles): DateTime;
	static ParseExact(s: string, format: string, provider: IFormatProvider): DateTime;
	static ParseExact(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles): DateTime;
	static ParseExact(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles): DateTime;
	Subtract(value: DateTime): TimeSpan;
	Subtract(value: TimeSpan): DateTime;
	private static TicksToOADate;
	ToOADate(): double;
	ToFileTime(): long;
	ToFileTimeUtc(): long;
	ToLocalTime(): DateTime;
	ToLocalTime(throwOnOverflow: boolean): DateTime;
	ToLongDateString(): string;
	ToLongTimeString(): string;
	ToShortDateString(): string;
	ToShortTimeString(): string;
	ToString(): string;
	ToString(format: string): string;
	ToString(provider: IFormatProvider): string;
	ToString(format: string, provider: IFormatProvider): string;
	ToUniversalTime(): DateTime;
	static TryParse(s: string, result: Out<DateTime>): boolean;
	static TryParse(s: string, provider: IFormatProvider, styles: DateTimeStyles, result: Out<DateTime>): boolean;
	static TryParseExact(s: string, format: string, provider: IFormatProvider, style: DateTimeStyles, result: Out<DateTime>): boolean;
	static TryParseExact(s: string, formats: string[], provider: IFormatProvider, style: DateTimeStyles, result: Out<DateTime>): boolean;
	static Add(d: DateTime, t: TimeSpan): DateTime;
	static Sub(d: DateTime, t: TimeSpan): DateTime;
	static Sub(d1: DateTime, d2: DateTime): TimeSpan;
	static Equals(d1: DateTime, d2: DateTime): boolean;
	static NotEquals(d1: DateTime, d2: DateTime): boolean;
	lessThan(value: DateTime): boolean;
	lessThanOrEqual(value: DateTime): boolean;
	greaterThan(value: DateTime): boolean;
	greaterThanOrEqual(value: DateTime): boolean;
	GetDateTimeFormats(): string[];
	GetDateTimeFormats(provider: IFormatProvider): string[];
	GetDateTimeFormats(format: char): string[];
	GetDateTimeFormats(format: char, provider: IFormatProvider): string[];
	GetTypeCode(): TypeCode;
	static TryCreate(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, result: Out<DateTime>): boolean;
}
declare abstract class Calendar extends TObject implements ICloneable<Calendar> {
	static readonly TicksPerMillisecond: long;
	static readonly TicksPerSecond: long;
	static readonly TicksPerMinute: long;
	static readonly TicksPerHour: long;
	static readonly TicksPerDay: long;
	static readonly MillisPerSecond: int;
	static readonly MillisPerMinute: int;
	static readonly MillisPerHour: int;
	static readonly MillisPerDay: int;
	static readonly DaysPerYear: int;
	static readonly DaysPer4Years: int;
	static readonly DaysPer100Years: int;
	static readonly DaysPer400Years: int;
	static readonly DaysTo10000: int;
	static readonly MaxMillis: long;
	static readonly CAL_GREGORIAN: int;
	static readonly CAL_GREGORIAN_US: int;
	static readonly CAL_JAPAN: int;
	static readonly CAL_TAIWAN: int;
	static readonly CAL_KOREA: int;
	static readonly CAL_HIJRI: int;
	static readonly CAL_THAI: int;
	static readonly CAL_HEBREW: int;
	static readonly CAL_GREGORIAN_ME_FRENCH: int;
	static readonly CAL_GREGORIAN_ARABIC: int;
	static readonly CAL_GREGORIAN_XLIT_ENGLISH: int;
	static readonly CAL_GREGORIAN_XLIT_FRENCH: int;
	static readonly CAL_JULIAN: int;
	static readonly CAL_JAPANESELUNISOLAR: int;
	static readonly CAL_CHINESELUNISOLAR: int;
	static readonly CAL_SAKA: int;
	static readonly CAL_LUNAR_ETO_CHN: int;
	static readonly CAL_LUNAR_ETO_KOR: int;
	static readonly CAL_LUNAR_ETO_ROKUYOU: int;
	static readonly CAL_KOREANLUNISOLAR: int;
	static readonly CAL_TAIWANLUNISOLAR: int;
	static readonly CAL_PERSIAN: int;
	static readonly CAL_UMALQURA: int;
	m_currentEraValue: int;
	private m_isReadOnly;
	protected Get_MinSupportedDateTime(): DateTime;
	get MinSupportedDateTime(): DateTime;
	protected Get_MaxSupportedDateTime(): DateTime;
	get MaxSupportedDateTime(): DateTime;
	protected constructor();
	protected Get_ID(): int;
	get ID(): int;
	protected Get_BaseCalendarID(): int;
	get BaseCalendarID(): int;
	protected Get_AlgorithmType(): CalendarAlgorithmType;
	get AlgorithmType(): int;
	get IsReadOnly(): boolean;
	Clone(): Calendar;
	static ReadOnly(calendar: Calendar): Calendar;
	VerifyWritable(): void;
	SetReadOnlyState(readOnly: boolean): void;
	get CurrentEraValue(): int;
	static readonly CurrentEra: int;
	twoDigitYearMax: int;
	static CheckAddResult(ticks: long, minValue: DateTime, maxValue: DateTime): void;
	Add(time: DateTime, value: int, scale: int): DateTime;
	Add(time: DateTime, value: double, scale: int): DateTime;
	AddMilliseconds(time: DateTime, milliseconds: double): DateTime;
	AddDays(time: DateTime, days: int): DateTime;
	AddHours(time: DateTime, hours: int): DateTime;
	AddMinutes(time: DateTime, minutes: int): DateTime;
	abstract AddMonths(time: DateTime, months: int): DateTime;
	AddSeconds(time: DateTime, seconds: int): DateTime;
	AddWeeks(time: DateTime, weeks: int): DateTime;
	abstract AddYears(time: DateTime, years: int): DateTime;
	abstract GetDayOfMonth(time: DateTime): int;
	abstract GetDayOfWeek(time: DateTime): DayOfWeek;
	abstract GetDayOfYear(time: DateTime): int;
	GetDaysInMonth(year: int, month: int, era: int): int;
	GetDaysInMonth(year: int, month: int): int;
	GetDaysInYear(year: int): int;
	GetDaysInYear(year: int, era: int): int;
	abstract GetEra(time: DateTime): int;
	protected abstract Get_Eras(): IntArray;
	get Eras(): IntArray;
	GetHour(time: DateTime): int;
	GetMilliseconds(time: DateTime): double;
	GetMinute(time: DateTime): int;
	abstract GetMonth(time: DateTime): int;
	GetMonthsInYear(year: int, era: int): int;
	GetMonthsInYear(year: int): int;
	GetSecond(time: DateTime): int;
	GetFirstDayWeekOfYear(time: DateTime, firstDayOfWeek: int): int;
	private GetWeekOfYearFullDays;
	private GetWeekOfYearOfMinSupportedDateTime;
	protected get DaysInYearBeforeMinSupportedYear(): int;
	GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
	abstract GetYear(time: DateTime): int;
	IsLeapDay(year: int, month: int, day: int, era: int): boolean;
	IsLeapDay(year: int, month: int, day: int): boolean;
	IsLeapMonth(year: int, month: int, era: int): boolean;
	IsLeapMonth(year: int, month: int): boolean;
	GetLeapMonth(year: int): int;
	GetLeapMonth(year: int, era: int): int;
	IsLeapYear(year: int): boolean;
	IsLeapYear(year: int, era: int): boolean;
	ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
	ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
	TryToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int, result: Out<DateTime>): boolean;
	IsValidYear(year: int, era: int): boolean;
	IsValidMonth(year: int, month: int, era: int): boolean;
	IsValidDay(year: int, month: int, day: int, era: int): boolean;
	protected Get_TwoDigitYearMax(): int;
	get TwoDigitYearMax(): int;
	protected Set_TwoDigitYearMax(value: int): void;
	set TwoDigitYearMax(value: int);
	ToFourDigitYear(year: int): int;
	static TimeToTicks(hour: int, minute: int, second: int, millisecond: int): long;
	static GetSystemTwoDigitYearSetting(CalID: int, defaultYearValue: int): int;
}
declare enum DateTimeFormatFlags {
	None = 0,
	UseGenitiveMonth = 1,
	UseLeapYearMonth = 2,
	UseSpacesInMonthNames = 4,
	UseHebrewRule = 8,
	UseSpacesInDayNames = 16,
	UseDigitPrefixInTokens = 32,
	NotInitialized = -1
}
declare enum MonthNameStyles {
	Regular = 0,
	Genitive = 1,
	LeapYear = 2
}
declare enum TokenType {
	NumberToken = 1,
	YearNumberToken = 2,
	Am = 3,
	Pm = 4,
	MonthToken = 5,
	EndOfString = 6,
	DayOfWeekToken = 7,
	TimeZoneToken = 8,
	EraToken = 9,
	DateWordToken = 10,
	UnknownToken = 11,
	HebrewNumber = 12,
	JapaneseEraToken = 13,
	TEraToken = 14,
	IgnorableSymbol = 15,
	SEP_Unk = 256,
	SEP_End = 512,
	SEP_Space = 768,
	SEP_Am = 1024,
	SEP_Pm = 1280,
	SEP_Date = 1536,
	SEP_Time = 1792,
	SEP_YearSuff = 2048,
	SEP_MonthSuff = 2304,
	SEP_DaySuff = 2560,
	SEP_HourSuff = 2816,
	SEP_MinuteSuff = 3072,
	SEP_SecondSuff = 3328,
	SEP_LocalTimeMark = 3584,
	SEP_DateOrOffset = 3840,
	RegularTokenMask = 255,
	SeparatorTokenMask = 65280
}
declare type __DTString = any;
export declare class CultureInfo extends TObject implements ICloneable<CultureInfo>, IFormatProvider {
	protected dispose(disposing: boolean): void;
	m_isReadOnly: boolean;
	compareInfo: CompareInfo;
	textInfo: TextInfo;
	regionInfo: RegionInfo;
	numInfo: NumberFormatInfo;
	dateTimeInfo: DateTimeFormatInfo;
	calendar: Calendar;
	m_dataItem: int;
	cultureID: int;
	m_cultureData: CultureData;
	m_isInherited: boolean;
	private m_consoleFallbackCulture;
	m_name: string;
	private m_nonSortName;
	private m_sortName;
	private static s_userDefaultCulture;
	private static s_InvariantCultureInfo;
	private static s_userDefaultUICulture;
	private static s_InstalledUICultureInfo;
	private static s_DefaultThreadCurrentUICulture;
	private static s_DefaultThreadCurrentCulture;
	private static s_LcidCachedCultures;
	private static s_NameCachedCultures;
	private m_parent;
	static readonly LOCALE_NEUTRAL: int;
	private static readonly LOCALE_USER_DEFAULT;
	private static readonly LOCALE_SYSTEM_DEFAULT;
	static readonly LOCALE_CUSTOM_DEFAULT: int;
	static readonly LOCALE_CUSTOM_UNSPECIFIED: int;
	static readonly LOCALE_INVARIANT: int;
	private static readonly LOCALE_TRADITIONAL_SPANISH;
	private static Init;
	private static InitUserDefaultCulture;
	private static InitUserDefaultUICulture;
	constructor(name: string);
	constructor(name: string, useUserOverride: boolean);
	constructor(cultureData: CultureData);
	constructor(culture: int);
	constructor(culture: int, useUserOverride: boolean);
	constructor(cultureName: string, textAndCompareCultureName: string);
	constructor1(name: string): void;
	constructor2(name: string, useUserOverride: boolean): void;
	private constructor3;
	private static CreateCultureInfoNoThrow;
	constructor4(culture: int): void;
	constructor5(culture: int, useUserOverride: boolean): void;
	private InitializeFromCultureId;
	constructor6(cultureName: string, textAndCompareCultureName: string): void;
	private static GetCultureByName;
	static CreateSpecificCulture(name: string): CultureInfo;
	static VerifyCultureName(cultureName: string, throwException: boolean): boolean;
	static VerifyCultureName(culture: CultureInfo, throwException: boolean): boolean;
	static get CurrentCulture(): CultureInfo;
	static set CurrentCulture(value: CultureInfo);
	static get UserDefaultCulture(): CultureInfo;
	static get UserDefaultUICulture(): CultureInfo;
	static get CurrentUICulture(): CultureInfo;
	static set CurrentUICulture(value: CultureInfo);
	static get InstalledUICulture(): CultureInfo;
	static get DefaultThreadCurrentCulture(): CultureInfo;
	static set DefaultThreadCurrentCulture(value: CultureInfo);
	static get DefaultThreadCurrentUICulture(): CultureInfo;
	static set DefaultThreadCurrentUICulture(value: CultureInfo);
	static get InvariantCulture(): CultureInfo;
	get Parent(): CultureInfo;
	get LCID(): int;
	get KeyboardLayoutId(): int;
	static GetCultures(types: CultureTypes): CultureInfo[];
	get Name(): string;
	get SortName(): string;
	get IetfLanguageTag(): string;
	get DisplayName(): string;
	get NativeName(): string;
	get EnglishName(): string;
	get TwoLetterISOLanguageName(): string;
	get ThreeLetterISOLanguageName(): string;
	get ThreeLetterWindowsLanguageName(): string;
	get CompareInfo(): CompareInfo;
	private get Region();
	get TextInfo(): TextInfo;
	Equals<CultureInfo>(value: CultureInfo): boolean;
	GetHashCode(): int;
	ToString(): string;
	GetFormat(formatType: Type): any;
	get IsNeutralCulture(): boolean;
	get CultureTypes(): CultureTypes;
	get NumberFormat(): NumberFormatInfo;
	set NumberFormat(value: NumberFormatInfo);
	get DateTimeFormat(): DateTimeFormatInfo;
	set DateTimeFormat(value: DateTimeFormatInfo);
	ClearCachedData(): void;
	static GetCalendarInstance(calType: int): Calendar;
	static GetCalendarInstanceRare(calType: int): Calendar;
	get Calendar(): Calendar;
	get OptionalCalendars(): Calendar[];
	get UseUserOverride(): boolean;
	GetConsoleFallbackUICulture(): CultureInfo;
	Clone(): CultureInfo;
	static ReadOnly(ci: CultureInfo): CultureInfo;
	get IsReadOnly(): boolean;
	private VerifyWritable;
	get HasInvariantCultureName(): boolean;
	static GetCultureInfoHelper(lcid: int, name: string, altName: string): CultureInfo;
	static GetCultureInfo(culture: int): CultureInfo;
	static GetCultureInfo(name: string): CultureInfo;
	static GetCultureInfo(name: string, altName: string): CultureInfo;
	static GetCultureInfoByIetfLanguageTag(name: string): CultureInfo;
	private static s_isTaiwanSku;
	private static s_haveIsTaiwanSku;
	static get IsTaiwanSku(): boolean;
	private static GetDefaultLocaleName;
	private static InternalGetDefaultLocaleName;
	private static GetUserDefaultUILanguage;
	private static InternalGetUserDefaultUILanguage;
	private static GetSystemDefaultUILanguage;
	private static InternalGetSystemDefaultUILanguage;
	static nativeGetResourceFallbackArray(): string[];
}
export declare class CultureData extends TObject {
	protected dispose(disposing: boolean): void;
	private sRealName;
	private sWindowsName;
	private sName;
	private sParent;
	private sLocalizedDisplayName;
	private sEnglishDisplayName;
	private sNativeDisplayName;
	private sSpecificCulture;
	private sISO639Language;
	private sLocalizedLanguage;
	private sEnglishLanguage;
	private sNativeLanguage;
	private sRegionName;
	private iGeoId;
	private sLocalizedCountry;
	private sEnglishCountry;
	private sNativeCountry;
	private sISO3166CountryName;
	private sPositiveSign;
	private sNegativeSign;
	private saNativeDigits;
	private iDigitSubstitution;
	private iLeadingZeros;
	private iDigits;
	private iNegativeNumber;
	private waGrouping;
	private sDecimalSeparator;
	private sThousandSeparator;
	private sNaN;
	private sPositiveInfinity;
	private sNegativeInfinity;
	private iNegativePercent;
	private iPositivePercent;
	private sPercent;
	private sPerMille;
	private sCurrency;
	private sIntlMonetarySymbol;
	private sEnglishCurrency;
	private sNativeCurrency;
	private iCurrencyDigits;
	private iCurrency;
	private iNegativeCurrency;
	private waMonetaryGrouping;
	private sMonetaryDecimal;
	private sMonetaryThousand;
	private iMeasure;
	private sListSeparator;
	private sAM1159;
	private sPM2359;
	private sTimeSeparator;
	private saLongTimes;
	private saShortTimes;
	private saDurationFormats;
	private iFirstDayOfWeek;
	private iFirstWeekOfYear;
	private waCalendars;
	private calendars;
	private iReadingLayout;
	private sTextInfo;
	private sCompareInfo;
	private sScripts;
	private iDefaultAnsiCodePage;
	private iDefaultOemCodePage;
	private iDefaultMacCodePage;
	private iDefaultEbcdicCodePage;
	private iLanguage;
	private sAbbrevLang;
	private sAbbrevCountry;
	private sISO639Language2;
	private sISO3166CountryName2;
	private iInputLanguageHandle;
	private sConsoleFallbackName;
	private sKeyboardsToInstall;
	private fontSignature;
	private bUseOverrides;
	private bNeutral;
	private bWin32Installed;
	private bFramework;
	private static get RegionNames();
	private static s_RegionNames;
	static get Invariant(): CultureData;
	private static s_Invariant;
	private static s_cachedCultures;
	static GetCultureData(cultureName: string, useUserOverride: boolean): CultureData;
	static GetCultureData(culture: int, bUseUserOverride: boolean): CultureData;
	private static CreateCultureData;
	private InitCultureData;
	private static s_cachedRegions;
	static GetCultureDataForRegion(cultureName: string, useUserOverride: boolean): CultureData;
	static LCIDToLocaleName(lcid: int): string;
	static ClearCachedData(): void;
	static GetCultures(types: CultureTypes): CultureInfo[];
	get IsReplacementCulture(): boolean;
	static s_replacementCultureNames: string[];
	private static IsReplacementCultureName;
	static specificCultures: CultureInfo[];
	private static get SpecificCultures();
	get CultureName(): string;
	get UseUserOverride(): boolean;
	get SNAME(): string;
	get SPARENT(): string;
	get SLOCALIZEDDISPLAYNAME(): string;
	get SENGDISPLAYNAME(): string;
	get SISO3166CTRYNAME2(): string;
	get SNATIVEDISPLAYNAME(): string;
	get SSPECIFICCULTURE(): string;
	get SISO639LANGNAME(): string;
	get SLOCALIZEDLANGUAGE(): string;
	get SENGLISHLANGUAGE(): string;
	get SNATIVELANGUAGE(): string;
	get SREGIONNAME(): string;
	get IGEOID(): int;
	get SLOCALIZEDCOUNTRY(): string;
	get SENGCOUNTRY(): string;
	get SNATIVECOUNTRY(): string;
	get IINPUTLANGUAGEHANDLE(): int;
	get SABBREVCTRYNAME(): string;
	get SISO639LANGNAME2(): string;
	get SABBREVLANGNAME(): string;
	get SISO3166CTRYNAME(): string;
	get WAGROUPING(): IntArray;
	get SNAN(): string;
	get SPOSINFINITY(): string;
	get SNEGINFINITY(): string;
	get INEGATIVEPERCENT(): int;
	get IPOSITIVEPERCENT(): int;
	get SPERCENT(): string;
	get SPERMILLE(): string;
	get SCURRENCY(): string;
	get SINTLSYMBOL(): string;
	get SENGLISHCURRENCY(): string;
	get SNATIVECURRENCY(): string;
	get WAMONGROUPING(): IntArray;
	get IMEASURE(): int;
	get SLIST(): string;
	get SAM1159(): string;
	get SPM2359(): string;
	get LongTimes(): string[];
	get ShortTimes(): string[];
	private DeriveShortTimesFromLong;
	private static StripSecondsFromPattern;
	private static GetIndexOfNextTokenAfterSeconds;
	get SADURATION(): string[];
	get IFIRSTDAYOFWEEK(): int;
	get IFIRSTWEEKOFYEAR(): int;
	ShortDates(calendarId: int): string[];
	LongDates(calendarId: int): string[];
	YearMonths(calendarId: int): string[];
	DayNames(calendarId: int): string[];
	AbbreviatedDayNames(calendarId: int): string[];
	SuperShortDayNames(calendarId: int): string[];
	MonthNames(calendarId: int): string[];
	GenitiveMonthNames(calendarId: int): string[];
	AbbreviatedMonthNames(calendarId: int): string[];
	AbbreviatedGenitiveMonthNames(calendarId: int): string[];
	LeapYearMonthNames(calendarId: int): string[];
	MonthDay(calendarId: int): string;
	get CalendarIds(): IntArray;
	CalendarName(calendarId: int): string;
	GetCalendar(calendarId: int): CalendarData;
	CurrentEra(calendarId: int): int;
	get IsRightToLeft(): boolean;
	private get IREADINGLAYOUT();
	get STEXTINFO(): string;
	get SCOMPAREINFO(): string;
	get IsSupplementalCustomCulture(): boolean;
	get IDEFAULTANSICODEPAGE(): int;
	get IDEFAULTOEMCODEPAGE(): int;
	get IDEFAULTMACCODEPAGE(): int;
	get IDEFAULTEBCDICCODEPAGE(): int;
	static LocaleNameToLCID(localeName: string): int;
	get ILANGUAGE(): int;
	get IsWin32Installed(): boolean;
	get IsFramework(): boolean;
	get IsNeutralCulture(): boolean;
	get IsInvariantCulture(): boolean;
	get DefaultCalendar(): Calendar;
	EraNames(calendarId: int): string[];
	AbbrevEraNames(calendarId: int): string[];
	AbbreviatedEnglishEraNames(calendarId: int): string[];
	get TimeSeparator(): string;
	DateSeparator(calendarId: int): string;
	private static UnescapeNlsString;
	static ReescapeWin32String(str: string): string;
	static ReescapeWin32Strings(array: string[]): string[];
	private static GetTimeSeparator;
	private static GetDateSeparator;
	private static GetSeparator;
	private static IndexOfTimePart;
	private DoGetLocaleInfo;
	private DoGetLocaleInfoInt;
	private DoEnumTimeFormats;
	private DoEnumShortTimeFormats;
	private static IsCustomCultureId;
	GetNFIValues(nfi: NumberFormatInfo): void;
	private static ConvertFirstDayOfWeekMonToSun;
	static AnsiToLower(testString: string): string;
	private static ConvertWin32GroupString;
	private static readonly LOCALE_NOUSEROVERRIDE;
	private static readonly LOCALE_RETURN_NUMBER;
	private static readonly LOCALE_RETURN_GENITIVE_NAMES;
	private static readonly LOCALE_SLOCALIZEDDISPLAYNAME;
	private static readonly LOCALE_SENGLISHDISPLAYNAME;
	private static readonly LOCALE_SNATIVEDISPLAYNAME;
	private static readonly LOCALE_SLOCALIZEDLANGUAGENAME;
	private static readonly LOCALE_SENGLISHLANGUAGENAME;
	private static readonly LOCALE_SNATIVELANGUAGENAME;
	private static readonly LOCALE_SLOCALIZEDCOUNTRYNAME;
	private static readonly LOCALE_SENGLISHCOUNTRYNAME;
	private static readonly LOCALE_SNATIVECOUNTRYNAME;
	private static readonly LOCALE_SABBREVLANGNAME;
	private static readonly LOCALE_ICOUNTRY;
	private static readonly LOCALE_SABBREVCTRYNAME;
	private static readonly LOCALE_IGEOID;
	private static readonly LOCALE_IDEFAULTLANGUAGE;
	private static readonly LOCALE_IDEFAULTCOUNTRY;
	private static readonly LOCALE_IDEFAULTCODEPAGE;
	private static readonly LOCALE_IDEFAULTANSICODEPAGE;
	private static readonly LOCALE_IDEFAULTMACCODEPAGE;
	private static readonly LOCALE_SLIST;
	private static readonly LOCALE_IMEASURE;
	private static readonly LOCALE_SDECIMAL;
	private static readonly LOCALE_STHOUSAND;
	private static readonly LOCALE_SGROUPING;
	private static readonly LOCALE_IDIGITS;
	private static readonly LOCALE_ILZERO;
	private static readonly LOCALE_INEGNUMBER;
	private static readonly LOCALE_SNATIVEDIGITS;
	private static readonly LOCALE_SCURRENCY;
	private static readonly LOCALE_SINTLSYMBOL;
	private static readonly LOCALE_SMONDECIMALSEP;
	private static readonly LOCALE_SMONTHOUSANDSEP;
	private static readonly LOCALE_SMONGROUPING;
	private static readonly LOCALE_ICURRDIGITS;
	private static readonly LOCALE_IINTLCURRDIGITS;
	private static readonly LOCALE_ICURRENCY;
	private static readonly LOCALE_INEGCURR;
	private static readonly LOCALE_SDATE;
	private static readonly LOCALE_STIME;
	private static readonly LOCALE_SSHORTDATE;
	private static readonly LOCALE_SLONGDATE;
	private static readonly LOCALE_STIMEFORMAT;
	private static readonly LOCALE_IDATE;
	private static readonly LOCALE_ILDATE;
	private static readonly LOCALE_ITIME;
	private static readonly LOCALE_ITIMEMARKPOSN;
	private static readonly LOCALE_ICENTURY;
	private static readonly LOCALE_ITLZERO;
	private static readonly LOCALE_IDAYLZERO;
	private static readonly LOCALE_IMONLZERO;
	private static readonly LOCALE_S1159;
	private static readonly LOCALE_S2359;
	private static readonly LOCALE_ICALENDARTYPE;
	private static readonly LOCALE_IOPTIONALCALENDAR;
	private static readonly LOCALE_IFIRSTDAYOFWEEK;
	private static readonly LOCALE_IFIRSTWEEKOFYEAR;
	private static readonly LOCALE_SDAYNAME1;
	private static readonly LOCALE_SDAYNAME2;
	private static readonly LOCALE_SDAYNAME3;
	private static readonly LOCALE_SDAYNAME4;
	private static readonly LOCALE_SDAYNAME5;
	private static readonly LOCALE_SDAYNAME6;
	private static readonly LOCALE_SDAYNAME7;
	private static readonly LOCALE_SABBREVDAYNAME1;
	private static readonly LOCALE_SABBREVDAYNAME2;
	private static readonly LOCALE_SABBREVDAYNAME3;
	private static readonly LOCALE_SABBREVDAYNAME4;
	private static readonly LOCALE_SABBREVDAYNAME5;
	private static readonly LOCALE_SABBREVDAYNAME6;
	private static readonly LOCALE_SABBREVDAYNAME7;
	private static readonly LOCALE_SMONTHNAME1;
	private static readonly LOCALE_SMONTHNAME2;
	private static readonly LOCALE_SMONTHNAME3;
	private static readonly LOCALE_SMONTHNAME4;
	private static readonly LOCALE_SMONTHNAME5;
	private static readonly LOCALE_SMONTHNAME6;
	private static readonly LOCALE_SMONTHNAME7;
	private static readonly LOCALE_SMONTHNAME8;
	private static readonly LOCALE_SMONTHNAME9;
	private static readonly LOCALE_SMONTHNAME10;
	private static readonly LOCALE_SMONTHNAME11;
	private static readonly LOCALE_SMONTHNAME12;
	private static readonly LOCALE_SMONTHNAME13;
	private static readonly LOCALE_SABBREVMONTHNAME1;
	private static readonly LOCALE_SABBREVMONTHNAME2;
	private static readonly LOCALE_SABBREVMONTHNAME3;
	private static readonly LOCALE_SABBREVMONTHNAME4;
	private static readonly LOCALE_SABBREVMONTHNAME5;
	private static readonly LOCALE_SABBREVMONTHNAME6;
	private static readonly LOCALE_SABBREVMONTHNAME7;
	private static readonly LOCALE_SABBREVMONTHNAME8;
	private static readonly LOCALE_SABBREVMONTHNAME9;
	private static readonly LOCALE_SABBREVMONTHNAME10;
	private static readonly LOCALE_SABBREVMONTHNAME11;
	private static readonly LOCALE_SABBREVMONTHNAME12;
	private static readonly LOCALE_SABBREVMONTHNAME13;
	private static readonly LOCALE_SPOSITIVESIGN;
	private static readonly LOCALE_SNEGATIVESIGN;
	private static readonly LOCALE_IPOSSIGNPOSN;
	private static readonly LOCALE_INEGSIGNPOSN;
	private static readonly LOCALE_IPOSSYMPRECEDES;
	private static readonly LOCALE_IPOSSEPBYSPACE;
	private static readonly LOCALE_INEGSYMPRECEDES;
	private static readonly LOCALE_INEGSEPBYSPACE;
	private static readonly LOCALE_FONTSIGNATURE;
	private static readonly LOCALE_SISO639LANGNAME;
	private static readonly LOCALE_SISO3166CTRYNAME;
	private static readonly LOCALE_IDEFAULTEBCDICCODEPAGE;
	private static readonly LOCALE_IPAPERSIZE;
	private static readonly LOCALE_SENGCURRNAME;
	private static readonly LOCALE_SNATIVECURRNAME;
	private static readonly LOCALE_SYEARMONTH;
	private static readonly LOCALE_SSORTNAME;
	private static readonly LOCALE_IDIGITSUBSTITUTION;
	private static readonly LOCALE_SNAME;
	private static readonly LOCALE_SDURATION;
	private static readonly LOCALE_SKEYBOARDSTOINSTALL;
	private static readonly LOCALE_SSHORTESTDAYNAME1;
	private static readonly LOCALE_SSHORTESTDAYNAME2;
	private static readonly LOCALE_SSHORTESTDAYNAME3;
	private static readonly LOCALE_SSHORTESTDAYNAME4;
	private static readonly LOCALE_SSHORTESTDAYNAME5;
	private static readonly LOCALE_SSHORTESTDAYNAME6;
	private static readonly LOCALE_SSHORTESTDAYNAME7;
	private static readonly LOCALE_SISO639LANGNAME2;
	private static readonly LOCALE_SISO3166CTRYNAME2;
	private static readonly LOCALE_SNAN;
	private static readonly LOCALE_SPOSINFINITY;
	private static readonly LOCALE_SNEGINFINITY;
	private static readonly LOCALE_SSCRIPTS;
	private static readonly LOCALE_SPARENT;
	private static readonly LOCALE_SCONSOLEFALLBACKNAME;
	private static readonly LOCALE_IREADINGLAYOUT;
	private static readonly LOCALE_INEUTRAL;
	private static readonly LOCALE_INEGATIVEPERCENT;
	private static readonly LOCALE_IPOSITIVEPERCENT;
	private static readonly LOCALE_SPERCENT;
	private static readonly LOCALE_SPERMILLE;
	private static readonly LOCALE_SMONTHDAY;
	private static readonly LOCALE_SSHORTTIME;
	private static readonly LOCALE_SOPENTYPELANGUAGETAG;
	private static readonly LOCALE_SSORTLOCALE;
	static readonly TIME_NOSECONDS: uint;
	static nativeInitCultureData(cultureData: CultureData): boolean;
	static nativeGetNumberFormatInfoValues(localeName: string, nfi: NumberFormatInfo, useUserOverride: boolean): boolean;
	private static nativeEnumTimeFormats;
	static nativeEnumCultureNames(cultureTypes: int, retStringArray: any): int;
	static nativeGetLocaleInfoEx(localeName: string, field: string): string;
	static nativeGetLocaleInfoExInt(localeName: string, field: string): int;
	static nativeSetThreadLocale(localeName: string): boolean;
}
export declare class TokenHashValue {
	tokenString: string;
	tokenType: TokenType;
	tokenValue: int;
	constructor(tokenString: string, tokenType: TokenType, tokenValue: int);
}
export declare class DateTimeFormatInfo extends TObject implements ICloneable<DateTimeFormatInfo>, IFormatProvider {
	protected dispose(disposing: boolean): void;
	private static invariantInfo;
	private m_cultureData;
	m_name: string;
	private m_langName;
	private m_compareInfo;
	private m_cultureInfo;
	amDesignator: string;
	pmDesignator: string;
	dateSeparator: string;
	generalShortTimePattern: string;
	generalLongTimePattern: string;
	timeSeparator: string;
	monthDayPattern: string;
	dateTimeOffsetPattern: string;
	static readonly rfc1123Pattern: string;
	static readonly sortableDateTimePattern: string;
	static readonly universalSortableDateTimePattern: string;
	calendar: Calendar;
	firstDayOfWeek: int;
	calendarWeekRule: int;
	fullDateTimePattern: string;
	abbreviatedDayNames: string[];
	m_superShortDayNames: string[];
	dayNames: string[];
	abbreviatedMonthNames: string[];
	monthNames: string[];
	genitiveMonthNames: string[];
	m_genitiveAbbreviatedMonthNames: string[];
	leapYearMonthNames: string[];
	longDatePattern: string;
	shortDatePattern: string;
	yearMonthPattern: string;
	longTimePattern: string;
	shortTimePattern: string;
	private allYearMonthPatterns;
	allShortDatePatterns: string[];
	allLongDatePatterns: string[];
	allShortTimePatterns: string[];
	allLongTimePatterns: string[];
	m_eraNames: string[];
	m_abbrevEraNames: string[];
	m_abbrevEnglishEraNames: string[];
	optionalCalendars: IntArray;
	private static readonly DEFAULT_ALL_DATETIMES_SIZE;
	m_isReadOnly: boolean;
	static InitPreferExistingTokens(): boolean;
	formatFlags: DateTimeFormatFlags;
	static preferExistingTokens: boolean;
	private get CultureName();
	private get Culture();
	private get LanguageName();
	private internalGetAbbreviatedDayOfWeekNames;
	private internalGetSuperShortDayNames;
	private internalGetDayOfWeekNames;
	private internalGetAbbreviatedMonthNames;
	private internalGetMonthNames;
	constructor(cultureData?: CultureData, cal?: Calendar);
	private InitializeOverridableProperties;
	private CultureID;
	private m_useUserOverride;
	m_dateWords: string[];
	static get InvariantInfo(): DateTimeFormatInfo;
	static get CurrentInfo(): DateTimeFormatInfo;
	static GetInstance(provider: IFormatProvider): DateTimeFormatInfo;
	GetFormat(formatType: Type): any;
	Clone(): DateTimeFormatInfo;
	get AMDesignator(): string;
	set AMDesignator(value: string);
	get Calendar(): Calendar;
	set Calendar(value: Calendar);
	private get OptionalCalendars();
	GetEra(eraName: string): int;
	get EraNames(): string[];
	GetEraName(era: int): string;
	get AbbreviatedEraNames(): string[];
	GetAbbreviatedEraName(era: int): string;
	get AbbreviatedEnglishEraNames(): string[];
	get DateSeparator(): string;
	get FirstDayOfWeek(): DayOfWeek;
	set FirstDayOfWeek(value: DayOfWeek);
	get CalendarWeekRule(): CalendarWeekRule;
	set CalendarWeekRule(value: CalendarWeekRule);
	get FullDateTimePattern(): string;
	set FullDateTimePattern(value: string);
	get LongDatePattern(): string;
	set LongDatePattern(value: string);
	get LongTimePattern(): string;
	set LongTimePattern(value: string);
	get MonthDayPattern(): string;
	set MonthDayPattern(value: string);
	get PMDesignator(): string;
	set PMDesignator(value: string);
	get RFC1123Pattern(): string;
	get ShortDatePattern(): string;
	set ShortDatePattern(value: string);
	get ShortTimePattern(): string;
	set ShortTimePattern(value: string);
	get SortableDateTimePattern(): string;
	get GeneralShortTimePattern(): string;
	get GeneralLongTimePattern(): string;
	get DateTimeOffsetPattern(): string;
	get TimeSeparator(): string;
	get UniversalSortableDateTimePattern(): string;
	get YearMonthPattern(): string;
	set YearMonthPattern(value: string);
	private static CheckNullValue;
	get AbbreviatedDayNames(): string[];
	set AbbreviatedDayNames(value: string[]);
	get ShortestDayNames(): string[];
	set ShortestDayNames(value: string[]);
	get DayNames(): string[];
	set DayNames(value: string[]);
	get AbbreviatedMonthNames(): string[];
	set AbbreviatedMonthNames(value: string[]);
	get MonthNames(): string[];
	set MonthNames(value: string[]);
	get HasSpacesInMonthNames(): boolean;
	get HasSpacesInDayNames(): boolean;
	internalGetMonthName(month: int, style: MonthNameStyles, abbreviated: boolean): string;
	private internalGetGenitiveMonthNames;
	internalGetLeapYearMonthNames(): string[];
	GetAbbreviatedDayName(dayofweek: DayOfWeek): string;
	GetShortestDayName(dayOfWeek: DayOfWeek): string;
	private static GetCombinedPatterns;
	GetAllDateTimePatterns(): string[];
	GetAllDateTimePatterns(format: char): string[];
	GetDayName(dayofweek: DayOfWeek): string;
	GetAbbreviatedMonthName(month: int): string;
	GetMonthName(month: int): string;
	private static GetMergedPatterns;
	private get AllYearMonthPatterns();
	private get AllShortDatePatterns();
	private get AllShortTimePatterns();
	private get AllLongDatePatterns();
	private get AllLongTimePatterns();
	private get UnclonedYearMonthPatterns();
	private get UnclonedShortDatePatterns();
	private get UnclonedLongDatePatterns();
	private get UnclonedShortTimePatterns();
	private get UnclonedLongTimePatterns();
	static ReadOnly(dtfi: DateTimeFormatInfo): DateTimeFormatInfo;
	get IsReadOnly(): boolean;
	get NativeCalendarName(): string;
	SetAllDateTimePatterns(patterns: string[], format: char): void;
	get AbbreviatedMonthGenitiveNames(): string[];
	set AbbreviatedMonthGenitiveNames(value: string[]);
	get MonthGenitiveNames(): string[];
	set MonthGenitiveNames(value: string[]);
	private m_fullTimeSpanPositivePattern;
	get FullTimeSpanPositivePattern(): string;
	private m_fullTimeSpanNegativePattern;
	get FullTimeSpanNegativePattern(): string;
	get CompareInfo(): CompareInfo;
	static readonly InvalidDateTimeStyles: DateTimeStyles;
	static ValidateStyles(style: DateTimeStyles, parameterName: string): void;
	get FormatFlags(): DateTimeFormatFlags;
	get HasForceTwoDigitYears(): boolean;
	get HasYearMonthAdjustment(): boolean;
	YearMonthAdjustment(year: Out<int>, month: Out<int>, parsedMonthName: boolean): boolean;
	private m_dtfiTokenHash;
	private static readonly TOKEN_HASH_SIZE;
	private static readonly SECOND_PRIME;
	private static readonly dateSeparatorOrTimeZoneOffset;
	private static readonly invariantDateSeparator;
	private static readonly invariantTimeSeparator;
	static readonly IgnorablePeriod: string;
	static readonly IgnorableComma: string;
	static readonly CJKYearSuff: string;
	static readonly CJKMonthSuff: string;
	static readonly CJKDaySuff: string;
	static readonly KoreanYearSuff: string;
	static readonly KoreanMonthSuff: string;
	static readonly KoreanDaySuff: string;
	static readonly KoreanHourSuff: string;
	static readonly KoreanMinuteSuff: string;
	static readonly KoreanSecondSuff: string;
	static readonly CJKHourSuff: string;
	static readonly ChineseHourSuff: string;
	static readonly CJKMinuteSuff: string;
	static readonly CJKSecondSuff: string;
	static readonly JapaneseEraStart: string;
	static readonly LocalTimeMark: string;
	static readonly KoreanLangName: string;
	static readonly JapaneseLangName: string;
	static readonly EnglishLangName: string;
	private static s_jajpDTFI;
	private static s_zhtwDTFI;
	static GetJapaneseCalendarDTFI(): DateTimeFormatInfo;
	static GetTaiwanCalendarDTFI(): DateTimeFormatInfo;
	private ClearTokenHashTable;
	CreateTokenHashTable(): TokenHashValue[];
	private AddMonthNames;
	private static TryParseHebrewNumber;
	private static IsHebrewChar;
	Tokenize(TokenMask: TokenType, tokenType: Out<TokenType>, tokenValue: Out<int>, str: __DTString): boolean;
	private InsertAtCurrentHashNode;
	private InsertHash;
}
interface ISerializable {
	serialize(): string;
}
export declare class IntPtr implements ISerializable {
	private m_value;
	static readonly Zero: IntPtr;
	static get Size(): int;
	constructor(value: int);
	serialize(): string;
	get IsZero(): boolean;
	Equals(obj: IntPtr): boolean;
	GetHashCode(): int;
	GetObjectData(info: any, context: any): void;
	ToInt32(): int;
	ToInt64(): int;
	ToString(): string;
}
export declare class SafeFileHandle extends IntPtr {
	constructor(value: IntPtr, safe?: boolean);
}
declare enum BindingFlags {
	Default = 0,
	IgnoreCase = 1,
	DeclaredOnly = 2,
	Instance = 4,
	Static = 8,
	Public = 16,
	NonPublic = 32,
	FlattenHierarchy = 64,
	InvokeMethod = 256,
	CreateInstance = 512,
	GetField = 1024,
	SetField = 2048,
	GetProperty = 4096,
	SetProperty = 8192,
	PutDispProperty = 16384,
	PutRefDispProperty = 32768,
	ExactBinding = 65536,
	SuppressChangeType = 131072,
	OptionalParamBinding = 262144,
	IgnoreReturn = 16777216
}
declare enum MethodImplAttributes {
	CodeTypeMask = 3,
	IL = 0,
	Native = 1,
	OPTIL = 2,
	Runtime = 3,
	ManagedMask = 4,
	Unmanaged = 4,
	Managed = 0,
	ForwardRef = 16,
	PreserveSig = 128,
	InternalCall = 4096,
	Synchronized = 32,
	NoInlining = 8,
	NoOptimization = 64,
	MaxMethodImplVal = 65535,
	AggressiveInlining = 256
}
declare class ParameterInfo {
}
declare type InputData = number | ArrayBufferLike | ArrayBufferView | TBuffer | Buffer;
interface IOBufferOptions {
	/**
	 * Ignore the first n bytes of the ArrayBuffer.
	 */
	offset?: number;
}
export declare class TBuffer {
	/**
	 * Reference to the internal ArrayBuffer object.
	 */
	buffer: ArrayBufferLike;
	/**
	 * Byte length of the internal ArrayBuffer.
	 */
	byteLength: number;
	/**
	 * Byte offset of the internal ArrayBuffer.
	 */
	byteOffset: number;
	/**
	 * Byte length of the internal ArrayBuffer.
	 */
	length: number;
	/**
	 * The current offset of the buffer's pointer.
	 */
	offset: number;
	private lastWrittenByte;
	private littleEndian;
	private _data;
	private _mark;
	private _marks;
	/**
	 * @param data - The data to construct the IOBuffer with.
	 * If data is a number, it will be the new buffer's length<br>
	 * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
	 * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
	 * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
	 * @param options
	 */
	constructor(data?: InputData, options?: IOBufferOptions);
	/**
	 * Checks if the memory allocated to the buffer is sufficient to store more
	 * bytes after the offset.
	 * @param byteLength - The needed memory in bytes.
	 * @returns `true` if there is sufficient space and `false` otherwise.
	 */
	available(byteLength?: number): boolean;
	/**
	 * Check if little-endian mode is used for reading and writing multi-byte
	 * values.
	 * @returns `true` if little-endian mode is used, `false` otherwise.
	 */
	isLittleEndian(): boolean;
	/**
	 * Set little-endian mode for reading and writing multi-byte values.
	 */
	setLittleEndian(): this;
	/**
	 * Check if big-endian mode is used for reading and writing multi-byte values.
	 * @returns `true` if big-endian mode is used, `false` otherwise.
	 */
	isBigEndian(): boolean;
	/**
	 * Switches to big-endian mode for reading and writing multi-byte values.
	 */
	setBigEndian(): this;
	/**
	 * Move the pointer n bytes forward.
	 * @param n - Number of bytes to skip.
	 */
	skip(n?: number): this;
	/**
	 * Move the pointer to the given offset.
	 * @param offset
	 */
	seek(offset: number): this;
	/**
	 * Store the current pointer offset.
	 * @see {@link IOBuffer#reset}
	 */
	mark(): this;
	/**
	 * Move the pointer back to the last pointer offset set by mark.
	 * @see {@link IOBuffer#mark}
	 */
	reset(): this;
	/**
	 * Push the current pointer offset to the mark stack.
	 * @see {@link IOBuffer#popMark}
	 */
	pushMark(): this;
	/**
	 * Pop the last pointer offset from the mark stack, and set the current
	 * pointer offset to the popped value.
	 * @see {@link IOBuffer#pushMark}
	 */
	popMark(): this;
	/**
	 * Move the pointer offset back to 0.
	 */
	rewind(): this;
	/**
	 * Make sure the buffer has sufficient memory to write a given byteLength at
	 * the current pointer offset.
	 * If the buffer's memory is insufficient, this method will create a new
	 * buffer (a copy) with a length that is twice (byteLength + current offset).
	 * @param byteLength
	 */
	ensureAvailable(byteLength?: number): this;
	/**
	 * Read a byte and return false if the byte's value is 0, or true otherwise.
	 * Moves pointer forward by one byte.
	 */
	readBoolean(): boolean;
	/**
	 * Read a signed 8-bit integer and move pointer forward by 1 byte.
	 */
	readInt8(): number;
	/**
	 * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
	 */
	readUint8(): number;
	/**
	 * Alias for {@link IOBuffer#readUint8}.
	 */
	readByte(): number;
	/**
	 * Read `n` bytes and move pointer forward by `n` bytes.
	 */
	readBytes(n?: number): Uint8Array;
	/**
	 * Read a 16-bit signed integer and move pointer forward by 2 bytes.
	 */
	readInt16(): number;
	/**
	 * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
	 */
	readUint16(): number;
	/**
	 * Read a 32-bit signed integer and move pointer forward by 4 bytes.
	 */
	readInt32(): number;
	/**
	 * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
	 */
	readUint32(): number;
	/**
	 * Read a 32-bit floating number and move pointer forward by 4 bytes.
	 */
	readFloat32(): number;
	/**
	 * Read a 64-bit floating number and move pointer forward by 8 bytes.
	 */
	readFloat64(): number;
	/**
	 * Read a 1-byte ASCII character and move pointer forward by 1 byte.
	 */
	readChar(): string;
	/**
	 * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
	 */
	readChars(n?: number): string;
	/**
	 * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
	 * forward by `n` bytes.
	 */
	readUtf8(n?: number): string;
	/**
	 * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
	 * forward by 1 byte.
	 */
	writeBoolean(value: unknown): this;
	/**
	 * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
	 */
	writeInt8(value: number): this;
	/**
	 * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
	 * byte.
	 */
	writeUint8(value: number): this;
	/**
	 * An alias for {@link IOBuffer#writeUint8}.
	 */
	writeByte(value: number): this;
	/**
	 * Write all elements of `bytes` as uint8 values and move pointer forward by
	 * `bytes.length` bytes.
	 */
	writeBytes(bytes: ArrayLike<number>): this;
	/**
	 * Write `value` as a 16-bit signed integer and move pointer forward by 2
	 * bytes.
	 */
	writeInt16(value: number): this;
	/**
	 * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
	 * bytes.
	 */
	writeUint16(value: number): this;
	ReadLong(): number;
	WriteLong(value: number): this;
	/**
	 * Write `value` as a 32-bit signed integer and move pointer forward by 4
	 * bytes.
	 */
	writeInt32(value: number): this;
	/**
	 * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
	 * bytes.
	 */
	writeUint32(value: number): this;
	/**
	 * Write `value` as a 32-bit floating number and move pointer forward by 4
	 * bytes.
	 */
	writeFloat32(value: number): this;
	/**
	 * Write `value` as a 64-bit floating number and move pointer forward by 8
	 * bytes.
	 */
	writeFloat64(value: number): this;
	/**
	 * Write the charCode of `str`'s first character as an 8-bit unsigned integer
	 * and move pointer forward by 1 byte.
	 */
	writeChar(str: string): this;
	/**
	 * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
	 * and move pointer forward by `str.length` bytes.
	 */
	writeChars(str: string): this;
	/**
	 * UTF-8 encode and write `str` to the current pointer offset and move pointer
	 * forward according to the encoded length.
	 */
	writeUtf8(str: string): this;
	/**
	 * Export a Uint8Array view of the internal buffer.
	 * The view starts at the byte offset and its length
	 * is calculated to stop at the last written byte or the original length.
	 */
	toArray(): Uint8Array;
	/**
	 * Update the last written byte offset
	 * @private
	 */
	private _updateLastWrittenByte;
	DebugOutput(): void;
	static InternalBlockCopy(src: TypedArray, srcOffsetBytes: int, dst: TypedArray, dstOffsetBytes: int, byteCount: int): void;
}
export declare abstract class UMP extends TBuffer {
	private _pointer;
	protected get pointer(): number;
	protected set pointer(value: number);
	constructor();
	protected StructureToPtr(ptr: number): void;
	protected PtrToStructure(ptr: number): void;
	Dispose(): void;
}
export declare abstract class UMO extends TBuffer {
	protected pointer: number;
	constructor(pointer?: number);
	Dispose(): void;
}
export declare class Marshal {
	static get Heap8(): Uint8Array;
	/**
	 * Allocates memory from the unmanaged memory of the process by using the specified number of bytes.
	 * @param cb
	 */
	static AllocHGlobal(cb: int): IntPtr;
	static FreeHGlobal(hglobal: IntPtr): void;
	static ReadByte(ptr: IntPtr, ofs: int): byte;
	static WriteByte(ptr: IntPtr, ofs: int, val: byte): void;
	static ReadInt16(ptr: IntPtr, ofs: int): byte;
	static WriteInt16(ptr: IntPtr, ofs: int, val: char): void;
	static ReadInt32(ptr: IntPtr, ofs: int): byte;
	static WriteInt32(ptr: IntPtr, ofs: int, val: int): void;
	static SizeOf(structure: any): int;
	static StructureToPtr<T extends UMP>(structure: T, ptr: IntPtr, fDeleteOld: boolean): void;
	static PtrToStructure<T extends UMP>(ptr: IntPtr, type: Type): T;
	static PtrToStringUni(ptr: IntPtr): string;
	static Copy(buffer: IntArray, index: int, ptr: IntPtr, size: int): any;
	static Copy(buffer: ByteArray, index: int, ptr: IntPtr, size: int): any;
	static Copy(ptr: IntPtr, buffer: ByteArray, index: int, size: int): any;
	static Copy(ptr: IntPtr, buffer: IntArray, index: int, size: int): any;
	static Copy(ptr: IntPtr, buffer: ByteArray, index: int, size: int): any;
	static GetBufferFromPointer(ptr: IntPtr): TBuffer;
}
declare class RuntimeMethodHandle {
	private value;
	constructor(v: IntPtr);
	get Value(): IntPtr;
	private static GetFunctionPointer;
	GetFunctionPointer(): IntPtr;
	Equals(handle: RuntimeMethodHandle): boolean;
	GetHashCode(): int;
}
declare class RuntimeTypeHandle {
	private value;
	constructor(val: IntPtr);
	get Value(): IntPtr;
	Equals(handle: RuntimeTypeHandle): boolean;
	GetHashCode(): int;
	GetModuleHandle(): any;
}
declare enum MethodAttributes {
	MemberAccessMask = 7,
	PrivateScope = 0,
	Private = 1,
	FamANDAssem = 2,
	Assembly = 3,
	Family = 4,
	FamORAssem = 5,
	Public = 6,
	Static = 16,
	Final = 32,
	Virtual = 64,
	HideBySig = 128,
	CheckAccessOnOverride = 512,
	VtableLayoutMask = 256,
	ReuseSlot = 0,
	NewSlot = 256,
	Abstract = 1024,
	SpecialName = 2048,
	PinvokeImpl = 8192,
	UnmanagedExport = 8,
	RTSpecialName = 4096,
	ReservedMask = 53248,
	HasSecurity = 16384,
	RequireSecObject = 32768
}
declare enum CallingConventions {
	Standard = 1,
	VarArgs = 2,
	Any = 3,
	HasThis = 32,
	ExplicitThis = 64
}
declare type Binder = any;
declare type MethodBody = any;
declare abstract class MethodBase extends MemberInfo {
	static GetCurrentMethod(): MethodBase;
	static GetMethodFromHandleNoGenericCheck(handle: RuntimeMethodHandle): MethodBase;
	private static GetMethodFromIntPtr;
	static GetMethodFromHandle(handle: RuntimeMethodHandle): MethodBase;
	static GetMethodFromHandle(handle: RuntimeMethodHandle, declaringType: RuntimeTypeHandle): MethodBase;
	private static GetMethodFromHandleInternalType;
	abstract GetMethodImplementationFlags(): MethodImplAttributes;
	abstract GetParameters(): ParameterInfo[];
	GetParametersInternal(): ParameterInfo[];
	GetParametersCount(): int;
	GetParameterType(pos: int): Type;
	abstract Invoke(obj: any, invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any;
	protected constructor();
	protected abstract Get_MethodHandle(): RuntimeMethodHandle;
	get MethodHandle(): RuntimeMethodHandle;
	protected abstract Get_Attributes(): MethodAttributes;
	get Attributes(): MethodAttributes;
	get CallingConvention(): CallingConventions;
	get IsPublic(): Boolean;
	get IsPrivate(): boolean;
	get IsFamily(): boolean;
	get IsAssembly(): boolean;
	get IsFamilyAndAssembly(): boolean;
	get IsFamilyOrAssembly(): boolean;
	get IsStatic(): boolean;
	get IsFinal(): boolean;
	get IsVirtual(): boolean;
	get IsHideBySig(): boolean;
	get IsAbstract(): boolean;
	get IsSpecialName(): boolean;
	get IsConstructor(): boolean;
	get_next_table_index(obj: any, table: int, inc: boolean): int;
	GetGenericArguments(): Type[];
	get ContainsGenericParameters(): boolean;
	get IsGenericMethodDefinition(): boolean;
	get IsGenericMethod(): boolean;
	static GetMethodBodyInternal(handle: IntPtr): MethodBody;
	static GetMethodBody(handle: IntPtr): MethodBody;
	GetMethodBody(): MethodBody;
	Equals(obj: any): boolean;
}
declare abstract class MethodInfo extends MethodBase {
	getMemberType(): MemberTypes;
	private myReturnParameter;
	get ReturnParameter(): ParameterInfo;
	protected getReturnParameter(): ParameterInfo;
	private myReturnType;
	get ReturnType(): Type;
	protected getReturnType(): Type;
	get ReturnTypeCustomAttributes(): ICustomAttributeProvider;
	protected abstract getReturnTypeCustomAttributes(): ICustomAttributeProvider;
	constructor();
}
declare enum PropertyAttributes {
	None = 0,
	SpecialName = 512,
	RTSpecialName = 1024,
	HasDefault = 4096,
	Reserved2 = 8192,
	Reserved3 = 16384,
	Reserved4 = 32768,
	ReservedMask = 62464
}
declare class PropertyInfo extends MemberInfo {
	Get_DeclaringType(): Type;
	protected Get_MemberType(): MemberTypes;
	Get_Name(): string;
	protected Get_ReflectedType(): Type;
	IsDefined(attributeType: Type, inherit: boolean): boolean;
	GetCustomAttributes(inherit: boolean): any[];
	GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
	protected dispose(disposing: boolean): void;
	private myCanRead;
	private myCanWrite;
	get Attributes(): PropertyAttributes;
	protected getAttributes(): PropertyAttributes;
	get CanRead(): boolean;
	protected getCanRead(): boolean;
	get CanWrite(): boolean;
	protected getCanWrite(): boolean;
	private myGetMethod;
	get GetMethod(): MethodInfo;
	protected getGetMethod(): MethodInfo;
	private myIsSpecialName;
	get IsSpecialName(): boolean;
	protected getMemberType(): MemberTypes;
	private myPropertyType;
	get PropertyType(): Type;
	protected getPropertyType(): Type;
	private mySetMethod;
	get SetMethod(): MethodInfo;
	protected getSetMethod(): MethodInfo;
	protected getDeclaringType(): Type;
	constructor();
}
declare type Binder = any;
declare type CultureInfo = any;
declare abstract class ConstructorInfo extends MethodBase {
	static readonly ConstructorName: string;
	static readonly TypeConstructorName: string;
	protected constructor();
	protected Get_MemberType(): MemberTypes;
	Invoke(parameters: any[]): any;
	Invoke(invokeAttr: BindingFlags, binder: Binder, parameters: any[], culture: CultureInfo): any;
}
declare enum TypeAttributes {
	NotPublic = 0,
	AutoLayout = 0,
	Class = 0,
	AnsiClass = 0,
	Public = 1,
	NestedPublic = 2,
	NestedPrivate = 3,
	NestedFamily = 4,
	NestedAssembly = 5,
	NestedFamANDAssem = 6,
	VisibilityMask = 7,
	NestedFamORAssem = 7,
	SequentialLayout = 8,
	ExplicitLayout = 16,
	LayoutMask = 24,
	ClassSemanticsMask = 32,
	Interface = 32,
	Abstract = 128,
	Sealed = 256,
	SpecialName = 1024,
	RTSpecialName = 2048,
	Import = 4096,
	Serializable = 8192,
	WindowsRuntime = 16384,
	UnicodeClass = 65536,
	AutoClass = 131072,
	StringFormatMask = 196608,
	CustomFormatClass = 196608,
	HasSecurity = 262144,
	ReservedMask = 264192,
	BeforeFieldInit = 1048576,
	CustomFormatMask = 12582912
}
export declare class VoidType extends Type {
	protected Set_FullName(value: string): void;
	protected Get_Assembly(): Assembly;
	protected Get_AssemblyQualifiedName(): string;
	protected Get_BaseType(): Type;
	protected Get_FullName(): string;
	protected Get_GUID(): string;
	Get_Namespace(): string;
	protected GetConstructorImpl(bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): ConstructorInfo;
	protected Get_UnderlyingSystemType(): Type;
	GetInterfaces(): Type[];
	GetElementType(): Type;
	protected GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): MethodInfo;
	protected GetPropertyImpl(name: string, bindingAttr: BindingFlags, binder: any, returnType: Type, types: Type[], modifiers: any[]): void;
	protected GetAttributeFlagsImpl(): TypeAttributes;
	protected HasElementTypeImpl(): boolean;
	protected IsArrayImpl(): boolean;
	protected IsByRefImpl(): boolean;
	protected IsCOMObjectImpl(): boolean;
	protected IsPointerImpl(): boolean;
	protected IsPrimitiveImpl(): boolean;
	GetCustomAttributes(inherit: boolean): any[];
	GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
	Get_DeclaringType(): Type;
	Get_MemberType(): MemberTypes;
	Get_Name(): string;
	Get_ReflectedType(): Type;
	IsDefined(attributeType: Type, inherit: boolean): boolean;
	protected dispose(disposing: boolean): void;
	GetProperty(name: string): PropertyInfo;
	GetProperty(name: string, returnType: Type): PropertyInfo;
	protected getMemberType(): MemberTypes;
}
export declare class StringType extends Type {
	protected Set_FullName(value: string): void;
	protected Get_Assembly(): Assembly;
	protected Get_AssemblyQualifiedName(): string;
	protected Get_BaseType(): Type;
	protected Get_FullName(): string;
	protected Get_GUID(): string;
	Get_Namespace(): string;
	protected GetConstructorImpl(bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): ConstructorInfo;
	protected Get_UnderlyingSystemType(): Type;
	GetInterfaces(): Type[];
	GetElementType(): Type;
	protected GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): MethodInfo;
	protected GetPropertyImpl(name: string, bindingAttr: BindingFlags, binder: any, returnType: Type, types: Type[], modifiers: any[]): void;
	protected GetAttributeFlagsImpl(): TypeAttributes;
	protected HasElementTypeImpl(): boolean;
	protected IsArrayImpl(): boolean;
	protected IsByRefImpl(): boolean;
	protected IsCOMObjectImpl(): boolean;
	protected IsPointerImpl(): boolean;
	protected IsPrimitiveImpl(): boolean;
	Get_Name(): string;
	IsDefined(attributeType: Type, inherit: boolean): boolean;
	GetCustomAttributes(inherit: boolean): any[];
	GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
	protected dispose(disposing: boolean): void;
	GetProperty(name: string): PropertyInfo;
	GetProperty(name: string, returnType: Type): PropertyInfo;
	protected getMemberType(): MemberTypes;
}
export declare class ArrayType extends Type {
	protected Set_FullName(value: string): void;
	protected Get_Assembly(): Assembly;
	protected Get_AssemblyQualifiedName(): string;
	protected Get_BaseType(): Type;
	protected Get_FullName(): string;
	protected Get_GUID(): string;
	Get_Namespace(): string;
	protected GetConstructorImpl(bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): ConstructorInfo;
	protected Get_UnderlyingSystemType(): Type;
	GetInterfaces(): Type[];
	GetElementType(): Type;
	protected GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): MethodInfo;
	protected GetPropertyImpl(name: string, bindingAttr: BindingFlags, binder: any, returnType: Type, types: Type[], modifiers: any[]): void;
	protected GetAttributeFlagsImpl(): TypeAttributes;
	protected HasElementTypeImpl(): boolean;
	protected IsArrayImpl(): boolean;
	protected IsByRefImpl(): boolean;
	protected IsCOMObjectImpl(): boolean;
	protected IsPointerImpl(): boolean;
	protected IsPrimitiveImpl(): boolean;
	Get_Name(): string;
	IsDefined(attributeType: Type, inherit: boolean): boolean;
	GetCustomAttributes(inherit: boolean): any[];
	GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
	protected dispose(disposing: boolean): void;
	GetProperty(name: string): PropertyInfo;
	GetProperty(name: string, returnType: Type): PropertyInfo;
	protected getMemberType(): MemberTypes;
}
export declare class NumberType extends Type {
	protected Set_FullName(value: string): void;
	protected Get_Assembly(): Assembly;
	protected Get_AssemblyQualifiedName(): string;
	protected Get_BaseType(): Type;
	protected Get_FullName(): string;
	protected Get_GUID(): string;
	Get_Namespace(): string;
	protected GetConstructorImpl(bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): ConstructorInfo;
	protected Get_UnderlyingSystemType(): Type;
	GetInterfaces(): Type[];
	GetElementType(): Type;
	protected GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): MethodInfo;
	protected GetPropertyImpl(name: string, bindingAttr: BindingFlags, binder: any, returnType: Type, types: Type[], modifiers: any[]): void;
	protected GetAttributeFlagsImpl(): TypeAttributes;
	protected HasElementTypeImpl(): boolean;
	protected IsArrayImpl(): boolean;
	protected IsByRefImpl(): boolean;
	protected IsCOMObjectImpl(): boolean;
	protected IsPointerImpl(): boolean;
	protected IsPrimitiveImpl(): boolean;
	Get_Name(): string;
	IsDefined(attributeType: Type, inherit: boolean): boolean;
	GetCustomAttributes(inherit: boolean): any[];
	GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
	protected dispose(disposing: boolean): void;
	GetProperty(name: string): PropertyInfo;
	GetProperty(name: string, returnType: Type): PropertyInfo;
	protected getMemberType(): MemberTypes;
}
export declare class BooleanType extends Type {
	protected Set_FullName(value: string): void;
	protected Get_Assembly(): Assembly;
	protected Get_AssemblyQualifiedName(): string;
	protected Get_BaseType(): Type;
	protected Get_FullName(): string;
	protected Get_GUID(): string;
	Get_Namespace(): string;
	protected GetConstructorImpl(bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): ConstructorInfo;
	protected Get_UnderlyingSystemType(): Type;
	GetInterfaces(): Type[];
	GetElementType(): Type;
	protected GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): MethodInfo;
	protected GetPropertyImpl(name: string, bindingAttr: BindingFlags, binder: any, returnType: Type, types: Type[], modifiers: any[]): void;
	protected GetAttributeFlagsImpl(): TypeAttributes;
	protected HasElementTypeImpl(): boolean;
	protected IsArrayImpl(): boolean;
	protected IsByRefImpl(): boolean;
	protected IsCOMObjectImpl(): boolean;
	protected IsPointerImpl(): boolean;
	protected IsPrimitiveImpl(): boolean;
	Get_Name(): string;
	IsDefined(attributeType: Type, inherit: boolean): boolean;
	GetCustomAttributes(inherit: boolean): any[];
	GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
	protected dispose(disposing: boolean): void;
	GetProperty(name: string): PropertyInfo;
	GetProperty(name: string, returnType: Type): PropertyInfo;
	protected getMemberType(): MemberTypes;
}
export declare class PrimitiveTypes {
	static Array: ArrayType;
	static Number: NumberType;
	static Boolean: BooleanType;
	static String: StringType;
	static Void: VoidType;
}
declare const VOID0: undefined, _BOOLEAN: "boolean", _NUMBER: "number", _STRING: "string", _SYMBOL: "symbol", _OBJECT: "object", _UNDEFINED: "undefined", _FUNCTION: "function", LENGTH: string;
/**
 * Exposes easy access to type information including inquiring about members.
 */
export declare class TypeInfo {
	protected readonly target: any;
	readonly type: string;
	readonly isBoolean: boolean;
	readonly isNumber: boolean;
	readonly isFinite: boolean;
	readonly isValidNumber: boolean;
	readonly isString: boolean;
	readonly isTrueNaN: boolean;
	readonly isObject: boolean;
	readonly isArray: boolean;
	readonly isFunction: boolean;
	readonly isUndefined: boolean;
	readonly isNull: boolean;
	readonly isNullOrUndefined: boolean;
	readonly isPrimitive: boolean;
	readonly isSymbol: boolean;
	constructor(target: any, onBeforeFreeze?: (instance: any) => void);
	/**
	 * Returns a TypeInfo for any member or non-member,
	 * where non-members are of type undefined.
	 * @param name
	 * @returns {TypeInfo}
	 */
	member(name: string | number | symbol): TypeInfo;
	/**
	 * Returns a TypeInfo for any target object.
	 * If the target object is of a primitive type, it returns the TypeInfo instance assigned to that type.
	 * @param target
	 * @returns {TypeInfo}
	 */
	static getFor(target: any): TypeInfo;
	/**
	 * Returns true if the target matches the type (instanceof).
	 * @param type
	 * @returns {boolean}
	 */
	is<T>(type: {
		new (...params: any[]): T;
	}): boolean;
	/**
	 * Returns null if the target does not match the type (instanceof).
	 * Otherwise returns the target as the type.
	 * @param type
	 * @returns {T|null}
	 */
	as<T>(type: {
		new (...params: any[]): T;
	}): T | null;
}
declare enum FieldAttributes {
	PrivateScope = 0,
	Private = 1,
	FamANDAssem = 2,
	Assembly = 3,
	Family = 4,
	FamORAssem = 5,
	Public = 6,
	FieldAccessMask = 7,
	Static = 16,
	InitOnly = 32,
	Literal = 64,
	NotSerialized = 128,
	HasFieldRVA = 256,
	SpecialName = 512,
	RTSpecialName = 1024,
	HasFieldMarshal = 4096,
	PinvokeImpl = 8192,
	HasDefault = 32768,
	ReservedMask = 38144
}
declare class FieldInfo extends MemberInfo {
	Get_DeclaringType(): Type;
	protected Get_MemberType(): MemberTypes;
	Get_Name(): string;
	protected Get_ReflectedType(): Type;
	IsDefined(attributeType: Type, inherit: boolean): boolean;
	GetCustomAttributes(inherit: boolean): any[];
	GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
	protected dispose(disposing: boolean): void;
	get Attributes(): FieldAttributes;
	protected getAttributes(): FieldAttributes;
	private myFieldType;
	get FieldType(): Type;
	protected getFieldType(): Type;
	private myIsAssembly;
	get IsAssembly(): boolean;
	private myIsFamily;
	get IsFamily(): boolean;
	private myIsFamilyAndAssembly;
	get IsFamilyAndAssembly(): boolean;
	private myIsFamilyOrAssembly;
	get IsFamilyOrAssembly(): boolean;
	private myIsInitOnly;
	get IsInitOnly(): boolean;
	private myIsLiteral;
	get IsLiteral(): boolean;
	private myIsNotSerialized;
	get IsNotSerialized(): boolean;
	private myIsPrivate;
	get IsPrivate(): boolean;
	private myIsPublic;
	get IsPublic(): boolean;
	protected getMemberType(): MemberTypes;
	protected getDeclaringType(): Type;
	constructor();
}
interface InterfaceTypeConfig {
	baseType: Type;
	name: string;
	fullName: string;
	methods: MethodInfo[];
	fields: FieldInfo[];
}
declare class InterfaceType extends Type {
	protected Set_FullName(value: string): void;
	protected Get_Assembly(): Assembly;
	protected Get_AssemblyQualifiedName(): string;
	protected Get_BaseType(): Type;
	protected Get_FullName(): string;
	protected Get_GUID(): string;
	Get_Namespace(): string;
	protected GetConstructorImpl(bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): ConstructorInfo;
	protected Get_UnderlyingSystemType(): Type;
	GetInterfaces(): Type[];
	GetElementType(): Type;
	protected GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: any, callConvention: CallingConventions, types: Type[], modifiers: any[]): MethodInfo;
	protected GetPropertyImpl(name: string, bindingAttr: BindingFlags, binder: any, returnType: Type, types: Type[], modifiers: any[]): void;
	protected GetAttributeFlagsImpl(): TypeAttributes;
	protected HasElementTypeImpl(): boolean;
	protected IsArrayImpl(): boolean;
	protected IsByRefImpl(): boolean;
	protected IsCOMObjectImpl(): boolean;
	protected IsPointerImpl(): boolean;
	protected IsPrimitiveImpl(): boolean;
	Get_Name(): string;
	IsDefined(attributeType: Type, inherit: boolean): boolean;
	GetCustomAttributes(inherit: boolean): any[];
	GetCustomAttributes(attributeType: Type, inherit: boolean): any[];
	protected dispose(disposing: boolean): void;
	private myMethods;
	private myFields;
	getMemberType(): MemberTypes;
	constructor(config?: InterfaceTypeConfig);
	GetProperty(name: string): PropertyInfo;
	GetProperty(name: string, returnType: Type): PropertyInfo;
}
export declare function typeOf(objName: string | Symbol | object): Type;
interface ClassTypeConfig {
	baseType?: Type;
	name?: string;
	fullName?: Symbol;
	implements?: InterfaceType[];
	instanceof?: Symbol[];
	package?: string;
}
export declare function ClassInfo(config: ClassTypeConfig): (target: any) => void;
export declare function sealed(): (target: any) => void;
export declare function Internal(target: any, propertyKey: string, descriptor: PropertyDescriptor): void;
export declare function Override(target: any, propertyKey: string, descriptor: PropertyDescriptor): void;
export declare function Virtual(target: any, propertyKey: string, descriptor: PropertyDescriptor): void;
export declare function Package(packageName: any): (target: any) => void;
export interface ModuleMetadata {
	name?: string | Symbol;
	fullName?: string | Symbol;
	instanceof?: Symbol[];
}
export declare function Class(metadata: ModuleMetadata): ClassDecorator;
export declare class Reflection {
	static GetMetadata(metadata: any, target: Object): any;
}
export declare class Reflect {
	static decorate(decorators: any, target: any, propertyKey: any, attributes: any): any;
	/**
	 * A default metadata decorator factory that can be used on a class, class member, or parameter.
	 * @param metadataKey The key for the metadata entry.
	 * @param metadataValue The value for the metadata entry.
	 * @returns A decorator function.
	 * @remarks
	 * If `metadataKey` is already defined for the target and target key, the
	 * metadataValue for that key will be overwritten.
	 * @example
	 *
	 *     // constructor
	 *     @Reflect.metadata(key, value)
	 *     class Example {
	 *     }
	 *
	 *     // property (on constructor, TypeScript only)
	 *     class Example {
	 *         @Reflect.metadata(key, value)
	 *         static staticProperty;
	 *     }
	 *
	 *     // property (on prototype, TypeScript only)
	 *     class Example {
	 *         @Reflect.metadata(key, value)
	 *         property;
	 *     }
	 *
	 *     // method (on constructor)
	 *     class Example {
	 *         @Reflect.metadata(key, value)
	 *         static staticMethod() { }
	 *     }
	 *
	 *     // method (on prototype)
	 *     class Example {
	 *         @Reflect.metadata(key, value)
	 *         method() { }
	 *     }
	 *
	 */
	static metadata(metadataKey: any, metadataValue: any): (target: any, propertyKey: any) => void;
	/**
	 * Define a unique metadata entry on the target.
	 * @param metadataKey A key used to store and retrieve metadata.
	 * @param metadataValue A value that contains attached metadata.
	 * @param target The target object on which to define metadata.
	 * @param propertyKey (Optional) The property key for the target.
	 * @example
	 *
	 *     class Example {
	 *         // property declarations are not part of ES6, though they are valid in TypeScript:
	 *         // static staticProperty;
	 *         // property;
	 *
	 *         constructor(p) { }
	 *         static staticMethod(p) { }
	 *         method(p) { }
	 *     }
	 *
	 *     // constructor
	 *     Reflect.defineMetadata("custom:annotation", options, Example);
	 *
	 *     // property (on constructor)
	 *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
	 *
	 *     // property (on prototype)
	 *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
	 *
	 *     // method (on constructor)
	 *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
	 *
	 *     // method (on prototype)
	 *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
	 *
	 *     // decorator factory as metadata-producing annotation.
	 *     function MyAnnotation(options): Decorator {
	 *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
	 *     }
	 *
	 */
	static defineMetadata(metadataKey: any, metadataValue: any, target: any, propertyKey?: any): void;
	/**
 * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
 * @param metadataKey A key used to store and retrieve metadata.
 * @param target The target object on which the metadata is defined.
 * @param propertyKey (Optional) The property key for the target.
 * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
 * @example
 *
 *     class Example {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     result = Reflect.hasMetadata("custom:annotation", Example);
 *
 *     // property (on constructor)
 *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
 *
 *     // property (on prototype)
 *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
 *
 *     // method (on constructor)
 *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
 *
 *     // method (on prototype)
 *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
 *
 */
	static hasMetadata(metadataKey: any, target: any, propertyKey: any): any;
	/**
	 * Gets a value indicating whether the target object has the provided metadata key defined.
	 * @param metadataKey A key used to store and retrieve metadata.
	 * @param target The target object on which the metadata is defined.
	 * @param propertyKey (Optional) The property key for the target.
	 * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
	 * @example
	 *
	 *     class Example {
	 *         // property declarations are not part of ES6, though they are valid in TypeScript:
	 *         // static staticProperty;
	 *         // property;
	 *
	 *         constructor(p) { }
	 *         static staticMethod(p) { }
	 *         method(p) { }
	 *     }
	 *
	 *     // constructor
	 *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
	 *
	 *     // property (on constructor)
	 *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
	 *
	 *     // property (on prototype)
	 *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
	 *
	 *     // method (on constructor)
	 *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
	 *
	 *     // method (on prototype)
	 *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
	 *
	 */
	static hasOwnMetadata(metadataKey: any, target: any, propertyKey: any): boolean;
	/**
 * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
 * @param metadataKey A key used to store and retrieve metadata.
 * @param target The target object on which the metadata is defined.
 * @param propertyKey (Optional) The property key for the target.
 * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
 * @example
 *
 *     class Example {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     result = Reflect.getMetadata("custom:annotation", Example);
 *
 *     // property (on constructor)
 *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
 *
 *     // property (on prototype)
 *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
 *
 *     // method (on constructor)
 *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
 *
 *     // method (on prototype)
 *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
 *
 */
	static getMetadata(metadataKey: any, target: any, propertyKey?: any): any;
	/**
	 * Gets the metadata value for the provided metadata key on the target object.
	 * @param metadataKey A key used to store and retrieve metadata.
	 * @param target The target object on which the metadata is defined.
	 * @param propertyKey (Optional) The property key for the target.
	 * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
	 * @example
	 *
	 *     class Example {
	 *         // property declarations are not part of ES6, though they are valid in TypeScript:
	 *         // static staticProperty;
	 *         // property;
	 *
	 *         constructor(p) { }
	 *         static staticMethod(p) { }
	 *         method(p) { }
	 *     }
	 *
	 *     // constructor
	 *     result = Reflect.getOwnMetadata("custom:annotation", Example);
	 *
	 *     // property (on constructor)
	 *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
	 *
	 *     // property (on prototype)
	 *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
	 *
	 *     // method (on constructor)
	 *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
	 *
	 *     // method (on prototype)
	 *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
	 *
	 */
	static getOwnMetadata(metadataKey: any, target: any, propertyKey?: any): any;
	/**
	 * Gets the metadata keys defined on the target object or its prototype chain.
	 * @param target The target object on which the metadata is defined.
	 * @param propertyKey (Optional) The property key for the target.
	 * @returns An array of unique metadata keys.
	 * @example
	 *
	 *     class Example {
	 *         // property declarations are not part of ES6, though they are valid in TypeScript:
	 *         // static staticProperty;
	 *         // property;
	 *
	 *         constructor(p) { }
	 *         static staticMethod(p) { }
	 *         method(p) { }
	 *     }
	 *
	 *     // constructor
	 *     result = Reflect.getMetadataKeys(Example);
	 *
	 *     // property (on constructor)
	 *     result = Reflect.getMetadataKeys(Example, "staticProperty");
	 *
	 *     // property (on prototype)
	 *     result = Reflect.getMetadataKeys(Example.prototype, "property");
	 *
	 *     // method (on constructor)
	 *     result = Reflect.getMetadataKeys(Example, "staticMethod");
	 *
	 *     // method (on prototype)
	 *     result = Reflect.getMetadataKeys(Example.prototype, "method");
	 *
	 */
	static getMetadataKeys(target: any, propertyKey: any): any;
	/**
	 * Gets the unique metadata keys defined on the target object.
	 * @param target The target object on which the metadata is defined.
	 * @param propertyKey (Optional) The property key for the target.
	 * @returns An array of unique metadata keys.
	 * @example
	 *
	 *     class Example {
	 *         // property declarations are not part of ES6, though they are valid in TypeScript:
	 *         // static staticProperty;
	 *         // property;
	 *
	 *         constructor(p) { }
	 *         static staticMethod(p) { }
	 *         method(p) { }
	 *     }
	 *
	 *     // constructor
	 *     result = Reflect.getOwnMetadataKeys(Example);
	 *
	 *     // property (on constructor)
	 *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
	 *
	 *     // property (on prototype)
	 *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
	 *
	 *     // method (on constructor)
	 *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
	 *
	 *     // method (on prototype)
	 *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
	 *
	 */
	static getOwnMetadataKeys(target: any, propertyKey: any): any[];
	/**
 * Deletes the metadata entry from the target object with the provided key.
 * @param metadataKey A key used to store and retrieve metadata.
 * @param target The target object on which the metadata is defined.
 * @param propertyKey (Optional) The property key for the target.
 * @returns `true` if the metadata entry was found and deleted; otherwise, false.
 * @example
 *
 *     class Example {
 *         // property declarations are not part of ES6, though they are valid in TypeScript:
 *         // static staticProperty;
 *         // property;
 *
 *         constructor(p) { }
 *         static staticMethod(p) { }
 *         method(p) { }
 *     }
 *
 *     // constructor
 *     result = Reflect.deleteMetadata("custom:annotation", Example);
 *
 *     // property (on constructor)
 *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
 *
 *     // property (on prototype)
 *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
 *
 *     // method (on constructor)
 *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
 *
 *     // method (on prototype)
 *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
 *
 */
	static deleteMetadata(metadataKey: any, target: any, propertyKey: any): boolean;
}
export interface IDisposable {
	Dispose(): void;
}
interface IDisposableAware extends IDisposable {
	wasDisposed: boolean;
}
export interface Selector<TSource, TResult> {
	(source: TSource): TResult;
}
export interface SelectorWithIndex<TSource, TResult> {
	(source: TSource, index: number): TResult;
}
export interface Action<T> extends Selector<T, void> {
}
export interface Action2<T1, T2> {
	(arg1: T1, arg2: T2): void;
}
export interface ActionWithIndex<T> extends SelectorWithIndex<T, void> {
}
export interface Predicate<T> extends Selector<T, boolean> {
}
export interface PredicateWithIndex<T> extends SelectorWithIndex<T, boolean> {
}
export interface Comparison<T> {
	(a: T, b: T, strict?: boolean): number;
}
export interface EqualityComparison<T> {
	(a: T, b: T, strict?: boolean): boolean;
}
export interface Func<TResult> {
	(): TResult;
}
export interface Func1<T1, TResult> {
	(args1: T1): TResult;
}
export interface Closure {
	(): void;
}
export declare abstract class DisposableBase implements IDisposableAware {
	private readonly __finalizer?;
	constructor(__finalizer?: Closure | null | undefined);
	private __wasDisposed;
	get wasDisposed(): boolean;
	protected _disposableObjectName: string;
	protected throwIfDisposed(message?: string, objectName?: string): true | never;
	Dispose(): void;
	protected _onDispose(): void;
}
export declare function using<TDisposable extends IDisposable, TReturn>(disposable: TDisposable, closure: (disposable: TDisposable) => TReturn): TReturn;
export interface IMap<TValue> {
	[key: string]: TValue;
}
export interface Error {
	name: string;
	message: string;
}
/**
 * Represents errors that occur during application execution.
 */
export declare class Exception implements Error, IDisposable {
	readonly message: string;
	/**
	 * A string representation of the error type.
	 * The default is 'Error'.
	 */
	readonly name: string;
	readonly stack: string;
	readonly data: IMap<any>;
	/**
	 * Initializes a new instance of the Exception class with a specified error message and optionally a reference to the inner exception that is the cause of this exception.
	 * @param message
	 * @param innerException
	 * @param beforeSealing This delegate is used to allow actions to occur just before this constructor finishes.  Since some compilers do not allow the use of 'this' before super.
	 */
	constructor(message: string, innerException?: Error, beforeSealing?: (ex: any) => void);
	/**
	 * A string representation of the error type.
	 * The default is 'Error'.
	 */
	protected getName(): string;
	/**
	 * The string representation of the Exception instance.
	 */
	ToString(): string;
	protected toStringWithoutBrackets(): string;
	/**
	 * Clears the data object.
	 */
	Dispose(): void;
}
export declare class SystemException extends Exception {
	protected getName(): string;
}
export declare class InvalidOperationException extends SystemException {
	protected getName(): string;
}
export declare class ObjectDisposedException extends InvalidOperationException {
	readonly objectName: string;
	constructor(objectName: string, message?: string, innerException?: Error);
	protected getName(): string;
	ToString(): string;
	static throwIfDisposed(disposable: IDisposableAware, objectName: string, message?: string): true | never;
}
export declare abstract class TObject implements IDisposable {
	/**
 * Convenience wrapper for `Object.assign`.
 *
 * @param {Object} target
 * @param {...Object} others
 *
 * @return {Object} the target
 */
	static Assign(target: any, ...others: any[]): any;
	static ToString(value: any, defaultForUnknown?: string): string;
	ToString(): string;
	private toString;
	protected Finalize(): void;
	Equals<T>(obj: T): boolean;
	static Equals(value: any, obj: any): boolean;
	GetHashCode(): int;
	static GetHashCode(value?: any): int;
	protected MemberwiseClone<T>(): T;
	GetType(): Type;
	Dispose(): void;
	protected abstract dispose(disposing: boolean): void;
}
export declare enum SeekOrigin {
	Begin = 0,
	Current = 1,
	End = 2
}
export declare abstract class Stream extends TObject implements IDisposable {
	protected dispose(disposing: boolean): void;
	static readonly Null: Stream;
	protected abstract Get_CanRead(): boolean;
	get CanRead(): boolean;
	protected abstract Get_CanSeek(): boolean;
	get CanSeek(): boolean;
	protected abstract Get_CanWrite(): boolean;
	get CanWrite(): boolean;
	protected abstract Get_Length(): int;
	get Length(): int;
	protected abstract Get_Position(): int;
	get Position(): int;
	protected abstract Set_Position(value: int): any;
	set Position(value: int);
	static StaticConstructor(): void;
	protected Stream(): void;
	Close(): void;
	abstract Flush(): void;
	abstract Read(buffer: ByteArray, offset: int, count: int): int;
	ReadByte(): int;
	abstract Seek(offset: int, origin: SeekOrigin): int;
	abstract SetLength(value: int): void;
	Dispose(): void;
	abstract Write(buffer: ByteArray, offset: int, count: int): void;
	WriteByte(value: byte): void;
}
export interface IResource {
	culture: string;
	resources: IResourcePage[];
}
export interface IResourcePage {
	name: string;
	resources: IResourceItem[];
}
export interface IResourceItem {
	key: string;
	value: ByteArray | string;
}
export declare class Assembly {
	EntryPoint: MethodInfo;
	static Resources: IResource[];
	static Load(path: string): Assembly;
	GetManifestResourceStream(name: string): Stream;
	static GetEntryAssembly(): Assembly;
	static GetCallingAssembly(): Assembly;
	GetName(): any;
}
declare class MemberFilter extends Delegate<(m: MemberInfo, filterCriteria: any) => boolean> {
}
declare class TypeFilter extends Delegate<(m: Type, filterCriteria: any) => boolean> {
}
declare var Binder: any, MethodInfo: any;
declare type InterfaceMapping = any;
declare type EventInfo = any;
declare type Binder = any;
declare type ParameterModifier = any;
declare type CultureInfo = any;
declare type GenericParameterAttributes = any;
declare type PropertyInfo = any;
declare type MethodInfo = any;
export declare class Missing {
	static readonly Value: Missing;
	constructor();
}
export declare abstract class Type extends MemberInfo {
	static hasMemberOfType<T>(...args: any[]): boolean;
	static hasMethod<T>(...args: any[]): boolean;
	static hasMember<T>(...args: any[]): boolean;
	static UNDEFINED: any;
	static FUNCTION: string;
	static STRING: string;
	static BOOLEAN: string;
	static NUMBER: string;
	static OBJECT: string;
	_impl: RuntimeTypeHandle;
	static readonly Delimiter: char;
	static readonly EmptyTypes: Type[];
	static readonly FilterAttribute: MemberFilter;
	static readonly FilterName: MemberFilter;
	static readonly FilterNameIgnoreCase: MemberFilter;
	static readonly Missing: any;
	static readonly DefaultBindingFlags: BindingFlags;
	private static FilterName_impl;
	private static FilterNameIgnoreCase_impl;
	private static FilterAttribute_impl;
	protected constructor();
	protected abstract Get_Assembly(): Assembly;
	get Assembly(): Assembly;
	protected abstract Get_AssemblyQualifiedName(): string;
	get AssemblyQualifiedName(): string;
	get Attributes(): TypeAttributes;
	protected abstract Get_BaseType(): Type;
	get BaseType(): Type;
	Get_DeclaringType(): Type;
	static get DefaultBinder(): Binder;
	protected abstract Get_FullName(): string;
	get FullName(): string;
	protected abstract Set_FullName(value: string): any;
	set FullName(value: string);
	protected abstract Get_GUID(): string;
	get GUID(): string;
	get HasElementType(): boolean;
	get IsAbstract(): boolean;
	get IsAnsiClass(): boolean;
	get IsArray(): boolean;
	get IsAutoClass(): boolean;
	get IsAutoLayout(): boolean;
	get IsByRef(): boolean;
	get IsClass(): boolean;
	get IsCOMObject(): boolean;
	get IsConstructedGenericType(): boolean;
	get IsContextful(): boolean;
	get IsEnum(): boolean;
	get IsExplicitLayout(): boolean;
	get IsImport(): boolean;
	get IsInterface(): boolean;
	get IsLayoutSequential(): boolean;
	get IsMarshalByRef(): boolean;
	get IsNestedAssembly(): boolean;
	get IsNestedFamANDAssem(): boolean;
	get IsNestedFamily(): boolean;
	get IsNestedFamORAssem(): boolean;
	get IsNestedPrivate(): boolean;
	get IsNestedPublic(): boolean;
	get IsNotPublic(): boolean;
	get IsPointer(): boolean;
	get IsPrimitive(): boolean;
	get IsPublic(): boolean;
	get IsSealed(): boolean;
	get IsSerializable(): boolean;
	get IsSpecialName(): boolean;
	get IsUnicodeClass(): boolean;
	get IsValueType(): boolean;
	protected Get_MemberType(): MemberTypes;
	abstract Get_Namespace(): string;
	get Namespace(): string;
	protected Get_ReflectedType(): Type;
	get TypeHandle(): RuntimeTypeHandle;
	get TypeInitializer(): ConstructorInfo;
	protected abstract GetConstructorImpl(bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): ConstructorInfo;
	protected abstract Get_UnderlyingSystemType(): Type;
	get UnderlyingSystemType(): Type;
	Equals(o: Type): boolean;
	GetEnumUnderlyingType(): Type;
	GetEnumNames(): string[];
	private static CreateNIE;
	GetEnumValues(): Array<any>;
	private IsValidEnumType;
	GetEnumName(value: any): string;
	IsEnumDefined(value: any): boolean;
	get IsSecurityTransparent(): boolean;
	get IsSecurityCritical(): boolean;
	get IsSecuritySafeCritical(): boolean;
	EqualsInternal(type: Type): boolean;
	private static internal_from_handle;
	private static internal_from_name;
	static GetType(typeName: string): Type;
	static GetType(typeName: string, throwOnError: boolean): Type;
	static GetType(typeName: string, throwOnError: boolean, ignoreCase: boolean): Type;
	static GetTypeArray(args: any[]): Type[];
	static GetTypeCodeInternal(type: Type): TypeCode;
	protected GetTypeCodeImpl(): TypeCode;
	static GetTypeCode(type: Type): TypeCode;
	static GetTypeFromCLSID(clsid: string): Type;
	static GetTypeFromCLSID(clsid: string, throwOnError: boolean): Type;
	static GetTypeFromCLSID(clsid: string, server: string): Type;
	static GetTypeFromCLSID(clsid: string, server: string, throwOnError: boolean): Type;
	static GetTypeFromHandle(handle: RuntimeTypeHandle): Type;
	static GetTypeFromProgID(progID: string): Type;
	static GetTypeFromProgID(progID: string, throwOnError: boolean): Type;
	static GetTypeFromProgID(progID: string, server: string): Type;
	static GetTypeFromProgID(progID: string, server: string, throwOnError: boolean): Type;
	static GetTypeHandle(o: any): RuntimeTypeHandle;
	static type_is_subtype_of(a: Type, b: Type, check_interfaces: boolean): boolean;
	static type_is_assignable_from(a: Type, b: Type): boolean;
	IsSubclassOf(c: Type): boolean;
	FindInterfaces(filter: TypeFilter, filterCriteria: any): Type[];
	GetInterface(name: string): Type;
	GetInterface(name: string, ignoreCase: boolean): Type;
	static GetInterfaceMapData(t: Type, iface: Type, targets: Out<MethodInfo[]>, methods: Out<MethodInfo[]>): void;
	GetInterfaceMap(interfaceType: Type): InterfaceMapping;
	abstract GetInterfaces(): Type[];
	IsAssignableFrom(c: Type): boolean;
	private static IsInstanceOfType;
	IsInstanceOfType(o: any): boolean;
	GetArrayRank(): int;
	abstract GetElementType(): Type;
	GetEvent(name: string): EventInfo;
	GetEvent(name: string, bindingAttr: BindingFlags): EventInfo;
	GetEvents(): EventInfo[];
	GetEvents(bindingAttr: BindingFlags): EventInfo[];
	GetField(name: string): FieldInfo;
	GetField(name: string, bindingAttr: BindingFlags): FieldInfo;
	GetField(fromNoninstanciated: FieldInfo): FieldInfo;
	GetFields(): FieldInfo[];
	GetFields(bindingAttr: BindingFlags): FieldInfo[];
	GetHashCode(): int;
	GetMember(name: string): MemberInfo[];
	GetMember(name: string, bindingAttr: BindingFlags): MemberInfo[];
	GetMember(name: string, type: MemberTypes, bindingAttr: BindingFlags): MemberInfo[];
	GetMembers(): MemberInfo[];
	GetMembers(bindingAttr: BindingFlags): MemberInfo[];
	GetMethod(name: string): MethodInfo;
	GetMethod(name: string, bindingAttr: BindingFlags): MethodInfo;
	GetMethod(name: string, types: Type[]): MethodInfo;
	GetMethod(name: string, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
	GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
	GetMethod(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
	protected abstract GetMethodImpl(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
	GetMethodImplInternal(name: string, bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): MethodInfo;
	GetMethods(): MethodInfo[];
	GetMethods(bindingAttr: BindingFlags): MethodInfo[];
	GetNestedType(name: string): Type;
	GetNestedType(name: string, bindingAttr: BindingFlags): Type;
	GetNestedTypes(): Type[];
	GetNestedTypes(bindingAttr: BindingFlags): Type[];
	GetProperties(): PropertyInfo[];
	GetProperties(bindingAttr: BindingFlags): PropertyInfo[];
	GetProperty(name: string): PropertyInfo;
	GetProperty(name: string, bindingAttr: BindingFlags): PropertyInfo;
	GetProperty(name: string, returnType: Type): PropertyInfo;
	GetProperty(name: string, types: Type[]): PropertyInfo;
	GetProperty(name: string, returnType: Type, types: Type[]): PropertyInfo;
	GetProperty(name: string, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
	GetProperty(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
	protected abstract GetPropertyImpl(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
	GetPropertyImplInternal(name: string, bindingAttr: BindingFlags, binder: Binder, returnType: Type, types: Type[], modifiers: ParameterModifier[]): PropertyInfo;
	protected abstract GetAttributeFlagsImpl(): TypeAttributes;
	protected abstract HasElementTypeImpl(): boolean;
	protected abstract IsArrayImpl(): boolean;
	protected abstract IsByRefImpl(): boolean;
	protected abstract IsCOMObjectImpl(): boolean;
	protected abstract IsPointerImpl(): boolean;
	protected abstract IsPrimitiveImpl(): boolean;
	static IsArrayImpl(type: Type): boolean;
	protected IsValueTypeImpl(): boolean;
	protected IsContextfulImpl(): boolean;
	protected IsMarshalByRefImpl(): boolean;
	GetConstructor(types: Type[]): ConstructorInfo;
	GetConstructor(bindingAttr: BindingFlags, binder: Binder, types: Type[], modifiers: ParameterModifier[]): ConstructorInfo;
	GetConstructor(bindingAttr: BindingFlags, binder: Binder, callConvention: CallingConventions, types: Type[], modifiers: ParameterModifier[]): ConstructorInfo;
	GetConstructors(): ConstructorInfo[];
	GetConstructors(bindingAttr: BindingFlags): ConstructorInfo[];
	GetDefaultMembers(): MemberInfo[];
	FindMembers(memberType: MemberTypes, bindingAttr: BindingFlags, filter: MemberFilter, filterCriteria: any): MemberInfo[];
	InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[]): any;
	InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[], culture: CultureInfo): any;
	InvokeMember(name: string, invokeAttr: BindingFlags, binder: Binder, target: any, args: any[], modifiers: ParameterModifier[], culture: CultureInfo, namedParameters: string[]): any;
	ToString(): string;
	InternalResolve(): Type;
	get IsSystemType(): boolean;
	GetGenericArguments(): Type[];
	get ContainsGenericParameters(): boolean;
	protected Get_IsGenericTypeDefinition(): boolean;
	get IsGenericTypeDefinition(): boolean;
	GetGenericTypeDefinition_impl(): Type;
	GetGenericTypeDefinition(): Type;
	protected Get_IsGenericType(): boolean;
	get IsGenericType(): boolean;
	MakeGenericType(...typeArguments: Type[]): Type;
	get IsGenericParameter(): boolean;
	get IsNested(): boolean;
	get IsVisible(): boolean;
	GetGenericParameterPosition(): int;
	get GenericParameterPosition(): int;
	GetGenericParameterAttributes(): GenericParameterAttributes;
	get GenericParameterAttributes(): GenericParameterAttributes;
	GetGenericParameterConstraints_impl(): Type[];
	GetGenericParameterConstraints(): Type[];
	get DeclaringMethod(): MethodBase;
	make_array_type(rank: int): Type;
	MakeArrayType(): Type;
	MakeArrayType(rank: int): Type;
	private make_byref_type;
	MakeByRefType(): Type;
	static MakePointerType(type: Type): Type;
	MakePointerType(): Type;
	static ReflectionOnlyGetType(typeName: string, throwIfNotFound: boolean, ignoreCase: boolean): Type;
	GetPacking(packing: Out<int>, size: Out<int>): void;
	GetPseudoCustomAttributes(): any[];
	get IsUserType(): boolean;
}
export declare class Activator {
	static CreateInstance<T>(type: Type): T;
}
export declare function applyToDefaults<T, K extends object | boolean>(defaults_: T, options: K, isNullOverride?: boolean): T & K | undefined;
export declare function as<T>(obj: any, typeName: Symbol): T;
export declare class TuvalStorage {
	private _config;
	private _defaultConfig;
	private _driverSet;
	private _initDriver;
	private _ready;
	private _dbInfo;
	private _driver;
	constructor(options?: any);
	clear(): void;
	setItem(key: string, value: any, callbacks?: Function): Promise<any>;
	getItem(key: string, callbacks?: Function): Promise<any>;
	config(options: any): any;
	defineDriver(driverObject: any, callback?: any, errorCallback?: any): Promise<unknown>;
	driver(): any;
	getDriver(driverName: any, callback?: any, errorCallback?: any): Promise<any>;
	getSerializer(callback: any): Promise<{
		serialize: (value: any, callback: any) => void;
		deserialize: (value: any) => any;
		stringToBuffer: (serializedString: any) => ArrayBuffer;
		bufferToString: (buffer: any) => string;
	}>;
	ready(callback: any): any;
	setDriver(drivers: any, callback?: any, errorCallback?: any): any;
	supports(driverName: any): boolean;
	_extend(libraryMethodsAndProperties: any): void;
	_getSupportedDrivers(drivers: any): any[];
	_wrapLibraryMethodsWithReady(): void;
	createInstance(options: any): TuvalStorage;
	SaveFile(url: string, key: string, callback?: Function): Promise<string>;
	GetFile(key: string, callback?: Function): Promise<string>;
	GetFileBytes(key: string, callback?: Function): Promise<Blob>;
	SaveArrayBuffer(key: string, value: ArrayBuffer, callback?: Function): Promise<ArrayBuffer>;
	GetArrayBuffer(key: string, callback?: Function): Promise<ArrayBuffer>;
	SaveString(key: string, value: string, callback?: Function): Promise<string>;
	GetString(key: string, callback?: Function): Promise<string>;
	SaveArray<T>(key: string, value: Array<T>, callback?: Function): Promise<Array<T>>;
	GetArray<T>(key: string, callback?: Function): Promise<Array<T>>;
	SaveBlob(key: string, value: Blob, callback?: Function): Promise<Blob>;
	GetBlob(key: string, callback?: Function): Promise<Blob>;
	SaveFloat32Array(key: string, value: Blob, callback?: Function): Promise<Float32Array>;
	GetFloat32Array(key: string, callback?: Function): Promise<Float32Array>;
	SaveFloat64Array(key: string, value: Float64Array, callback?: Function): Promise<Float64Array>;
	GetFloat64Array(key: string, callback?: Function): Promise<Float64Array>;
	SaveInt8Array(key: string, value: Int8Array, callback?: Function): Promise<Int8Array>;
	GetInt8Array(key: string, callback?: Function): Promise<Int8Array>;
	SaveInt16Array(key: string, value: Int16Array, callback?: Function): Promise<Int16Array>;
	GetInt16Array(key: string, callback?: Function): Promise<Int16Array>;
	SaveInt32Array(key: string, value: Int32Array, callback?: Function): Promise<Int32Array>;
	GetInt32Array(key: string, callback?: Function): Promise<Int32Array>;
	SaveNumber(key: string, value: number, callback?: Function): Promise<number>;
	GetNumber(key: string, callback?: Function): Promise<number>;
	SaveObject(key: string, value: Object, callback?: Function): Promise<Object>;
	GetObject(key: string, callback?: Function): Promise<Object>;
	RemoveItem(key: string): Promise<void>;
	Clear(): Promise<void>;
	Length(): Promise<int>;
	Key(index: int): Promise<string>;
	Keys(): Promise<Array<string>>;
	SaveUint8Array(key: string, value: Uint8Array, callback?: Function): Promise<Uint8Array>;
	GetUint8Array(key: string, callback?: Function): Promise<Uint8Array>;
	SaveUint8ClampedArray(key: string, value: Uint8ClampedArray, callback?: Function): Promise<Uint8ClampedArray>;
	GetUint8ClampedArray(key: string, callback?: Function): Promise<Uint8ClampedArray>;
	SaveUint16Array(key: string, value: Uint16Array, callback?: Function): Promise<Uint16Array>;
	GetUint16Array(key: string, callback?: Function): Promise<Uint16Array>;
	SaveUint32Array(key: string, value: Uint16Array, callback?: Function): Promise<Uint32Array>;
	GetUint32Array(key: string, callback?: Function): Promise<Uint32Array>;
}
export declare const TStorage: TuvalStorage;
/**
 * Verilen condition'a gre geilen message veya Error 'u throw eder.
 * @param condition
 * @param args
 */
export declare function assert(condition: boolean, message: string): void;
export declare function assert(condition: boolean, error?: Error): void;
export declare function assert(condition: boolean, ...message: string[]): void;
export declare const inflateProperty: (propSet: any) => void;
export declare const getProperty: (propSet: any, ch: any) => any;
export declare const assertChar: (ch: any) => void;
export declare const assertString: (string: string) => void;
export declare const assertFunction: (callback: Function) => void;
export declare const findProperty: (ci: any, codpnt: any, str: any, end: any) => any;
/**
 *  Used to find the directionality, which is handled a bit differently than the other sets of properties since we need a value back, not just true/false.
 *  Returns one of the following:
 *  + `UNDEFINED`
 *  + `L`   for LEFT_TO_RIGHT
 *  + `R`   for RIGHT_TO_LEFT
 *  + `AL`  for RIGHT_TO_LEFT_ARABIC
 *  + `EN`  for EUROPEAN_NUMBER
 *  + `ES`  for EUROPEAN_NUMBER_SEPARATOR
 *  + `ET`  for EUROPEAN_NUMBER_TERMINATOR
 *  + `AN`  for ARABIC_NUMBER
 *  + `CS`  for COMMON_NUMBER_SEPARATOR
 *  + `NSM` for NONSPACING_MARK
 *  + `BN`  for BOUNDARY_NEUTRAL
 *  + `B`   for PARAGRAPH_SEPARATOR
 *  + `S`   for SEGMENT_SEPARATOR
 *  + `WS`  for WHITESPACE
 *  + `ON`  for OTHER_NEUTRALS
 *  + `LRE` for LEFT_TO_RIGHT_EMBEDDING
 *  + `LRO` for LEFT_TO_RIGHT_OVERRIDE
 *  + `RLE` for RIGHT_TO_LEFT_EMBEDDING
 *  + `RLO` for RIGHT_TO_LEFT_OVERRIDE
 *  + `PDF` for POP_DIRECTIONAL_FORMAT
 *
 *  @param {String} string - a length 1 string
 *  @returns {String} a string representing the directionality, as defined above
 */
export declare const getDirectionality: (ch: any) => any;
/**
 *  Returns an array of contiguous matching strings for which the callback returns true, similar to String.match().
 *  `CharFunk.getMatches("test this out",CharFunk.isLetter); // returns ["test","this","out"]`
 *  @param {String} string - a string of any length
 *  @param {Function} callback - a function to call for each character, which must return true if a match or false if not a match.  This function will be provided three arguments: a char to check, a number for the position, and a number for the string length
 *  @returns {Array{String}}
 */
export declare const getMatches: (string: string, callback: Function) => any;
/**
 *  Returns true if the string argument is composed of all letters and digits
 *  @param {String} string - a string of any length
 *  @returns {Boolean}
 */
export declare const isAllLettersOrDigits: (string: string) => boolean;
/**
 *  Returns true if provided a length 1 string that is a digit
 *  @param {String} ch - a length 1 string
 *  @returns {Boolean}
 */
export declare const isDigit: (ch: string) => boolean;
export declare function isSpace(aChar: any): boolean;
/**
 *  Returns true if provided a length 1 string that is a letter
 *  @param {String} ch - a length 1 string
 *  @returns {Boolean}
 */
export declare const isLetter: (ch: any) => boolean;
/**
 *  Returns true if provided a length 1 string that is in the Unicode "Nl" category.
 *  Beware -- this is NOT the same thing as isLetterOrDigit()!
 *  @param {String} ch - a length 1 string
 *  @returns {Boolean}
 */
export declare const isLetterNumber: (ch: any) => boolean;
/**
 *  Returns true if provided a length 1 string that is a letter or a digit
 *  @param {String} ch - a length 1 string
 *  @returns {Boolean}
 */
export declare const isLetterOrDigit: (ch: any) => boolean;
/**
 *  Returns true if provided a length 1 string that is lowercase
 *  @param {String} ch - a length 1 string
 *  @returns {Boolean}
 */
export declare const isLowerCase: (ch: any) => boolean;
/**
 *  Returns true if provided a length 1 string that is a mirrored character
 *  @param {String} ch - a length 1 string
 *  @returns {Boolean}
 */
export declare const isMirrored: (ch: any) => boolean;
/**
 *  Returns true if provided a length 1 string that is uppercase
 *  @param {String} ch - a length 1 string
 *  @returns {Boolean}
 */
export declare const isUpperCase: (ch: any) => boolean;
/**
 *  Returns true if provided a length 1 string that is a valid leading character for a JavaScript identifier
 *  @param {String} ch - a length 1 string
 *  @returns {Boolean}
 */
export declare const isValidFirstForName: (ch: any) => boolean;
/**
 *  Returns true if provided a length 1 string that is a valid non-leading character for a ECMAScript identifier
 *  @param {String} ch - a length 1 string
 *  @returns {Boolean}
 */
export declare const isValidMidForName: (ch: any) => boolean;
/**
 *  Returns true if the string is a valid ECMAScript identifier.
 *  This is a bit more restrictive than browsers tend to be, using the actual rules http://www.ecma-international.org/ecma-262/5.1/
 *  @param {String} string - a string of any length
 *  @param {Boolean} checkReserved - set to true if you wish to get back false if string is a reserved ECMAScript keyword
 *  @returns {Boolean}
 */
export declare const isValidName: (string: string, checkReserved: any) => boolean;
/**
 *  Returns true if provided a length 1 string that is a whitespace character
 *  @param {String} ch - a length 1 string
 *  @returns {Boolean}
 */
export declare const isWhitespace: (ch: any) => boolean;
/**
 *  Returns the first index where the character causes a true return from the callback, or -1 if no match
 *  @param {String} string - a string of any length
 *  @param {Function} callback - a function to call for each character, which must return true if a match or false if not a match.  This function will be provided three arguments: a char to check, a number for the position, and a number for the string length
 *  @returns {Number}
 */
export declare const indexOf: (string: string, callback: Function) => any;
/**
 *  Returns the last index where the character causes a true return from the callback, or -1 if no match
 *  @param {String} string - a string of any length
 *  @param {Function} callback - a function to call for each character, which must return true if a match or false if not a match.  This function will be provided three arguments: a char to check, a number for the position, and a number for the string length
 *  @returns {Number}
 */
export declare const lastIndexOf: (string: string, callback: Function) => any;
/**
 *  Returns true if all characters in the provided string result in a true return from the callback.
 *  @param {String} string - a string of any length
 *  @param {Function} callback - a function to call for each character, which must return true if a match or false if not a match.  This function will be provided three arguments: a char to check, a number for the position, and a number for the string length
 *  @returns {Boolean}
 */
export declare const matchesAll: (string: string, callback: Function) => boolean;
/**
 *  Returns a new string with all matched characters replaced, similar to String.replace().
 *  If the callback returns a string, then that will be used as the replacement.
 *  Otherwise, if a ch argument is provided, then that will be used as a replacement.
 *  If the callback does not return a string and the ch is not provided, then matched characters will simply be removed.
 *  @param {String} string - a string of any length
 *  @param {Function} callback - a function to call for each character, which must return a string as a replacement value, otherwise a true if a match or false if not a match.  This function will be provided three arguments: a char to check, a number for the position, and a number for the string length
 *  @param {String} ch - optional, a length 1 string for replacement
 *  @returns {String} a new string
 */
export declare const replaceMatches: (string: string, callback: Function, ch: number) => any;
/**
 *  Splits the string on all matches, similar to String.split().
 *  `CharFunk.splitOnMatches("test this out",CharFunk.isWhitespace); // returns ["test","this","out"]`
 *  @param {String} string - a string of any length
 *  @param {Function} callback - a function to call for each character, which must return true if a match or false if not a match.  This function will be provided three arguments: a char to check, a number for the position, and a number for the string length
 *  @returns {Boolean}
 */
export declare const splitOnMatches: (string: string, callback: Function) => any;
export declare function checkNotNull<T>(obj: T, message?: string): T;
export declare function checkCriticalArgument(condition: boolean, ...message: string[]): void;
export declare function checkState(condition: boolean, message?: string): void;
export declare function classNames(...args: string[]): string;
export declare function clone<T extends {
	[index: string]: any;
}>(obj: T, seen?: Map<any, any>): T;
export declare function cloneObject<T extends {
	[k: string]: any;
}>(obj: T): T;
export declare function cloneWithShallow<T>(source: T, keys: string[]): T;
export declare const enum CompareResult {
	Equal = 0,
	Greater = 1,
	Less = -1
}
/**
 * Used for special comparison including NaN.
 * @param a
 * @param b
 * @param strict
 * @returns {boolean|any}
 */
export declare function areEqual(a: any, b: any, strict?: boolean): boolean;
/**
 * Compares two comparable objects or primitives.
 * @param a
 * @param b
 */
export declare function compare<T>(a: IComparable<T>, b: IComparable<T>): number;
export declare function compare<T extends Primitive>(a: T, b: T, strict?: boolean): CompareResult;
/**
 * Determines if two primitives are equal or if two objects have the same key/value combinations.
 * @param a
 * @param b
 * @param nullEquivalency If true, null/undefined will be equivalent to an empty object {}.
 * @param extraDepth
 * @returns {boolean}
 */
export declare function areEquivalent(a: any, b: any, nullEquivalency?: boolean, extraDepth?: number): boolean;
export declare type Constructor<T> = {
	new (...args: any[]): T;
};
export declare function escapeRegex(string: string): string;
export declare function contain(ref: any, values: string | string[], options?: any): boolean;
export declare class Conversion {
	static Float(str: string | Array<any>): number | number[];
	static Int(n: string | number | boolean, radix: number): number;
	static Str(n: string): string;
	static Boolean(n: number | string | boolean): boolean;
	static Byte(n: number | string | boolean): byte;
	static Char(n: number | string): string;
}
export declare function convert<T>(obj: any): T;
export declare type uint8_t = number;
export declare type int8_t = number;
export declare type uint16_t = number;
export declare type int16_t = number;
export declare type uint32_t = number;
export declare type int32_t = number;
export declare type uint64_t = bigint;
export declare type int64_t = bigint;
export declare function f64(value: any): number;
export declare function i64(value: any): int64_t;
export declare function u64(value: any): uint64_t;
export declare function u8(value: number): uint8_t;
export declare function i8(value: number): int8_t;
export declare function u16(value: number): uint16_t;
export declare function i16(value: number): int16_t;
export declare function u32(value: number): uint32_t;
export declare function i32(value: number): int32_t;
export declare class Convert {
	static ToInt32Array(array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int16Array | Uint16Array | Int32Array | Uint32Array, offset?: number, length?: number): Int32Array;
	static ToByteArray(array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, byteIndex?: int): Uint8Array;
	static ToCharArray(array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, charIndex?: int): Uint16Array;
	static ToShortArray(array: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array, charIndex?: int): Int16Array;
	static ToIntPtr(value: number): IntPtr;
	static ToLong(value: any): long;
	static ToULong(value: number): uint64_t;
	static ToFloat(value: number): number;
	static ToDouble(value: number): BigNumber;
	static ToDecimal(value: number): bigint;
	static ToByte(value: number): number;
	static ToSByte(value: number): number;
	static ToUInt8(value: number): number;
	static ToInt8(value: number): number;
	static ToInt64(value: number | Int64 | BigNumber): BigNumber;
	static ToShort(value: number): number;
	static ToChar(value: number): number;
	static ToUShort(value: number): number;
	static ToInt32(value: string | number | BigNumber, fromBase?: int): int;
	static ToUInt32(value: any, fromBase?: int): int;
	static ToUInt16(value: any, fromBase?: int): int;
	static ToString(value: any, toBase?: number): string;
	static ToBase64String(bytes: ByteArray): string;
	static FromBase64String(text: string): ByteArray;
	static ToBlobUrl(buffer: ArrayBuffer, type: string): string;
}
export declare function deepEqual(obj: any, ref: any, options?: any, seen?: any): boolean;
export declare class Enum {
	static GetValues(enumType: any): number[];
	static GetKeys(enumType: any): number[];
	static Parse<T>(enumValue: any): T;
	static IsDefined(enumObject: any, value: any): boolean;
}
export declare const isCommonJS: boolean;
export declare const isRequireJS: boolean;
export declare const isNodeJS: boolean;
declare enum SpecialFolderOption {
	None = 0,
	DoNotVerify = 16384,
	Create = 32768
}
export declare enum SpecialFolder {
	MyDocuments = 5,
	Desktop = 0,
	MyComputer = 17,
	Programs = 2,
	Personal = 5,
	Favorites = 6,
	Startup = 7,
	Recent = 8,
	SendTo = 9,
	StartMenu = 11,
	MyMusic = 13,
	DesktopDirectory = 16,
	Templates = 21,
	ApplicationData = 26,
	LocalApplicationData = 28,
	InternetCache = 32,
	Cookies = 33,
	History = 34,
	CommonApplicationData = 35,
	System = 37,
	ProgramFiles = 38,
	MyPictures = 39,
	CommonProgramFiles = 43,
	MyVideos = 14,
	NetworkShortcuts = 19,
	Fonts = 20,
	CommonStartMenu = 22,
	CommonPrograms = 23,
	CommonStartup = 24,
	CommonDesktopDirectory = 25,
	PrinterShortcuts = 27,
	Windows = 36,
	UserProfile = 40,
	SystemX86 = 41,
	ProgramFilesX86 = 42,
	CommonProgramFilesX86 = 44,
	CommonTemplates = 45,
	CommonDocuments = 46,
	CommonAdminTools = 47,
	AdminTools = 48,
	CommonMusic = 53,
	CommonPictures = 54,
	CommonVideos = 55,
	Resources = 56,
	LocalizedResources = 57,
	CommonOemLinks = 58,
	CDBurning = 59
}
export declare class Environment {
	static OSVersion: any;
	static NewLine: string;
	static OSInfo: any;
	static OSName: any;
	static IsRunningOnWindows: boolean;
	static get TickCount(): int;
	static GetResourceString(key: string): string;
	static GetResourceString(key: string, a: string): string;
	static GetResourceString(key: string, a: number): string;
	static GetResourceString(key: string, a: number, b: number): string;
	static GetLogicalDrives(): string[];
	static GetFolderPath(folder: SpecialFolder, option?: SpecialFolderOption): string;
	static GetWindowsFolderPath(folder: SpecialFolder): string;
	static UnixGetFolderPath(folder: SpecialFolder, option: SpecialFolderOption): string;
	static GetEnvironmentVariable(name: string): string;
	static GetCommandLineArgs(): string[];
	static CurrentDirectory: string;
}
export declare function error(str: string): Error;
export declare class EventArgs {
	static readonly Empty: EventArgs;
	constructor();
}
export declare type EventHandler = (sender: any, e: EventArgs) => void;
export declare function extend(child: any, parent: any): void;
export declare function flatten(array: any[], target?: any[]): any[];
export interface IIteratorResult<T> {
	done: boolean;
	value?: T;
	index?: number;
}
export interface IIterator<T> {
	Next(value?: any): IIteratorResult<T>;
	"return"?<TReturn>(value?: TReturn): IIteratorResult<TReturn>;
	"throw"?(e?: any): IIteratorResult<T>;
}
export interface IEnumerator<T> extends IIterator<T>, IDisposable {
	/**
	 * The current value within the enumeration.
	 */
	Current: T;
	/**
	 * Will indicate if moveNext is safe.
	 */
	CanMoveNext?: boolean;
	/**
	 * Safely moves to the next entry and returns true if there is one.
	 */
	MoveNext(value?: any): boolean;
	/**
	 * Moves to the next entry and emits the value through the out callback.
	 */
	TryMoveNext(out: (value: T) => void): boolean;
	/**
	 * Restarts the enumeration.
	 */
	Reset(): void;
	/**
	 * Interrupts/completes the enumeration.
	 */
	End(): void;
	/**
	 * Calls .moveNext() and returns .current
	 */
	NextValue(value?: any): T | undefined;
	/**
	 * Provides a way of flagging endless enumerations that may cause issues.
	 */
	IsEndless?: boolean;
	Next(value?: any): IIteratorResult<T>;
	"return"?<TReturn>(value?: TReturn): IIteratorResult<TReturn>;
	"throw"?(e?: any): IIteratorResult<T>;
	Dispose(): void;
}
export interface IEnumerable<T> {
	GetEnumerator(): IEnumerator<T>;
	IsEndless?: boolean;
}
export interface ICollection<T> extends IEnumerable<T> {
	Count: int;
	IsReadOnly: boolean;
	Add(item: T): void;
	Clear(): void;
	Contains(item: T): boolean;
	CopyTo(array: T[], arrayIndex: int): void;
	Remove(item: T): boolean;
}
export interface IList<T> extends ICollection<T>, IEnumerable<T> {
	Get(index: int): T;
	Set(index: int, value: T): void;
	IndexOf(item: T): int;
	Insert(index: int, item: T): void;
	RemoveAt(index: int): void;
}
export declare const CONTINUE: number;
export declare const BREAK: number;
export declare function foreach<T>(enumerable: IEnumerator<T> | IEnumerable<T> | IList<T> | Array<T> | ICollection<T> | Iterator<T> | Iterable<T> | Set<T>, func: (obj: T) => void | never | number): void;
export declare function foreachAsync<T>(enumerable: IEnumerator<T> | IEnumerable<T> | IList<T> | Array<T> | ICollection<T> | Iterator<T> | Iterable<T> | Set<T>, func: (obj: T) => Promise<void> | Promise<never> | Promise<number>): Promise<void>;
export declare class Functions {
	/**
	 * A typed method for use with simple selection of the parameter.
	 * @returns {boolean}
	 */
	static readonly Identity: <T>(x: T) => T;
	/**
	 * Returns false.
	 * @returns {boolean}
	 */
	static readonly True: () => boolean;
	/**
	 * Returns false.
	 * @returns {boolean}
	 */
	static readonly False: () => boolean;
	/**
	 * Does nothing.
	 */
	static readonly Blank: () => void;
}
export interface ILazy<T> extends IDisposable, IEquatable<ILazy<T>> {
	value: T;
	isValueCreated: boolean;
}
export declare function initArray<T>(count: number, initFunc: () => T): T[];
export declare function inlineType<T>(classType: any, obj: any): T;
export interface ArrayLikeWritable<T> {
	length: number;
	[n: number]: T;
}
export declare class LazyValue<T> {
	Value: T;
	constructor(val: T);
	ToString(): string;
}
export declare function lazy<T>(value: any): LazyValue<T>;
export declare function isTypeOf<T>(obj: any, typeName: Symbol): obj is T;
export declare function isAll<T>(obj: any[], typeName: Symbol): boolean;
export declare function isFloat(obj: any): boolean;
export declare function isInt(obj: any): boolean;
export declare function isChar(obj: any): boolean;
export declare function isString(obj: any): boolean;
export declare function isBoolean(obj: any): boolean;
export declare class is {
	static AsyncFunction(input: any): boolean;
	static Promise<T = any>(promise: any): promise is Promise<T>;
	static CharArray(value: any): boolean;
	static ByteArray(value: any): boolean;
	static BooleanArray(value: any): boolean;
	static FloatArray(value: any): boolean;
	static DoubleArray(value: any): boolean;
	static LongArray(value: any): boolean;
	static WebSQLValid(): boolean;
	static LocalStorageValid(): boolean;
	static IndexedDBValid(): boolean;
	static mobileDevice(): boolean;
	static undefined(obj: any): boolean;
	static defined(obj: any): boolean;
	static nil(obj: any): boolean;
	static Int8Array(value: any): boolean;
	static Uint8Array(value: any): boolean;
	static Uint8ClampedArray(value: any): boolean;
	static Int16Array(value: any): boolean;
	static Uint16Array(value: any): boolean;
	static Int32Array(value: any): boolean;
	static Uint32Array(value: any): boolean;
	static Float32Array(value: any): boolean;
	static Float64Array(value: any): boolean;
	static BigInt64Array(value: any): boolean;
	static BigUint64Array(value: any): boolean;
	static nan(value: any): boolean;
	static null(value: any): boolean;
	static notNull(value: any): boolean;
	static nullOrEmpty(value: any): boolean;
	static int(value: any): value is number;
	static long(value: any): value is BigNumber;
	static double(value: any): value is BigNumber;
	static char(value: any): value is number;
	static float(value: any): value is number;
	/**
	* Returns true if the value parameter is a string.
	* @param value
	* @returns {boolean}
	*/
	static string(value: any): value is string;
	/**
	 * Returns true if the value parameter is a function.
	 * @param value
	 * @returns {boolean}
	 */
	static function(value: any): value is Function;
	static lazy<T>(value: any): value is LazyValue<T>;
	static array<T = any>(value: any): value is Array<T>;
	static typeof<T>(obj: any, typeName: Symbol): obj is T;
	static equals(item1: any, item2: any): boolean;
	/**
	 * Returns true if is a number and is NaN.
	 * @param value
	 * @returns {boolean}
	 */
	static trueNaN(value: any): value is number;
	/**
	* Returns true if the value is a boolean, string, number, null, or undefined.
	* @param value
	* @param allowUndefined if set to true will return true if the value is undefined.
	* @returns {boolean}
	*/
	static primitive(value: any, allowUndefined?: boolean): value is Primitive;
	/**
	 * For detecting if the value can be used as a key.
	 * @param value
	 * @param allowUndefined
	 * @returns {boolean|boolean}
	 */
	static primitiveOrSymbol(value: any, allowUndefined?: boolean): value is Primitive | symbol;
	/**
	 * Returns true if the value is a string, number, or symbol.
	 * @param value
	 * @returns {boolean}
	 */
	static propertyKey(value: any): value is string | number | symbol;
	/**
	* Returns true if the value parameter is an object.
	* @param value
	* @param allowNull If false (default) null is not considered an object.
	* @returns {boolean}
	*/
	static object(value: any, allowNull?: boolean): boolean;
	/**
	 * Guarantees a number value or NaN instead.
	 * @param value
	 * @returns {number}
	 */
	static numberOrNaN(value: any): number;
	/**
	 * Returns true if the value parameter is a number.
	 * @param value
	 * @param ignoreNaN Default is false. When true, NaN is not considered a number and will return false.
	 * @returns {boolean}
	 */
	static number(value: any, ignoreNaN?: boolean): value is number;
	static arrayLike<T>(instance: any): instance is ArrayLikeWritable<T>;
	/**
	* Returns true if the value parameter is null or undefined.
	* @param value
	* @returns {boolean}
	*/
	static nullOrUndefined(value: any): value is null | undefined;
	/**
	 * Returns true if the value parameter is a boolean.
	 * @param value
	 * @returns {boolean}
	 */
	static boolean(value: any): value is boolean;
	/**
	* Returns true if the target matches the type (instanceof).
	* @param target
	* @param type
	* @returns {T|null}
	*/
	static instanceof<T>(target: Object, type: {
		new (...params: any[]): T;
	}): target is T;
	static browser(): boolean;
	static mobile(): boolean;
	static arrayish(obj: any): boolean;
	static callable(obj: any): boolean;
	static html(str: string): boolean;
	static workerContext(): boolean;
	static NodeEnvironment(): boolean;
	static localhost(): boolean;
}
export declare function isBrowser(): boolean;
export declare function isEqual(a: any, b: any): boolean;
export declare function isImplement<T>(obj: any, name: Type): obj is T;
export declare function isInDocument(el: any): boolean;
export declare type JsonEntry = Primitive | JsonArray | JsonMap;
export interface JsonArray extends ArrayLike<JsonEntry> {
}
export interface JsonMap extends IMap<JsonEntry> {
}
export declare type JsonData = JsonMap | JsonArray;
export interface IKeyValuePair<TKey, TValue> {
	key: TKey;
	value: TValue;
}
export declare type KeyValuePair<TKey, TValue> = IKeyValuePair<TKey, TValue> | [
	TKey,
	TValue
];
export interface IStringKeyValuePair<TValue> extends IKeyValuePair<string, TValue> {
}
export declare type StringKeyValuePair<TValue> = IStringKeyValuePair<TValue> | [
	string,
	TValue
];
export declare function isKeyValuePair<TKey, TValue>(kvp: any): kvp is IKeyValuePair<TKey, TValue>;
export declare function assertKey<TKey>(key: TKey, name?: string): TKey | never;
export declare function assertTuple(tuple: ArrayLike<any>, name?: string): void | never;
export declare function assertNotUndefined<T>(value: T, name: string): T | never;
export declare function extractKeyValue<TKey, TValue, TResult>(item: KeyValuePair<TKey, TValue>, to: (key: TKey, value: TValue) => TResult): TResult;
export declare abstract class ResolverBase<T> extends DisposableBase {
	protected _valueFactory: Func<T>;
	private readonly _trapExceptions;
	private readonly _allowReset;
	protected _isValueCreated: boolean | null;
	protected _value: T;
	constructor(_valueFactory: Func<T>, _trapExceptions: boolean, _allowReset?: boolean);
	protected _error: any;
	protected getError(): any;
	get error(): any;
	getValue(): T;
	get canReset(): boolean;
	protected _onDispose(): void;
	tryReset(): boolean;
}
export declare class Lazy<T> extends ResolverBase<T> implements ILazy<T> {
	constructor(valueFactory: Func<T>, trapExceptions?: boolean, allowReset?: boolean);
	get isValueCreated(): boolean;
	get value(): T;
	Equals(other: Lazy<T>): boolean;
	valueEquals(other: Lazy<T>): boolean;
	static create<T>(valueFactory: Func<T>, trapExceptions?: boolean, allowReset?: boolean): Lazy<T>;
}
export declare class ResettableLazy<T> extends Lazy<T> {
	constructor(valueFactory: Func<T>, trapExceptions?: boolean);
	static create<T>(valueFactory: Func<T>, trapExceptions?: boolean): ResettableLazy<T>;
}
export declare function mapToObject(array: any[], key?: any): any;
export declare type IndexType = {
	[index: string]: any;
};
/**
 * Merge all properties of source into target. source wins in conflict, and by default null and undefined
 * from source are applied.
 * @param target
 * @param source
 * @param isNullOverride
 * @param isMergeArray
 */
export declare function merge<T extends IndexType, K extends IndexType>(target_: T, source: K, isNullOverride?: boolean, isMergeArray?: boolean): T & K;
export declare function nameof(obj: any): string;
export declare type Optional<T> = {
	[P in keyof T]?: T[P];
};
export declare function prepareToStringify(obj: any): any;
export declare class PropertyChangedEventArgs {
	PropertyName: string;
	constructor(propertyName: string);
}
export declare function proto(obj: any): void;
export interface ReachOptions {
	separator?: string;
	default?: any;
	strict?: boolean;
	functions?: boolean;
}
export declare function reach(obj: any, chain: string, options?: ReachOptions): any;
export declare function shallow(source: any): any;
export declare function shalowExtend(child: Constructor<any>, parent: Constructor<any>, ignores: string[]): void;
export declare function stringify(object: any): string;
export declare class System {
}
export declare namespace System {
	const Types: {
		Extensions: {
			ArrayEnumerator: symbol;
		};
		IntPtr: symbol;
		Guid: symbol;
		TObject: symbol;
		Cryptography: {
			ICryptoTransform: symbol;
			RijndaelManaged: symbol;
			Rijndael: symbol;
			Aes: symbol;
			AesManaged: symbol;
			SymmetricAlgorithm: symbol;
			CryptoStream: symbol;
		};
		Text: {
			StringBuilder: symbol;
		};
		DateTime: symbol;
		TimeSpan: symbol;
		DateTimeOffset: symbol;
		TimeZoneInfo: symbol;
		Globalization: {
			NumberFormatInfo: symbol;
			DateTimeResult: symbol;
			GregorianCalendar: symbol;
			CultureInfo: symbol;
			DateTimeFormatInfo: symbol;
			Calendar: symbol;
			CultureData: symbol;
			JapaneseCalendar: symbol;
		};
		CompareInfo: symbol;
		UMP: {
			POINT: symbol;
			RECT: symbol;
			GdipEncoderParameter: symbol;
		};
		com: {
			tuval: {
				twt: {
					core: {
						shared: {
							impl: {
								JsLogger: symbol;
							};
						};
					};
				};
			};
		};
		tuval: {
			util: {
				FloatArray: symbol;
				function: {
					DoubleConsumer: symbol;
				};
				logging: {
					LogRecord: symbol;
				};
				CharSequence: symbol;
				AbstractMap: {
					AbstractMap: symbol;
					AbstractEntry: symbol;
				};
				Map: {
					Map: symbol;
					Entry: symbol;
				};
				Set: symbol;
				Pool: {
					Pool: symbol;
					Poolable: symbol;
				};
			};
			io: {};
			lang: {};
			nio: {
				LongToByteBufferAdapter: symbol;
				FloatArrayBuffer: symbol;
				DoubleToByteBufferAdapter: symbol;
				DirectReadWriteShortBufferAdapter: symbol;
				DirectReadWriteIntBufferAdapter: symbol;
				DirectReadWriteFloatBufferAdapter: symbol;
				DirectReadWriteByteBuffer: symbol;
				ShortArrayBuffer: symbol;
				ReadWriteIntArrayBuffer: symbol;
				ReadOnlyIntArrayBuffer: symbol;
				LongArrayBuffer: symbol;
				ByteBufferWrapper: symbol;
				IntToByteBufferAdapter: symbol;
				IntArrayBuffer: symbol;
				HeapByteBuffer: symbol;
				FloatToByteBufferAdapter: symbol;
				DoubleBuffer: symbol;
				DoubleArrayBuffer: symbol;
				DirectReadOnlyShortBufferAdapter: symbol;
				DirectReadOnlyIntBufferAdapter: symbol;
				DirectReadOnlyFloatBufferAdapter: symbol;
				DirectReadOnlyByteBuffer: symbol;
				HasArrayBufferView: symbol;
				DirectByteBuffer: symbol;
				CharSequenceAdapter: symbol;
				BufferFactory: symbol;
				BaseByteBuffer: symbol;
				LongBuffer: symbol;
				FloatBuffer: symbol;
				CharToByteBufferAdapter: symbol;
				CharBuffer: symbol;
				CharSequence: symbol;
				ByteBuffer: symbol;
				ShortBuffer: symbol;
				IntBuffer: symbol;
				Buffer: symbol;
			};
		};
		Primitives: {
			Byte: symbol;
			Short: symbol;
			Int: symbol;
			Float: symbol;
			Double: symbol;
			Number: symbol;
			String: symbol;
			Boolean: symbol;
		};
		Encoding: {
			Encoding: symbol;
			UnicodeEncoding: symbol;
			EncoderExceptionFallback: symbol;
			DecoderExceptionFallback: symbol;
			EncoderFallback: symbol;
			DecoderFallback: symbol;
			ASCIIEncoding: symbol;
			UTF32Encoding: symbol;
			UTF8Encoding: symbol;
		};
		IO: {
			Stream: symbol;
			MemoryStream: symbol;
			TextReader: symbol;
			StreamReader: symbol;
		};
		IServiceProvider: symbol;
		Collections: {
			BitArray: symbol;
			CompatibleComparer: symbol;
			ArrayList: {
				ArrayList: symbol;
				ArrayListEnumeratorSimple: symbol;
			};
			ArrayLikeCollection: symbol;
			CollectionBase: symbol;
			Collection: symbol;
			ICollection: symbol;
			IReadOnlyCollection: symbol;
			IHashCodeProvider: symbol;
			Enumeration: {
				IEnumerable: symbol;
				IEnumerateEach: symbol;
				IEnumerator: symbol;
				IIterator: symbol;
			};
			Generics: {
				LinkedList: symbol;
				LinkedListNode: symbol;
				Queue: symbol;
				Stack: symbol;
				IList: symbol;
				List: symbol;
				SortedList: symbol;
				ICollection: symbol;
				DictionaryEntry: symbol;
				Dictionaries: {
					Dictionary: symbol;
					DictionaryBase: symbol;
					IDictionary: symbol;
					IReadOnlyDictionary: symbol;
					OrderedStringKeyDictionary: symbol;
					SimpleDictionary: symbol;
					SimpleDictionaryEnumerator: symbol;
					StringKeyDictionary: symbol;
					KeyCollection: symbol;
				};
				RandomizedObjectEqualityComparer: symbol;
				IDictionary: symbol;
				KeyValuePair: symbol;
			};
			Hashtable: {
				Hashtable: symbol;
				KeyCollection: symbol;
			};
		};
		Disposable: {
			IDisposable: symbol;
			IDisposableAware: symbol;
			DisposableBase: symbol;
		};
		Reflection: {
			Decorators: {
				Class: symbol;
			};
			ClassType: symbol;
		};
		Windows: {
			Forms: {
				Components: {
					TuElement: symbol;
					TuElement2: symbol;
				};
			};
		};
		Math: {
			Circle: symbol;
			Vector: symbol;
			Vector2: symbol;
			Vector3: symbol;
			Matrix3: symbol;
			Matrix4: symbol;
			Affine2: symbol;
			Quaternion: symbol;
			GridPoint2: symbol;
		};
		ICloneable: symbol;
		IEquatable: symbol;
		IComparer: symbol;
		IComparable: symbol;
		IEqualityComparer: symbol;
		IWellKnownStringEqualityComparer: symbol;
		Delegate: symbol;
		IFormatProvider: symbol;
	};
	const Runtime: {
		Serialization: {
			ISerializable: symbol;
		};
	};
	class out {
		static println(str: string): void;
	}
	class err {
		static println(str: string): void;
	}
}
export declare function toByte(value: number): number;
export declare function toChar(value: number): char;
export declare function toDouble(value: number): float;
export declare function toFloat(value: number): float;
export declare function toShort(value: number): short;
export declare function trace(msg: string): void;
export declare class TypeInfoHelper extends TypeInfo {
	private _value;
	constructor(value: any);
	contains<TDescriptor>(descriptor: any): this is TDescriptor;
}
export declare class TypeValidator<T> {
	private readonly _typeDescriptor;
	constructor(_typeDescriptor: any);
	isSubsetOf(o: any): o is T;
}
export declare namespace TypeValue {
	type Boolean = "boolean";
	type Number = "number";
	type String = "string";
	type Symbol = "symbol";
	type Object = "object";
	type Undefined = "undefined";
	type Function = "function";
	type Primitive = String | Number | Boolean;
	type Any = Primitive | Symbol | Undefined | Function;
}
/**
 * Remove duplicate items from Array
 * Example
 * var array = [1, 2, 2, 3, 3, 4, 5, 6];
 * var newArray = Hoek.unique(array);    // results in [1,2,3,4,5,6]
 * array = [{id: 1}, {id: 1}, {id: 2}];
 * newArray = unique(array, "id");  // results in [{id: 1}, {id: 2}]
 * @param array Array to
 * @param key
 */
export declare function unique(array: any[], key?: string): any[];
export declare class Void {
}
export declare function warn(str: string): void;
export declare enum Order {
	Ascending = 0,
	Descending = 1
}
/**
 * A factory function that creates a comparer to be used in multi-dimensional sorting.
 *
 * <h4>Example</h4>
 * ```typescript
 * var myArray = [{a:1:b:2},{a:3,b:4},{a:1,b:3}];
 *
 * // First sort by a, then by b.
 * myArray.sort(
 *   createComparer(
 *     (e)=> [e.a, e.b],
 *     [Order.Ascending, Order.Descending]
 *   )
 * );
 *
 * // result: [{a:1,b:3},{a:1:b:2},{a:3,b:4}]
 * ```
 *
 * @param selector
 * @param order
 * @param equivalentToNaN
 * @returns {(a:TSource, b:TSource)=>CompareResult}
 */
export declare function createComparer<TSource, TSelect extends Primitive>(selector: Selector<TSource, TSelect | TSelect[]>, order?: Order | Order[], equivalentToNaN?: any): Comparison<TSource>;
/**
 * https://en.wikipedia.org/wiki/Insertion_sort
 * @param target
 * @returns {T[]}
 */
export declare function insertionSort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(target: TArray): TArray;
/**
 * Merge internalSort O(n log (n))
 * Warning: Uses recursion.
 * @param target
 * @returns {number[]}
 */
export declare function mergeSort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(target: TArray): TArray;
/**
 * Quick internalSort O(n log (n))
 * Warning: Uses recursion.
 * @param target
 * @returns {T[]}
 */
export declare function quickSort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(target: TArray): TArray;
export declare function $array(...args: any[]): any[];
/**
 *
 * @param source
 * @param sourceIndex
 * @param length
 * @returns {any}
 */
export declare function copy<T>(source: ArrayLike<T>, sourceIndex?: number, length?: number): T[];
/**
 * Copies one array to another.
 * @param source
 * @param destination
 * @param sourceIndex
 * @param destinationIndex
 * @param length An optional limit to stop copying.
 * @returns The destination array.
 */
export declare function copyTo<T, TDestination extends ArrayLikeWritable<T>>(source: ArrayLike<T>, destination: TDestination, sourceIndex?: number, destinationIndex?: number, length?: number): TDestination;
export interface DispatchErrorHandler {
	(ex: any, index: number): void;
}
/**
 * Simply takes a payload and passes it to all the listeners.
 * Makes a arrayCopy of the listeners before calling dispatchUnsafe.
 *
 * @param listeners
 * @param payload
 * @param trap
 */
export declare function dispatch<T>(listeners: ArrayLike<Selector<T, any>>, payload: T, trap?: boolean | DispatchErrorHandler): void;
export declare namespace dispatch {
	/**
	 * Simply takes a payload and passes it to all the listeners.
	 *
	 * While dispatching:
	 * * This is an unsafe method if by chance any of the listeners modify the array.
	 * * It cannot prevent changes to the payload.
	 *
	 * Improving safety:
	 * * Only use a local array that isn't exposed to the listeners.
	 * * Use the dispatch method instead as it makes a arrayCopy of the listeners array.
	 * * Freeze the listeners array so it can't be modified.
	 * * Freeze the payload.
	 *
	 * Specifying trap will catch any errors and pass them along if trap is a function.
	 * A payload is used instead of arguments for easy typing.
	 *
	 *
	 * @param listeners
	 * @param payload
	 * @param trap
	 */
	function unsafe<T>(listeners: ArrayLike<Selector<T, any>>, payload: T, trap?: boolean | DispatchErrorHandler): void;
	/**
	 * Simply takes a payload and passes it to all the listeners.
	 * Returns the results in an array that matches the indexes of the listeners.
	 *
	 * @param listeners
	 * @param payload
	 * @param trap
	 * @returns {any}
	 */
	function mapped<T, TResult>(listeners: ArrayLike<Selector<T, TResult>>, payload: T, trap?: boolean | DispatchErrorHandler): TResult[];
}
/**
 * Initializes an array depending on the requested capacity.
 * The returned array will have a .length equal to the value provided.
 * @param length
 * @returns {T[]}
 */
export declare function initialize<T>(length: number): T[];
export declare function sum(source: ArrayLike<number>, ignoreNaN?: boolean): number;
export declare function average(source: ArrayLike<number>, ignoreNaN?: boolean): number;
export declare function product(source: ArrayLike<number>, ignoreNaN?: boolean): number;
/**
 * Takes the first number and divides it by all following.
 * @param source
 * @param ignoreNaN Will cause this skip any NaN values.
 * @returns {number}
 */
export declare function quotient(source: ArrayLike<number>, ignoreNaN?: boolean): number;
export declare function min(source: ArrayLike<number>, ignoreNaN?: boolean): number;
export declare function max(source: ArrayLike<number>, ignoreNaN?: boolean): number;
export interface IReadOnlyCollection<T> extends IEnumerable<T> {
	Count: number;
	IsReadOnly: boolean;
	contains(entry: T): boolean;
	copyTo(target: Array<T>, index?: number): Array<T>;
	toArray(): T[];
	GetEnumerator(): IEnumerator<T>;
	IsEndless?: boolean;
}
export declare type IEnumerableOrArray<T> = ArrayLike<T> | IEnumerable<T>;
export interface _ICollection<T> extends IReadOnlyCollection<T> {
	add(entry: T): int;
	remove(entry: T, max?: number): number;
	clear(): number;
	importEntries(entries: IEnumerableOrArray<T> | IEnumerator<T>): number;
	toArray(): T[];
	removeAt(index: number): void;
	Count: number;
	IsReadOnly: boolean;
	contains(entry: T): boolean;
	copyTo(target: Array<T>, index?: number): Array<T>;
	toArray(): T[];
	GetEnumerator(): IEnumerator<T>;
	IsEndless?: boolean;
}
export interface IEnumerateEach<T> {
	/**
	 * If the action returns false, the enumeration will stop.
	 * @param action
	 * @param useCopy
	 */
	_forEach(action: ActionWithIndex<T>, useCopy?: boolean): number;
	_forEach(action: PredicateWithIndex<T>, useCopy?: boolean): number;
}
export interface IComparer<T> {
	Compare(a: T, b: T): number;
}
export declare class ArrayLikeCollection<T> extends DisposableBase {
	[key: number]: T;
	[Symbol.unscopables](): {
		copyWithin: boolean;
		entries: boolean;
		fill: boolean;
		find: boolean;
		findIndex: boolean;
		keys: boolean;
		values: boolean;
	};
	private args;
	constructor(..._arguments: T[]);
	get IsEmpty(): boolean;
	each(func: Function): void;
	toArray(): Array<T>;
	copyArray(): Array<T>;
	copyTo(array: Array<T>, index: number): Array<T>;
	insert(index: number, item: T): void;
	add(item: T): void;
	addRange(coll: _ICollection<T> | T[]): void;
	static _mapMethod(methodName: string): void;
	static mapMethods(constructor: Function): void;
	ToString(): string;
	/**
	  * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
	  */
	toLocaleString(): string;
	/**
	  * Removes the last element from an array and returns it.
	  */
	pop(): T | undefined;
	/**
	  * Appends new elements to an array, and returns the new length of the array.
	  * @param items New elements of the Array.
	  */
	push(...items: T[]): number;
	/**
	  * Combines two or more arrays.
	  * @param items Additional items to add to the end of array1.
	  */
	concat(...items: ConcatArray<T>[]): T[];
	concat(...items: (T | ConcatArray<T>)[]): T[];
	/**
	  * Combines two or more arrays.
	  * @param items Additional items to add to the end of array1.
	  */
	/**
	  * Adds all the elements of an array separated by the specified separator string.
	  * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
	  */
	join(separator?: string): string;
	/**
	  * Reverses the elements in an Array.
	  */
	reverse(): T[];
	/**
	  * Removes the first element from an array and returns it.
	  */
	shift(): T | undefined;
	/**
	  * Returns a section of an array.
	  * @param start The beginning of the specified portion of the array.
	  * @param end The end of the specified portion of the array.
	  */
	slice(start?: number, end?: number): T[];
	/**
	  * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.
	  * @param start The zero-based location in the array from which to start removing elements.
	  * @param deleteCount The number of elements to remove.
	  */
	splice(start: number, deleteCount?: number): T[];
	splice(start: number, deleteCount: number, ...items: T[]): T[];
	/**
	  * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.
	  * @param start The zero-based location in the array from which to start removing elements.
	  * @param deleteCount The number of elements to remove.
	  * @param items Elements to insert into the array in place of the deleted elements.
	  */
	/**
	  * Inserts new elements at the start of an array.
	  * @param items  Elements to insert at the start of the Array.
	  */
	unshift(...items: T[]): number;
	/**
	  * Returns the index of the first occurrence of a value in an array.
	  * @param searchElement The value to locate in the array.
	  * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
	  */
	indexOf(searchElement: T, fromIndex?: number): number;
	/**
	  * Returns the index of the last occurrence of a specified value in an array.
	  * @param searchElement The value to locate in the array.
	  * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
	  */
	lastIndexOf(searchElement: T, fromIndex?: number): number;
	/**
	  * Determines whether all the members of an array satisfy the specified test.
	  * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in array1 until the callbackfn returns false, or until the end of the array.
	  * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
	  */
	every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;
	/**
	  * Determines whether the specified callback function returns true for any element of an array.
	  * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in array1 until the callbackfn returns true, or until the end of the array.
	  * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
	  */
	some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any): boolean;
	/**
	  * Performs the specified action for each element in an array.
	  * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
	  * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
	  */
	forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;
	/**
	  * Calls a defined callback function on each element of an array, and returns an array that contains the results.
	  * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
	  * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
	  */
	map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];
	/**
	 * Returns the elements of an array that meet the condition specified in a callback function.
	 * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.
	 * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
	 */
	filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];
	filter(callbackfn: (value: T, index: number, array: T[]) => any, thisArg?: any): T[];
	/**
	  * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
	  * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
	  * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
	  */
	reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;
	reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;
	reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;
	/**
	  * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
	  * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
	  * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
	  */
	reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T): T;
	reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) => T, initialValue: T): T;
	reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U, initialValue: U): U;
	find<S extends T>(predicate: (this: void, value: T, index: number, obj: T[]) => value is S, thisArg?: any): S | undefined;
	find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined;
	findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number;
	fill(value: T, start?: number, end?: number): T[];
	copyWithin(target: number, start: number, end?: number): T[];
	/** Iterator */
	[Symbol.iterator](): IterableIterator<T>;
	/**
	 * Returns an iterable of key, value pairs for every entry in the array
	 */
	entries(): IterableIterator<[
		number,
		T
	]>;
	keys(): IterableIterator<number>;
	values(): IterableIterator<T>;
	getUpperBound(index: number): number;
	equals(array: Array<T>): boolean;
	clone(): Array<T>;
	length: number;
	sort(compareFn?: (a: T, b: T) => number): T[];
	sortItems(comparer: IComparer<T>, index?: number, count?: number): void;
	contains(obj: T): boolean;
	get Count(): number;
	get IsReadOnly(): boolean;
	removeAt(index: number): void;
	static FastRemove<T>(a: ArrayLikeCollection<T>, o: T): number;
}
export declare class ArrayList<T = any> implements IList<T>, ICollection<T>, IEnumerable<T>, ICloneable<ArrayList<T>> {
	importEntries(entries: IEnumerable<T> | ArrayLike<T> | IEnumerator<T>): number;
	IsEndless?: boolean | undefined;
	private _items;
	private _size;
	private _version;
	private static readonly _defaultCapacity;
	private static readonly emptyArray;
	get Capacity(): int;
	set Capacity(value: int);
	protected /**virtual */ GetCapacity(): int;
	protected /**virtual */ SetCapacity(value: int): void;
	get Count(): int;
	Get_Count(): int;
	get IsFixedSize(): boolean;
	Get_IsFixedSize(): boolean;
	get IsReadOnly(): boolean;
	Get_IsReadOnly(): boolean;
	Get(index: int): T;
	Set(index: int, value: T): boolean;
	staticConstructor(): void;
	constructor();
	constructor(array: Array<any>);
	constructor(trash: boolean);
	constructor(capacity: int);
	constructor(c: ICollection<T>);
	static Adapter<T>(list: IList<T>): ArrayList;
	Add(value: T): int;
	AddRange(c: ICollection<T> | Array<T>): void;
	Clear(): number;
	Clone(): ArrayList<T>;
	Contains(item: T): boolean;
	CopyTo(array: Array<T>): Array<T>;
	CopyTo(array: Array<T>, arrayIndex: int): Array<T>;
	CopyTo(index: int, array: Array<T>, arrayIndex: int, count: int): Array<T>;
	private ensureCapacity;
	static FixedSize<T>(list: IList<T>): IList<T>;
	static FixedSize<T>(list: ArrayList<T>): ArrayList<T>;
	GetEnumerator(): IEnumerator<T>;
	GetEnumerator(index: int, count: int): IEnumerator<T>;
	GetRange(index: int, count: int): ArrayList<T>;
	IndexOf(value: T): int;
	IndexOf(value: T, startIndex: int): int;
	IndexOf(value: T, startIndex: int, count: int): int;
	Insert(index: int, value: T): void;
	InsertRange(index: int, c: ICollection<T>): void;
	InsertRange(index: int, c: Array<T>): void;
	LastIndexOf(value: T): int;
	LastIndexOf(value: T, startIndex: int): int;
	LastIndexOf(value: T, startIndex: int, count: int): int;
	static ReadOnly<T>(list: IList<T>): IList<T>;
	static ReadOnly<T>(list: ArrayList<T>): ArrayList<T>;
	Remove(obj: T): boolean;
	RemoveAt(index: int): boolean;
	RemoveRange(index: int, count: int): void;
	static Repeat<T>(value: T, count: int): ArrayList<T>;
	Reverse(): void;
	Reverse(index: int, count: int): void;
	SetRange(index: int, c: ICollection<T>): void;
	Sort(): void;
	Sort(comparer: IComparer<T>): void;
	Sort(index: int, count: int, comparer: IComparer<T>): void;
	ToArray(): Array<T>;
	TrimToSize(): void;
	BinarySearch(value: T): int;
	BinarySearch(value: T, comparer: IComparer<T>): int;
	BinarySearch(index: int, count: int, value: T, comparer: IComparer<T>): int;
	ToString(): string;
	private static ArrayListEnumerator;
	private static FixedSizeArrayList;
	private static FixedSizeList;
	private static IListWrapper;
}
export declare class Range<T> extends ArrayList<T> {
	private _baseList;
	private _baseIndex;
	private _baseSize;
	private _baseVersion;
	GetCapacity(): int;
	SetCapacity(value: int): void;
	Get_Count(): int;
	Get_IsFixedSize(): boolean;
	Get_IsReadOnly(): boolean;
	Get(index: int): T;
	Set(index: int, value: T): boolean;
	constructor(list: ArrayList<T>, index: int, count: int);
	Add(value: T): int;
	AddRange(c: ICollection<T>): void;
	Clear(): number;
	Clone(): Range<T>;
	Contains(item: T): boolean;
	CopyTo(array: Array<T>): Array<T>;
	CopyTo(array: Array<T>, arrayIndex: int): Array<T>;
	CopyTo(index: int, array: Array<T>, arrayIndex: int, count: int): Array<T>;
	GetEnumerator(): IEnumerator<T>;
	GetEnumerator(index: int, count: int): IEnumerator<T>;
	GetRange(index: int, count: int): ArrayList<T>;
	IndexOf(value: T): int;
	IndexOf(value: T, startIndex: int): int;
	IndexOf(value: T, startIndex: int, count: int): int;
	Insert(index: int, value: T): void;
	InsertRange(index: int, c: ICollection<T>): void;
	InsertRange(index: int, c: Array<T>): void;
	private internalUpdateRange;
	private internalUpdateVersion;
	LastIndexOf(value: T): int;
	LastIndexOf(value: T, startIndex: int): int;
	LastIndexOf(value: T, startIndex: int, count: int): int;
	RemoveAt(index: int): boolean;
	RemoveRange(index: int, count: int): void;
	Reverse(): void;
	Reverse(index: int, count: int): void;
	SetRange(index: int, c: ICollection<T>): void;
	Sort(): void;
	Sort(comparer: IComparer<T>): void;
	Sort(index: int, count: int, comparer: IComparer<T>): void;
	ToArray(): Array<T>;
}
export declare class ReadOnlyArrayList<T> extends ArrayList<T> {
	private _list;
	GetCapacity(): int;
	SetCapacity(value: int): void;
	Get_Count(): int;
	Get_IsFixedSize(): boolean;
	Get_IsReadOnly(): boolean;
	Get(index: int): T;
	Set(index: int, value: T): boolean;
	constructor(l: ArrayList<T>);
	Add(obj: T): int;
	AddRange(c: ICollection<T>): void;
	Clear(): number;
	Clone(): ReadOnlyArrayList<T>;
	Contains(obj: T): boolean;
	CopyTo(array: Array<T>): Array<T>;
	CopyTo(array: Array<T>, arrayIndex: int): Array<T>;
	CopyTo(index: int, array: Array<T>, arrayIndex: int, count: int): Array<T>;
	GetEnumerator(): IEnumerator<T>;
	GetEnumerator(index: int, count: int): IEnumerator<T>;
	GetRange(index: int, count: int): ArrayList<T>;
	IndexOf(value: T): int;
	IndexOf(value: T, startIndex: int): int;
	IndexOf(value: T, startIndex: int, count: int): int;
	Insert(index: int, obj: T): void;
	InsertRange(index: int, c: ICollection<T>): void;
	InsertRange(index: int, c: Array<T>): void;
	LastIndexOf(value: T): int;
	LastIndexOf(value: T, startIndex: int): int;
	LastIndexOf(value: T, startIndex: int, count: int): int;
	Remove(value: T): boolean;
	RemoveAt(index: int): boolean;
	RemoveRange(index: int, count: int): void;
	Reverse(): void;
	Reverse(index: int, count: int): void;
	SetRange(index: int, c: ICollection<T>): void;
	Sort(): void;
	Sort(comparer: IComparer<T>): void;
	Sort(index: int, count: int, comparer: IComparer<T>): void;
	ToArray(): T[];
}
export declare class ReadOnlyList<T> implements IList<T>, ICollection<T>, IEnumerable<T> {
	private _list;
	get Count(): int;
	get IsFixedSize(): boolean;
	get IsReadOnly(): boolean;
	Get(index: int): T;
	Set(index: int, value: T): boolean;
	constructor(l: IList<T>);
	Add(obj: T): int;
	Clear(): number;
	Contains(obj: T): boolean;
	CopyTo(array: Array<T>, index: int): Array<T>;
	GetEnumerator(): IEnumerator<T>;
	IndexOf(value: T): int;
	Insert(index: int, obj: T): void;
	Remove(value: T): boolean;
	RemoveAt(index: int): boolean;
}
export declare class ArrayListEnumeratorSimple<T> implements IEnumerator<T>, ICloneable<T> {
	private list;
	private index;
	private version;
	private currentElement;
	private isArrayList;
	private static dummyObject;
	get Current(): T;
	static staticConstructor(): void;
	constructor(list: ArrayList<T>);
	Clone(): T;
	MoveNext(): boolean;
	Reset(): void;
	CanMoveNext?: boolean | undefined;
	TryMoveNext(out: (value: T) => void): boolean;
	End(): void;
	NextValue(value?: any): T | undefined;
	IsEndless?: boolean | undefined;
	Next(value?: any): IIteratorResult<T>;
	Dispose(): void;
}
declare abstract class _CollectionBase<T> extends ArrayLikeCollection<T> implements _ICollection<T>, IEnumerateEach<T> {
	protected _equalityComparer: EqualityComparison<T | null | undefined>;
	constructor(source?: IEnumerableOrArray<T> | IEnumerator<T>, _equalityComparer?: EqualityComparison<T | null | undefined>);
	protected abstract getCount(): number;
	get Count(): number;
	protected getIsReadOnly(): boolean;
	get IsReadOnly(): boolean;
	protected assertModifiable(): true | never;
	protected _version: number;
	protected assertVersion(version: number): true | never;
	private _modifiedCount;
	private _updateRecursion;
	protected _onModified(): void;
	protected _signalModification(increment?: boolean): boolean;
	protected _incrementModified(): void;
	get isUpdating(): boolean;
	/**
	 * Takes a closure that if returning true will propagate an update signal.
	 * Multiple update operations can be occurring at once or recursively and the onModified signal will only occur once they're done.
	 * @param closure
	 * @returns {boolean}
	 */
	handleUpdate(closure?: () => boolean): boolean;
	protected abstract _addInternal(entry: T): boolean;
	/**
	 * Adds an entry to the collection.
	 * @param entry
	 */
	add(entry: T): int;
	protected abstract _removeInternal(entry: T, max?: number): number;
	/**
	 * Removes entries from the collection allowing for a limit.
	 * For example if the collection not a distinct set, more than one entry could be removed.
	 * @param entry The entry to remove.
	 * @param max Limit of entries to remove.  Will remove all matches if no max specified.
	 * @returns {number} The number of entries removed.
	 */
	remove(entry: T, max?: number): number;
	protected abstract _clearInternal(): number;
	/**
	 * Clears the contents of the collection resulting in a count of zero.
	 * @returns {number}
	 */
	clear(): number;
	protected _onDispose(): void;
	protected _importEntries(entries: IEnumerableOrArray<T> | IEnumerator<T> | null | undefined): number;
	/**
	 * Safely imports any array enumerator, or enumerable.
	 * @param entries
	 * @returns {number}
	 */
	importEntries(entries: IEnumerableOrArray<T> | IEnumerator<T>): number;
	/**
	 * Returns a enumerator for this collection.
	 */
	abstract GetEnumerator(): IEnumerator<T>;
	/**
	 * Returns an array filtered by the provided predicate.
	 * Provided for similarity to JS Array.
	 * @param predicate
	 * @returns {[]}
	 */
	_filter(predicate: PredicateWithIndex<T>): T[];
	/**
	 * Returns true the first time predicate returns true.  Otherwise false.
	 * Useful for searching through a collection.
	 * @param predicate
	 * @returns {any}
	 */
	any(predicate?: PredicateWithIndex<T>): boolean;
	/**
	 * Returns true the first time predicate returns true.  Otherwise false.
	 * See '.any(predicate)'.  As this method is just just included to have similarity with a JS Array.
	 * @param predicate
	 * @returns {any}
	 */
	_some(predicate?: PredicateWithIndex<T>): boolean;
	/**
	 * Returns true if the equality comparer resolves true on any element in the collection.
	 * @param entry
	 * @returns {boolean}
	 */
	contains(entry: T): boolean;
	/**
	 * Special implementation of 'forEach': If the action returns 'false' the enumeration will stop.
	 * @param action
	 * @param useCopy
	 */
	_forEach(action: ActionWithIndex<T>, useCopy?: boolean): number;
	_forEach(action: PredicateWithIndex<T>, useCopy?: boolean): number;
	/**
	 * Copies all values to numerically indexable object.
	 * @param target
	 * @param index
	 * @returns {TTarget}
	 */
	copyTo(target: Array<T>, index?: number): Array<T>;
	/**
	 * Returns an array of the collection contents.
	 * @returns {any[]|Array}
	 */
	toArray(): T[];
}
export declare abstract class ReadOnlyCollectionBase<T> implements ICollection<T>, IEnumerable<T> {
	private list;
	protected Get_Count(): int;
	get Count(): int;
	protected get InnerList(): ArrayList<T>;
	protected constructor();
	get IsReadOnly(): boolean;
	Add(item: T): void;
	Clear(): void;
	Contains(item: T): boolean;
	Remove(item: T): boolean;
	IsEndless?: boolean | undefined;
	GetEnumerator(): IEnumerator<T>;
	CopyTo(array: Array<T>, index: int): void;
}
export declare abstract class _ReadOnlyCollectionBase<T> extends _CollectionBase<T> {
	protected abstract _getCount(): number;
	protected getCount(): number;
	protected getIsReadOnly(): boolean;
	protected _addInternal(_entry: T): boolean;
	protected _removeInternal(_entry: T, _max?: number): number;
	protected _clearInternal(): number;
	protected abstract _getEnumerator(): IEnumerator<T>;
	GetEnumerator(): IEnumerator<T>;
}
export declare class ReadOnlyCollectionWrapper<T> extends _ReadOnlyCollectionBase<T> {
	constructor(collection: _ICollection<T> | ArrayLike<T>);
	private __getCount;
	private __getEnumerator;
	protected _getCount(): number;
	protected _getEnumerator(): IEnumerator<T>;
	protected _onDispose(): void;
}
export declare class ReadOnlyArrayWrapper<T> extends ReadOnlyCollectionWrapper<T> {
	constructor(array: ArrayLike<T>);
	protected _onDispose(): void;
	private __getValueAt;
	getValueAt(index: number): T;
}
/**
 * Randomize array element order in-place.
 * Using Durstenfeld shuffle algorithm.
 */
export declare function shuffle<T extends ArrayLikeWritable<any>>(target: T): T;
export declare class ArraySort {
	static readonly quick: typeof quickSort;
	static using<TSource, TSelect extends Primitive>(target: TSource[], selector: Selector<TSource, TSelect | TSelect[]>, order?: Order | Order[], equivalentToNaN?: any): TSource[];
}
export interface ILinkedNodeList<TNode extends ILinkedNode<TNode>> {
	first: TNode | null;
	last: TNode | null;
	getNodeAt(index: number): TNode | null;
	removeNode(node: TNode): boolean;
}
export interface ILinkedList<T> extends ILinkedNodeList<ILinkedListNode<T>>, _ICollection<T>, IEnumerateEach<T> {
	first: ILinkedListNode<T> | null;
	last: ILinkedListNode<T> | null;
	getValueAt(index: number): T | undefined;
	_find(entry: T): ILinkedListNode<T> | null;
	findLast(entry: T): ILinkedListNode<T> | null;
	addFirst(entry: T): void;
	addLast(entry: T): void;
	removeFirst(): void;
	removeLast(): void;
	addAfter(node: ILinkedListNode<T>, entry: T): void;
}
export interface ILinkedNode<TNode extends ILinkedNode<TNode>> {
	previous?: TNode | null;
	next?: TNode | null;
}
export interface INodeWithValue<TValue> {
	value: TValue;
}
export interface ILinkedNodeWithValue<T> extends ILinkedNode<ILinkedListNode<T>>, INodeWithValue<T> {
}
export interface ILinkedListNode<T> extends ILinkedNodeWithValue<T> {
	previous: ILinkedListNode<T> | null;
	next: ILinkedListNode<T> | null;
	list: ILinkedList<T>;
	addBefore(entry: T): void;
	addAfter(entry: T): void;
	remove(): void;
}
/**
 * JavaScript hashing can only truly be done with strings (and potentially symbols).
 * This provides a mechanism to enforce hashable
 */
export interface IHashable {
	getHashCode(): string | number;
}
export interface ISymbolizable {
	getSymbol(): symbol;
}
export interface IDictionary<TKey, TValue> extends _ICollection<IKeyValuePair<TKey, TValue>> {
	Keys: TKey[];
	Values: TValue[];
	addByKeyValue(key: TKey, value: TValue): boolean;
	setValue(key: TKey, value: TValue | undefined): boolean;
	getValue(key: TKey): TValue | undefined;
	getAssuredValue(key: TKey): TValue;
	tryGetValue(key: TKey, out: Action<TValue>): boolean;
	containsKey(key: TKey): boolean;
	containsValue(value: TValue): boolean;
	removeByKey(key: TKey): boolean;
	removeByValue(value: TValue): number;
}
export interface IStringKeyDictionary<TValue> extends IDictionary<string, TValue>, _ICollection<IStringKeyValuePair<TValue>> {
	importMap(map: IMap<TValue>): boolean;
}
export interface IOrderedDictionary<TKey, TValue> extends IDictionary<TKey, TValue> {
	indexOfKey(key: TKey): number;
	getValueByIndex(index: number): TValue;
}
export declare abstract class DictionaryBase<TKey, TValue> extends _CollectionBase<IKeyValuePair<TKey, TValue>> implements IDictionary<TKey, TValue> {
	constructor(source?: IEnumerableOrArray<IKeyValuePair<TKey, TValue>>);
	protected _onValueModified(_key: TKey, _value: TValue | undefined, _old: TValue | undefined): void;
	protected _addInternal(item: KeyValuePair<TKey, TValue>): boolean;
	protected _clearInternal(): number;
	contains(item: KeyValuePair<TKey, TValue>): boolean;
	protected _removeInternal(item: IKeyValuePair<TKey, TValue> | [
		TKey,
		TValue
	]): number;
	protected abstract getKeys(): TKey[];
	get Keys(): TKey[];
	protected abstract getValues(): TValue[];
	get Values(): TValue[];
	addByKeyValue(key: TKey, value: TValue): boolean;
	protected abstract _getEntry(key: TKey): IKeyValuePair<TKey, TValue> | null;
	abstract getValue(key: TKey): TValue | undefined;
	getAssuredValue(key: TKey): TValue;
	tryGetValue(key: TKey, out: Action<TValue>): boolean;
	protected abstract _setValueInternal(key: TKey, value: TValue | undefined): boolean;
	/**
	 * Sets the value of an entry.
	 * It's important to know that 'undefined' cannot exist as a value in the dictionary and is used as a flag for removal.
	 * @param key
	 * @param value
	 * @returns {boolean}
	 */
	setValue(key: TKey, value: TValue | undefined): boolean;
	containsKey(key: TKey): boolean;
	containsValue(value: TValue): boolean;
	removeByKey(key: TKey): boolean;
	removeByValue(value: TValue): number;
	importEntries(pairs: IEnumerableOrArray<KeyValuePair<TKey, TValue>> | IEnumerator<KeyValuePair<TKey, TValue>> | null | undefined): number;
	protected _importEntries(pairs: IEnumerableOrArray<KeyValuePair<TKey, TValue>> | IEnumerator<KeyValuePair<TKey, TValue>> | null | undefined): number;
	GetEnumerator(): IEnumerator<IKeyValuePair<TKey, TValue>>;
}
export interface IHashEntry<TKey, TValue> extends ILinkedNode<IHashEntry<TKey, TValue>>, IKeyValuePair<TKey, TValue> {
}
export declare class _Dictionary<TKey, TValue> extends DictionaryBase<TKey, TValue> {
	private readonly _keyGenerator?;
	private readonly _entries;
	private readonly _buckets;
	constructor(_keyGenerator?: Selector<TKey, string | number | symbol> | undefined);
	protected _onDispose(): void;
	protected getCount(): number;
	private _getBucket;
	private _getBucketEntry;
	protected _getEntry(key: TKey): IHashEntry<TKey, TValue> | null;
	getValue(key: TKey): TValue | undefined;
	protected _setValueInternal(key: TKey, value: TValue | undefined): boolean;
	protected _clearInternal(): number;
	GetEnumerator(): IEnumerator<IKeyValuePair<TKey, TValue>>;
	protected getKeys(): TKey[];
	protected getValues(): TValue[];
}
export declare function getIdentifier(obj: any): string | number | symbol;
export declare function getIdentifier(obj: any, throwIfUnknown: false): string | number | symbol;
export declare function getIdentifier(obj: any, throwIfUnknown: boolean): string | number | symbol | never;
export declare function getIdentifier(obj: any, unknownHandler: Selector<any, string | number | symbol>): string | number | symbol;
export declare class StringKeyDictionary<TValue> extends DictionaryBase<string, TValue> implements IStringKeyDictionary<TValue> {
	protected _onDispose(): void;
	private _count;
	private readonly _map;
	protected _getEntry(key: string): IKeyValuePair<string, TValue> | null;
	containsKey(key: string): boolean;
	containsValue(value: TValue): boolean;
	getValue(key: string): TValue | undefined;
	protected _setValueInternal(key: string, value: TValue | undefined): boolean;
	importMap(values: IMap<TValue>): boolean;
	toMap(selector?: (key: string, value: TValue) => TValue): IMap<TValue>;
	protected getKeys(): string[];
	protected getValues(): TValue[];
	protected getCount(): number;
}
export declare class OrderedStringKeyDictionary<TValue> extends StringKeyDictionary<TValue> implements IOrderedDictionary<string, TValue> {
	private _order;
	constructor();
	indexOfKey(key: string): number;
	getValueByIndex(index: number): TValue;
	setValue(key: string, value: TValue | undefined, keepIndex?: boolean): boolean;
	setByIndex(index: number, value: TValue | undefined): boolean;
	importValues(values: TValue[]): boolean;
	setValues(...values: TValue[]): boolean;
	removeByIndex(index: number): boolean;
	protected getKeys(): string[];
}
export declare class SimpleDictionaryEnumerator<TKey, TValue> extends DisposableBase implements IEnumerator<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>> {
	private myArray;
	private myForward;
	private myIndex;
	constructor(a: SimpleDictionary<TKey, TValue>, forward: boolean);
	get Current(): {
		key: TKey;
		value: TValue;
	};
	GetEnumerator(): SimpleDictionaryEnumerator<TKey, TValue>;
	MoveNext(): boolean;
	Reset(): void;
	TryMoveNext(out: (value: KeyValuePair<TKey, TValue>) => void): boolean;
	End(): void;
	NextValue(value?: any): KeyValuePair<TKey, TValue> | undefined;
	IsEndless: boolean;
	Next(value?: any): IIteratorResult<KeyValuePair<TKey, TValue>>;
	"return"?(value?: any): IIteratorResult<any>;
	"throw"?(e?: any): IIteratorResult<KeyValuePair<TKey, TValue>>;
}
export declare class SimpleDictionary<TKey, TValue> implements IEnumerable<KeyValuePair<TKey, TValue>> {
	private keys;
	private values;
	get Values(): TValue[];
	constructor(init?: SimpleDictionary<TKey, TValue>);
	add(key: TKey, value: TValue): boolean;
	set(key: TKey, value: TValue): void;
	get Count(): number;
	contains(value: TValue): boolean;
	containsKey(key: TKey): boolean;
	remove(value: TValue): boolean;
	removeKey(key: TKey): void;
	tryGetValue(key: TKey, /*out*/ result: Out<TValue>): boolean;
	get(key: TKey): TValue;
	clear(): number;
	GetEnumerator(): SimpleDictionaryEnumerator<TKey, TValue>;
	getKeys(): TKey[];
}
export interface IYield<T> {
	current: T | undefined;
	yieldReturn(value: T | undefined): boolean;
	yieldBreak(): boolean;
}
export declare class EnumeratorBase<T> extends DisposableBase implements IEnumerator<T> {
	private _initializer;
	private _tryGetNext;
	private _yielder;
	private _state;
	private _disposer;
	get Current(): T;
	get index(): number;
	constructor(initializer: Closure | null, tryGetNext: (yielder: IYield<T>) => boolean, isEndless?: boolean);
	constructor(initializer: Closure | null, tryGetNext: (yielder: IYield<T>) => boolean, disposer?: Closure | null, isEndless?: boolean);
	protected _isEndless: boolean;
	get IsEndless(): boolean | undefined;
	/**
	 * Added for compatibility but only works if the enumerator is active.
	 */
	Reset(): void;
	private _assertBadState;
	/**
	 * Passes the current value to the out callback if the enumerator is active.
	 * Note: Will throw ObjectDisposedException if this has faulted or manually disposed.
	 */
	tryGetCurrent(out: Action<T>): boolean;
	get CanMoveNext(): boolean;
	/**
	 * Safely moves to the next entry and returns true if there is one.
	 * Note: Will throw ObjectDisposedException if this has faulted or manually disposed.
	 */
	MoveNext(): boolean;
	/**
	 * Moves to the next entry and emits the value through the out callback.
	 * Note: Will throw ObjectDisposedException if this has faulted or manually disposed.
	 */
	TryMoveNext(out: Action<T>): boolean;
	NextValue(): T | undefined;
	/**
	 * Exposed for compatibility with generators.
	 */
	Next(): IIteratorResult<T>;
	End(): void;
	"return"(): IIteratorResult<void>;
	"return"<TReturn>(value: TReturn): IIteratorResult<TReturn>;
	private _ensureDisposeState;
	protected _onDispose(): void;
}
export interface IndexEnumeratorSource<T> {
	source: {
		[index: number]: T;
	};
	length: number;
	step?: number;
	pointer?: number;
}
export declare class IndexEnumerator<T> extends EnumeratorBase<T> {
	constructor(sourceFactory: () => IndexEnumeratorSource<T>);
}
export declare class ArrayEnumerator<T> extends IndexEnumerator<T> {
	constructor(arrayFactory: () => ArrayLike<T>, start?: number, step?: number);
	constructor(array: ArrayLike<T>, start?: number, step?: number);
}
export declare class EmptyEnumerable implements IEnumerable<any> {
	constructor();
	GetEnumerator(): IEnumerator<any>;
	/**
	 * Provides a way of flagging endless enumerations that may cause issues.
	 */
	readonly IsEndless: boolean;
}
/**
 * A simplified stripped down enumerable that is always complete and has no results.
 * Frozen and exported as 'empty' to allow for reuse.
 */
export declare const EmptyEnumerator: IEnumerator<any>;
export declare abstract class SimpleEnumerableBase<T> implements IEnumerator<T> {
	protected _current: T | undefined;
	protected _index: number;
	constructor();
	get Current(): T;
	protected abstract _canMoveNext(): boolean;
	get CanMoveNext(): boolean;
	abstract MoveNext(): boolean;
	TryMoveNext(out: Action<T>): boolean;
	protected incrementIndex(): number;
	NextValue(): T | undefined;
	Next(): IIteratorResult<T>;
	End(): void;
	"return"(): IIteratorResult<void>;
	"return"<TReturn>(value: TReturn): IIteratorResult<TReturn>;
	Reset(): void;
	Dispose(): void;
	protected getIsEndless(): boolean;
	get IsEndless(): boolean | undefined;
}
/**
 * An aggregate/reduce style factory function that expects a previous value and the current index of the enumeration.
 */
export interface InfiniteValueFactory<T> {
	(previous: T | undefined, index: number): T;
}
/**
 * A simplified stripped down enumerator that until disposed will infinitely return the provided factory.
 * This is analogous to a 'generator' and has a compatible interface.
 */
export declare class InfiniteEnumerator<T> extends SimpleEnumerableBase<T> {
	private readonly _factory;
	/**
	 * See InfiniteValueFactory
	 * @param _factory
	 */
	constructor(_factory: InfiniteValueFactory<T>);
	protected _canMoveNext(): boolean;
	MoveNext(): boolean;
	Dispose(): void;
}
export declare type ForEachEnumerable<T> = IEnumerableOrArray<T> | IEnumerator<T> | IIterator<T>;
export declare function throwIfEndless(isEndless: false): true;
export declare function throwIfEndless(isEndless: true): never;
export declare function throwIfEndless(isEndless: boolean | undefined): true | never;
/**
 * Returns the enumerator for the specified collection, enumerator, or iterator.
 * If the source is identified as IEnumerator it will return the source as is.
 * @param source
 * @returns {any}
 */
export declare function _from<T>(source: ForEachEnumerable<T> | InfiniteValueFactory<T>): IEnumerator<T>;
export declare function isEnumerable<T>(instance: any): instance is IEnumerable<T>;
export declare function isEnumerableOrArrayLike<T>(instance: any): instance is IEnumerableOrArray<T>;
export declare function isEnumerator<T>(instance: any): instance is IEnumerator<T>;
export declare function isIterator<T>(instance: any): instance is IIterator<T>;
/**
 * Flexible method for iterating any enumerable, enumerable, iterator, array, or array-like object.
 * @param e The enumeration to loop on.
 * @param action The action to take on each.
 * @param max Stops after max is reached.  Allows for forEach to be called on infinite enumerations.
 * @returns the total times iterated.  If the enumerable is unrecognized then -1.
 */
export declare function forEach<T>(e: ForEachEnumerable<T>, action: ActionWithIndex<T>, max?: number): number;
export declare function forEach<T>(e: ForEachEnumerable<T>, action: PredicateWithIndex<T>, max?: number): number;
/**
 * Converts any enumerable to an array.
 * @param source
 * @param max Stops after max is reached.  Allows for forEach to be called on infinite enumerations.
 * @returns {any}
 */
export declare function toArray<T>(source: ForEachEnumerable<T>, max?: number): T[];
/**
 * Converts any enumerable to an array of selected values.
 * @param source
 * @param selector
 * @param max Stops after max is reached.  Allows for forEach to be called on infinite enumerations.
 * @returns {TResult[]}
 */
export declare function map<T, TResult>(source: ForEachEnumerable<T>, selector: SelectorWithIndex<T, TResult>, max?: number): TResult[];
/**
 * A simplified stripped down enumerator that until disposed will infinitely return the provided factory.
 * This is analogous to a 'generator' and has a compatible interface.
 *
 *
 */
export declare class IteratorEnumerator<T> extends SimpleEnumerableBase<T> {
	private readonly _iterator;
	private readonly _isEndless?;
	/**
	 * @param _iterator
	 * @param _isEndless true and false are explicit where as undefined means 'unknown'.
	 */
	constructor(_iterator: IIterator<T>, _isEndless?: boolean | undefined);
	protected _canMoveNext(): boolean;
	MoveNext(value?: any): boolean;
	Dispose(): void;
	protected getIsEndless(): boolean;
}
export declare class IteratorResult<T> implements IIteratorResult<T> {
	readonly value: T;
	readonly index?: number;
	readonly done: boolean;
	constructor(value: T, done: boolean);
	constructor(value: T, index?: number, done?: boolean);
	static readonly Done: IteratorResult<any>;
	static GetDone(): IteratorResult<any>;
}
/**
 * Creates a randomized version of the source.
 * Note: An iterator will always require a arrayCopy (buffer) to pull random results one by one.
 */
export declare class Randomizer<T> extends SimpleEnumerableBase<T> {
	private readonly _allowReset;
	private readonly _buffer;
	private _pointer;
	constructor(source: ForEachEnumerable<T>, _allowReset?: boolean);
	protected _canMoveNext(): boolean;
	MoveNext(): boolean;
	Reset(): void;
	Dispose(): void;
	protected getIsEndless(): boolean;
}
export declare class UnsupportedEnumerableException extends SystemException {
	constructor(message?: string);
	protected getName(): string;
}
export declare class FloatComparer implements IComparer<float> {
	private static myDefaultComparer;
	static get Default(): FloatComparer;
	Compare(a: float, b: float): number;
}
declare class SortContext<T> implements IComparer<T> {
	protected _next: IComparer<T> | null;
	protected _comparer: Comparison<T>;
	protected _order: Order;
	/**
	 * Direction of the comparison.
	 * @type {Order}
	 */
	get order(): Order;
	constructor(_next: IComparer<T> | null, _comparer?: Comparison<T>, _order?: Order);
	/**
	 * Generates an array of indexes from the source in order of their expected internalSort without modifying the source.
	 * @param source
	 * @returns {number[]}
	 */
	generateSortedIndexes(source: T[]): number[];
	/**
	 * Compares two values based upon SortContext parameters.
	 * @param a
	 * @param b
	 * @returns {any}
	 */
	Compare(a: T, b: T): number;
}
export declare class KeySortedContext<T, TKey extends Comparable> extends SortContext<T> {
	protected _keySelector: Selector<T, TKey> | null;
	constructor(next: IComparer<T> | null, _keySelector: Selector<T, TKey> | null, order?: Order, comparer?: Comparison<T>);
	Compare(a: T, b: T): number;
}
declare class LinkedNodeList<TNode extends ILinkedNode<TNode>> implements ILinkedNodeList<TNode>, IEnumerateEach<TNode>, IDisposable {
	private _first;
	private _last;
	unsafeCount: number;
	constructor();
	private _version;
	assertVersion(version: number): true | never;
	/**
	 * The first node.  Will be null if the collection is empty.
	 */
	get first(): TNode | null;
	/**
	 * The last node.
	 */
	get last(): TNode | null;
	/**
	 * Iteratively counts the number of linked nodes and returns the value.
	 * @returns {number}
	 */
	get count(): number;
	_forEach(action: ActionWithIndex<TNode>, ignoreVersioning?: boolean): number;
	_forEach(action: PredicateWithIndex<TNode>, ignoreVersioning?: boolean): number;
	map<T>(selector: Selector<TNode, T>): T[];
	map<T>(selector: SelectorWithIndex<TNode, T>): T[];
	/**
	 * Erases the linked node's references to each other and returns the number of nodes.
	 * @returns {number}
	 */
	clear(): number;
	/**
	 * Clears the list.
	 */
	Dispose(): void;
	/**
	 * Iterates the list to see if a node exists.
	 * @param node
	 * @returns {boolean}
	 */
	contains(node: TNode): boolean;
	/**
	 * Gets the index of a particular node.
	 * @param index
	 */
	getNodeAt(index: number): TNode | null;
	find(condition: PredicateWithIndex<TNode>): TNode | null;
	/**
	 * Iterates the list to find the specified node and returns its index.
	 * @param node
	 * @returns {boolean}
	 */
	indexOf(node: TNode): number;
	/**
	 * Removes the first node and returns true if successful.
	 * @returns {boolean}
	 */
	removeFirst(): boolean;
	/**
	 * Removes the last node and returns true if successful.
	 * @returns {boolean}
	 */
	removeLast(): boolean;
	/**
	 * Removes the specified node.
	 * Returns true if successful and false if not found (already removed).
	 * @param node
	 * @returns {boolean}
	 */
	removeNode(node: TNode): boolean;
	/**
	 * Adds a node to the end of the list.
	 * @param node
	 * @returns {LinkedNodeList}
	 */
	addNode(node: TNode): this;
	/**
	 * Inserts a node before the specified 'before' node.
	 * If no 'before' node is specified, it inserts it as the first node.
	 * @param node
	 * @param before
	 * @returns {LinkedNodeList}
	 */
	addNodeBefore(node: TNode, before?: TNode | null): this;
	/**
	 * Inserts a node after the specified 'after' node.
	 * If no 'after' node is specified, it appends it as the last node.
	 * @param node
	 * @param after
	 * @returns {LinkedNodeList}
	 */
	addNodeAfter(node: TNode, after?: TNode | null): this;
	/**
	 * Takes and existing node and replaces it.
	 * @param node
	 * @param replacement
	 * @returns {any}
	 */
	replace(node: TNode, replacement: TNode): this;
	static valueEnumeratorFrom<T>(list: LinkedNodeList<ILinkedNodeWithValue<T>>): IEnumerator<T>;
	static copyValues<T, TDestination extends ArrayLikeWritable<any>>(list: LinkedNodeList<ILinkedNodeWithValue<T>>, array: TDestination, index?: number): TDestination;
}
export interface ISet<T> extends _ICollection<T> {
	exceptWith(other: IEnumerableOrArray<T>): void;
	intersectWith(other: IEnumerableOrArray<T>): void;
	isProperSubsetOf(other: IEnumerableOrArray<T>): boolean;
	isProperSupersetOf(other: IEnumerableOrArray<T>): boolean;
	isSubsetOf(other: IEnumerableOrArray<T>): boolean;
	isSupersetOf(other: IEnumerableOrArray<T>): boolean;
	overlaps(other: IEnumerableOrArray<T>): boolean;
	setEquals(other: IEnumerableOrArray<T>): boolean;
	symmetricExceptWith(other: IEnumerableOrArray<T>): void;
	unionWith(other: IEnumerableOrArray<T>): void;
}
export declare abstract class SetBase<T> extends _CollectionBase<T> implements ISet<T>, IDisposable {
	constructor(source?: IEnumerableOrArray<T>);
	protected abstract newUsing(source?: IEnumerableOrArray<T>): SetBase<T>;
	protected _set: LinkedNodeList<ILinkedNodeWithValue<T>>;
	protected _getSet(): LinkedNodeList<ILinkedNodeWithValue<T>>;
	protected getCount(): number;
	exceptWith(other: IEnumerableOrArray<T>): void;
	intersectWith(other: IEnumerableOrArray<T>): void;
	isProperSubsetOf(other: IEnumerableOrArray<T>): boolean;
	isProperSupersetOf(other: IEnumerableOrArray<T>): boolean;
	isSubsetOf(other: IEnumerableOrArray<T>): boolean;
	isSupersetOf(other: IEnumerableOrArray<T>): boolean;
	overlaps(other: IEnumerableOrArray<T>): boolean;
	setEquals(other: IEnumerableOrArray<T>): boolean;
	symmetricExceptWith(other: IEnumerableOrArray<T>): void;
	unionWith(other: IEnumerableOrArray<T>): void;
	protected _clearInternal(): number;
	protected _onDispose(): void;
	protected abstract _getNode(item: T): ILinkedNodeWithValue<T> | undefined;
	contains(item: T): boolean;
	GetEnumerator(): IEnumerator<T>;
	protected _removeNode(node: ILinkedNodeWithValue<T> | null | undefined): boolean;
	removeFirst(): boolean;
	removeLast(): boolean;
}
export declare class HashSet<T> extends SetBase<T> {
	private readonly _keyGenerator;
	constructor(keyGenerator: Selector<T, string | number | symbol>);
	constructor(source: IEnumerableOrArray<T> | undefined, keyGenerator: Selector<T, string | number | symbol>);
	protected newUsing(source?: IEnumerableOrArray<T>): HashSet<T>;
	private _registry;
	protected _addInternal(item: T): boolean;
	protected _clearInternal(): number;
	protected _onDispose(): void;
	protected _getNode(item: T): ILinkedNodeWithValue<T> | undefined;
	protected _removeInternal(item: T, max?: number): number;
}
export declare class IntMap<T> extends SimpleDictionary<number, T> {
	constructor(initialCapacity: number);
}
export declare class Set<T extends Primitive | ISymbolizable | symbol> extends HashSet<T> {
	constructor(source?: IEnumerableOrArray<T>);
}
export declare class IntSet extends Set<number> {
	constructor();
}
export declare class KeyNotFoundException extends SystemException {
	protected getName(): string;
}
interface IReadOnlyList<T> extends IReadOnlyCollection<T> {
	get(index: number): T;
	indexOf(item: T): number;
}
export declare class LazyList<T> extends _ReadOnlyCollectionBase<T> implements IReadOnlyList<T> {
	private _enumerator;
	private _cached;
	constructor(source: IEnumerable<T>);
	protected _onDispose(): void;
	protected _getCount(): number;
	protected _getEnumerator(): IEnumerator<T>;
	get(index: number): T;
	indexOf(item: T): number;
	contains(item: T): boolean;
	private getNext;
	private finish;
}
export declare class _LinkedList<T> extends _CollectionBase<T> implements ILinkedList<T> {
	private readonly _listInternal;
	constructor(source?: IEnumerableOrArray<T>, equalityComparer?: EqualityComparison<T>);
	protected assertVersion(version: number): true | never;
	protected _onDispose(): void;
	protected getCount(): number;
	protected _addInternal(entry: T): boolean;
	protected _removeInternal(entry: T, max?: number): number;
	protected _clearInternal(): number;
	_forEach(action: ActionWithIndex<T>, useCopy?: boolean): number;
	_forEach(action: PredicateWithIndex<T>, useCopy?: boolean): number;
	GetEnumerator(): IEnumerator<T>;
	private _findFirst;
	private _findLast;
	removeOnce(entry: T): boolean;
	get first(): ILinkedListNode<T> | null;
	get firstValue(): T | undefined;
	get last(): ILinkedListNode<T> | null;
	get lastValue(): T | undefined;
	getValueAt(index: number): T | undefined;
	getNodeAt(index: number): ILinkedListNode<T> | null;
	_find(entry: T): ILinkedListNode<T> | null;
	findLast(entry: T): ILinkedListNode<T> | null;
	addFirst(entry: T): this;
	addLast(entry: T): this;
	private _removeNodeInternal;
	removeFirst(): boolean;
	removeLast(): boolean;
	removeAt(index: number): boolean;
	removeNode(node: ILinkedListNode<T>): boolean;
	addBefore(before: ILinkedListNode<T>, entry: T): this;
	addAfter(after: ILinkedListNode<T>, entry: T): this;
}
export declare class MapUtility {
	/**
	 * Takes a target object and applies all source values to it.
	 * @param target
	 * @param source
	 * @returns {any}
	 */
	static apply<T extends IMap<any>, U extends IMap<any>>(target: T, source: U): T & U;
	/**
	 * Takes a target object and ensures values exist.
	 * @param target
	 * @param defaults
	 * @returns {any}
	 */
	static ensure<T extends IMap<any>, U extends IMap<any>>(target: T, defaults: U): T & U;
	/**
	 * Make a copy of the source object.
	 * @param source
	 * @returns {Object}
	 */
	static copy<T extends IMap<any>>(source: T): T;
	/**
	 * Takes two objects and creates another with the values of both.
	 * B overwrites A.
	 * @param a
	 * @param b
	 */
	static merge<A extends IMap<any>, B extends IMap<any>>(a: A, b: B): A & B;
	/**
	 * Removes any keys that don't exist on the keyMap.
	 * @param target
	 * @param keyMap
	 */
	static trim<TResult extends IMap<any>>(target: IMap<any>, keyMap: TResult): void;
	static wipe(map: IMap<any>, depth?: number): void;
}
export declare class _Queue<T> extends _CollectionBase<T> {
	private _array;
	private _head;
	private _tail;
	private _size;
	private _capacity;
	constructor(source?: IEnumerableOrArray<T> | number, equalityComparer?: EqualityComparison<T>);
	protected getCount(): number;
	protected _addInternal(item: T): boolean;
	protected _removeInternal(item: T, max?: number): number;
	protected _clearInternal(): number;
	protected _onDispose(): void;
	/**
	 * Dequeues entries into an array.
	 */
	dump(max?: number): T[];
	setCapacity(capacity: number): this;
	enqueue(item: T): this;
	protected _tryDequeueInternal(out: Action<T>): boolean;
	/**
	 * Pulls an entry from the head of the queue and returns it.
	 * Returns undefined if the queue is already empty.
	 */
	dequeue(): T | undefined;
	/**
	 * Pulls an entry from the head of the queue and returns it.
	 * Returns undefined if the queue is already empty and throwIfEmpty is false.
	 * Throws an InvalidOperationException if the queue is already empty and throwIfEmpty is true.
	 * @param throwIfEmpty
	 */
	dequeue(throwIfEmpty: true): T;
	/**
	 * Pulls an entry from the head of the queue and returns it.
	 * Returns undefined if the queue is already empty and throwIfEmpty is false.
	 * Throws an InvalidOperationException if the queue is already empty and throwIfEmpty is true.
	 * @param throwIfEmpty
	 */
	dequeue(throwIfEmpty: boolean): T | undefined;
	/**
	 * Checks to see if the queue has entries an pulls an entry from the head of the queue and passes it to the out handler.
	 * @param out The 'out' handler that receives the value if it exists.
	 * @returns {boolean} True if a value was retrieved.  False if not.
	 */
	tryDequeue(out: Action<T>): boolean;
	private _getElement;
	/**
	 * Returns the entry at the head of the queue.
	 * Returns undefined if the queue is already empty.
	 */
	peek(): T | undefined;
	/**
	 * Returns the entry at the head of the queue.
	 * Returns undefined if the queue is already empty and throwIfEmpty is false.
	 * Throws an InvalidOperationException if the queue is already empty and throwIfEmpty is true.
	 * @param throwIfEmpty
	 */
	peek(throwIfEmpty: true): T;
	/**
	 * Returns the entry at the head of the queue.
	 * Returns undefined if the queue is already empty and throwIfEmpty is false.
	 * Throws an InvalidOperationException if the queue is already empty and throwIfEmpty is true.
	 * @param throwIfEmpty
	 */
	peek(throwIfEmpty: boolean): T | undefined;
	trimExcess(threshold?: number): void;
	GetEnumerator(): IEnumerator<T>;
}
interface IEqualityComparer<T> {
	Equals(x: T, y: T): boolean;
	GetHashCode(obj: T): int;
}
interface IHashCodeProvider {
	GetHashCode(obj: any): int;
}
declare class KeyValuePair<TKey, TValue> {
	private key;
	private value;
	get Key(): TKey;
	get Value(): TValue;
	constructor(key?: TKey, value?: TValue);
	static CreateArray<TKey, TValue>(len: int): Array<KeyValuePair<TKey, TValue>>;
	toString(): string;
}
interface IDictionary<TKey, TValue> extends ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>> {
	Get(key: TKey): TValue;
	Keys: ICollection<TKey>;
	Values: ICollection<TValue>;
	Add(item: KeyValuePair<TKey, TValue>): void;
	Add(key: TKey, value: TValue): void;
	ContainsKey(key: TKey): boolean;
	Remove(key: KeyValuePair<TKey, TValue>): boolean;
	Remove(key: TKey): boolean;
}
interface IReadOnlyCollection<T> extends IEnumerable<T> {
	Count: int;
}
interface IReadOnlyDictionary<TKey, TValue> extends IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>> {
	Get(key: TKey): TValue;
	Keys: IEnumerable<TKey>;
	Values: IEnumerable<TValue>;
	ContainsKey(key: TKey): boolean;
	TryGetValue(key: TKey, value: Out<TValue>): boolean;
}
export declare class Dictionary<TKey, TValue> implements IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>> {
	IsEndless?: boolean | undefined;
	private buckets;
	private entries;
	private count;
	private version;
	private freeList;
	private freeCount;
	private comparer;
	private keys;
	private values;
	private static readonly VersionName;
	private static readonly HashSizeName;
	private static readonly KeyValuePairsName;
	private static readonly ComparerName;
	get Comparer(): IEqualityComparer<TKey>;
	get Count(): int;
	private getInternal;
	Get(key: TKey): TValue;
	private setInternal;
	Set(key: TKey, value: TValue): void;
	get Keys(): ICollection<TKey>;
	get IsReadOnly(): boolean;
	get Values(): ICollection<TValue>;
	get IsFixedSize(): boolean;
	private _constructor1;
	private _constructor2;
	private _constructor3;
	private _constructor4;
	private _constructor5;
	private _constructor6;
	static staticConstructor(): void;
	constructor();
	constructor(capacity: int);
	constructor(comparer: IEqualityComparer<TKey>);
	constructor(capacity: int, comparer: IEqualityComparer<TKey>);
	constructor(dictionary: IDictionary<TKey, TValue>);
	constructor(dictionary: IDictionary<TKey, TValue>, comparer: IEqualityComparer<TKey>);
	private addInternal;
	Add(item: KeyValuePair<TKey, TValue>): void;
	Add(key: TKey, value: TValue): void;
	Clear(): void;
	ContainsKey(key: TKey): boolean;
	ContainsValue(value: TValue): boolean;
	CopyTo(array: KeyValuePair<TKey, TValue>[], index: int): void;
	private findEntry;
	GetValueOrDefault(key: TKey): TValue;
	private initialize;
	private insert;
	private static IsCompatibleKey;
	private resize;
	Contains(keyValuePair: KeyValuePair<TKey, TValue>): boolean;
	Remove(keyValuePair: KeyValuePair<TKey, TValue>): boolean;
	Remove(key: TKey): boolean;
	GetEnumerator(): IEnumerator<KeyValuePair<TKey, TValue>>;
	TryGetValue(key: TKey, value: Out<TValue>): boolean;
	private static Enumerator;
	private static KeyCollection;
	private static ValueCollection;
}
export declare class Hashtable<TKey = string, TValue = any> implements IDictionary<TKey, TValue> {
	static readonly HashPrime: int;
	private static readonly InitialSize;
	private static readonly LoadFactorName;
	private static readonly VersionName;
	private static readonly ComparerName;
	private static readonly HashCodeProviderName;
	private static readonly HashSizeName;
	private static readonly KeysName;
	private static readonly ValuesName;
	private static readonly KeyComparerName;
	private buckets;
	private count;
	private occupancy;
	private loadsize;
	private loadFactor;
	private version;
	private isWriterInProgress;
	private keys;
	private values;
	private _keycomparer;
	protected get comparer(): IComparer<TKey>;
	protected set comparer(value: IComparer<TKey>);
	get Count(): int;
	protected get EqualityComparer(): IEqualityComparer<TKey>;
	protected get hcp(): IHashCodeProvider;
	protected set hcp(value: IHashCodeProvider);
	get IsFixedSize(): boolean;
	get IsReadOnly(): boolean;
	Get(key: TKey): TValue;
	Set(key: TKey, value: TValue): void;
	get Keys(): ICollection<TKey>;
	get Values(): ICollection<TValue>;
	_constructor(capacity: int, loadFactor: float): void;
	static staticConstructor(): void;
	constructor();
	constructor(trash: boolean);
	constructor(array: Array<any>);
	constructor(dictionary: Dictionary<any, any>);
	constructor(capacity: int);
	constructor(capacity: int, loadFactor: float);
	constructor(capacity: int, loadFactor: float, hcp: IHashCodeProvider, comparer: IComparer<TKey>);
	constructor(capacity: int, loadFactor: float, equalityComparer: IEqualityComparer<TKey>);
	constructor(hcp: IHashCodeProvider, comparer: IComparer<TKey>);
	constructor(equalityComparer: IEqualityComparer<TKey>);
	constructor(capacity: int, equalityComparer: IEqualityComparer<TKey>);
	Add(item: KeyValuePair<TKey, TValue>): void;
	Add(key: TKey, value: TValue): void;
	Clear(): number;
	Clone(): Hashtable<TKey, TValue>;
	Contains(item: KeyValuePair<TKey, TValue>): boolean;
	Contains(key: TKey): boolean;
	ContainsKey(key: TKey): boolean;
	ContainsValue(value: TValue): boolean;
	private CopyEntries;
	private CopyKeys;
	CopyTo(array: Array<KeyValuePair<TKey, TValue>>, arrayIndex: int): Array<KeyValuePair<TKey, TValue>>;
	private CopyValues;
	private expand;
	GetEnumerator(): IEnumerator<KeyValuePair<TKey, TValue>>;
	/**
	 * Eklenen key iin bir hash code oluturur.
	 * @param key
	 */
	protected GetHash(key: TKey): int;
	private initHash;
	private insert;
	protected keyEquals(item: TKey, key: TKey): boolean;
	private putEntry;
	private rehash;
	Remove(key: KeyValuePair<TKey, TValue>): boolean;
	Remove(key: TKey): boolean;
	private updateVersion;
	private static HashtableEnumerator;
	private static KeyCollection;
	private static ValueCollection;
}
interface Converter<TInput, TOutput> {
	(input: TInput): TOutput;
}
interface IReadOnlyList<T> extends IReadOnlyCollection<T>, IEnumerable<T> {
	Get(index: int): T;
}
export declare class List<T> extends TObject implements IList<T>, ICollection<T>, IEnumerable<T>, IReadOnlyList<T>, IReadOnlyCollection<T> {
	[key: number]: T;
	protected dispose(disposing: boolean): void;
	private static readonly _defaultCapacity;
	private _items;
	private _size;
	private _version;
	private static readonly _emptyArray;
	get Capacity(): int;
	set Capacity(value: int);
	get Count(): int;
	private getInternal;
	Get(index: int): T;
	private setInternal;
	Set(index: int, value: T): void;
	get IsReadOnly(): boolean;
	get IsFixedSize(): boolean;
	constructor();
	constructor(capacity: int);
	constructor(collection: IEnumerable<T>);
	constructor(array: Array<T>);
	private addInternal;
	Add(item: T): number;
	AddRange(collection: IEnumerable<T> | Array<T>): void;
	BinarySearch(index: int, count: int, item: T, comparer: IComparer<T>): int;
	Clear(): number;
	Contains(item: T): boolean;
	ConvertAll<TOutput>(converter: Converter<T, TOutput>): List<TOutput>;
	CopyTo(array: T[]): T[];
	CopyTo(index: int, array: T[], arrayIndex: int, count: int): T[];
	CopyTo(array: T[], arrayIndex: int): T[];
	private ensureCapacity;
	Exists(match: Predicate<T>): boolean;
	Find(match: Predicate<T>): T;
	FindAll(match: Predicate<T>): List<T>;
	FindIndex(match: Predicate<T>): int;
	FindIndex(startIndex: int, match: Predicate<T>): int;
	FindIndex(startIndex: int, count: int, match: Predicate<T>): int;
	FindLast(match: Predicate<T>): T;
	FindLastIndex(match: Predicate<T>): int;
	FindLastIndex(startIndex: int, match: Predicate<T>): int;
	FindLastIndex(startIndex: int, count: int, match: Predicate<T>): int;
	ForEach(action: Action<T>): void;
	GetEnumerator(): List.Enumerator<T>;
	GetRange(index: int, count: int): List<T>;
	IndexOf(item: T): int;
	IndexOf(item: T, index: int): int;
	IndexOf(item: T, index: int, count: int): int;
	Insert(index: int, item: T): void;
	InsertRange(index: int, collection: IEnumerable<T> | Array<T>): void;
	LastIndexOf(item: T): int;
	LastIndexOf(item: T, index: int): int;
	LastIndexOf(item: T, index: int, count: int): int;
	Remove(item: T): boolean;
	RemoveAll(match: Predicate<T>): int;
	RemoveAt(index: int): void;
	RemoveRange(index: int, count: int): void;
	Reverse(): void;
	Reverse(index: int, count: int): void;
	Sort(): void;
	Sort(comparer: IComparer<T>): void;
	Sort(index: int, count: int, comparer: IComparer<T>): void;
	ToArray(type?: Type): T[];
	TrimExcess(): void;
	TrueForAll(match: Predicate<T>): boolean;
	Where(f: (item: T) => boolean): List<T>;
	Select(f: (item: T, index?: number) => boolean): List<any>;
	FirstOrDefault(f: Predicate<T>, _default: T): T;
	ToString(): string;
}
export declare namespace List {
	class Enumerator<T> implements IEnumerator<T>, IDisposable {
		CanMoveNext?: boolean | undefined;
		TryMoveNext(out: (value: T) => void): boolean;
		End(): void;
		NextValue(value?: any): T | undefined;
		IsEndless?: boolean | undefined;
		Next(value?: any): IIteratorResult;
		private list;
		private index;
		private version;
		private current;
		get Current(): T;
		constructor(list: List<T>);
		Dispose(): void;
		MoveNext(): boolean;
		private moveNextRare;
		Reset(): void;
	}
}
export declare class Stack<T> implements ICollection<T>, IEnumerable<T>, ICloneable<Stack<T>> {
	IsReadOnly: boolean;
	Add(item: T): void;
	Remove(item: T): boolean;
	IsEndless?: boolean | undefined;
	private _array;
	private _size;
	private _version;
	private static readonly _defaultCapacity;
	get Count(): number;
	constructor();
	constructor(array: T[]);
	constructor(initialCapacity: int);
	Clear(): void;
	Clone(): Stack<T>;
	Contains(obj: T): boolean;
	CopyTo(array: Array<T>, index: int): void;
	GetEnumerator(): IEnumerator<T>;
	Peek(): T;
	Pop(): T;
	Push(obj: T): void;
	toArray(): T[];
}
export declare namespace Stack {
	class StackEnumerator<T> implements IEnumerator<T>, ICloneable<StackEnumerator<T>> {
		CanMoveNext?: boolean | undefined;
		TryMoveNext(out: (value: T) => void): boolean;
		End(): void;
		NextValue(value?: any): T | undefined;
		IsEndless?: boolean | undefined;
		Next(value?: any): IIteratorResult;
		Dispose(): void;
		private _stack;
		private _index;
		private _version;
		private currentElement;
		get Current(): T;
		constructor(stack: Stack<T>);
		Clone(): StackEnumerator<T>;
		MoveNext(): boolean;
		Reset(): void;
	}
}
declare class KeyValuePairs {
	private key;
	private value;
	constructor(key: any, value: any);
	get Key(): any;
	get Value(): any;
}
interface IDictionaryEnumerator<TKey, TValue> extends IEnumerator<KeyValuePair<TKey, TValue>> {
	Entry: KeyValuePair<TKey, TValue>;
	Key: TKey;
	Value: TValue;
}
export declare class SortedList<TKey, TValue> implements IDictionary<TKey, TValue>, ICloneable<SortedList<TKey, TValue>> {
	private keys;
	private values;
	private _size;
	private version;
	private comparer;
	private keyList;
	private valueList;
	private static readonly _defaultCapacity;
	private static emptyArray;
	constructor();
	constructor(initialCapacity: int);
	constructor(array2d: Array<any>);
	constructor(comparer: IComparer<any>);
	constructor(comparer: IComparer<any>, capacity: int);
	constructor(d: IDictionary<TKey, TValue>);
	constructor(d: IDictionary<TKey, TValue>, comparer: IComparer<any>);
	constructor1(): void;
	private Init;
	constructor2(initialCapacity: int): void;
	constructor3(comparer: IComparer<any>): void;
	constructor4(comparer: IComparer<any>, capacity: int): void;
	constructor5(d: IDictionary<TKey, TValue>): void;
	constructor6(d: IDictionary<TKey, TValue>, comparer: IComparer<any>): void;
	Add(keyValuePair: KeyValuePair<TKey, TValue>): void;
	Add(key: TKey, value: TValue): void;
	get Capacity(): int;
	set Capacity(value: int);
	get Count(): int;
	get Keys(): ICollection<TKey>;
	get Values(): ICollection<TValue>;
	get IsReadOnly(): boolean;
	get IsFixedSize(): boolean;
	Clear(): void;
	Clone(): SortedList<TKey, TValue>;
	Contains(keyValuePair: KeyValuePair<TKey, TValue>): boolean;
	Contains(key: TKey): boolean;
	ContainsKey(key: TKey): boolean;
	ContainsValue(value: TValue): boolean;
	CopyTo(array: Array<any>, arrayIndex: int): void;
	ToKeyValuePairsArray(): KeyValuePairs[];
	private EnsureCapacity;
	GetByIndex(index: int): TValue;
	GetEnumerator(): IEnumerator<KeyValuePair<TKey, TValue>>;
	GetKey(index: int): TKey;
	GetKeyList(): KeyList<TKey>;
	GetValueList(): IList<TValue>;
	Get(key: TKey): TValue;
	Set(key: TKey, value: TValue): void;
	IndexOfKey(key: TKey): int;
	IndexOfValue(value: TValue): int;
	private Insert;
	RemoveAt(index: int): void;
	Remove(key: TKey | KeyValuePair<TKey, TValue>): boolean;
	SetByIndex(index: int, value: TValue): void;
	TrimToSize(): void;
	ToString(): string;
}
export declare class SortedListEnumerator<TKey, TValue> extends TObject implements IDictionaryEnumerator<TKey, TValue>, ICloneable<SortedListEnumerator<TValue, TKey>> {
	protected dispose(disposing: boolean): void;
	private sortedList;
	private key;
	private value;
	private index;
	private startIndex;
	private endIndex;
	private version;
	private current;
	private getObjectRetType;
	static readonly Keys: int;
	static readonly Values: int;
	static readonly DictEntry: int;
	constructor(sortedList: SortedList<TKey, TValue>, index: int, count: int, getObjRetType: int);
	/**
	 * Moves to the next entry and emits the value through the out callback.
	 */
	TryMoveNext(out: (value: KeyValuePair<TKey, TValue>) => void): boolean;
	End(): void;
	NextValue(value?: any): KeyValuePair<TKey, TValue> | undefined;
	Next(value?: any): IIteratorResult<KeyValuePair<TKey, TValue>>;
	Clone(): any;
	get Key(): TKey;
	MoveNext(): boolean;
	get Entry(): KeyValuePair<TKey, TValue>;
	get Current(): KeyValuePair<TKey, TValue>;
	get Value(): TValue;
	Reset(): void;
}
export declare class KeyList<TKey> implements IList<TKey> {
	private sortedList;
	constructor(sortedList: SortedList<TKey, any>);
	get Count(): int;
	get IsReadOnly(): boolean;
	get IsFixedSize(): boolean;
	Add(key: TKey): int;
	Clear(): void;
	Contains(key: TKey): boolean;
	CopyTo(array: Array<TKey>, arrayIndex: int): void;
	Insert(index: int, value: TKey): void;
	Get(index: int): TKey;
	Set(index: int, value: TKey): void;
	GetEnumerator(): IEnumerator<TKey>;
	IndexOf(key: TKey): int;
	Remove(key: TKey): boolean;
	RemoveAt(index: int): void;
}
export declare class ValueList<TValue> implements IList<TValue> {
	private sortedList;
	constructor(sortedList: SortedList<any, TValue>);
	get Count(): int;
	get IsReadOnly(): boolean;
	get IsFixedSize(): boolean;
	Add(key: TValue): int;
	Clear(): void;
	Contains(value: TValue): boolean;
	CopyTo(array: Array<TValue>, arrayIndex: int): void;
	Insert(index: int, value: TValue): void;
	Get(index: int): TValue;
	Set(index: int, value: TValue): void;
	GetEnumerator(): IEnumerator<TValue>;
	IndexOf(value: TValue): int;
	Remove(value: TValue): boolean;
	RemoveAt(index: int): void;
}
export declare class Queue<T> implements IEnumerable<T>, ICollection<T>, IReadOnlyCollection<T> {
	private _array;
	private _head;
	private _tail;
	private _size;
	private _version;
	private static readonly _MinimumGrow;
	private static readonly _ShrinkThreshold;
	private static readonly _GrowFactor;
	private static readonly _DefaultCapacity;
	private static _emptyArray;
	IsEndless?: boolean | undefined;
	IsReadOnly: boolean;
	Add(item: T): void;
	Remove(item: T): boolean;
	contains(entry: T): boolean;
	copyTo(target: T[], index?: number): T[];
	toArray(): T[];
	constructor();
	constructor(capacity: int);
	constructor(collection: IEnumerable<T>);
	constructor(array: ArrayLike<T>);
	get Count(): int;
	Clear(): void;
	CopyTo(array: T[], arrayIndex: int): void;
	Enqueue(item: T): void;
	GetEnumerator(): IEnumerator<T>;
	Dequeue(): T;
	TryDequeue(out: Action<T>): boolean;
	Peek(): T;
	Contains(item: T): boolean;
	GetElement(i: int): T;
	ToArray(): T[];
	private SetCapacity;
	TrimExcess(): void;
}
export declare class QueueEnumerator<T> implements IEnumerator<T> {
	private _q;
	private _index;
	private _version;
	private _currentElement;
	constructor(q: Queue<T>);
	CanMoveNext?: boolean | undefined;
	TryMoveNext(out: (value: T) => void): boolean;
	End(): void;
	NextValue(value?: any): T | undefined;
	IsEndless?: boolean | undefined;
	Next(value?: any): IIteratorResult<T>;
	Dispose(): void;
	MoveNext(): boolean;
	get Current(): T;
	Reset(): void;
}
declare class LinkedListNode<T> {
	list: LinkedList<T>;
	next: LinkedListNode<T>;
	prev: LinkedListNode<T>;
	item: T;
	constructor(value: T);
	constructor(list: LinkedList<T>, value: T);
	get List(): LinkedList<T>;
	get Next(): LinkedListNode<T>;
	get Previous(): LinkedListNode<T>;
	get Value(): T;
	set Value(value: T);
	Invalidate(): void;
}
export declare class LinkedList<T> implements ICollection<T>, IReadOnlyCollection<T> {
	head: LinkedListNode<T>;
	count: int;
	version: int;
	private static readonly VersionName;
	private static readonly CountName;
	private static readonly ValuesName;
	constructor();
	constructor(collection: IEnumerable<T>);
	get Count(): int;
	get First(): LinkedListNode<T>;
	get Last(): LinkedListNode<T>;
	get IsReadOnly(): boolean;
	Add(value: T): void;
	AddAfter(node: LinkedListNode<T>, newNode: LinkedListNode<T>): void;
	AddAfter(node: LinkedListNode<T>, value: T): LinkedListNode<T>;
	AddBefore(node: LinkedListNode<T>, newNode: LinkedListNode<T>): void;
	AddBefore(node: LinkedListNode<T>, value: T): LinkedListNode<T>;
	AddFirst(node: LinkedListNode<T>): void;
	AddFirst(value: T): LinkedListNode<T>;
	AddLast(node: LinkedListNode<T>): void;
	AddLast(value: T): LinkedListNode<T>;
	Clear(): void;
	Contains(value: T): boolean;
	CopyTo(array: T[], index: int): void;
	Find(value: T): LinkedListNode<T>;
	FindLast(value: T): LinkedListNode<T>;
	GetEnumerator(): IEnumerator<T>;
	Remove(node: LinkedListNode<T>): void;
	Remove(value: T): boolean;
	RemoveFirst(): void;
	RemoveLast(): void;
	private InternalInsertNodeBefore;
	private InternalInsertNodeToEmptyList;
	InternalRemoveNode(node: LinkedListNode<T>): void;
	ValidateNewNode(node: LinkedListNode<T>): void;
	ValidateNode(node: LinkedListNode<T>): void;
}
export declare class LinkedListEnumerator<T> implements IEnumerator<T> {
	private list;
	private node;
	private version;
	private current;
	private index;
	private static readonly LinkedListName;
	private static readonly CurrentValueName;
	private static readonly VersionName;
	private static readonly IndexName;
	constructor(list: LinkedList<T>);
	CanMoveNext?: boolean | undefined;
	TryMoveNext(out: (value: T) => void): boolean;
	End(): void;
	NextValue(value?: any): T | undefined;
	IsEndless?: boolean | undefined;
	Next(value?: any): IIteratorResult<T>;
	get Current(): T;
	MoveNext(): boolean;
	Reset(): void;
	Dispose(): void;
}
export declare class ListProxy {
	static CreateProxy<T>(thisarg: any): any;
}
export declare class CaseInsensitiveComparer<T> extends TObject implements IComparer<T> {
	protected dispose(disposing: boolean): void;
	private m_compareInfo;
	private static m_InvariantCaseInsensitiveComparer;
	constructor();
	constructor(culture: CultureInfo);
	static get Default(): CaseInsensitiveComparer<any>;
	static get DefaultInvariant(): CaseInsensitiveComparer<any>;
	Compare(a: T, b: T): int;
}
export declare class BitArray extends TObject implements ICollection<boolean>, ICloneable<BitArray> {
	protected dispose(disposing: boolean): void;
	private m_array;
	private m_length;
	private _version;
	private static readonly _ShrinkThreshold;
	Add(item: boolean): void;
	Clear(): void;
	Contains(item: boolean): boolean;
	Remove(item: boolean): boolean;
	IsEndless?: boolean | undefined;
	constructor();
	constructor(length: int);
	constructor(length: int, defaultValue: boolean);
	constructor(bytes: ByteArray);
	constructor(values: boolean[]);
	constructor(values: IntArray);
	constructor(bits: BitArray);
	private constructor1;
	constructor2(length: int): void;
	constructor3(length: int, defaultValue: boolean): void;
	constructor4(bytes: ByteArray): void;
	constructor5(values: boolean[]): void;
	constructor6(values: IntArray): void;
	constructor7(bits: BitArray): void;
	Get(index: int): boolean;
	Set(index: int, value: boolean): void;
	SetAll(value: boolean): void;
	And(value: BitArray): BitArray;
	Or(value: BitArray): BitArray;
	Xor(value: BitArray): BitArray;
	Not(): BitArray;
	get Length(): int;
	set Length(value: int);
	CopyTo(array: Array<boolean> | IntArray | ByteArray, index: int): void;
	get Count(): int;
	Clone(): BitArray;
	get IsReadOnly(): boolean;
	GetEnumerator(): IEnumerator<boolean>;
	private static readonly BitsPerInt32;
	private static readonly BytesPerInt32;
	private static readonly BitsPerByte;
	private static GetArrayLength;
}
export declare class BitArrayEnumeratorSimple extends TObject implements IEnumerator<boolean>, ICloneable<BitArrayEnumeratorSimple> {
	protected dispose(disposing: boolean): void;
	private bitarray;
	private index;
	private version;
	private currentElement;
	constructor(bitarray: BitArray);
	CanMoveNext?: boolean | undefined;
	TryMoveNext(out: (value: boolean) => void): boolean;
	End(): void;
	NextValue(value?: any): boolean | undefined;
	IsEndless?: boolean | undefined;
	Next(value?: any): IIteratorResult<boolean>;
	Clone(): BitArrayEnumeratorSimple;
	MoveNext(): boolean;
	get Current(): boolean;
	Reset(): void;
}
export declare class StringDictionary implements IEnumerable<KeyValuePair<string, string>> {
	contents: Hashtable<string, string>;
	constructor();
	get Count(): int;
	Get(key: string): string;
	Set(key: string, value: string): void;
	get Keys(): ICollection<string>;
	get Values(): ICollection<string>;
	Add(key: string, value: string): void;
	Clear(): void;
	ContainsKey(key: string): boolean;
	ContainsValue(value: string): boolean;
	CopyTo(array: Array<KeyValuePair<string, string>>, index: int): void;
	GetEnumerator(): IEnumerator<KeyValuePair<string, string>>;
	Remove(key: string): void;
	ReplaceHashtable(useThisHashtableInstead: Hashtable): void;
	AsGenericDictionary(): IDictionary<string, string>;
}
declare type DBNull = any;
declare abstract class NameObjectCollectionBase implements ICollection<any> {
	Add(item: any): void;
	Clear(): void;
	Contains(item: any): boolean;
	Remove(item: any): boolean;
	IsEndless?: boolean | undefined;
	private static readonly ReadOnlyName;
	private static readonly CountName;
	private static readonly ComparerName;
	private static readonly HashCodeProviderName;
	private static readonly KeysName;
	private static readonly ValuesName;
	private static readonly KeyComparerName;
	private static readonly VersionName;
	private _readOnly;
	private _entriesArray;
	private _keyComparer;
	private _entriesTable;
	private _nullKeyEntry;
	private _keys;
	private _version;
	private static defaultComparer;
	constructor();
	protected constructor1(): void;
	protected constructor2(equalityComparer: IEqualityComparer<string>): void;
	protected constructor3(capacity: int, equalityComparer: IEqualityComparer<string>): void;
	protected constructor4(hashProvider: IHashCodeProvider, comparer: IComparer<any>): void;
	protected constructor5(capacity: int, hashProvider: IHashCodeProvider, comparer: IComparer<any>): void;
	protected constructor6(capacity: int): void;
	constructor7(dummy: DBNull): void;
	private Reset;
	private FindEntry;
	get Comparer(): IEqualityComparer<any>;
	set Comparer(value: IEqualityComparer<any>);
	get IsReadOnly(): boolean;
	set IsReadOnly(value: boolean);
	protected BaseHasKeys(): boolean;
	protected BaseAdd(name: string, value: any): void;
	protected BaseRemove(name: string): void;
	protected BaseRemoveAt(index: int): void;
	protected BaseClear(): void;
	protected BaseGet(name: string): any;
	protected BaseGet(index: int): any;
	protected BaseSet(name: string, value: any): void;
	protected BaseSet(index: int, value: any): void;
	protected BaseGetKey(index: int): string;
	GetEnumerator(): IEnumerator<any>;
	get Count(): int;
	CopyTo(array: Array<any>, index: int): void;
	protected BaseGetAllKeys(): string[];
	protected BaseGetAllValues(): any[];
	get Keys(): KeysCollection;
}
declare class KeysCollection implements ICollection<any> {
	private _coll;
	constructor(coll: NameObjectCollectionBase);
	IsReadOnly: boolean;
	Add(item: any): void;
	Clear(): void;
	Contains(item: any): boolean;
	Remove(item: any): boolean;
	IsEndless?: boolean | undefined;
	Get(index: int): string;
	GetEnumerator(): IEnumerator<any>;
	get Count(): int;
	CopyTo(array: Array<any>, index: int): void;
}
export declare class NameValueCollection extends NameObjectCollectionBase {
	private _all;
	private _allKeys;
	constructor();
	protected InvalidateCachedArrays(): void;
	private static GetAsOneString;
	private static GetAsStringArray;
	Add(c: NameValueCollection): void;
	Add(name: string, value: string): void;
	Clear(): void;
	CopyTo(dest: Array<any>, index: int): void;
	HasKeys(): boolean;
	InternalHasKeys(): boolean;
	Get(name: string): string;
	Get(index: int): string;
	GetValues(name: string): string[];
	GetValues(index: int): string[];
	Set(name: string, value: string): void;
	Remove(name: string): boolean;
	GetKey(index: int): string;
	get AllKeys(): string[];
}
export declare abstract class StringComparer implements IComparer<string>, IEqualityComparer<string> {
	private static readonly _invariantCulture;
	private static readonly _invariantCultureIgnoreCase;
	private static readonly _ordinal;
	private static readonly _ordinalIgnoreCase;
	static get InvariantCulture(): StringComparer;
	static get InvariantCultureIgnoreCase(): StringComparer;
	static get CurrentCulture(): StringComparer;
	static get CurrentCultureIgnoreCase(): StringComparer;
	static get Ordinal(): StringComparer;
	static get OrdinalIgnoreCase(): StringComparer;
	static Create(culture: CultureInfo, ignoreCase: boolean): StringComparer;
	abstract Compare(x: string, y: string): int;
	abstract Equals(x: string, y: string): boolean;
	abstract GetHashCode(obj: string): int;
}
export declare class StringCollection implements IList<string> {
	private data;
	Get(index: int): string;
	Set(index: int, value: string): void;
	get Count(): int;
	get IsFixedSize(): boolean;
	Add(value: string): int;
	AddRange(value: string[]): void;
	Clear(): void;
	Contains(value: string): boolean;
	CopyTo(array: string[], index: int): void;
	GetEnumerator(): StringEnumerator;
	IndexOf(value: string): int;
	Insert(index: int, value: string): void;
	get IsReadOnly(): boolean;
	Remove(value: string): boolean;
	RemoveAt(index: int): void;
}
export declare class StringEnumerator implements IEnumerator<string> {
	private baseEnumerator;
	private temp;
	constructor(mappings: StringCollection);
	CanMoveNext?: boolean | undefined;
	TryMoveNext(out: (value: string) => void): boolean;
	End(): void;
	NextValue(value?: any): string | undefined;
	IsEndless?: boolean | undefined;
	Next(value?: any): IIteratorResult<string>;
	Dispose(): void;
	get Current(): string;
	MoveNext(): boolean;
	Reset(): void;
}
declare class _Event {
	[key: string]: any;
	type: string;
	readonly target: any;
	protected currentTarget: object;
	private eventPhase;
	protected readonly bubbles: boolean;
	protected readonly cancelable: boolean;
	private readonly timeStamp;
	private defaultPrevented;
	private propagationStopped;
	private immediatePropagationStopped;
	private removed;
	constructor(type: string, bubbles?: boolean, cancelable?: boolean);
	preventDefault(): _Event;
	stopPropagation(): _Event;
	stopImmediatePropagation(): _Event;
	remove(): _Event;
	clone(): _Event;
	set(props: any): _Event;
	toString(): string;
}
export declare class EventDispatcher {
	private _listeners;
	private _captureListeners;
	name: string;
	static initialize(target: any): void;
	constructor();
	addEventListener(type: string, listener: Function | Object, useCapture?: boolean): Function | Object;
	on(type: string, listener: Function | Object, scope?: any, once?: boolean, data?: Object, useCapture?: boolean): Object | Function;
	removeEventListener(type: string, listener: Function | Object, useCapture?: boolean): void;
	off(type: string, listener: Function | Object, useCapture?: boolean): void;
	removeAllEventListeners(type?: string): void;
	dispatchEvent(eventObj: Object | _Event | string, bubbles?: boolean, cancelable?: boolean): boolean;
	hasEventListener(type: string): boolean;
	willTrigger(type: string): boolean;
	toString(): string;
	private _dispatchEvent;
}
export declare class Ticker extends EventDispatcher {
	timingMode: string;
	maxDelta: number;
	paused: boolean;
	private _inited;
	private _startTime;
	private _pausedTime;
	private _ticks;
	private _pausedTicks;
	private _interval;
	private _lastTime;
	private _times;
	private _tickTimes;
	private _timerId;
	private _raf;
	static get RAF_SYNCHED(): string;
	static get RAF(): string;
	static get TIMEOUT(): string;
	constructor(name: string);
	get interval(): number;
	set interval(interval: number);
	get framerate(): number;
	set framerate(framerate: number);
	init(): void;
	/**
	 * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.
	 */
	reset(): void;
	/**
	 * Init the Ticker instance if it hasn't been already.
	 */
	addEventListener(type: string, listener: Function | Object, useCapture?: boolean): Object | Function;
	/**
	 * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS
	 * because it only measures the time spent within the tick execution stack.
	 *
	 * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between
	 * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that
	 * there may be up to 35ms of "idle" time between the end of one tick and the start of the next.
	 *
	 * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of
	 * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something
	 * other than the tick is using ~80ms (another script, DOM rendering, etc).
	 *
	 * @param {number} [ticks=null] The number of previous ticks over which to measure the average time spent in a tick.
	 * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.
	 * @return {number} The average time spent in a tick in milliseconds.
	 */
	getMeasuredTickTime(ticks?: number): number;
	/**
	 * Returns the actual frames / ticks per second.
	 *
	 * @param {number} [ticks=null] The number of previous ticks over which to measure the actual frames / ticks per second.
	 * Defaults to the number of ticks per second.
	 * @return {number} The actual frames / ticks per second. Depending on performance, this may differ
	 * from the target frames per second.
	 */
	getMeasuredFPS(ticks?: number): number;
	getDeltaTime(): number;
	/**
	 * Returns the number of milliseconds that have elapsed since Ticker was initialized via {@link core.Ticker#init}.
	 * Returns -1 if Ticker has not been initialized. For example, you could use
	 * this in a time synchronized animation to determine the exact amount of time that has elapsed.
	 *
	 * @param {boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.
	 * If false, the value returned will be total time elapsed since the first tick event listener was added.
	 * @return {number} Number of milliseconds that have elapsed since Ticker was initialized or -1.
	 */
	getTime(runTime?: boolean): number;
	/**
	 * Similar to {@link core.Ticker#getTime}, but returns the time on the most recent {@link core.Ticker#event:tick}
	 * event object.
	 *
	 * @param {boolean} [runTime=false] If true, the runTime property will be returned instead of time.
	 * @returns {number} The time or runTime property from the most recent tick event or -1.
	 */
	getEventTime(runTime?: boolean): number;
	/**
	 * Returns the number of ticks that have been broadcast by Ticker.
	 *
	 * @param {boolean} [pauseable=false] Indicates whether to include ticks that would have been broadcast
	 * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.
	 * If false, tick events that would have been broadcast while Ticker was paused will be included in the return
	 * value.
	 * @return {number} of ticks that have been broadcast.
	 */
	getTicks(pauseable?: boolean): number;
	/**
	 * @private
	 */
	private _handleSynch;
	/**
	 * @private
	 */
	private _handleRAF;
	/**
	 * @private
	 */
	private _handleTimeout;
	/**
	 * @private
	 */
	private _setupTick;
	/**
	 * @private
	 * @emits core.Ticker#event:tick
	 */
	private _tick;
	/**
	 * @private
	 */
	private _getTime;
	static on(type: any, listener: any, scope: any, once: any, data: any, useCapture: any): Object | Function;
	static removeEventListener(type: any, listener: any, useCapture: any): void;
	static off(type: any, listener: any, useCapture: any): void;
	static removeAllEventListeners(type: any): void;
	static dispatchEvent(eventObj: any, bubbles: any, cancelable: any): boolean;
	static hasEventListener(type: any): boolean;
	static willTrigger(type: any): boolean;
	static toString(): string;
	static init(): void;
	static reset(): void;
	static addEventListener(type: any, listener: any, useCapture?: any): void;
	static getMeasuredTickTime(ticks: any): number;
	static getMeasuredFPS(ticks: any): number;
	static getTime(runTime: any): number;
	static getEventTime(runTime: any): number;
	static getTicks(pauseable: any): number;
	static getDeltaTime(): number;
	static get interval(): number;
	static set interval(interval: number);
	static get framerate(): number;
	static set framerate(framerate: number);
	static get timingMode(): string;
	static set timingMode(timingMode: string);
	static get maxDelta(): number;
	static set maxDelta(maxDelta: number);
	static get paused(): boolean;
	static set paused(paused: boolean);
}
/**
 * A simple event dispatcher provided as an alternative to built-in event.
 * If just dispatching a payload to a uniform set of functions, it may be better to just use the utilities in System/Collections/Array/Dispatch.
 */
export declare class EventSimple<T extends Function> implements IDisposable {
	protected readonly _listeners: T[];
	add(listener: T): void;
	remove(listener: T): void;
	dispatch(...params: any[]): void;
	toMulticastFunction(): Function;
	Dispose(): void;
}
/**
 * A general purpose event bus.
 *
 * This component is used to communicate across a diagram instance.
 * Other parts of a diagram can use it to listen to and broadcast events.
 *
 *
 * ## Registering for Events
 *
 * The event bus provides the {@link EventBus#on} and {@link EventBus#once}
 * methods to register for events. {@link EventBus#off} can be used to
 * remove event registrations. Listeners receive an instance of {@link Event}
 * as the first argument. It allows them to hook into the event execution.
 *
 * ```javascript
 *
 * // listen for event
 * eventBus.on('foo', function(event) {
 *
 *   // access event type
 *   event.type; // 'foo'
 *
 *   // stop propagation to other listeners
 *   event.stopPropagation();
 *
 *   // prevent event default
 *   event.preventDefault();
 * });
 *
 * // listen for event with custom payload
 * eventBus.on('bar', function(event, payload) {
 *   console.log(payload);
 * });
 *
 * // listen for event returning value
 * eventBus.on('foobar', function(event) {
 *
 *   // stop event propagation + prevent default
 *   return false;
 *
 *   // stop event propagation + return custom result
 *   return {
 *     complex: 'listening result'
 *   };
 * });
 *
 *
 * // listen with custom priority (default=1000, higher is better)
 * eventBus.on('priorityfoo', 1500, function(event) {
 *   console.log('invoked first!');
 * });
 *
 *
 * // listen for event and pass the context (`this`)
 * eventBus.on('foobar', function(event) {
 *   this.foo();
 * }, this);
 * ```
 *
 *
 * ## Emitting Events
 *
 * Events can be emitted via the event bus using {@link EventBus#fire}.
 *
 * ```javascript
 *
 * // false indicates that the default action
 * // was prevented by listeners
 * if (eventBus.fire('foo') === false) {
 *   console.log('default has been prevented!');
 * };
 *
 *
 * // custom args + return value listener
 * eventBus.on('sum', function(event, a, b) {
 *   return a + b;
 * });
 *
 * // you can pass custom arguments + retrieve result values.
 * var sum = eventBus.fire('sum', 1, 2);
 * console.log(sum); // 3
 * ```
 */
export declare class EventBus {
	static Default: EventBus;
	private _listeners;
	constructor();
	/**
	 * Register an event listener for events with the given name.
	 *
	 * The callback will be invoked with `event, ...additionalArguments`
	 * that have been passed to {@link EventBus#fire}.
	 *
	 * Returning false from a listener will prevent the events default action
	 * (if any is specified). To stop an event from being processed further in
	 * other listeners execute {@link Event#stopPropagation}.
	 *
	 * Returning anything but `undefined` from a listener will stop the listener propagation.
	 *
	 * @param {String|Array<String>} events
	 * @param {Number} [priority=1000] the priority in which this listener is called, larger is higher
	 * @param {Function} callback
	 * @param {Object} [that] Pass context (`this`) to the callback
	 */
	on(events: string | Array<string>, priority: number | Function, callback?: Function, that?: any): void;
	/**
	 * Register an event listener that is executed only once.
	 *
	 * @param {String} event the event name to register for
	 * @param {Number} [priority=1000] the priority in which this listener is called, larger is higher
	 * @param {Function} callback the callback to execute
	 * @param {Object} [that] Pass context (`this`) to the callback
	 */
	once(event: string, priority: number, callback: Function, that: object): void;
	/**
	 * Removes event listeners by event and callback.
	 *
	 * If no callback is given, all listeners for a given event name are being removed.
	 *
	 * @param {String|Array<String>} events
	 * @param {Function} [callback]
	 */
	off(events: string | Array<string>, callback: Function): void;
	/**
	 * Create an EventBus event.
	 *
	 * @param {Object} data
	 *
	 * @return {Object} event, recognized by the eventBus
	 */
	createEvent(data: Object): Object;
	/**
	 * Fires a named event.
	 *
	 * @example
	 *
	 * // fire event by name
	 * events.fire('foo');
	 *
	 * // fire event object with nested type
	 * var event = { type: 'foo' };
	 * events.fire(event);
	 *
	 * // fire event with explicit type
	 * var event = { x: 10, y: 20 };
	 * events.fire('element.moved', event);
	 *
	 * // pass additional arguments to the event
	 * events.on('foo', function(event, bar) {
	 *   alert(bar);
	 * });
	 *
	 * events.fire({ type: 'foo' }, 'I am bar!');
	 *
	 * @param {String} [name] the optional event name
	 * @param {Object} [event] the event object
	 * @param {...Object} additional arguments to be passed to the callback functions
	 *
	 * @return {Boolean} the events return value, if specified or false if the
	 *                   default action was prevented by listeners
	 */
	fire(type: string | Object, data: any): boolean;
	fireAsync(type: string | Object, data: any): void;
	handleError(error: any): boolean;
	private _destroy;
	private _invokeListeners;
	private _invokeListenersAsync;
	private _invokeListener;
	private _addListener;
	private _getListeners;
	private _setListeners;
	private _removeListener;
}
export declare abstract class EventBusPreProcesser {
	abstract process(eventText: string, callback: Function): any;
}
export declare class EventProcessor {
	private eventBus;
	constructor();
	on(event: int, callback: Function): void;
	fire(event: int, args: any): void;
}
export declare class GEventBus {
	private m_Listeners;
	private m_Filters;
	constructor();
	registerProcessor(processorId: int, processor: EventProcessor): void;
	on(event: int, callback: Function): any;
	on(filter: int, event: int, callback: Function): any;
	fire(event: int, eventArgs: any): any;
	fire(filter: int, event: int, eventArgs: any): any;
}
export declare class NullReferenceException extends SystemException {
	protected getName(): string;
}
export declare class NotImplementedException extends SystemException {
	protected getName(): string;
}
export declare class NotSupportedException extends SystemException {
	protected getName(): string;
}
export declare class ArgumentException extends SystemException {
	private paramName;
	constructor(paramName: string, message?: string, innerException?: Error, beforeSealing?: (ex: any) => void);
	protected getName(): string;
}
export declare class ArgumentOutOfRangeException extends ArgumentException {
	actualValue: Primitive | null | undefined;
	constructor(paramName: string, actualValue?: Primitive | null | undefined, message?: string, innerException?: Error);
	protected getName(): string;
}
export declare class ArgumentNullException extends SystemException {
	constructor(paramName: string, message?: string, innerException?: Error);
	protected getName(): string;
}
export declare class InvalidFilterCriteriaException extends SystemException {
	protected getName(): string;
}
export declare class InvalidEnumArgumentException extends SystemException {
	protected getName(): string;
}
export declare class OutOfMemoryException extends Exception {
	constructor(...params: any[]);
}
export declare class MemberAccessException extends Exception {
	constructor(...params: any[]);
}
export declare class InternalBufferOverflowException extends Exception {
	constructor(...params: any[]);
}
export declare class UnauthorizedAccessException extends SystemException {
}
export declare class OverflowException extends Exception {
	constructor(...params: any[]);
}
export declare function constrain(n: number, low: number, high: number): number;
export declare function dist(x1: number, y1: number, x2: number, y2: number): number | undefined;
export declare function hypot(x: number, y: number, z?: number): number;
export declare const random: (min: number | number[], max: number) => number;
export declare const randomGaussian: (mean: number, sd: number) => number;
export declare function lerp(start: float, stop: float, amt: float): number;
export declare class Vector {
	x: float;
	y: float;
	z: float;
	constructor(x?: number, y?: number | number[], z?: number);
	toString(): string;
	set(x?: number, y?: number, z?: number): Vector;
	set(value: Vector | number[]): Vector;
	copy(): Vector;
	add(x: number, y?: number, z?: number): Vector;
	add(value: Vector | number[]): Vector;
	sub(x: number, y?: number, z?: number): Vector;
	sub(value: Vector | number[]): Vector;
	mult(n: number): Vector;
	div(n: number): Vector;
	mag(): number;
	magSq(): number;
	dot(x: number, y?: number, z?: number): number;
	dot(value: Vector): number;
	cross(v: Vector): Vector;
	dist(v: Vector): number;
	normalize(): Vector;
	limit(max: number): Vector;
	setMag(len: number): Vector;
	heading(): number;
	rotate(angle: number): Vector;
	angleBetween(v: Vector): number;
	lerp(v: Vector, amt: number): Vector;
	lerp(x: number, y: number, z: number, amt?: number): Vector;
	array(): number[];
	equals(x?: number, y?: number, z?: number): boolean;
	equals(value: Vector | any[]): boolean;
	static fromAngle(angle: number, length?: number): Vector;
	static fromAngles(theta: number, phi: number, length?: number): Vector;
	static random2D(): Vector;
	static random3D(): Vector;
	static add(v1: Vector, v2: Vector, target: Vector): void;
	static add(v1: Vector, v2: Vector): Vector;
	static sub(v1: Vector, v2: Vector, target: Vector): void;
	static sub(v1: Vector, v2: Vector): Vector;
	static mult(v: Vector, n: number, target: Vector): void;
	static mult(v: Vector, n: number): Vector;
	static div(v: Vector, n: number, target: Vector): void;
	static div(v: Vector, n: number): Vector;
	static dot(v1: Vector, v2: Vector): number;
	static cross(v1: Vector, v2: Vector): Vector;
	static dist(v1: Vector, v2: Vector): number;
	static lerp(v1: Vector, v2: Vector, amt: number, target: Vector): void;
	static lerp(v1: Vector, v2: Vector, amt: number): number;
	static mag(vecT: Vector): number;
}
export declare class TMath {
	static readonly HALF_PI: number;
	static readonly PI: number;
	static readonly QUARTER_PI: number;
	static readonly TAU: number;
	static readonly TWO_PI: number;
	static noise(x: int, y?: int, z?: int): int;
	static noiseDetail(lod: int, falloff: int): void;
	static noiseSeed(seed: int): void;
	static abs(x: int): int;
	static ceil(x: int): int;
	static constrain(n: int, low: int, high: int): number;
	static dist(x1: int, y1: int, z1: int, x2: int, y2: int, z2: int): int;
	static dist(x1: int, y1: int, x2: int, y2: int): int;
	static exp(x: int): int;
	static floor(x: int): int;
	static lerp(start: int, stop: int, amt: int): int;
	static log(x: int): int;
	static mag(x: int, y: int): number;
	static map(n: int, start1: int, stop1: int, start2: int, stop2: int, withinBounds?: boolean): int;
	static max(...values: int[]): int;
	static min(...values: int[]): int;
	static norm(n: int, start: int, stop: int): int;
	static pow(x: int, y: int): int;
	static round(n: int, decimals?: int): number;
	static sq(n: int): int;
	static sqrt(n: int): int;
	fract(toConvert: int): int;
	static randomSeed(seed: number): void;
	static random(min: int | int[], max?: int): int;
	static randomGaussian(mean: number, sd: number): number;
	static createVector(x?: int, y?: int, z?: int): Vector;
	static Clamp(x: number, a: number, b: number): number;
	static ClampBottom(x: any, a: any): any;
	static MapLinear(x: number, a1: number, a2: number, b1: number, b2: number): number;
	static SmoothStep(x: number, min: number, max: number): number;
	static SmootherStep(x: number, min: number, max: number): number;
	static Random16(): number;
	static RandInt(low: number, high: number): number;
	static RandFloat(low: number, high: number): number;
	static RandFloatSpread(range: number): number;
	static Sign(x: number): number;
	static generateUUID: () => string;
	static DegToRad: (degrees: number) => number;
	static RadToDeg: (radians: number) => number;
	static IsPowerOfTwo(value: number): boolean;
}
export declare class Vector3f {
	x: int32_t;
	y: int32_t;
	z: int32_t;
	constructor(x?: int32_t, y?: int32_t, z?: int32_t);
	mult(scale: int32_t): Vector3f;
	sub(vec: Vector3f): Vector3f;
	sub2(vec1: Vector3f, vec2: Vector3f): void;
	mul(scal: number): Vector3f;
	add(vec: Vector3f): Vector3f;
	add2(vec: Vector3f, vec2: Vector3f): void;
	cross(vec: Vector3f): Vector3f;
	cross2(vec1: Vector3f, vec2: Vector3f): void;
	length(): int32_t;
	normalize(): Vector3f;
	normalize2(): void;
	dot(vec: Vector3f): int32_t;
}
export declare class Injector {
	private parent;
	private currentlyResolving;
	providers: any;
	instances: any;
	private _providers;
	private _instances;
	constructor(modules: any, parent?: any);
	registerModules(modules: any): void;
	registerType(name: any, value: any): void;
	private error;
	get(name: any, strict?: any): any;
	fnDef(fn: any, locals?: any): {
		fn: any;
		dependencies: any;
	};
	instantiate(Type: any): any;
	invoke(func: any, context: any, locals: any): any;
	private createPrivateInjectorFactory;
	private createChild;
}
/**
 * The main diagram-js entry point that bootstraps the diagram with the given
 * configuration.
 *
 * To register extensions with the diagram, pass them as Array<Module> to the constructor.
 *
 * @class djs.Diagram
 * @memberOf djs
 * @constructor
 *
 * @example
 *
 * <caption>Creating a plug-in that logs whenever a shape is added to the canvas.</caption>
 *
 * // plug-in implemenentation
 * function MyLoggingPlugin(eventBus) {
 *   eventBus.on('shape.added', function(event) {
 *     console.log('shape ', event.shape, ' was added to the diagram');
 *   });
 * }
 *
 * // export as module
 * export default {
 *   __init__: [ 'myLoggingPlugin' ],
 *     myLoggingPlugin: [ 'type', MyLoggingPlugin ]
 * };
 *
 *
 * // instantiate the diagram with the new plug-in
 *
 * import MyLoggingModule from 'path-to-my-logging-plugin';
 *
 * var diagram = new Diagram({
 *   modules: [
 *     MyLoggingModule
 *   ]
 * });
 *
 * diagram.invoke([ 'canvas', function(canvas) {
 *   // add shape to drawing canvas
 *   canvas.addShape({ x: 10, y: 10 });
 * });
 *
 * // 'shape ... was added to the diagram' logged to console
 *
 * @param {Object} options
 * @param {Array<Module>} [options.modules] external modules to instantiate with the diagram
 * @param {Injector} [injector] an (optional) injector to bootstrap the diagram with
 */
export declare class Context {
	private injector;
	static Current: Context;
	constructor(options?: {}, injector?: any);
	addType(name: any, type: any): void;
	addModules(modules: any): void;
	/**
 * Resolves a diagram service
 *
 * @method Diagram#get
 *
 * @param {String} name the name of the diagram service to be retrieved
 * @param {Boolean} [strict=true] if false, resolve missing services to null
 */
	"get": Function;
	/**
	* Executes a function into which diagram services are injected
	*
	* @method Diagram#invoke
	*
	* @param {Function|Object[]} fn the function to resolve
	* @param {Object} locals a number of locals to use to resolve certain dependencies
	*/
	"invoke": Function;
}
export declare function has(target: any, key: any): boolean;
export declare class TArray {
	static readonly MaxArrayLength: int;
	static readonly MaxByteArrayLength: int;
	static Resize<T>(newEras: T[] | Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array, newSize: int): T[] | Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
	static CreateInstance<T>(type: Type, length: number): Array<T>;
	static LastIndexOf<T>(array: Array<T>, value: T, startIndex: int, count: int): int;
	static GetUpperBound<T>(array: Array<T>, index: number): number;
	static GetLowerBound<T>(array: Array<T>, index: number): number;
	static IndexOf<T>(array: Array<T>, value: T): int;
	static IndexOf<T>(array: Array<T>, value: T, startIndex: int, count: int): int;
	static Clear<T>(array: Array<T> | TypedArray, start: int, end: int): void;
	/**
	 *
	 * @param args
	 */
	static Copy<T extends ArrayLike<any>>(source: T, dest: T, count: int): void;
	static Copy<T extends ArrayLike<any>>(source: T, index: int, dest: T, destIndex: int): void;
	static Copy<T extends ArrayLike<any>>(source: T, index: int, dest: T, destIndex: int, count: int): void;
	static Reverse(sourceArray: Array<any> | Uint8Array, index?: number, length?: number): void;
	static SortImpl(keys: Array<any>, items: Array<any>, comparer: IComparer<any>): void;
	static Sort<T>(sourceArray: T[], index: number, length: number, comparer: IComparer<T>): void;
	static Fill<T>(sourceArray: Array<T>, value: T): void;
	static Clone<T>(array: Array<T>): Array<T>;
	static Clone(array: Int8Array): Int8Array;
	static Clone(array: Uint8Array): Uint8Array;
	static Clone(array: Int16Array): Int16Array;
	static Clone(array: Uint16Array): Uint16Array;
	static Clone(array: Int32Array): Int32Array;
	static Clone(array: Uint32Array): Uint32Array;
	static CloneInt32Array: (array: Int32Array) => Int32Array;
	static BinarySearch<T>(array: Array<T>, value: T): int;
	static BinarySearch<T>(array: Array<T>, index: int, length: int, value: T): int;
	static BinarySearch<T>(array: Array<T>, value: T, comparer: IComparer<T>): int;
	static BinarySearch<T>(array: T[], index: int, length: int, value: T, comparer: IComparer<T>): int;
	static Flatten<T>(arr: T[]): any[];
	static Find<T>(collection: T[] | object, matcher: Function): any;
	static Filter<T>(collection: T[] | object, matcher: Function): T[];
	static ForEach<T>(collection: T[] | object, iterator: Function): any;
	static Without<T>(arr: T[], matcher: Function): T[];
	static Reduce<T>(collection: T[] | object, iterator: Function, result: any): any;
	static Every<T>(collection: T[] | object, matcher: any): boolean;
	static Some<T>(collection: T[] | object, matcher: Function): boolean;
	static Map<T>(collection: T[] | object, fn: Function): T[];
	static Keys<T>(collection: T[] | object): string[];
	static Size<T>(collection: T[] | object): number;
	static Values<T>(collection: T[] | object): T[];
	static GroupBy<T>(collection: T[] | object, extractor: Function, grouped?: any): any;
	static UniqueBy(extractor: any, ...collections: any[]): unknown[];
	static SortBy<T>(collection: T[] | object, extractor: Function): T[];
	static MatchPattern(pattern: any): Function;
	static GetEnumerator<T>(array: ArrayLike<T>): IEnumerator<T>;
	static Equals<T>(array1: Array<T>, array2: Array<T>): boolean;
}
export declare enum BidiCategory {
	LeftToRight = 0,
	LeftToRightEmbedding = 1,
	LeftToRightOverride = 2,
	RightToLeft = 3,
	RightToLeftArabic = 4,
	RightToLeftEmbedding = 5,
	RightToLeftOverride = 6,
	PopDirectionalFormat = 7,
	EuropeanNumber = 8,
	EuropeanNumberSeparator = 9,
	EuropeanNumberTerminator = 10,
	ArabicNumber = 11,
	CommonNumberSeparator = 12,
	NonSpacingMark = 13,
	BoundaryNeutral = 14,
	ParagraphSeparator = 15,
	SegmentSeparator = 16,
	Whitespace = 17,
	OtherNeutrals = 18,
	LeftToRightIsolate = 19,
	RightToLeftIsolate = 20,
	FirstStrongIsolate = 21,
	PopDirectionIsolate = 22
}
export declare enum UnicodeCategory {
	UppercaseLetter = 0,
	LowercaseLetter = 1,
	TitlecaseLetter = 2,
	ModifierLetter = 3,
	OtherLetter = 4,
	NonSpacingMark = 5,
	SpacingCombiningMark = 6,
	EnclosingMark = 7,
	DecimalDigitNumber = 8,
	LetterNumber = 9,
	OtherNumber = 10,
	SpaceSeparator = 11,
	LineSeparator = 12,
	ParagraphSeparator = 13,
	Control = 14,
	Format = 15,
	Surrogate = 16,
	PrivateUse = 17,
	ConnectorPunctuation = 18,
	DashPunctuation = 19,
	OpenPunctuation = 20,
	ClosePunctuation = 21,
	InitialQuotePunctuation = 22,
	FinalQuotePunctuation = 23,
	OtherPunctuation = 24,
	MathSymbol = 25,
	CurrencySymbol = 26,
	ModifierSymbol = 27,
	OtherSymbol = 28,
	OtherNotAssigned = 29
}
export declare class CharUnicodeInfo {
	static readonly HIGH_SURROGATE_START: char;
	static readonly HIGH_SURROGATE_END: char;
	static readonly LOW_SURROGATE_START: char;
	static readonly LOW_SURROGATE_END: char;
	static readonly UNICODE_CATEGORY_OFFSET: int;
	static readonly BIDI_CATEGORY_OFFSET: int;
	private static s_initialized;
	static s_pCategoryLevel1Index: Uint16Array;
	static s_pCategoriesValue: Uint8Array;
	static s_pNumericLevel1Index: Uint16Array;
	static s_pNumericValues: Uint8Array;
	static s_pDigitValues: Int8Array;
	static readonly UNICODE_INFO_FILE_NAME: string;
	static readonly UNICODE_PLANE01_START: int;
	private static InitTable;
	static InternalConvertToUtf32(s: string, index: int): int;
	static InternalConvertToUtf32_1(s: string, index: int, charLength: Out<int>): int;
	static IsWhiteSpace_1(s: string, index: int): boolean;
	static IsWhiteSpace(c: char): boolean;
	static InternalGetNumericValue(ch: int): int;
	static InternalGetDigitValues(ch: int): Int8Array;
	static InternalGetDecimalDigitValue(ch: int): int;
	static InternalGetDigitValue(ch: int): int;
	static GetNumericValue(ch: char): int;
	static GetNumericValue2(s: string, index: int): int;
	static GetDecimalDigitValue(ch: char): int;
	static GetDecimalDigitValue2(s: string, index: int): int;
	static GetDigitValue(ch: char): int;
	static GetDigitValue2(s: string, index: int): int;
	static GetUnicodeCategory(ch: char): UnicodeCategory;
	static GetUnicodeCategory1(s: string, index: int): UnicodeCategory;
	static InternalGetUnicodeCategory(ch: int): UnicodeCategory;
	static InternalGetCategoryValue(ch: int, offset: int): byte;
	static GetBidiCategory(s: string, index: int): BidiCategory;
	static InternalGetUnicodeCategory2(value: string, index: int): UnicodeCategory;
	static InternalGetUnicodeCategory3(str: string, index: int, charLength: Out<int>): UnicodeCategory;
	static IsCombiningCategory(uc: UnicodeCategory): boolean;
}
export declare class TChar {
	private static readonly categoryForLatin1;
	static IsSurrogate(c: char): boolean;
	private static IsAscii;
	static IsLetter(c: char): boolean;
	static CheckLetter(uc: UnicodeCategory): boolean;
	private static IsWhiteSpaceLatin1;
	private static IsLatin1;
	static IsWhiteSpace(c: char): boolean;
	static IsLetterOrDigit(c: char): boolean;
	private static GetLatin1UnicodeCategory;
	static CheckLetterOrDigit(uc: UnicodeCategory): boolean;
	static IsDigit(c: char): boolean;
	static IsDigit(c: string): boolean;
	static ToLower(c: char, culture: CultureInfo): char;
	static ToLower(c: char): char;
	static ToUpper(c: char): char;
	static ToUpper(c: char, culture: CultureInfo): char;
	static ToUpperInvariant(c: char): char;
	static IsSurrogatePair(s: string, index: int): boolean;
	static IsSurrogatePair(highSurrogate: char, lowSurrogate: char): boolean;
}
declare enum ExceptionResource {
	ArgumentOutOfRange_NeedNonNegNumRequired = 0,
	Argument_ImplementIComparable = 1,
	Argument_InvalidType = 2,
	Argument_InvalidArgumentForComparison = 3,
	Argument_InvalidRegistryKeyPermissionCheck = 4,
	ArgumentOutOfRange_NeedNonNegNum = 5,
	Arg_ArrayPlusOffTooSmall = 6,
	Arg_NonZeroLowerBound = 7,
	Arg_RankMultiDimNotSupported = 8,
	Arg_RegKeyDelHive = 9,
	Arg_RegKeyStrLenBug = 10,
	Arg_RegSetStrArrNull = 11,
	Arg_RegSetMismatchedKind = 12,
	Arg_RegSubKeyAbsent = 13,
	Arg_RegSubKeyValueAbsent = 14,
	Argument_AddingDuplicate = 15,
	Serialization_InvalidOnDeser = 16,
	Serialization_MissingKeys = 17,
	Serialization_NullKey = 18,
	Argument_InvalidArrayType = 19,
	NotSupported_KeyCollectionSet = 20,
	NotSupported_ValueCollectionSet = 21,
	ArgumentOutOfRange_SmallCapacity = 22,
	ArgumentOutOfRange_Index = 23,
	Argument_InvalidOffLen = 24,
	Argument_ItemNotExist = 25,
	ArgumentOutOfRange_Count = 26,
	ArgumentOutOfRange_InvalidThreshold = 27,
	ArgumentOutOfRange_ListInsert = 28,
	NotSupported_ReadOnlyCollection = 29,
	InvalidOperation_CannotRemoveFromStackOrQueue = 30,
	InvalidOperation_EmptyQueue = 31,
	InvalidOperation_EnumOpCantHappen = 32,
	InvalidOperation_EnumFailedVersion = 33,
	InvalidOperation_EmptyStack = 34,
	ArgumentOutOfRange_BiggerThanCollection = 35,
	InvalidOperation_EnumNotStarted = 36,
	InvalidOperation_EnumEnded = 37,
	NotSupported_SortedListNestedWrite = 38,
	InvalidOperation_NoValue = 39,
	InvalidOperation_RegRemoveSubKey = 40,
	Security_RegistryPermission = 41,
	UnauthorizedAccess_RegistryNoWrite = 42,
	ObjectDisposed_RegKeyClosed = 43,
	NotSupported_InComparableType = 44,
	Argument_InvalidRegistryOptionsCheck = 45,
	Argument_InvalidRegistryViewCheck = 46
}
declare enum ExceptionArgument {
	obj = 0,
	dictionary = 1,
	dictionaryCreationThreshold = 2,
	array = 3,
	info = 4,
	key = 5,
	collection = 6,
	list = 7,
	match = 8,
	converter = 9,
	queue = 10,
	stack = 11,
	capacity = 12,
	index = 13,
	startIndex = 14,
	value = 15,
	count = 16,
	arrayIndex = 17,
	name = 18,
	mode = 19,
	item = 20,
	options = 21,
	view = 22,
	sourceBytesToCopy = 23
}
export declare class ThrowHelper {
	static GetArgumentName(argument: ExceptionArgument): string;
	private static GetResourceName;
	static ThrowNotImplementedException(msg: string | ExceptionResource): void;
	static ThrowInvalidOperationException(resource: ExceptionResource): void;
	static ThrowArgumentNullException(argument: ExceptionArgument): void;
	static ThrowArgumentOutOfRangeException(): void;
	static ThrowArgumentOutOfRangeException(argument: ExceptionArgument): void;
	static ThrowArgumentOutOfRangeException(argument: ExceptionArgument, resource: ExceptionResource): void;
	static ThrowArgumentException(resource: ExceptionResource): void;
	static ThrowNotSupportedException(resource: ExceptionResource): void;
}
export declare class Linq<T = any> implements IEnumerable<T> {
	GetEnumerator(): IEnumerator<T>;
	IsEndless?: boolean | undefined;
	private _items;
	constructor(array: T[]);
	where(f: (item: T) => boolean): Linq<T>;
	select(f: (item: T, index?: number) => any): Linq<T>;
	firstOrDefault(f: Predicate<T>, _default?: T): T;
}
export declare namespace Linq {
	class LinqEnumerator<T> implements IEnumerator<T> {
		CanMoveNext?: boolean | undefined;
		TryMoveNext(out: (value: T) => void): boolean;
		End(): void;
		NextValue(value?: any): T | undefined;
		IsEndless?: boolean | undefined;
		Next(value?: any): IIteratorResult<T>;
		private list;
		private index;
		private version;
		private current;
		get Current(): T;
		constructor(list: T[]);
		Dispose(): void;
		MoveNext(): boolean;
		private moveNextRare;
		Reset(): void;
	}
}
export declare function from<T>(array: T[]): Linq<T>;
export declare class StringBuilder extends TObject {
	protected dispose(disposing: boolean): void;
	static readonly DefaultCapacity: int;
	m_currentThread: int;
	m_MaxCapacity: int;
	m_StringValue: string;
	get Capacity(): int;
	set Capacity(value: int);
	get(index: int): char;
	set(index: int, value: char): void;
	get Length(): int;
	set Length(value: int);
	get MaxCapacity(): int;
	constructor();
	constructor(capacity: int);
	constructor(value: string);
	constructor(value: string, capacity: int);
	constructor(value: string, startIndex: int, length: int, capacity: int);
	constructor(capacity: int, maxCapacity: int);
	constructor1(): void;
	constructor2(capacity: int): void;
	constructor3(value: string): void;
	constructor4(value: string, capacity: int): void;
	constructor5(value: string, startIndex: int, length: int, capacity: int): void;
	constructor6(capacity: int, maxCapacity: int): void;
	AppendChar(value: string): StringBuilder;
	AppendChar(value: string, repeatCount: int): StringBuilder;
	AppendChar(value: char): StringBuilder;
	AppendChar(value: char, repeatCount: int): StringBuilder;
	AppendCharArray(value: CharArray): StringBuilder;
	AppendCharArray(value: CharArray, startIndex: int, charCount: int): StringBuilder;
	Append(value: string): StringBuilder;
	Append(value: string, startIndex: int, count: int): StringBuilder;
	AppendLine(): StringBuilder;
	AppendLine(str: string): StringBuilder;
	AppendBoolean(value: boolean): StringBuilder;
	AppendByte(value: byte): StringBuilder;
	AppendShort(value: short): StringBuilder;
	AppendInt(value: int): StringBuilder;
	AppendLong(value: long): StringBuilder;
	AppendFloat(value: float): StringBuilder;
	AppendDouble(value: double): StringBuilder;
	AppendDecimal(value: decimal): StringBuilder;
	AppendUShort(value: ushort): StringBuilder;
	AppendUInt(value: uint): StringBuilder;
	AppendULong(value: ulong): StringBuilder;
	AppendAny(value: any): StringBuilder;
	AppendFormat(format: string, ...args: any[]): StringBuilder;
	EnsureCapacity(capacity: int): int;
	Equals<StringBuilder>(sb: StringBuilder): boolean;
	private static FormatError;
	Insert(index: int, value: string): StringBuilder;
	Insert(index: int, value: string, count: int): StringBuilder;
	Insert(index: int, value: CharArray, startIndex: int, charCount: int): StringBuilder;
	InsertBoolean(index: int, value: boolean): StringBuilder;
	InsertByte(index: int, value: byte): StringBuilder;
	InsertShort(index: int, value: short): StringBuilder;
	InsertChar(index: int, value: char): StringBuilder;
	InsertCharArray(index: int, value: CharArray): StringBuilder;
	InsertInt(index: int, value: int): StringBuilder;
	InsertLong(index: int, value: long): StringBuilder;
	InsertFloat(index: int, value: float): StringBuilder;
	InsertDouble(index: int, value: double): StringBuilder;
	InsertDecimal(index: int, value: decimal): StringBuilder;
	InsertUShort(index: int, value: ushort): StringBuilder;
	InsertUInt(index: int, value: uint): StringBuilder;
	InsertULong(index: int, value: ulong): StringBuilder;
	InsertAny(index: int, value: any): StringBuilder;
	Remove(startIndex: int, length: int): StringBuilder;
	Replace(oldValue: string, newValue: string): StringBuilder;
	Replace(oldValue: string, newValue: string, startIndex: int, count: int): StringBuilder;
	Replace(oldChar: char, newChar: char): StringBuilder;
	Replace(oldChar: char, newChar: char, startIndex: int, count: int): StringBuilder;
	private ReplaceString;
	ToString(): string;
	ToString(startIndex: int, length: int): string;
	Clear(): StringBuilder;
}
export declare function capitalize(str: string): string;
export declare namespace RegexOptions {
	type Global = "g";
	type IgnoreCase = "i";
	type MultiLine = "m";
	type Unicode = "u";
	type Sticky = "y";
	type IgnorePatternWhitespace = "w";
	type Literal = Global | IgnoreCase | MultiLine | Unicode | Sticky | IgnorePatternWhitespace;
	/**
	 * Specifies case-insensitive matching. For more information, see the "Case-Insensitive Matching " section in the Regular Expression Options topic.
	 */
	const IGNORE_CASE: IgnoreCase;
	const I: IgnoreCase;
	/**
	 * Specifies global matching instead of single.
	 */
	const GLOBAL: Global;
	const G: Global;
	/**
	 * treat beginning and end characters (^ and $) as working over multiple lines (i.e., match the beginning or end of each line (delimited by \n or \r), not only the very beginning or end of the whole input string)
	 */
	const MULTI_LINE: MultiLine;
	const M: MultiLine;
	/**
	 * treat pattern as a sequence of unicode code points
	 */
	const UNICODE: Unicode;
	const U: Unicode;
	/**
	 * matches only from the index indicated by the lastIndex property of this regular expression in the target string (and does not attempt to match from any later indexes).
	 */
	const STICKY: Sticky;
	const Y: Sticky;
	/**
	 * Modifies the pattern to ignore standard whitespace characters.
	 */
	const IGNORE_PATTERN_WHITESPACE: IgnorePatternWhitespace;
	const W: IgnorePatternWhitespace;
}
export declare class Regex {
	private readonly _re;
	private readonly _keys;
	constructor(pattern: string | RegExp, options?: RegexOptions.Literal | RegexOptions.Literal[], ...extra: RegexOptions.Literal[]);
	match(input: string, startIndex?: number): Match;
	matches(input: string): Match[];
	replace(input: string, replacement: Primitive, count?: number): string;
	replace(input: string, evaluator: SelectorWithIndex<Match, Primitive>, count?: number): string;
	isMatch(input: string): boolean;
	static isMatch(input: string, pattern: string, options?: RegexOptions.Literal[]): boolean;
	static replace(input: string, pattern: string, replacement: string, options?: RegexOptions.Literal[]): string;
	static replace(input: string, pattern: string, evaluator: SelectorWithIndex<Match, Primitive>, options?: RegexOptions.Literal[]): string;
}
export declare class Capture {
	readonly value: string;
	readonly index: number;
	get length(): number;
	constructor(value?: string, index?: number);
	freeze(): void;
}
export declare class Group extends Capture {
	get success(): boolean;
	constructor(value?: string, index?: number);
	static get Empty(): Group;
}
export declare class Match extends Group {
	readonly groups: Group[];
	readonly namedGroups: IMap<Group>;
	constructor(value?: string, index?: number, groups?: Group[], namedGroups?: IMap<Group>);
	freeze(): void;
	static get Empty(): Match;
}
export declare class RegexMatchEnumerator {
	private readonly _pattern;
	constructor(pattern: string | RegExp | Regex);
	matches(input: string): IEnumerator<Match>;
	static matches(input: string, pattern: string | RegExp | Regex): IEnumerator<Match>;
}
export declare class Guid extends TObject {
	protected dispose(disposing: boolean): void;
	private value;
	private hash;
	private firstCharCode;
	private lastCharCode;
	constructor(val: string);
	private makeHash;
	static NewGuid(): Guid;
	Equals<Guid>(guid: Guid): boolean;
	ToString(): string;
}
export interface ModuleInfo {
	name: string;
	module: any;
}
export declare class ModuleLoader {
	static LoadedModules: any;
	static cache: Dictionary<string, any>;
	static get Cache(): Dictionary<string, any>;
	static Load(url: string, moduleName?: string, callback?: Function): Promise<any>;
	private static InstalledLibs;
	static LoadLib(url: string, moduleName: string, callback?: Function): Promise<void>;
	static LoadFromLocal(moduleName: string): Promise<ModuleInfo>;
	static LoadFromUrl(url: string, moduleName: string): Promise<ModuleInfo>;
	static LoadBundledModule(url: string, moduleName: string): Promise<ModuleInfo>;
	private static Loading;
	private static librariesHeaders;
	private static librariesUrls;
	private static GetDeps;
	static LoadBundledModuleWithDecode(encodedUrl: string, moduleName: string, isLib?: boolean): Promise<ModuleInfo>;
	static FireModuleLoadedEvent(moduleName: string, module: any): void;
}
export declare function httpDo(url: string, method?: string, callbackFunc?: Function): Promise<any>;
export declare class Http {
	static Json<T>(url: string): Promise<T>;
	static Text(url: string): Promise<string>;
	static JS(url: string): Promise<string>;
	static Binary(url: string): Promise<string>;
	static Do(url: string): Promise<Response>;
}
export declare class State extends Dictionary<string, any> {
	private static default;
	static get Default(): State;
	Get(key: string): any;
	Set(key: string, value: any): void;
}
export declare class FileDownloader {
	private params;
	private link;
	private request;
	/**
	 * You need to define a {String} "url" params and optionally others
	 * * {String} filename
	 * * {Int} timeout in ms
	 * * {Boolean} mobileDisabled
	 * * {Function} process call on request event
	 * @param {Object} customParams
	 */
	constructor(customParams?: {});
	start(): Promise<unknown>;
	downloadFile(): Promise<unknown>;
	initDonwload(resolve: any, reject: any): any;
	isMobile(): boolean;
	createRequest(): XMLHttpRequest;
	getFileName(): any;
	createLink(): HTMLAnchorElement;
	clickLink(): void;
	getFile(response: any, fileName: any): any;
	startDownload(): any;
}
export declare type HttpClientRequestHeaders = Record<string, string | number | boolean>;
export declare type HttpClientResponseHeaders = Record<string, string> & {
	"set-cookie"?: string[];
};
export interface HttpClientRequestTransformer {
	(data: any, headers?: HttpClientRequestHeaders): any;
}
export interface HttpClientResponseTransformer {
	(data: any, headers?: HttpClientResponseHeaders): any;
}
export interface HttpClientAdapter {
	(config: HttpClientRequestConfig): HttpClientPromise;
}
export interface HttpClientBasicCredentials {
	username: string;
	password: string;
}
export interface HttpClientProxyConfig {
	host: string;
	port: number;
	auth?: {
		username: string;
		password: string;
	};
	protocol?: string;
}
export declare type Method = "get" | "GET" | "delete" | "DELETE" | "head" | "HEAD" | "options" | "OPTIONS" | "post" | "POST" | "put" | "PUT" | "patch" | "PATCH" | "purge" | "PURGE" | "link" | "LINK" | "unlink" | "UNLINK";
export declare type ResponseType = "arraybuffer" | "blob" | "document" | "json" | "text" | "stream";
export interface TransitionalOptions {
	silentJSONParsing?: boolean;
	forcedJSONParsing?: boolean;
	clarifyTimeoutError?: boolean;
}
export interface HttpClientRequestConfig<D = any> {
	url?: string;
	method?: Method;
	baseURL?: string;
	transformRequest?: HttpClientRequestTransformer | HttpClientRequestTransformer[];
	transformResponse?: HttpClientResponseTransformer | HttpClientResponseTransformer[];
	headers?: HttpClientRequestHeaders;
	params?: any;
	paramsSerializer?: (params: any) => string;
	data?: D;
	timeout?: number;
	timeoutErrorMessage?: string;
	withCredentials?: boolean;
	adapter?: HttpClientAdapter;
	auth?: HttpClientBasicCredentials;
	responseType?: ResponseType;
	xsrfCookieName?: string;
	xsrfHeaderName?: string;
	onUploadProgress?: (progressEvent: any) => void;
	onDownloadProgress?: (progressEvent: any) => void;
	maxContentLength?: number;
	validateStatus?: ((status: number) => boolean) | null;
	maxBodyLength?: number;
	maxRedirects?: number;
	socketPath?: string | null;
	httpAgent?: any;
	httpsAgent?: any;
	proxy?: HttpClientProxyConfig | false;
	cancelToken?: CancelToken;
	decompress?: boolean;
	transitional?: TransitionalOptions;
	signal?: AbortSignal;
	insecureHTTPParser?: boolean;
}
export interface HeadersDefaults {
	common: HttpClientRequestHeaders;
	delete: HttpClientRequestHeaders;
	get: HttpClientRequestHeaders;
	head: HttpClientRequestHeaders;
	post: HttpClientRequestHeaders;
	put: HttpClientRequestHeaders;
	patch: HttpClientRequestHeaders;
	options?: HttpClientRequestHeaders;
	purge?: HttpClientRequestHeaders;
	link?: HttpClientRequestHeaders;
	unlink?: HttpClientRequestHeaders;
}
export interface HttpClientDefaults<D = any> extends Omit<HttpClientRequestConfig<D>, "headers"> {
	headers: HeadersDefaults;
}
export interface HttpClientResponse<T = any, D = any> {
	data: T;
	status: number;
	statusText: string;
	headers: HttpClientResponseHeaders;
	config: HttpClientRequestConfig<D>;
	request?: any;
}
export interface HttpClientError<T = any, D = any> extends Error {
	config: HttpClientRequestConfig<D>;
	code?: string;
	request?: any;
	response?: HttpClientResponse<T, D>;
	isAxiosError: boolean;
	toJSON: () => object;
}
export interface HttpClientPromise<T = any> extends Promise<HttpClientResponse<T>> {
}
export interface CancelStatic {
	new (message?: string): Cancel;
}
export interface Cancel {
	message: string;
}
export interface Canceler {
	(message?: string): void;
}
export interface CancelTokenStatic {
	new (executor: (cancel: Canceler) => void): CancelToken;
	source(): CancelTokenSource;
}
export interface CancelToken {
	promise: Promise<Cancel>;
	reason?: Cancel;
	throwIfRequested(): void;
}
export interface CancelTokenSource {
	token: CancelToken;
	cancel: Canceler;
}
export interface AxiosInterceptorManager<V> {
	use<T = V>(onFulfilled?: (value: V) => T | Promise<T>, onRejected?: (error: any) => any): number;
	eject(id: number): void;
}
export declare class HttpClient {
	private axios;
	constructor(config?: HttpClientRequestConfig);
	static get defaults(): HttpClientDefaults;
	static CreateCancelToken(): CancelToken;
	static GetUri(config?: HttpClientRequestConfig): string;
	static Request<T = any, R = HttpClientResponse<T>, D = any>(config: HttpClientRequestConfig<D>): Promise<R>;
	static Get<T = any, D = any>(url: string, config?: HttpClientRequestConfig<D>): Promise<HttpClientResponse<T>>;
	static Delete<T = any, R = HttpClientResponse<T>, D = any>(url: string, config?: HttpClientRequestConfig<D>): Promise<R>;
	static Head<T = any, R = HttpClientResponse<T>, D = any>(url: string, config?: HttpClientRequestConfig<D>): Promise<R>;
	static Options<T = any, R = HttpClientResponse<T>, D = any>(url: string, config?: HttpClientRequestConfig<D>): Promise<R>;
	static Post<D = any, T = any, R = HttpClientResponse<T>>(url: string, data?: D, config?: HttpClientRequestConfig<D>): Promise<R>;
	static Put<T = any, R = HttpClientResponse<T>, D = any>(url: string, data?: D, config?: HttpClientRequestConfig<D>): Promise<R>;
	static patch<T = any, R = HttpClientResponse<T>, D = any>(url: string, data?: D, config?: HttpClientRequestConfig<D>): Promise<R>;
}
declare namespace SchemeValue {
	type File = "file";
	type Gopher = "gopher";
	type FTP = "ftp";
	type HTTP = "http";
	type HTTPS = "https";
	type LDAP = "ldap";
	type MailTo = "mailto";
	type Pipe = "net.pipe";
	type TCP = "net.tcp";
	type NNTP = "nntp" | "news";
	type Telnet = "telnet";
	type UUID = "uuid";
	/**
	 * The allowed HTTP Method values.
	 */
	type Any = File | Gopher | FTP | HTTP | HTTPS | LDAP | MailTo | Pipe | TCP | NNTP | Telnet | UUID;
}
declare namespace UriComponent {
	interface Formattable {
		toUriComponent(): string;
	}
	type Value = Primitive | ISerializable | Formattable;
	interface Map extends IMap<Value | Value[]> {
	}
}
declare namespace QueryParam {
	type Array = ArrayLike<StringKeyValuePair<UriComponent.Value | UriComponent.Value[]>>;
	type Enumerable = IEnumerable<StringKeyValuePair<UriComponent.Value | UriComponent.Value[]>>;
	type EnumerableOrArray = IEnumerableOrArray<StringKeyValuePair<UriComponent.Value | UriComponent.Value[]>>;
	type Convertible = string | UriComponent.Map | EnumerableOrArray;
}
interface IUrn {
	/**
	 * The scheme name for this URI.
	 */
	scheme?: SchemeValue.Any | null;
	/**
	 * The absolute path of the URI.
	 */
	path?: string | null;
}
interface IUri extends IUrn {
	/**
	 * The user name, password, or other user-specific information associated with the specified URI.
	 */
	userInfo?: string | null;
	/**
	 * The host component of this instance.
	 */
	host?: string | null;
	/**
	 * The port number of this URI.
	 */
	port?: number | null;
	/**
	 * Gets any query information included in the specified URI.
	 */
	query?: string | null;
	/**
	 * The escaped URI fragment.
	 */
	fragment?: string | null;
}
/**
 * Provides an read-only model representation of a uniform resource identifier (URI) and easy access to the parts of the URI.
 *
 * The read-only model (frozen) is easier for debugging than exposing accessors for each property.
 * ICloneable&lt;Uri&gt; is not used to prevent unnecessary copying of values that won't change.
 */
export declare class Uri implements IUri, IEquatable<IUri> {
	readonly scheme: SchemeValue.Any | null;
	readonly userInfo: string | null;
	readonly host: string | null;
	readonly port: number | null;
	readonly path: string | null;
	readonly query: string | null;
	readonly fragment: string | null;
	readonly queryParams: IMap<Primitive | Primitive[]>;
	/**
	 * @param scheme The user name, password, or other user-specific information associated with the specified URI.
	 * @param userInfo The host component of this instance.
	 * @param host The port number of this URI.
	 * @param port The absolute path of the URI.
	 * @param path The absolute path of the URI.
	 * @param query Any query information included in the specified URI.
	 * @param fragment The escaped URI fragment.
	 */
	constructor(scheme: SchemeValue.Any | null, userInfo: string | null, host: string | null, port: number | null, path: string | null, query?: QueryParam.Convertible, fragment?: string);
	/**
	 *  Compares the values of another IUri via toString comparison.
	 * @param other
	 * @returns {boolean}
	 */
	Equals(other: IUri): boolean;
	/**
	 * Parses or clones values from existing Uri values.
	 * @param uri
	 * @param defaults
	 * @returns {Uri}
	 */
	static from(uri: string | IUri | null | undefined, defaults?: IUri): Uri;
	/**
	 * Parses a URL into it's components.
	 * @param url The url to parse.
	 * @returns {IUri} Will throw an exception if not able to parse.
	 */
	static parse(url: string): IUri;
	static parse(url: string, throwIfInvalid: true): IUri;
	/**
	 * Parses a URL into it's components.
	 * @param url The url to parse.
	 * @param throwIfInvalid Defaults to true.
	 * @returns {IUri} Returns a map of the values or *null* if invalid and *throwIfInvalid* is <b>false</b>.
	 */
	static parse(url: string, throwIfInvalid: boolean): IUri | null;
	/**
	 * Parses a URL into it's components.
	 * @param url The url to parse.
	 * @param out A delegate to capture the value.
	 * @returns {boolean} True if valid.  False if invalid.
	 */
	static tryParse(url: string, out: (result: IUri) => void): boolean;
	static copyOf(map: IUri): IUri;
	copyTo(map: IUri): IUri;
	updateQuery(query: QueryParam.Convertible): Uri;
	/**
	 * Is provided for sub classes to override this value.
	 */
	protected getAbsoluteUri(): string;
	/**
	 * Is provided for sub classes to override this value.
	 */
	protected getAuthority(): string;
	/**
	 * Is provided for sub classes to override this value.
	 */
	protected getPathAndQuery(): string;
	/**
	 * The absolute URI.
	 */
	absoluteUri: string;
	/**
	 * Gets the Domain Name System (DNS) host name or IP address and the port number for a server.
	 */
	readonly authority: string | null;
	/**
	 * Gets the path and Query properties separated by a question mark (?).
	 */
	readonly pathAndQuery: string | null;
	/**
	 * Gets the full path without the query or fragment.
	 */
	readonly baseUri: string;
	get pathSegments(): string[];
	/**
	 * Creates a writable copy.
	 * @returns {IUri}
	 */
	toMap(): IUri;
	/**
	 * @returns {string} The full absolute uri.
	 */
	ToString(): string;
	/**
	 * Properly converts an existing URI to a string.
	 * @param uri
	 * @returns {string}
	 */
	static toString(uri: IUri): string;
	/**
	 * Returns the authority segment of an URI.
	 * @param uri
	 * @returns {string}
	 */
	static getAuthority(uri: IUri): string;
}
export declare enum Fields {
	scheme = 0,
	userInfo = 1,
	host = 2,
	port = 3,
	path = 4,
	query = 5,
	fragment = 6
}
export interface ICursorService {
	(cursorName: string): void;
}
export declare function ThreadWorkerObject<T extends {
	new (...args: any[]): {};
}>(constructor: T): void;
export declare class ThreadWorker {
	private m_MessageCallbacks;
	Worker: Worker;
	private m_WriteHeap;
	private m_MemoryManager;
	private m_WriteBuffer;
	private m_ReadHeap;
	private m_ReadBuffer;
	private m_CurrentUICulture;
	get CurrentUICulture(): CultureInfo;
	set CurrentUICulture(value: CultureInfo);
	private m_CurrentCulture;
	get CurrentCulture(): CultureInfo;
	set CurrentCulture(value: CultureInfo);
	private m_EventBus;
	constructor();
	private RetriveMessageCallbacks;
	private setupSharedMemory;
	private setupMemory;
	on(event: int, callback: Function): void;
	fire(event: int, eventArgs: any): void;
	private attachMessageParser;
	SendMessage(message: int, ...params: any[]): void;
	WorkerProc(msg: int, ...params: any[]): void;
	PreProcessMessage(msg: int, ...params: any[]): void;
	GetHashCode(): int;
}
export declare enum ThreadEvents {
	LOADED = 0,
	STARTED = 1
}
export interface IMessage<T> {
	Msg: int;
	params: any[];
}
export declare class ThreadEventDelegate extends Delegate<() => void> {
}
export declare class Thread {
	private workerObjectStr?;
	static urls: string[];
	static readonly THREADID: int;
	static readonly WORKERID: int;
	static get CurrentThread(): ThreadWorker;
	static set CurrentThread(value: ThreadWorker);
	static readonly TM_LOADING: int;
	private m_WorkerUrl;
	private m_WorkerScript;
	private m_WorkerBlobUrl;
	private m_Worker;
	private m_Loading;
	private m_Loaded;
	private m_EventBus;
	private m_WriteHeap;
	private m_MemoryManager;
	private m_WriteBuffer;
	protected m_ReadHeap: ArrayBuffer;
	protected m_ReadBuffer: TBuffer;
	OnThreadLoadingEvent: Event<ThreadEventDelegate>;
	OnThreadLoadedEvent: Event<ThreadEventDelegate>;
	OnThreadStatingEvent: Event<ThreadEventDelegate>;
	OnThreadStartedEvent: Event<ThreadEventDelegate>;
	get EventBus(): GEventBus;
	get Worker(): Worker;
	constructor(workerUrl: string, workerObjectStr?: string | undefined);
	private setupSharedMemory;
	private createWorker;
	on(event: int, callback: Function): void;
	fire(event: int, eventArgs: any): void;
	private initDeps;
	start(): void;
	SendMessage(message: int, ...params: any[]): void;
	PostMessage(message: int, wParam: any, lParam: any, transferArr: any[]): void;
	RegisterService(serviceName: string, port: MessagePort): void;
	load(): Promise<Thread>;
	private attachMessageParser;
	ThreadProc<T, K>(msg: int, ...params: any[]): void;
	PreProcessMessage<T, K>(msg: int, ...params: T[]): void;
	OnThreadLoading(): void;
	OnThreadLoaded(): void;
	OnThreadStarting(): void;
	OnThreadStarted(): void;
	IpcSetReadHeap(arrayBuffer: any): void;
	static GetDomainID(): int;
}
export declare class ThreadExceptionEventArgs extends EventArgs {
	private exception;
	get Exception(): Exception;
	constructor(t: Exception);
}
export declare class ThreadExceptionEventHandler extends Delegate<(sender: any, args: ThreadExceptionEventArgs) => void> {
}
export interface IServiceMessage<T> {
	Msg: int;
	clientId: string;
	wParam: T;
	lParam: T;
}
export declare function ServiceThreadWorkerObject<T extends {
	new (...args: any[]): {};
}>(constructor: T): void;
export declare class ServiceThreadWorker {
	Clients: Dictionary<string, MessagePort>;
	private m_MessageCallbacks;
	Worker: Worker;
	private m_WriteHeap;
	private m_MemoryManager;
	private m_WriteBuffer;
	private m_ReadHeap;
	private m_ReadBuffer;
	private m_EventBus;
	constructor();
	private RetriveMessageCallbacks;
	private setupSharedMemory;
	private setupMemory;
	on(event: int, callback: Function): void;
	fire(event: int, eventArgs: any): void;
	private attachMessageParser;
	private attachPortOnMessage;
	SendMessage(message: int, wParam: int, lParam: int): void;
	SendMessageToClient(message: int, clientId: string, ...params: any[]): void;
	WorkerProc(msg: int, ...params: any[]): void;
	Isc_SetPort(port: MessagePort, clientId: string): void;
	PreProcessMessage(msg: int, ...params: any[]): void;
	PreProcessPortMessage(msg: int, clientId: string, wParam: number, lParam: number): void;
	ClientProc(msg: int, clientId: string, wParam: number, lParam: number): void;
}
export declare enum IPC {
	FORCETOWORKERSTART = -1,
	WORKERLOADING = 0,
	WORKERLOADED = 1,
	WORKERSTARTING = 2,
	WORKERSTARTED = 3,
	SETWRITEHEAP = 4,
	SETREADHEAP = 5
}
export declare function Message(message: number): MethodDecorator;
interface ICancellable extends IDisposable {
	/**
	 * Returns true if cancelled.
	 * Returns false if already run or already cancelled or unable to cancel.
	 */
	cancel(): boolean;
}
export declare function defer(task: Closure, delay?: number): ICancellable;
export declare function defer<T>(task: Func<T>, delay?: number, payload?: T): ICancellable;
export declare function interval(task: Function, interval: number, count?: number): ICancellable;
declare class PromiseState<T> extends DisposableBase {
	protected _state: TSDNPromise.State;
	protected _result?: T | undefined;
	protected _error?: any;
	constructor(_state: TSDNPromise.State, _result?: T | undefined, _error?: any);
	protected _onDispose(): void;
	protected getState(): TSDNPromise.State;
	get state(): TSDNPromise.State;
	get isPending(): boolean;
	get isSettled(): boolean;
	get isFulfilled(): boolean;
	get isRejected(): boolean;
	protected getResult(): T | undefined;
	get result(): T | undefined;
	protected getError(): any;
	get error(): any;
}
declare abstract class PromiseBase<T> extends PromiseState<T> implements PromiseLike<T>, Promise<T> {
	readonly [Symbol.toStringTag]: "Promise";
	constructor();
	/**
	 * .doneNow is provided as a non-standard means that synchronously resolves as the end of a promise chain.
	 * As stated by promisejs.org: 'then' is to 'done' as 'map' is to 'forEach'.
	 * It is the underlying method by which propagation occurs.
	 * @param onFulfilled
	 * @param onRejected
	 */
	abstract doneNow(onFulfilled: TSDNPromise.Fulfill<T, any> | undefined | null, onRejected?: TSDNPromise.Reject<any> | undefined | null): void;
	abstract doneNow(onFulfilled: (v?: T) => any | undefined | null, onRejected?: (v?: any) => any | undefined | null): void;
	/**
	 * Calls the respective handlers once the promise is resolved.
	 * @param onFulfilled
	 * @param onRejected
	 */
	abstract thenSynchronous<TFulfilled = T, TRejected = never>(onFulfilled: TSDNPromise.Fulfill<T, TFulfilled> | undefined | null, onRejected?: TSDNPromise.Reject<TRejected> | undefined | null): PromiseBase<TFulfilled | TRejected>;
	/**
	 * Same as 'thenSynchronous' but does not return the result.  Returns the current promise instead.
	 * You may not need an additional promise result, and this will not create a new one.
	 * @param onFulfilled
	 * @param onRejected
	 */
	thenThis(onFulfilled: TSDNPromise.Fulfill<T, any> | undefined | null, onRejected?: TSDNPromise.Reject<any> | undefined | null): this;
	/**
	 * Standard .then method that defers execution until resolved.
	 * @param onFulfilled
	 * @param onRejected
	 * @returns {TSDNPromise}
	 */
	then<TFulfilled = T, TRejected = never>(onFulfilled: TSDNPromise.Fulfill<T, TFulfilled> | undefined | null, onRejected?: TSDNPromise.Reject<TRejected> | undefined | null): any;
	/**
	 * Same as .then but doesn't trap errors.  Exceptions may end up being fatal.
	 * @param onFulfilled
	 * @param onRejected
	 * @returns {TSDNPromise}
	 */
	thenAllowFatal<TFulfilled = T, TRejected = never>(onFulfilled: TSDNPromise.Fulfill<T, TFulfilled> | undefined | null, onRejected?: TSDNPromise.Reject<TRejected> | undefined | null): PromiseBase<TFulfilled | TRejected>;
	/**
	 * .done is provided as a non-standard means that maps to similar functionality in other promise libraries.
	 * As stated by promisejs.org: 'then' is to 'done' as 'map' is to 'forEach'.
	 * @param onFulfilled
	 * @param onRejected
	 */
	done(onFulfilled: TSDNPromise.Fulfill<T, any>, onRejected?: TSDNPromise.Reject<any>): void;
	/**
	 * Will yield for a number of milliseconds from the time called before continuing.
	 * @param milliseconds
	 * @returns A promise that yields to the current execution and executes after a delay.
	 */
	delayFromNow(milliseconds?: number): PromiseBase<T>;
	/**
	 * Will yield for a number of milliseconds from after this promise resolves.
	 * If the promise is already resolved, the delay will start from now.
	 * @param milliseconds
	 * @returns A promise that yields to the current execution and executes after a delay.
	 */
	delayAfterResolve(milliseconds?: number): PromiseBase<T>;
	/**
	 * Shortcut for trapping a rejection.
	 * @param onRejected
	 * @returns {PromiseBase<TResult>}
	 */
	"catch"<TResult = never>(onRejected: TSDNPromise.Reject<TResult>): any;
	/**
	 * Shortcut for trapping a rejection but will allow exceptions to propagate within the onRejected handler.
	 * @param onRejected
	 * @returns {PromiseBase<TResult>}
	 */
	catchAllowFatal<TResult = never>(onRejected: TSDNPromise.Reject<TResult>): PromiseBase<T | TResult>;
	/**
	 * Shortcut to for handling either resolve or reject.
	 * @param fin
	 * @returns {PromiseBase<TResult>}
	 */
	"finally"<TResult = never>(fin: () => TSDNPromise.Resolution<TResult>): any;
	/**
	 * Shortcut to for handling either resolve or reject but will allow exceptions to propagate within the handler.
	 * @param fin
	 * @returns {PromiseBase<TResult>}
	 */
	finallyAllowFatal<TResult = never>(fin: () => TSDNPromise.Resolution<TResult>): PromiseBase<TResult>;
	/**
	 * Shortcut to for handling either resolve or reject.  Returns the current promise instead.
	 * You may not need an additional promise result, and this will not create a new one.
	 * @param fin
	 * @param synchronous
	 * @returns {PromiseBase}
	 */
	finallyThis(fin: Closure, synchronous?: boolean): this;
}
declare abstract class Resolvable<T> extends PromiseBase<T> {
	doneNow(onFulfilled: (v?: T) => any, onRejected?: (v?: any) => any): void;
	thenSynchronous<TFulfilled = T, TRejected = never>(onFulfilled: TSDNPromise.Fulfill<T, TFulfilled> | undefined | null, onRejected?: TSDNPromise.Reject<TRejected> | undefined | null): PromiseBase<TFulfilled | TRejected>;
}
declare class TSDNPromise<T> extends Resolvable<T> {
	private _waiting;
	constructor(resolver?: TSDNPromise.Executor<T>, forceSynchronous?: boolean);
	thenSynchronous<TFulfilled = T, TRejected = never>(onFulfilled: TSDNPromise.Fulfill<T, TFulfilled> | undefined | null, onRejected?: TSDNPromise.Reject<TRejected> | undefined | null): PromiseBase<TFulfilled | TRejected>;
	doneNow(onFulfilled: (v?: T) => any, onRejected?: (v?: any) => any): void;
	protected _onDispose(): void;
	protected _resolvedCalled: boolean;
	resolveUsing(resolver: TSDNPromise.Executor<T>, forceSynchronous?: boolean): void;
	private _emitDisposalRejection;
	private _resolveInternal;
	private _rejectInternal;
	resolve(result?: T | PromiseLike<T>, throwIfSettled?: boolean): void;
	reject(error: any, throwIfSettled?: boolean): void;
}
declare class ArrayPromise<T> extends TSDNPromise<T[]> {
	/**
	 * Simplifies the use of a map function on an array of results when the source is assured to be an array.
	 * @param transform
	 * @returns {PromiseBase<Array<any>>}
	 */
	map<U>(transform: (value: T) => U): ArrayPromise<U>;
	reduce(reduction: (previousValue: T, currentValue: T, i?: number, array?: T[]) => T, initialValue?: T): PromiseBase<T>;
	reduce<U>(reduction: (previousValue: U, currentValue: T, i?: number, array?: T[]) => U, initialValue: U): PromiseBase<U>;
	static fulfilled<T>(value: T[]): ArrayPromise<T>;
}
declare class PromiseCollection<T> extends DisposableBase {
	private _source;
	constructor(source: PromiseLike<T>[] | null | undefined);
	protected _onDispose(): void;
	/**
	 * Returns a copy of the source promises.
	 * @returns {PromiseLike<PromiseLike<any>>[]}
	 */
	get promises(): PromiseLike<T>[];
	/**
	 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
	 * @returns {PromiseBase<any>}
	 */
	all(): ArrayPromise<T>;
	/**
	 * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
	 * or rejected.
	 * @returns {PromiseBase<any>} A new Promise.
	 */
	race(): PromiseBase<T>;
	/**
	 * Returns a promise that is fulfilled with array of provided promises when all provided promises have resolved (fulfill or reject).
	 * Unlike .all this method waits for all rejections as well as fulfillment.
	 * @returns {PromiseBase<PromiseLike<any>[]>}
	 */
	waitAll(): ArrayPromise<PromiseLike<T>>;
	/**
	 * Waits for all the values to resolve and then applies a transform.
	 * @param transform
	 * @returns {PromiseBase<Array<any>>}
	 */
	map<U>(transform: (value: T) => U): ArrayPromise<U>;
	/**
	 * Applies a transform to each promise and defers the result.
	 * Unlike map, this doesn't wait for all promises to resolve, ultimately improving the async nature of the request.
	 * @param transform
	 * @returns {PromiseCollection<U>}
	 */
	pipe<U>(transform: (value: T) => U | PromiseLike<U>): PromiseCollection<U>;
	reduce(reduction: (previousValue: T, currentValue: T, i?: number, array?: PromiseLike<T>[]) => T, initialValue?: T | PromiseLike<T>): PromiseBase<T>;
	reduce<U>(reduction: (previousValue: U, currentValue: T, i?: number, array?: PromiseLike<T>[]) => U, initialValue: U | PromiseLike<U>): PromiseBase<U>;
}
declare namespace TSDNPromise {
	/**
	 * The state of a promise.
	 * https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md
	 * If a promise is disposed the value will be undefined which will also evaluate (promise.state)==false.
	 */
	enum State {
		Pending = 0,
		Fulfilled = 1,
		Rejected = -1
	}
	type Resolution<TResult> = TResult | PromiseLike<TResult>;
	interface Fulfill<T, TResult> {
		(value: T): Resolution<TResult>;
	}
	interface Reject<TResult> {
		(reason: any): TResult | PromiseLike<TResult>;
	}
	interface Then<T, TResult> {
		(onfulfilled?: Fulfill<T, TResult> | undefined | null, onrejected?: Reject<TResult> | undefined | null): PromiseLike<TResult>;
		(onfulfilled?: Fulfill<T, TResult> | undefined | null, onrejected?: Reject<void> | undefined | null): PromiseLike<TResult>;
	}
	interface Executor<T> {
		(resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void): void;
	}
	interface Factory {
		<T>(executor: Executor<T>): PromiseLike<T>;
	}
	function factory<T>(e: Executor<T>): TSDNPromise<T>;
	/**
	 * Takes a set of promises and returns a PromiseCollection.
	 * @param promises
	 */
	function group<T>(promises: PromiseLike<T>[]): PromiseCollection<T>;
	function group<T>(promise: PromiseLike<T>, ...rest: PromiseLike<T>[]): PromiseCollection<T>;
	/**
	 * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
	 */
	function all<T>(promises: PromiseLike<T>[]): ArrayPromise<T>;
	function all<T>(promise: PromiseLike<T>, ...rest: PromiseLike<T>[]): ArrayPromise<T>;
	/**
	 * Returns a promise that is fulfilled with array of provided promises when all provided promises have resolved (fulfill or reject).
	 * Unlike .all this method waits for all rejections as well as fulfillment.
	 */
	function waitAll<T>(promises: PromiseLike<T>[]): ArrayPromise<PromiseLike<T>>;
	function waitAll<T>(promise: PromiseLike<T>, ...rest: PromiseLike<T>[]): ArrayPromise<PromiseLike<T>>;
	/**
	 * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved
	 * or rejected.
	 * @param promises An array of Promises.
	 * @returns A new Promise.
	 */
	function race<T>(promises: PromiseLike<T>[]): PromiseBase<T>;
	function race<T>(promise: PromiseLike<T>, ...rest: PromiseLike<T>[]): PromiseBase<T>;
	/**
	 * Creates a new resolved promise .
	 * @returns A resolved promise.
	 */
	function resolve(): PromiseBase<void>;
	/**
	 * Creates a new resolved promise for the provided value.
	 * @param value A value or promise.
	 * @returns A promise whose internal state matches the provided promise.
	 */
	function resolve<T>(value: T | PromiseLike<T>): PromiseBase<T>;
	/**
	 * Syntactic shortcut for avoiding 'new'.
	 * @param resolver
	 * @param forceSynchronous
	 * @returns {TSDNPromise}
	 */
	function using<T>(resolver: TSDNPromise.Executor<T>, forceSynchronous?: boolean): PromiseBase<T>;
	/**
	 * Takes a set of values or promises and returns a PromiseCollection.
	 * Similar to 'group' but calls resolve on each entry.
	 * @param resolutions
	 */
	function resolveAll<T>(resolutions: Array<T | PromiseLike<T>>): PromiseCollection<T>;
	function resolveAll<T>(promise: T | PromiseLike<T>, ...rest: Array<T | PromiseLike<T>>): PromiseCollection<T>;
	/**
	 * Creates a PromiseCollection containing promises that will resolve on the next tick using the transform function.
	 * This utility function does not chain promises together to create the result,
	 * it only uses one promise per transform.
	 * @param source
	 * @param transform
	 * @returns {PromiseCollection<T>}
	 */
	function map<T, U>(source: T[], transform: (value: T) => U): PromiseCollection<U>;
	/**
	 * Creates a new rejected promise for the provided reason.
	 * @param reason The reason the promise was rejected.
	 * @returns A new rejected Promise.
	 */
	function reject<T>(reason: T): PromiseBase<T>;
	/**
	 * Takes any Promise-Like object and ensures an extended version of it from this module.
	 * @param target The Promise-Like object
	 * @returns A new target that simply extends the target.
	 */
	function wrap<T>(target: T | PromiseLike<T>): PromiseBase<T>;
	/**
	 * A function that acts like a 'then' method (aka then-able) can be extended by providing a function that takes an onFulfill and onReject.
	 * @param then
	 * @returns {PromiseWrapper<T>}
	 */
	function createFrom<T>(then: Then<T, any>): PromiseBase<T>;
}
declare interface WorkerLike {
	onmessage: (message: {
		data: any;
	}) => void;
	onerror: (error: any) => void;
	postMessage(obj: any): void;
	terminate(): void;
}
export interface ParallelOptions {
	/**
	 * This is the path to the file eval.js.  This is required when running in node, and required for some browsers (IE 10) in order to work around cross-domain restrictions for web workers.  Defaults to the same location as parallel.js in node environments, and null in the browser.
	 **/
	evalPath?: string;
	/**
	 * The maximum number of permitted worker threads.  This will default to 4, or the number of CPUs on your computer if you're running node.
	 **/
	maxConcurrency?: number;
	/**
	 * If WebWorkers are not available, whether or not to fall back to synchronous processing using setTimeout.  Defaults to true.
	 **/
	allowSynchronous?: boolean;
	env?: any;
	envNamespace?: string;
}
export declare type RequireType = string | Function | {
	name?: string;
	fn: Function;
};
export declare class Parallel {
	options: ParallelOptions;
	_requiredScripts: string[];
	_requiredFunctions: {
		name?: string;
		fn: Function;
	}[];
	constructor(options?: ParallelOptions);
	static maxConcurrency(max: number): Parallel;
	protected _getWorkerSource(task: Function | string, env?: any): string;
	require(...required: RequireType[]): this;
	requireThese(required: RequireType[]): this;
	protected _spawnWorker(task: Function | string, env?: any): WorkerLike | undefined;
	/**
	 * Schedules the task to be run in the worker pool.
	 * @param data
	 * @param task
	 * @param env
	 * @returns {TSDNPromise<U>|TSDNPromise}
	 */
	startNew<T, U>(data: T, task: (data: T) => U, env?: any): TSDNPromise<U>;
	/**
	 * Runs the task within the local thread/process.
	 * Is good for use with testing.
	 * @param data
	 * @param task
	 * @returns {TSDNPromise<U>|TSDNPromise}
	 */
	startLocal<T, U>(data: T, task: (data: T) => U): TSDNPromise<U>;
	/**
	 * Returns an array of promises that each resolve after their task completes.
	 * Provides a potential performance benefit by not waiting for all promises to resolve before proceeding to next step.
	 * @param data
	 * @param task
	 * @param env
	 * @returns {PromiseCollection}
	 */
	pipe<T, U>(data: T[], task: (data: T) => U, env?: any): PromiseCollection<U>;
	private ensureClampedMaxConcurrency;
	/**
	 * Waits for all tasks to resolve and returns a promise with the results.
	 * @param data
	 * @param task
	 * @param env
	 * @returns {ArrayPromise}
	 */
	map<T, U>(data: T[], task: (data: T) => U, env?: any): ArrayPromise<U>;
	static get isSupported(): boolean;
	static options(options?: ParallelOptions): Parallel;
	static require(...required: RequireType[]): Parallel;
	static requireThese(required: RequireType[]): Parallel;
	static startNew<T, U>(data: T, task: (data: T) => U, env?: any): PromiseBase<U>;
	static map<T, U>(data: T[], task: (data: T) => U, env?: any): ArrayPromise<U>;
}
interface ITimer {
	isRunning: boolean;
	start(): void;
	stop(): void;
	reset(): void;
}
export declare class Stopwatch implements ITimer {
	static getTimestampMilliseconds(): number;
	private _elapsed;
	private _startTimeStamp;
	private _isRunning;
	get isRunning(): boolean;
	constructor();
	static startNew(): Stopwatch;
	static measure(closure: () => void): TimeSpan;
	start(): void;
	stop(): void;
	reset(): void;
	lap(): TimeSpan;
	get currentLapMilliseconds(): number;
	get currentLap(): TimeSpan;
	get elapsedMilliseconds(): number;
	get elapsed(): TimeSpan;
}
export declare class SynchronizationContext {
	static Current: SynchronizationContext;
	static SetSynchronizationContext(context: SynchronizationContext): void;
	CreateCopy(): SynchronizationContext;
}
export declare const ThreadingModule: {
	Thread: (string | typeof Thread)[];
};
export declare function LONG(target: any, name: string): any;
export declare function GUID(target: any, name: string): any;
export declare function STRING(lenght: number): Function;
export declare function FLOAT(target: any, name: string): any;
export declare function STRUCT(structType: any): Function;
declare abstract class DecoderFallbackBuffer {
	protected constructor();
	protected abstract Get_Remaining(): int;
	get Remaining(): int;
	abstract Fallback(bytesUnknown: ByteArray, index: int): boolean;
	abstract GetNextChar(): char;
	abstract MovePrevious(): boolean;
	Reset(): void;
}
declare abstract class DecoderFallback extends TObject {
	private static readonly exception_fallback;
	private static readonly replacement_fallback;
	private static readonly standard_safe_fallback;
	protected constructor();
	static get ExceptionFallback(): DecoderFallback;
	protected abstract Get_MaxCharCount(): int;
	get MaxCharCount(): number;
	static get ReplacementFallback(): DecoderFallback;
	static get StandardSafeFallback(): DecoderFallback;
	abstract CreateFallbackBuffer(): DecoderFallbackBuffer;
}
declare abstract class Decoder {
	protected constructor();
	private fallback;
	private fallback_buffer;
	get Fallback(): DecoderFallback;
	set Fallback(value: DecoderFallback);
	get FallbackBuffer(): DecoderFallbackBuffer;
	GetCharCount(bytes: ByteArray, index: int, count: int): int;
	GetCharCount(bytes: ByteArray, index: int, count: int, flush: boolean): int;
	GetCharCount(bytes: ByteArray, count: int, flush: boolean): int;
	GetChars(bytes: ByteArray, byteIndex: int, byteCount: int, chars: CharArray, charIndex: int): int;
	GetChars(bytes: ByteArray, byteIndex: int, byteCount: int, chars: CharArray, charIndex: int, flush: boolean): int;
	GetChars(bytes: ByteArray, byteCount: int, chars: CharArray, charCount: int, flush: boolean): int;
	Reset(): void;
	Convert(bytes: ByteArray, byteCount: int, chars: CharArray, charCount: int, flush: boolean, bytesUsed: Out<int>, charsUsed: Out<int>, completed: Out<boolean>): void;
	Convert(bytes: ByteArray, byteIndex: int, byteCount: int, chars: CharArray, charIndex: int, charCount: int, flush: boolean, bytesUsed: Out<int>, charsUsed: Out<int>, completed: Out<boolean>): void;
	private CheckArguments;
}
declare abstract class EncoderFallbackBuffer {
	protected constructor();
	protected abstract Get_Remaining(): int;
	get Remaining(): int;
	abstract Fallback(charUnknown: char, index: int): boolean;
	abstract Fallback(charUnknownHigh: char, charUnknownLow: char, index: int): boolean;
	abstract GetNextChar(): char;
	abstract MovePrevious(): boolean;
	Reset(): void;
}
declare abstract class EncoderFallback extends TObject {
	private static readonly exception_fallback;
	private static readonly replacement_fallback;
	private static readonly standard_safe_fallback;
	protected constructor();
	static get ExceptionFallback(): EncoderFallback;
	protected abstract Get_MaxCharCount(): int;
	get MaxCharCount(): int;
	static get ReplacementFallback(): EncoderFallback;
	static get StandardSafeFallback(): EncoderFallback;
	abstract CreateFallbackBuffer(): EncoderFallbackBuffer;
}
declare abstract class Encoder {
	protected constructor();
	private fallback;
	private fallback_buffer;
	get Fallback(): EncoderFallback;
	set Fallback(value: EncoderFallback);
	get FallbackBuffer(): EncoderFallbackBuffer;
	GetByteCount(chars: CharArray, index: int, count: int, flush: boolean): int;
	GetByteCount(chars: CharArray, count: int, flush: boolean): int;
	GetBytes(chars: CharArray, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int, flush: boolean): int;
	GetBytes(chars: CharArray, charCount: int, bytes: ByteArray, byteCount: int, flush: boolean): int;
	Reset(): void;
	Convert(chars: CharArray, charCount: int, bytes: ByteArray, byteCount: int, flush: boolean, charsUsed: Out<int>, bytesUsed: Out<int>, completed: Out<boolean>): void;
	Convert(chars: CharArray, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int, byteCount: int, flush: boolean, charsUsed: Out<int>, bytesUsed: Out<int>, completed: Out<boolean>): void;
	private CheckArguments;
}
declare class EncodingInfo extends TObject {
	protected dispose(disposing: boolean): void;
	private readonly codepage;
	private encoding;
	constructor(cp: int);
	get CodePage(): int;
	get DisplayName(): string;
	get Name(): string;
	Equals<EncodingInfo>(value: EncodingInfo): boolean;
	GetHashCode(): int;
	GetEncoding(): Encoding;
}
declare enum NormalizationForm {
	FormC = 1,
	FormD = 2,
	FormKC = 5,
	FormKD = 6
}
export declare abstract class Encoding extends TObject implements ICloneable<Encoding> {
	private static readonly UTF32_CODE_PAGE;
	private static readonly BIG_UTF32_CODE_PAGE;
	protected static readonly UTF8_CODE_PAGE: int;
	protected static readonly UNICODE_CODE_PAGE: int;
	private static readonly BIG_UNICODE_CODE_PAGE;
	private static readonly ISOLATIN_CODE_PAGE;
	private static readonly UTF7_CODE_PAGE;
	private static readonly ASCII_CODE_PAGE;
	codePage: int;
	windows_code_page: int;
	private is_readonly;
	protected constructor();
	protected constructor(codePage: int);
	static _(arg: string): string;
	private decoder_fallback;
	private encoder_fallback;
	get IsReadOnly(): boolean;
	protected Get_IsSingleByte(): boolean;
	get IsSingleByte(): boolean;
	get DecoderFallback(): DecoderFallback;
	set DecoderFallback(value: DecoderFallback);
	get EncoderFallback(): EncoderFallback;
	set EncoderFallback(value: EncoderFallback);
	SetFallbackInternal(e: EncoderFallback, d: DecoderFallback): void;
	static Convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: ByteArray): ByteArray;
	static Convert(srcEncoding: Encoding, dstEncoding: Encoding, bytes: ByteArray, index: int, count: int): ByteArray;
	Equals<Encoding>(value: Encoding): boolean;
	GetByteCount(chars: CharArray, index: int, count: int): int;
	GetByteCount(s: string): int;
	GetByteCount(chars: CharArray): int;
	GetByteCount(chars: CharArray, count: int): int;
	GetBytes(chars: CharArray, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int): int;
	GetBytes(s: string, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int): int;
	GetBytes(s: string): ByteArray;
	GetBytes(chars: CharArray, index: int, count: int): ByteArray;
	GetBytes(chars: CharArray): ByteArray;
	GetBytes(chars: CharArray, charCount: int, bytes: ByteArray, byteCount: int): int;
	GetCharCount(bytes: ByteArray, index: int, count: int): int;
	GetCharCount(bytes: ByteArray): int;
	GetCharCount(bytes: ByteArray, count: int): int;
	GetChars(bytes: ByteArray, byteIndex: int, byteCount: int, chars: CharArray, charIndex: int): int;
	GetChars(bytes: ByteArray, index: int, count: int): CharArray;
	GetChars(bytes: ByteArray, byteCount: int, chars: CharArray, charCount: int): int;
	GetChars(bytes: ByteArray): CharArray;
	GetDecoder(): Decoder;
	GetEncoder(): Encoder;
	private static i18nAssembly;
	private static i18nDisabled;
	private static InvokeI18N;
	static GetEncoding(codepage: int): Encoding;
	static GetEncoding(name: string): Encoding;
	static GetEncoding(codepage: int, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
	static GetEncoding(name: string, encoderFallback: EncoderFallback, decoderFallback: DecoderFallback): Encoding;
	Clone(): Encoding;
	private static encoding_infos;
	static GetEncodings(): EncodingInfo[];
	IsAlwaysNormalized(): boolean;
	IsAlwaysNormalized(form: NormalizationForm): boolean;
	GetHashCode(): int;
	abstract GetMaxByteCount(charCount: int): int;
	abstract GetMaxCharCount(byteCount: int): int;
	GetPreamble(): ByteArray;
	GetString(bytes: ByteArray, index: int, count: int): string;
	GetString(bytes: ByteArray): string;
	is_mail_news_display: boolean;
	is_mail_news_save: boolean;
	is_browser_save: boolean;
	is_browser_display: boolean;
	body_name: string;
	encoding_name: string;
	header_name: string;
	web_name: string;
	protected Get_BodyName(): string;
	get BodyName(): string;
	protected Get_CodePage(): int;
	get CodePage(): int;
	protected Get_EncodingName(): string;
	get EncodingName(): string;
	protected Get_HeaderName(): string;
	get HeaderName(): string;
	protected Get_IsBrowserDisplay(): boolean;
	get IsBrowserDisplay(): boolean;
	protected Get_IsBrowserSave(): boolean;
	get IsBrowserSave(): boolean;
	protected Get_IsMailNewsDisplay(): boolean;
	get IsMailNewsDisplay(): boolean;
	protected Get_IsMailNewsSave(): boolean;
	get IsMailNewsSave(): boolean;
	protected Get_WebName(): string;
	get WebName(): string;
	protected Get_WindowsCodePage(): int;
	get WindowsCodePage(): int;
	private static asciiEncoding;
	private static bigEndianEncoding;
	private static defaultEncoding;
	private static utf7Encoding;
	private static utf8EncodingWithMarkers;
	private static utf8EncodingWithoutMarkers;
	private static unicodeEncoding;
	private static isoLatin1Encoding;
	private static utf8EncodingUnsafe;
	private static utf32Encoding;
	private static bigEndianUTF32Encoding;
	static get ASCII(): Encoding;
	static get BigEndianUnicode(): Encoding;
	static InternalCodePage(code_page: Out<int>): string;
	static get Default(): Encoding;
	private static get ISOLatin1();
	static get UTF7(): Encoding;
	static get UTF8(): Encoding;
	static get UTF8Unmarked(): Encoding;
	static get UTF8UnmarkedUnsafe(): Encoding;
	static get Unicode(): Encoding;
	static get UTF32(): Encoding;
	static get BigEndianUTF32(): Encoding;
}
declare enum AccessControlSections {
	None = 0,
	Audit = 1,
	Access = 2,
	Owner = 4,
	Group = 8,
	All = 15
}
export declare enum FileAccess {
	Read = 1,
	Write = 2,
	ReadWrite = 3
}
export declare enum FileAttributes {
	ReadOnly = 1,
	Hidden = 2,
	System = 4,
	Directory = 16,
	Archive = 32,
	Device = 64,
	Normal = 128,
	Temporary = 256,
	SparseFile = 512,
	ReparsePoint = 1024,
	Compressed = 2048,
	Offline = 4096,
	NotContentIndexed = 8192,
	Encrypted = 16384
}
export declare enum FileMode {
	CreateNew = 1,
	Create = 2,
	Open = 3,
	OpenOrCreate = 4,
	Truncate = 5,
	Append = 6
}
declare enum FileOptions {
	None = 0,
	Encrypted = 16384,
	DeleteOnClose = 67108864,
	SequentialScan = 134217728,
	RandomAccess = 268435456,
	Asynchronous = 1073741824,
	WriteThrough = -2147483648
}
declare class FileSecurity {
	constructor(handle: SafeFileHandle, includeSections: AccessControlSections);
	constructor(path: string, includeSections: AccessControlSections);
	PersistModifications(path: string): void;
}
declare enum FileShare {
	None = 0,
	Read = 1,
	Write = 2,
	ReadWrite = 3,
	Delete = 4,
	Inheritable = 16
}
declare enum FileSystemRights {
	ListDirectory = 1,
	ReadData = 1,
	CreateFiles = 2,
	WriteData = 2,
	AppendData = 4,
	CreateDirectories = 4,
	ReadExtendedAttributes = 8,
	WriteExtendedAttributes = 16,
	ExecuteFile = 32,
	Traverse = 32,
	DeleteSubdirectoriesAndFiles = 64,
	ReadAttributes = 128,
	WriteAttributes = 256,
	Write = 278,
	Delete = 65536,
	ReadPermissions = 131072,
	Read = 131209,
	ReadAndExecute = 131241,
	Modify = 197055,
	ChangePermissions = 262144,
	TakeOwnership = 524288,
	Synchronize = 1048576,
	FullControl = 2032127
}
export declare class FileStream extends Stream {
	static readonly DefaultBufferSize: int;
	private static buf_recycle;
	private buf;
	private name;
	private safeHandle;
	private append_startpos;
	private handle;
	private access;
	private owner;
	private async;
	private canseek;
	private anonymous;
	private buf_dirty;
	private buf_size;
	private buf_length;
	private buf_offset;
	private buf_start;
	constructor(path: string, mode: FileMode);
	constructor(path: string, mode: FileMode, access: FileAccess);
	constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare);
	constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int);
	constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, useAsync: boolean);
	constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, options: FileOptions);
	constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, isAsync: boolean, anonymous: boolean);
	constructor(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, anonymous: boolean, options: FileOptions);
	constructor1(path: string, mode: FileMode): void;
	constructor2(path: string, mode: FileMode, access: FileAccess): void;
	constructor3(path: string, mode: FileMode, access: FileAccess, share: FileShare): void;
	constructor4(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int): void;
	constructor5(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, useAsync: boolean): void;
	constructor6(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, options: FileOptions): void;
	constructor10(path: string, mode: FileMode, rights: FileSystemRights, share: FileShare, bufferSize: int, options: FileOptions): void;
	constructor11(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, isAsync: boolean, anonymous: boolean): void;
	constructor12(path: string, mode: FileMode, access: FileAccess, share: FileShare, bufferSize: int, anonymous: boolean, options: FileOptions): void;
	protected Get_CanRead(): boolean;
	protected Get_CanWrite(): boolean;
	protected Get_CanSeek(): boolean;
	protected get IsAsync(): boolean;
	get Name(): string;
	protected Get_Length(): int;
	Get_Position(): int;
	Set_Position(value: int): void;
	protected Get_Handle(): IntPtr;
	get Handle(): IntPtr;
	protected Get_SafeFileHandle(): SafeFileHandle;
	get SafeFileHandle(): SafeFileHandle;
	private ExposeHandle;
	ReadByte(): int;
	WriteByte(value: byte): void;
	Read(array: ByteArray, offset: int, count: int): int;
	private ReadInternal;
	Write(array: ByteArray, offset: int, count: int): void;
	private WriteInternal;
	Seek(offset: int, origin: SeekOrigin): int;
	SetLength(value: int): void;
	Flush(): void;
	Flush(flushToDisk: boolean): void;
	Lock(position: int, length: int): void;
	Unlock(position: int, length: int): void;
	protected dispose(disposing: boolean): void;
	GetAccessControl(): FileSecurity;
	SetAccessControl(fileSecurity: FileSecurity): void;
	private ReadSegment;
	private WriteSegment;
	private FlushBuffer;
	private FlushBufferIfDirty;
	private RefillBuffer;
	private ReadData;
	private InitBuffer;
	private GetSecureFileName;
}
export declare abstract class TextReader extends TObject {
	static readonly Null: TextReader;
	static StaticConstructor(): void;
	protected constructor();
	Close(): void;
	protected dispose(disposing?: boolean): void;
	Peek(): int;
	Read(): int;
	Read(buffer: CharArray, index: int, count: int): int;
	ReadBlock(buffer: CharArray, index: int, count: int): int;
	ReadLine(): string;
	ReadToEnd(): string;
}
export declare class StreamReader extends TextReader {
	private static readonly DefaultBufferSize;
	private static readonly DefaultFileBufferSize;
	private static readonly MinimumBufferSize;
	private input_buffer;
	private static input_buffer_recycle;
	private decoded_buffer;
	static decoded_buffer_recycle: CharArray;
	private encoding;
	private decoder;
	private line_builder;
	private base_stream;
	private decoded_count;
	private pos;
	private buffer_size;
	private do_checks;
	private mayBlock;
	static readonly Null: StreamReader;
	private static _StaticConstructor;
	constructor();
	constructor(stream: Stream);
	constructor(stream: Stream, detectEncodingFromByteOrderMarks: boolean);
	constructor(stream: Stream, encoding: Encoding);
	constructor(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean);
	constructor(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int);
	constructor(path: string);
	constructor(path: string, detectEncodingFromByteOrderMarks: boolean);
	constructor(path: string, encoding: Encoding);
	constructor(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean);
	constructor(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int);
	private constructor1;
	constructor2(stream: Stream): void;
	constructor3(stream: Stream, detectEncodingFromByteOrderMarks: boolean): void;
	constructor4(stream: Stream, encoding: Encoding): void;
	constructor5(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean): void;
	private static readonly leave_open;
	constructor6(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int): void;
	constructor7(path: string): void;
	constructor8(path: string, detectEncodingFromByteOrderMarks: boolean): void;
	constructor9(path: string, encoding: Encoding): void;
	constructor10(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean): void;
	constructor11(path: string, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int): void;
	Initialize(stream: Stream, encoding: Encoding, detectEncodingFromByteOrderMarks: boolean, bufferSize: int): void;
	protected Get_BaseStream(): Stream;
	get BaseStream(): Stream;
	protected Get_CurrentEncoding(): Encoding;
	get CurrentEncoding(): Encoding;
	get EndOfStream(): boolean;
	Close(): void;
	protected dispose(disposing: boolean): void;
	private DoChecks;
	DiscardBufferedData(): void;
	private ReadBuffer;
	private ReadBufferCore;
	Peek(): int;
	DataAvailable(): boolean;
	Read(): int;
	Read(buffer: CharArray, index: int, count: int): int;
	private foundCR;
	private FindNextEOL;
	ReadLine(): string;
	ReadToEnd(): string;
	private CheckState;
}
export declare abstract class TextWriter extends TObject {
	private static readonly InitialNewLine;
	protected CoreNewLine: CharArray;
	private InternalFormatProvider;
	private static _Null;
	static get Null(): TextWriter;
	protected abstract Get_Encoding(): Encoding;
	get Encoding(): Encoding;
	protected Get_FormatProvider(): IFormatProvider;
	get FormatProvider(): IFormatProvider;
	protected Get_NewLine(): string;
	protected Set_NewLine(value: string): void;
	get NewLine(): string;
	set NewLine(value: string);
	protected constructor(formatProvider?: IFormatProvider);
	Close(): void;
	Flush(): void;
	WriteChar(value: char): void;
	WriteCharArray(buffer: CharArray): void;
	WriteCharArray(buffer: CharArray, index: int, count: int): void;
	WriteBoolean(value: boolean): void;
	WriteInt(value: int): void;
	WriteUInt(value: uint): void;
	WriteLong(value: long): void;
	WriteULong(value: ulong): void;
	WriteFloat(value: float): void;
	WriteDouble(value: double): void;
	WriteDecimal(value: decimal): void;
	Write(value: string): void;
	WriteAny(value: any): void;
	WriteLine(): void;
	WriteLineChar(value: char): void;
	WriteLineCharArray(buffer: CharArray): void;
	WriteLineCharArray(buffer: CharArray, index: int, count: int): void;
	WriteLineBoolean(value: boolean): void;
	WriteLineInt(value: int): void;
	WriteLineUInt(value: uint): void;
	WriteLineLong(value: long): void;
	WriteLineULong(value: ulong): void;
	WriteLineFloat(value: float): void;
	WriteLineDouble(value: double): void;
	WriteLineDecimal(value: decimal): void;
	WriteLineString(value: string, ...args: any[]): void;
	WriteLineAny(value: any): void;
}
export declare class StreamWriter extends TextWriter {
	private static readonly DefaultBufferSize;
	private static readonly DefaultFileStreamBufferSize;
	private static readonly MinBufferSize;
	stream: Stream;
	private encoding;
	private encoder;
	byteBuffer: ByteArray;
	charBuffer: CharArray;
	charPos: int;
	charLen: int;
	autoFlush: boolean;
	private haveWrittenPreamble;
	private closable;
	protected Get_AutoFlush(): boolean;
	get AutoFlush(): boolean;
	protected Set_AutoFlush(value: boolean): void;
	set AutoFlush(value: boolean);
	protected Get_BaseStream(): Stream;
	get BaseStream(): Stream;
	get Closable(): boolean;
	set Closable(value: boolean);
	Get_Encoding(): Encoding;
	private static __Null;
	static get Null(): StreamWriter;
	constructor();
	constructor(stream: Stream);
	constructor(stream: Stream, encoding: Encoding);
	constructor(stream: Stream, encoding: Encoding, bufferSize: int);
	constructor(path: string);
	constructor(path: string, append: boolean);
	constructor(path: string, append: boolean, encoding: Encoding);
	constructor(path: string, append: boolean, encoding: Encoding, bufferSize: int);
	constructor1(): void;
	constructor2(stream: Stream): void;
	constructor3(stream: Stream, encoding: Encoding): void;
	constructor4(stream: Stream, encoding: Encoding, bufferSize: int): void;
	constructor5(path: string): void;
	constructor6(path: string, append: boolean): void;
	constructor7(path: string, append: boolean, encoding: Encoding): void;
	constructor8(path: string, append: boolean, encoding: Encoding, bufferSize: int): void;
	Close(): void;
	private static CreateFile;
	protected dispose(disposing: boolean): void;
	protected Finalize(): void;
	Flush(): void;
	private FlushInternal;
	private Init;
	WriteChar(value: char): void;
	WriteCharArray(buffer: CharArray): void;
	WriteCharArray(buffer: CharArray, index: int, count: int): void;
	Write(value: string): void;
}
export declare class File {
	static AppendAllText(path: string, contents: string): void;
	static AppendAllText(path: string, contents: string, encoding: Encoding): void;
	static AppendText(path: string): StreamWriter;
	static Copy(sourceFileName: string, destFileName: string): void;
	static Copy(sourceFileName: string, destFileName: string, overwrite: boolean): void;
	static Create(path: string): FileStream;
	static Create(path: string, bufferSize: int): FileStream;
	static Create(path: string, bufferSize: int, options: FileOptions): FileStream;
	static Create(path: string, bufferSize: int, options: FileOptions, fileSecurity: FileSecurity): FileStream;
	static CreateText(path: string): StreamWriter;
	static Delete(path: string): void;
	static Exists(path: string): boolean;
	static GetAccessControl(path: string): FileSecurity;
	static GetAccessControl(path: string, includeSections: AccessControlSections): FileSecurity;
	static GetAttributes(path: string): FileAttributes;
	static GetCreationTime(path: string): DateTime;
	static GetCreationTimeUtc(path: string): DateTime;
	static GetLastAccessTime(path: string): DateTime;
	static GetLastAccessTimeUtc(path: string): DateTime;
	static GetLastWriteTime(path: string): DateTime;
	static GetLastWriteTimeUtc(path: string): DateTime;
	static Move(sourceFileName: string, destFileName: string): void;
	static Open(path: string, mode: FileMode): FileStream;
	static Open(path: string, mode: FileMode, access: FileAccess): FileStream;
	static Open(path: string, mode: FileMode, access: FileAccess, share: FileShare): FileStream;
	static OpenRead(path: string): FileStream;
	static OpenText(path: string): StreamReader;
	static OpenWrite(path: string): FileStream;
	static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string): void;
	static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): void;
	static SetAccessControl(path: string, fileSecurity: FileSecurity): void;
	static SetAttributes(path: string, fileAttributes: FileAttributes): void;
	static SetCreationTime(path: string, creationTime: DateTime): void;
	static SetCreationTimeUtc(path: string, creationTimeUtc: DateTime): void;
	static SetLastAccessTime(path: string, lastAccessTime: DateTime): void;
	static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void;
	static SetLastWriteTime(path: string, lastWriteTime: DateTime): void;
	static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void;
	static ReadAllBytes(path: string): ByteArray;
	static ReadAllLines(path: string): string[];
	static ReadAllLines(path: string, encoding: Encoding): string[];
	private static _ReadAllLines;
	static ReadAllText(path: string): string;
	static ReadAllText(path: string, encoding: Encoding): string;
	static WriteAllBytes(path: string, bytes: ByteArray): void;
	static WriteAllLines(path: string, contents: string[]): void;
	static WriteAllLines(path: string, contents: string[], encoding: Encoding): void;
	private static _WriteAllLines;
	static WriteAllText(path: string, contents: string): void;
	static WriteAllText(path: string, contents: string, encoding: Encoding): void;
	private static defaultLocalFileTime;
	private static get DefaultLocalFileTime();
	static Encrypt(path: string): void;
	static Decrypt(path: string): void;
}
declare enum MonoFileType {
	Unknown = 0,
	Disk = 1,
	Char = 2,
	Pipe = 3,
	Remote = 32768
}
declare enum MonoIOError {
	ERROR_SUCCESS = 0,
	ERROR_FILE_NOT_FOUND = 2,
	ERROR_PATH_NOT_FOUND = 3,
	ERROR_TOO_MANY_OPEN_FILES = 4,
	ERROR_ACCESS_DENIED = 5,
	ERROR_INVALID_HANDLE = 6,
	ERROR_INVALID_DRIVE = 15,
	ERROR_NOT_SAME_DEVICE = 17,
	ERROR_NO_MORE_FILES = 18,
	ERROR_WRITE_FAULT = 29,
	ERROR_READ_FAULT = 30,
	ERROR_GEN_FAILURE = 31,
	ERROR_SHARING_VIOLATION = 32,
	ERROR_LOCK_VIOLATION = 33,
	ERROR_HANDLE_DISK_FULL = 39,
	ERROR_FILE_EXISTS = 80,
	ERROR_CANNOT_MAKE = 82,
	ERROR_INVALID_PARAMETER = 87,
	ERROR_BROKEN_PIPE = 109,
	ERROR_INVALID_NAME = 123,
	ERROR_DIR_NOT_EMPTY = 145,
	ERROR_ALREADY_EXISTS = 183,
	ERROR_FILENAME_EXCED_RANGE = 206,
	ERROR_ENCRYPTION_FAILED = 6000
}
declare class MonoIOStat {
	Attributes: FileAttributes;
	Length: long;
	CreationTime: long;
	LastAccessTime: long;
	LastWriteTime: long;
}
export declare class MonoIO {
	private static fileID;
	private static filesRegistry;
	private static get FilesRegistry();
	static readonly FileAlreadyExistsHResult: int;
	static readonly InvalidFileAttributes: FileAttributes;
	static readonly InvalidHandle: IntPtr;
	static GetFileHandle(): IntPtr;
	static IsUnixPath(path: string): boolean;
	static GetUnixDirectoryString(path: string): string;
	static GetException(error: MonoIOError): Exception;
	static GetException(path: string, error: MonoIOError): Exception;
	static CreateDirectory(path: string, error: Out<MonoIOError>): boolean;
	static RemoveDirectory(path: string, error: Out<MonoIOError>): boolean;
	static GetFileSystemEntries(path: string, path_with_pattern: string, attrs: int, mask: int, error: Out<MonoIOError>): string[];
	private static currentDirectory;
	static GetCurrentDirectory(error: Out<MonoIOError>): string;
	static SetCurrentDirectory(path: string, error: Out<MonoIOError>): boolean;
	static MoveFile(path: string, dest: string, error: Out<MonoIOError>): boolean;
	static CopyFile(path: string, dest: string, overwrite: boolean, error: Out<MonoIOError>): boolean;
	static DeleteFile(path: string, error: Out<MonoIOError>): boolean;
	static ReplaceFile(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean, error: Out<MonoIOError>): boolean;
	static GetFileAttributes(path: string, error: Out<MonoIOError>): FileAttributes;
	static SetFileAttributes(path: string, attrs: FileAttributes, error: Out<MonoIOError>): boolean;
	static GetFileType(handle: IntPtr, error: Out<MonoIOError>): MonoFileType;
	static FindFirst(path: string, pattern: string, result_attr: Out<FileAttributes>, error: Out<MonoIOError>, handle: Out<IntPtr>): string;
	static FindNext(handle: IntPtr, result_attr: Out<FileAttributes>, error: Out<MonoIOError>): string;
	static FindClose(handle: IntPtr): int;
	static Exists(path: string, error: Out<MonoIOError>): boolean;
	static ExistsFile(path: string, error: Out<MonoIOError>): boolean;
	static ExistsDirectory(path: string, error: Out<MonoIOError>): boolean;
	static ExistsSymlink(path: string, error: Out<MonoIOError>): boolean;
	static GetFileStat(path: string, stat: Out<MonoIOStat>, error: Out<MonoIOError>): boolean;
	static Open(filename: string, mode: FileMode, access: FileAccess, share: FileShare, options: FileOptions, error: Out<MonoIOError>): IntPtr;
	static Close(handle: IntPtr, error: Out<MonoIOError>): boolean;
	static Read(handle: IntPtr, dest: ByteArray, dest_offset: int, count: int, position: int, error: Out<MonoIOError>): int;
	static Write(handle: IntPtr, src: ByteArray, src_offset: int, count: int, error: Out<MonoIOError>): int;
	static Seek(handle: IntPtr, offset: int, origin: SeekOrigin, error: Out<MonoIOError>): int;
	static Flush(handle: IntPtr, error: Out<MonoIOError>): boolean;
	static GetLength(handle: IntPtr, error: Out<MonoIOError>): int;
	static SetLength(handle: IntPtr, length: int, error: Out<MonoIOError>): boolean;
	static SetFileTime(path: string, creation_time: long, last_access_time: long, last_write_time: long, error: Out<MonoIOError>): boolean;
	static SetFileTime(handle: IntPtr, creation_time: long, last_access_time: long, last_write_time: long, error: Out<MonoIOError>): boolean;
	static SetFileTime(path: string, type: int, creation_time: long, last_access_time: long, last_write_time: long, dateTime: DateTime, error: Out<MonoIOError>): boolean;
	static SetCreationTime(path: string, dateTime: DateTime, error: Out<MonoIOError>): boolean;
	static SetLastAccessTime(path: string, dateTime: DateTime, error: Out<MonoIOError>): boolean;
	static SetLastWriteTime(path: string, dateTime: DateTime, error: Out<MonoIOError>): boolean;
	static Lock(handle: IntPtr, position: int, length: int, error: Out<MonoIOError>): void;
	static Unlock(handle: IntPtr, position: int, length: int, error: Out<MonoIOError>): void;
	static get ConsoleOutput(): IntPtr;
	static get ConsoleInput(): IntPtr;
	static get ConsoleError(): IntPtr;
	static CreatePipe(read_handle: Out<IntPtr>, write_handle: Out<IntPtr>): boolean;
	static DuplicateHandle(source_process_handle: IntPtr, source_handle: IntPtr, target_process_handle: IntPtr, target_handle: Out<IntPtr>, access: int, inherit: int, options: int): boolean;
	static get VolumeSeparatorChar(): char;
	static get DirectorySeparatorChar(): char;
	static get AltDirectorySeparatorChar(): char;
	static get PathSeparator(): char;
	static GetTempPath(path: Out<string>): int;
}
export declare class MemoryStream extends Stream {
	protected dispose(disposing: boolean): void;
	private static readonly MemStreamMaxLength;
	private _buffer;
	private _origin;
	private _position;
	private _length;
	private _capacity;
	private _expandable;
	private _writable;
	private _exposable;
	private _isOpen;
	protected Get_CanRead(): boolean;
	protected Get_CanSeek(): boolean;
	protected Get_CanWrite(): boolean;
	protected Get_Capacity(): int;
	protected Set_Capacity(value: int): void;
	get Capacity(): int;
	set Capacity(value: int);
	protected Get_Length(): int;
	protected Get_Position(): int;
	protected Set_Position(value: int): void;
	constructor();
	constructor(capacity: int);
	constructor(buffer: ByteArray);
	constructor(buffer: ByteArray, writable: boolean);
	constructor(buffer: ByteArray, index: int, count: int);
	constructor(buffer: ByteArray, index: int, count: int, writable: boolean);
	constructor(buffer: ByteArray, index: int, count: int, writable: boolean, publiclyVisible: boolean);
	constructor1(): void;
	constructor2(capacity: int): void;
	constructor3(buffer: ByteArray): void;
	constructor4(buffer: ByteArray, writable: boolean): void;
	constructor5(buffer: ByteArray, index: int, count: int): void;
	constructor6(buffer: ByteArray, index: int, count: int, writable: boolean): void;
	constructor7(buffer: ByteArray, index: int, count: int, writable: boolean, publiclyVisible: boolean): void;
	Close(): void;
	private EnsureCapacity;
	Flush(): void;
	GetBuffer(): ByteArray;
	Read(buffer: ByteArray, offset: int, count: int): int;
	ReadByte(): int;
	Seek(offset: int, loc: SeekOrigin): int;
	SetLength(value: int): void;
	InternalReadInt32(): int;
	InternalGetPosition(): int;
	InternalEmulateRead(count: int): int;
	InternalGetBuffer(): ByteArray;
	ToArray(): ByteArray;
	Write(buffer: ByteArray, offset: int, count: int): void;
	WriteByte(value: byte): void;
	WriteTo(stream: Stream): void;
}
export declare class StringReader extends TextReader {
	private _s;
	private _pos;
	private _length;
	constructor(s: string);
	Close(): void;
	dispose(disposing: boolean): void;
	Peek(): int;
	Read(): int;
	Read(buffer: CharArray, index: int, count: int): int;
	ReadLine(): string;
	ReadToEnd(): string;
}
export declare class StringWriter extends TextWriter {
	private static m_encoding;
	private _sb;
	private _isOpen;
	protected Get_Encoding(): Encoding;
	static StaticConstructor(): void;
	constructor(sb?: StringBuilder, formatProvider?: IFormatProvider);
	Close(): void;
	dispose(disposing: boolean): void;
	GetStringBuilder(): StringBuilder;
	ToString(): string;
	WriteChar(value: char): void;
	WriteCharArray(buffer: CharArray): void;
	WriteCharArray(buffer: CharArray, index: int, count: int): void;
	Write(value: string): void;
}
export declare class Path {
	static readonly InvalidPathChars: CharArray;
	static readonly AltDirectorySeparatorChar: char;
	static readonly DirectorySeparatorChar: char;
	static readonly PathSeparator: char;
	static readonly DirectorySeparatorStr: string;
	static readonly VolumeSeparatorChar: char;
	static readonly PathSeparatorChars: CharArray;
	private static readonly dirEqualsVolume;
	static ChangeExtension(path: string, extension: string): string;
	static CleanPath(s: string): string;
	static GetDirectoryName(path: string): string;
	static GetExtension(path: string): string;
	static GetFileName(path: string): string;
	static GetFileNameWithoutExtension(path: string): string;
	static GetFullPath(path: string): string;
	static WindowsDriveAdjustment(path: string): string;
	static InsecureGetFullPath(path: string): string;
	private static IsDsc;
	static GetPathRoot(path: string): string;
	static GetTempFileName(): string;
	static GetTempPath(): string;
	private static get_temp_path;
	static HasExtension(path: string): boolean;
	static IsPathRooted(path: string): boolean;
	static GetInvalidFileNameChars(): CharArray;
	static GetInvalidPathChars(): CharArray;
	static GetRandomFileName(): string;
	private static findExtension;
	static StaticConstructor(): void;
	private static GetServerAndShare;
	private static SameRoot;
	static Join(...paths: string[]): string;
	private static CanonicalizePath;
	private static IsPathSubsetOf;
	static Combine(...paths: string[]): string;
	static Validate(path: string, parameterName?: string): void;
}
export declare class BinaryReader extends TObject implements IDisposable {
	private static readonly MaxCharBytesSize;
	private static readonly MaxBufferSize;
	private m_stream;
	private m_buffer;
	private m_decoder;
	private m_encoding;
	private m_charBytes;
	private m_singleChar;
	private m_charBuffer;
	private m_maxCharsSize;
	private m_2BytesPerChar;
	private m_isMemoryStream;
	private m_leaveOpen;
	private m_disposed;
	constructor(input: Stream);
	constructor(input: Stream, encoding: Encoding);
	constructor(input: Stream, encoding: Encoding, leaveOpen: boolean);
	constructor1(input: Stream): void;
	constructor2(input: Stream, encoding: Encoding): void;
	constructor3(input: Stream, encoding: Encoding, leaveOpen: boolean): void;
	protected Get_BaseStream(): Stream;
	get BaseStream(): Stream;
	Close(): void;
	protected dispose(disposing: boolean): void;
	PeekChar(): int;
	ReadBoolean(): boolean;
	ReadByte(): byte;
	ReadSByte(): sbyte;
	ReadChar(): char;
	ReadInt16(): short;
	ReadUInt16(): ushort;
	ReadInt32(): int;
	ReadUInt32(): uint;
	ReadInt64(): long;
	ReadUInt64(): ulong;
	ReadSingle(): float;
	ReadString(): string;
	Read(): int;
	Read(buffer: CharArray, index: int, count: int): int;
	Read(buffer: ByteArray, index: int, count: int): int;
	ReadChars(count: int): CharArray;
	private ReadCharBytes;
	ReadBytes(count: int): ByteArray;
	protected FillBuffer(numBytes: int): void;
	protected Read7BitEncodedInt(): int;
	private CheckBuffer;
}
export declare class BinaryWriter extends TObject implements IDisposable {
	static readonly Null: BinaryWriter;
	private readonly leave_open;
	protected OutStream: Stream;
	private m_encoding;
	private buffer;
	private stringBuffer;
	private maxCharsPerRound;
	private disposed;
	constructor();
	constructor(input: Stream);
	constructor(input: Stream, encoding: Encoding);
	constructor(input: Stream, encoding: Encoding, leaveOpen: boolean);
	constructor1(input: Stream): void;
	constructor2(input: Stream, encoding: Encoding): void;
	constructor3(output: Stream, encoding: Encoding, leaveOpen: boolean): void;
	protected Get_BaseStream(): Stream;
	get BaseStream(): Stream;
	Close(): void;
	protected dispose(disposing: boolean): void;
	Flush(): void;
	Seek(offset: int, origin: SeekOrigin): int;
	WriteBoolean(value: boolean): void;
	WriteByte(value: byte): void;
	WriteByteArray(buffer: ByteArray): void;
	WriteByteArray(buffer: ByteArray, index: int, count: int): void;
	WriteChar(ch: char): void;
	WriteCharArray(chars: CharArray): void;
	WriteCharArray(chars: CharArray, index: int, count: int): void;
	WriteShort(value: short): void;
	WriteInt(value: int): void;
	WriteLong(value: long): void;
	WriteSByte(value: sbyte): void;
	WriteFloat(value: float): void;
	WriteString(value: string): void;
	WriteUShort(value: ushort): void;
	WriteUInt(value: uint): void;
	protected Write7BitEncodedInt(value: int): void;
}
export declare class BufferedStream extends Stream {
	private m_stream;
	private m_buffer;
	private m_buffer_pos;
	private m_buffer_read_ahead;
	private m_buffer_reading;
	private disposed;
	constructor(stream: Stream, bufferSize?: int);
	protected Get_CanRead(): boolean;
	protected Get_CanWrite(): boolean;
	protected Get_CanSeek(): boolean;
	protected Get_Length(): int;
	protected Get_Position(): int;
	protected Set_Position(value: int): void;
	protected dispose(disposing: boolean): void;
	Flush(): void;
	Seek(offset: int, origin: SeekOrigin): int;
	SetLength(value: int): void;
	ReadByte(): int;
	WriteByte(value: byte): void;
	Read(array: ByteArray, offset: int, count: int): int;
	Write(array: ByteArray, offset: int, count: int): void;
	private CheckObjectDisposedException;
}
declare class DirectorySecurity {
	constructor(path: string, includeSections: AccessControlSections);
	PersistModifications(path: string): void;
}
declare abstract class FileSystemInfo extends TObject {
	protected FullPath: string;
	protected OriginalPath: string;
	stat: MonoIOStat;
	valid: boolean;
	protected abstract Get_Exists(): boolean;
	get Exists(): boolean;
	protected abstract Get_Name(): string;
	get Name(): string;
	protected Get_FullName(): string;
	get FullName(): string;
	get Extension(): string;
	get Attributes(): FileAttributes;
	set Attributes(value: FileAttributes);
	get CreationTime(): DateTime;
	set CreationTime(value: DateTime);
	get CreationTimeUtc(): DateTime;
	set CreationTimeUtc(value: DateTime);
	get LastAccessTime(): DateTime;
	set LastAccessTime(value: DateTime);
	get LastAccessTimeUtc(): DateTime;
	set LastAccessTimeUtc(value: DateTime);
	get LastWriteTime(): DateTime;
	set LastWriteTime(value: DateTime);
	get LastWriteTimeUtc(): DateTime;
	set LastWriteTimeUtc(value: DateTime);
	abstract Delete(): void;
	Refresh(force?: boolean): void;
	protected constructor();
	InternalRefresh(): void;
	CheckPath(path: string): void;
}
declare enum SearchOption {
	TopDirectoryOnly = 0,
	AllDirectories = 1
}
declare class FileInfo extends FileSystemInfo {
	protected dispose(disposing: boolean): void;
	private exists;
	constructor(fileName: string);
	InternalRefresh(): void;
	protected Get_Exists(): boolean;
	protected Get_Name(): string;
	get IsReadOnly(): boolean;
	set IsReadOnly(value: boolean);
	Encrypt(): void;
	Decrypt(): void;
	get Length(): int;
	get DirectoryName(): string;
	get Directory(): DirectoryInfo;
	OpenText(): StreamReader;
	CreateText(): StreamWriter;
	AppendText(): StreamWriter;
	Create(): FileStream;
	OpenRead(): FileStream;
	OpenWrite(): FileStream;
	Open(mode: FileMode): FileStream;
	Open(mode: FileMode, access: FileAccess): FileStream;
	Open(mode: FileMode, access: FileAccess, share: FileShare): FileStream;
	Delete(): void;
	MoveTo(destFileName: string): void;
	CopyTo(destFileName: string): FileInfo;
	CopyTo(destFileName: string, overwrite: boolean): FileInfo;
	ToString(): string;
	GetAccessControl(): FileSecurity;
	GetAccessControl(includeSections: AccessControlSections): FileSecurity;
	Replace(destinationFileName: string, destinationBackupFileName: string): FileInfo;
	Replace(destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): FileInfo;
	SetAccessControl(fileSecurity: FileSecurity): void;
}
declare class DirectoryInfo extends FileSystemInfo {
	protected dispose(disposing: boolean): void;
	private current;
	private parent;
	constructor(path: string, simpleOriginalPath?: boolean);
	private Initialize;
	protected Get_Exists(): boolean;
	Get_Name(): string;
	get Parent(): DirectoryInfo;
	get Root(): DirectoryInfo;
	Create(): void;
	Create(directorySecurity: DirectorySecurity): void;
	CreateSubdirectory(path: string): DirectoryInfo;
	CreateSubdirectory(path: string, directorySecurity: DirectorySecurity): DirectoryInfo;
	GetDirectories(): DirectoryInfo[];
	GetDirectories(searchPattern: string): DirectoryInfo[];
	GetDirectories(searchPattern: string, searchOption: SearchOption): DirectoryInfo[];
	GetFileSystemInfos(): FileSystemInfo[];
	GetFileSystemInfos(searchPattern: string): FileSystemInfo[];
	GetFileSystemInfos(searchPattern: string, searchOption: SearchOption): FileSystemInfo[];
	private InternalGetFileSystemInfos;
	Delete(): void;
	Delete(recursive: boolean): void;
	MoveTo(destDirName: string): void;
	ToString(): string;
	GetFilesSubdirs(l: ArrayList, pattern: string): int;
	GetFiles(): FileInfo[];
	GetFiles(searchPattern: string): FileInfo[];
	GetFiles(searchPattern: string, searchOption: SearchOption): FileInfo[];
	GetAccessControl(): DirectorySecurity;
	GetAccessControl(includeSections: AccessControlSections): DirectorySecurity;
	SetAccessControl(directorySecurity: DirectorySecurity): void;
}
export declare class Directory {
	static CreateDirectory(path: string): DirectoryInfo;
	private static CreateDirectoriesInternal;
	static Delete(path: string): void;
	static Delete(path: string, recursive: boolean): void;
	private static RecursiveDelete;
	static Exists(path: string): boolean;
	static GetLastAccessTime(path: string): DateTime;
	static GetLastAccessTimeUtc(path: string): DateTime;
	static GetLastWriteTime(path: string): DateTime;
	static GetLastWriteTimeUtc(path: string): DateTime;
	static GetCreationTime(path: string): DateTime;
	static GetCreationTimeUtc(path: string): DateTime;
	static GetCurrentDirectory(): string;
	static InsecureGetCurrentDirectory(): string;
	static GetDirectories(path: string): string[];
	static GetDirectories(path: string, searchPattern: string): string[];
	static GetDirectories(path: string, searchPattern: string, searchOption: SearchOption): string[];
	private static GetDirectoriesRecurse;
	static GetDirectoryRoot(path: string): string;
	static GetFiles(path: string): string[];
	static GetFiles(path: string, searchPattern: string): string[];
	static GetFiles(path: string, searchPattern: string, searchOption: SearchOption): string[];
	private static GetFilesRecurse;
	static GetFileSystemEntries(path: string): string[];
	static GetFileSystemEntries(path: string, searchPattern: string): string[];
	static GetLogicalDrives(): string[];
	private static IsRootDirectory;
	static GetParent(path: string): DirectoryInfo;
	static Move(sourceDirName: string, destDirName: string): void;
	static SetAccessControl(path: string, directorySecurity: DirectorySecurity): void;
	static SetCreationTime(path: string, creationTime: DateTime): void;
	static SetCreationTimeUtc(path: string, creationTimeUtc: DateTime): void;
	static SetCurrentDirectory(path: string): void;
	static SetLastAccessTime(path: string, lastAccessTime: DateTime): void;
	static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void;
	static SetLastWriteTime(path: string, lastWriteTime: DateTime): void;
	static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void;
	private static ValidateDirectoryListing;
	private static _GetFileSystemEntries;
	static GetAccessControl(path: string): DirectorySecurity;
	static GetAccessControl(path: string, includeSections: AccessControlSections): DirectorySecurity;
}
interface IModule {
	setStatus(text: string): any;
	statusMessage: string;
	noExitRuntime: boolean;
	ABORT: boolean;
	ctx: CanvasRenderingContext2D;
	preloadPlugins: any[];
	postMainLoop: Function;
	preMainLoop: Function;
	noImageDecoding: boolean;
	preloadedImages: any;
	noAudioDecoding: boolean;
	preloadedAudios: any[];
	Canvas: HTMLCanvasElement;
	elementPointerLock: boolean;
	getUniqueRunDependency(text: string): string;
	RemoveRunDependency(id: string): void;
	AddRunDependency(id: string): void;
	forcedAspectRatio: float;
	readAsync(url: string, callback: Function, onerror: Function): Promise<any>;
	assert(condition: boolean, message: string): any;
	abort(message: string): any;
	HEAPU32: Uint16Array;
	HEAP32: Int32Array;
	onFullScreen: Function;
	onFullscreen: Function;
	warnOnce(message: string): any;
	checkStackCookie(): void;
	err(message: string): any;
	useWebGL: boolean;
}
declare class MainLoop {
	private Module;
	Scheduler: Function;
	method: string;
	currentlyRunningMainloop: int;
	func: Function;
	arg: int;
	timingMode: int;
	timingValue: int;
	currentFrameNumber: int;
	queue: any[];
	remainingBlockers: int;
	expectedBlockers: int;
	Runner: Function;
	tickStartTime: int;
	constructor(module: IModule);
	Pause(): void;
	Resume(): void;
	UpdateStatus(): void;
	private setMainLoop;
	runIter(func: Function): void;
}
export declare class Browser {
	private Module;
	mainLoop: MainLoop;
	isFullscreen: boolean;
	pointerLock: boolean;
	moduleContextCreatedCallbacks: Function[];
	workers: any[];
	initted: boolean;
	private hasBlobConstructor;
	private BlobBuilder;
	private URLObject;
	constructor(module: IModule);
	init(): void;
	CreateCanvas(width: int, height: int): HTMLCanvasElement;
	static CreateRenderingContext(width: int, height: int): CanvasRenderingContext2D;
	CreateContext(canvas: HTMLCanvasElement, useWebGL: boolean, setInModule: boolean, webGLContextAttributes: any): CanvasRenderingContext2D;
	destroyContext(canvas: HTMLCanvasElement, useWebGL: boolean, setInModule: boolean): void;
	private fullscreenHandlersInstalled;
	private lockPointer;
	private resizeCanvas;
	requestFullscreen(lockPointer: boolean, resizeCanvas: boolean): void;
	requestFullScreen(): void;
	exitFullscreen(): boolean;
	nextRAF: int;
	fakeRequestAnimationFrame(func: Function): void;
	requestAnimationFrame(func: Function): void;
	safeRequestAnimationFrame(func: Function): void;
	private noExitRuntime;
	safeSetTimeout(func: Function, timeout: int): int;
	private getMimetype;
	protected getUserMedia(func: Function): any;
	private getMovementX;
	private getMovementY;
	GetMouseWheelDelta(event: any): int;
	mouseX: int;
	mouseY: int;
	mouseMovementX: int;
	mouseMovementY: int;
	touches: any;
	lastTouches: any;
	CalculateMouseEvent(event: any): void;
	asyncLoad(url: string, onload: Function, onerror: Function, noRunDep?: boolean): void;
	resizeListeners: Function[];
	private updateResizeListeners;
	setCanvasSize(width: int, height: int, noUpdates?: boolean): void;
	private windowedWidth;
	private windowedHeight;
	private setFullscreenCanvasSize;
	private setWindowedCanvasSize;
	private updateCanvasDimensions;
	private wgetRequests;
	private nextWgetRequestHandle;
	private getNextWgetRequestHandle;
	static get WindowWidth(): int;
	static get WindowHeight(): int;
}
declare type PSTR = int;
declare type Pointer = int;
export declare class MonitorRunDependenciesDelegate extends Delegate<(runDependencies: int) => void> {
}
export declare class DependenciesFulfilledDelegate extends Delegate<() => void> {
}
export declare class RuntimeInitializedDelegate extends Delegate<() => void> {
}
export declare class BeforeRunDelegate extends Delegate<() => void> {
}
export declare abstract class TModule {
	private allocator;
	protected out: any;
	protected err: any;
	protected buffer: ArrayBuffer;
	protected HEAP8: Int8Array;
	protected HEAPU8: Uint8Array;
	protected HEAP16: Int16Array;
	protected HEAPU16: Uint16Array;
	protected HEAP32: Int32Array;
	protected HEAPU32: Uint32Array;
	protected HEAPF32: Float32Array;
	protected HEAPF64: Float64Array;
	Browser: Browser;
	private static readonly dataURIPrefix;
	private static readonly fileURIPrefix;
	private runDependencies;
	private runDependencyTracking;
	private runDependencyWatcher;
	private ABORT;
	private EXITSTATUS;
	private monitorRunDependencies;
	private dependenciesFulfilled;
	OnBeforeRun: Event<BeforeRunDelegate>;
	private calledRun;
	OnRuntimeInitialized: Event<RuntimeInitializedDelegate>;
	private shouldRunNow;
	private scriptDirectory;
	protected readBinary: Function;
	private UTF8Decoder;
	private UTF16Decoder;
	preloadPlugins: any[];
	preloadedImages: any;
	constructor();
	private static runDependencies;
	private static runDependencyWatcher;
	private static dependenciesFulfilled;
	private static runDependencyTracking;
	getUniqueRunDependency(id: string): string;
	protected updateGlobalBufferAndViews(buf: ArrayBuffer): void;
	private initMemory;
	protected _malloc(size: int): int;
	protected _free(size: int): int;
	protected _memset(pointer: int, value: byte, size: int): void;
	protected _memcpy(dest: int, src: byte, count: int): void;
	/**
	 * @param {number} idx
	 * @param {number=} maxBytesToRead
	 * @return {string}
	 */
	private UTF8ArrayToString;
	protected UTF8ToString(ptr: any, maxBytesToRead?: any): any;
	private stringToUTF8Array;
	protected stringToUTF8(str: string, outPtr: PSTR, maxBytesToWrite: int): int;
	private lengthBytesUTF8;
	protected intArrayFromString(stringy: string, dontAddNull?: any, length?: int): any[];
	private AsciiToString;
	private stringToAscii;
	private UTF16ToString;
	private stringToUTF16;
	private lengthBytesUTF16;
	private UTF32ToString;
	private stringToUTF32;
	private lengthBytesUTF32;
	private allocateUTF8;
	/** @deprecated
		@param {boolean=} dontAddNull */
	private writeStringToMemory;
	private writeArrayToMemory;
	/** @param {boolean=} dontAddNull */
	private writeAsciiToMemory;
	private read_;
	private readAsync;
	protected warnOnce(text: any): void;
	private demangle;
	private demangleAll;
	private jsStackTrace;
	private stackTrace;
	protected abort(what: any): void;
	protected assert(condition: any, text?: any): void;
	AddRunDependency(id: string): void;
	RemoveRunDependency(id: string): void;
	PreRun(): void;
	private _preRun;
	InitRuntime(): void;
	PreMain(): void;
	CallMain(...args: any[]): void;
	PostRun(): void;
	private runCaller;
	private depCheck;
	private preRunCalled;
	Run(...args: any[]): void;
	private hasPrefix;
	protected isDataURI(filename: string): boolean;
	protected locateFile(path: string): string;
	protected isFileURI(filename: string): boolean;
	private noExitRuntime;
	setMainLoop(browserIterationFunc: Function, fps: int, simulateInfiniteLoop: int, arg: int, noSetTiming: boolean): void;
	_emscripten_get_now(): int;
	private setImmediates;
	private _emscripten_set_main_loop_timing;
	_emscripten_set_main_loop(func: Function, fps: int, simulateInfiniteLoop: int, arg?: int, noSetTiming?: boolean): void;
	_emscripten_async_wget(url: int, file: int, onload: Function, onerror: Function): any;
	_emscripten_async_wget(url: string, file: string, onload: Function, onerror: Function): any;
	_emscripten_async_wget_data(url: int, arg: int, onload: Function | int, onerror: Function | int): void;
	_emscripten_cancel_main_loop(): void;
	stackSave(): int;
	stackRestore(stackPointer: int): void;
	stackAlloc(size: int): Pointer;
	static readonly ALLOC_NORMAL: int;
	static readonly ALLOC_STACK: int;
	/** @type {function((Uint8Array|Array<number>), number)} */
	allocate(slab: Uint8Array | Array<number>, allocator: int): any;
}
declare class PathInfo extends TObject {
	protected dispose(disposing: boolean): void;
	path: string;
	node: FSNode;
	constructor(path: string, node: any);
}
declare class Mount {
	mountpoint: string;
	mounts: Mount[];
	opts: any;
	root: FSNode;
	type: any;
	constructor(type: any, opts: any, mountpoint: string, mounts: Mount[]);
}
declare class FSNode extends TObject {
	protected dispose(disposing: boolean): void;
	private static readMode;
	private static writeMode;
	parent: FSNode;
	mount: Mount;
	mounted: Mount;
	id: int;
	name: string;
	mode: int;
	node_ops: IFSNodeOps;
	stream_ops: any;
	rdev: any;
	name_next: FSNode;
	timestamp: int;
	contents: byte[];
	url: string;
	constructor(parent: FSNode, name: string, mode: int, rdev: any);
	get read(): boolean;
	set read(value: boolean);
	get write(): boolean;
	set write(value: boolean);
	get isFolder(): boolean;
	get isDevice(): boolean;
}
declare class FSStream {
	path: string;
	ungotten: any[];
	position: int;
	seekable: boolean;
	getdents: any;
	fd: int;
	node: FSNode;
	flags: int;
	stream_ops: IStreamOps;
	get object(): FSNode;
	set object(value: FSNode);
	get isRead(): boolean;
	get isWrite(): boolean;
	get isAppend(): boolean;
}
interface IStreamOps {
	open?: (stream: FSStream) => void;
	llseek?: (stream: FSStream, offset: int, whence: int) => int;
	read?: (stream: FSStream, buffer: any, offset: int, length: int, position: int) => int;
	write?: (stream: FSStream, buffer: ByteArray, offset: int, length: int, position: int, canOwn: boolean) => int;
	close?: (stream: FSStream) => void;
	allocate?: (stream: FSStream, offset: int, length: int) => void;
	mmap?: (stream: FSStream, buffer: int, offset: int, length: int, position: int, prot: int, flags: int) => void;
	msync?: (stream: FSStream, buffer: ByteArray, offset: int, length: int, mmapFlags: int) => int;
	ioctl?: (stream: FSStream, cmd: string, arg: any) => int;
}
interface IFSType {
	createNode?: (parent: string | FSNode, name: string, mode: int, dev: int) => FSNode;
	expandFileStorage?: (node: FSNode, newCapacity: int) => void;
	getFileDataAsRegularArray?: (node: FSNode) => any[];
	getFileDataAsTypedArray?: (node: FSNode) => ByteArray;
	mount?: (mount: Mount) => FSNode;
	node_ops?: IFSNodeOps;
	ops_table?: any;
	resizeFileStorage?: (node: FSNode, newSize: int) => void;
	stream_ops?: IStreamOps;
}
interface IFSNodeOps {
	getattr?: (node: FSNode) => any;
	lookup?: (parent: FSNode, name: string) => FSNode;
	mknod?: (parent: FSNode, name: string, mode: int, dev: int) => FSNode;
	readdir?: (node: FSNode) => string[];
	readlink?: (node: FSNode) => FSNode;
	rename?: (old_node: FSNode, new_dir: FSNode, new_name: string) => void;
	rmdir?: (parent: FSNode, name: string) => void;
	setattr?: (node: FSNode, attr: any) => void;
	symlink?: (parent: FSNode, newname: string, oldpath: string | FSNode) => FSNode;
	unlink?: (parent: FSNode, name: string) => void;
}
export declare class FS extends TObject {
	protected dispose(disposing: boolean): void;
	private static MAX_OPEN_FDS;
	private static flagModes;
	static root: any;
	static mounts: any[];
	static devices: any;
	static streams: FSStream[];
	static nextInode: int;
	static nameTable: FSNode[];
	static currentPath: string;
	static initialized: boolean;
	static ignorePermissions: boolean;
	static trackingDelegate: any;
	static tracking: any;
	static ErrnoError: any;
	static genericErrors: any;
	static filesystems: any;
	static syncFSRequests: any;
	static handleFSError(e: any): any;
	static lookupPath(path: string | FSNode, opts?: any): PathInfo;
	static getPath(node: FSNode): string;
	static hashName(parentid: int, name: string): int;
	static hashAddNode(node: FSNode): void;
	static hashRemoveNode(node: FSNode): void;
	static lookupNode(parent: FSNode, name: string): FSNode;
	static createNode(parent: string | FSNode, name: string, mode: int, rdev: int): FSNode;
	static destroyNode(node: FSNode): void;
	static isRoot(node: FSNode): boolean;
	static isMountpoint(node: FSNode): boolean;
	static isFile(mode: int): boolean;
	static isDir(mode: int): boolean;
	static isLink(mode: int): boolean;
	static isChrdev(mode: int): boolean;
	static isBlkdev(mode: int): boolean;
	static isFIFO(mode: int): boolean;
	static isSocket(mode: int): boolean;
	static modeStringToFlags(str: string): int;
	static flagsToPermissionString(flag: int): string;
	static nodePermissions(node: FSNode, perms: any): int;
	static mayLookup(dir: FSNode): int;
	static mayCreate(dir: FSNode, name: string): number;
	static mayDelete(dir: FSNode, name: string, isdir: boolean): int;
	static mayOpen(node: FSNode, flags: int): int;
	static nextfd(fd_start: int, fd_end: int): int;
	static getStream(fd: int): any;
	static createStream(stream: any, fd_start: int, fd_end: int): FSStream;
	static closeStream(fd: int): void;
	private static _chrdev_stream_ops;
	static get chrdev_stream_ops(): IStreamOps;
	static major(dev: any): int;
	static minor(dev: any): int;
	static makedev(ma: int, mi: int): int;
	static registerDevice(dev: any, ops: IStreamOps): void;
	static getDevice(dev: int): IStreamOps;
	static getMounts(mount: Mount): Mount[];
	static syncfs(populate?: Function | boolean, callback?: Function): void;
	static mount(type: string | IFSType, opts: any, mountpoint: string): FSNode;
	static unmount(mountpoint: string): void;
	static lookup(parent: FSNode, name: string): FSNode;
	static mknod(path: string | FSNode, mode: int, dev: int): FSNode;
	static create(path: string | FSNode, mode: int): FSNode;
	static mkdir(path: string, mode?: int): FSNode;
	static mkdirTree(path: string, mode?: int): void;
	static mkdev(path: string, mode: int, dev?: int): FSNode;
	static symlink(oldpath: string | FSNode, newpath: string): FSNode;
	static rename(old_path: string, new_path: string): void;
	static rmdir(path: string): void;
	static readdir(path: string): string[];
	static unlink(path: string): void;
	static readlink(path: string): string;
	static stat(path: string, dontFollow?: boolean): any;
	lstat(path: string): any;
	static chmod(path: string | FSNode, mode: int, dontFollow?: boolean): void;
	static lchmod(path: string, mode: int): void;
	static fchmod(fd: int, mode: int): void;
	static chown(path: string, uid: string, gid: string, dontFollow?: boolean): void;
	static lchown(path: string, uid: string, gid: string): void;
	static fchown(fd: int, uid: string, gid: string): void;
	static truncate(path: FSNode, len: int): void;
	static ftruncate(fd: int, len: int): void;
	static utime(path: string, atime: int, mtime: int): void;
	static open(path: string | FSNode, _flags: string, mode?: int, fd_start?: int, fd_end?: int): FSStream;
	static close(stream: FSStream): void;
	static isClosed(stream: FSStream): boolean;
	static llseek(stream: FSStream, offset: int, whence: int): int;
	static read(stream: FSStream, buffer: any, offset: int, length: int, position?: int): int;
	static write(stream: FSStream, buffer: ByteArray, offset: int, length: int, position?: int, canOwn?: boolean): int;
	static allocate(stream: FSStream, offset: int, length: int): void;
	static mmap(stream: FSStream, buffer: int, offset: int, length: int, position: int, prot: int, flags: int): void;
	static msync(stream: FSStream, buffer: ByteArray, offset: int, length: int, mmapFlags: int): int;
	static munmap(stream: FSStream): int;
	static ioctl(stream: FSStream, cmd: string, arg: any): int;
	static readFile(path: string, opts?: any): Uint8Array;
	static writeFile(path: string, data: Uint8Array, opts: any): void;
	static cwd(): string;
	static chdir(path: string): void;
	static createDefaultDirectories(): void;
	static createDefaultDevices(): void;
	static createSpecialDirectories(): void;
	static createStandardStreams(): void;
	static ensureErrnoError(): void;
	static staticInit(): void;
	static init(input?: any, output?: any, error?: any): void;
	static quit(): void;
	static getMode(canRead: boolean, canWrite: boolean): int;
	static joinPath(parts: any, forceRelative: any): string;
	static absolutePath(relative: any, base: any): string;
	static standardizePath(path: string): string;
	static findObject(path: string, dontResolveLastLink: boolean): any;
	static analyzePath(path: string, dontResolveLastLink?: boolean): any;
	static createFolder(parent: FSNode, name: string, canRead: boolean, canWrite: boolean): FSNode;
	createPath(parent: string | FSNode, path: string, canRead: boolean, canWrite: boolean): FSNode;
	static createFile(parent: any, name: any, properties?: any, canRead?: boolean, canWrite?: boolean): FSNode;
	static createDataFile(parent: string | FSNode, name: string, data: any, canRead: boolean, canWrite: boolean, canOwn: boolean): FSNode;
	static createDevice(parent: string | FSNode, name: string, input: any, output?: any): FSNode;
	static createLink(parent: string | FSNode, name: string, target: FSNode, canRead: boolean, canWrite: boolean): FSNode;
	static forceLoadFile(obj: any): boolean;
	static createLazyFile(parent: string | FSNode, name: string, url: string, canRead: boolean, canWrite: boolean): FSNode;
	static createPreloadedFile(parent: string | FSNode, name: string, url: string, canRead: boolean, canWrite: boolean, onload: Function, onerror: Function, dontCreateFile: boolean, canOwn?: boolean, preFinish?: Function, browser?: Browser, module?: TModule): void;
	static indexedDB(): IDBFactory;
	static DB_NAME(): string;
	static DB_VERSION: int;
	static DB_STORE_NAME: string;
	static saveFilesToDB(paths: string[] | FSNode[], onload?: Function, onerror?: Function): any;
	static loadFilesFromDB(paths: string[] | FSNode, onload: Function, onerror: Function): void;
}
export declare const MEMFS: IFSType;
export declare const IDBFS: {
	dbs: {};
	indexedDB: () => any;
	DB_VERSION: number;
	DB_STORE_NAME: string;
	mount: (mount: Mount) => FSNode;
	syncfs: (mount: Mount, populate: boolean, callback: Function) => void;
	getDB: (name: any, callback: any) => any;
	getLocalSet: (mount: any, callback: any) => any;
	getRemoteSet: (mount: any, callback: any) => void;
	loadLocalEntry: (path: any, callback: any) => any;
	storeLocalEntry: (path: any, entry: any, callback: any) => any;
	removeLocalEntry: (path: any, callback: any) => any;
	loadRemoteEntry: (store: any, path: any, callback: any) => void;
	storeRemoteEntry: (store: any, path: any, entry: any, callback: any) => void;
	removeRemoteEntry: (store: any, path: any, callback: any) => void;
	reconcile: (src: any, dst: any, callback: any) => any;
};
export declare const PATH: {
	splitPath: (filename: string) => string[] | undefined;
	normalizeArray: (parts: any, allowAboveRoot: any) => any;
	normalize: (path: any) => string;
	dirname: (path: string) => string;
	basename: (path: any) => any;
	extname: (path: any) => any;
	join: (...args: any[]) => string;
	join2: (l: any, r: any) => string;
};
declare type int32 = number;
declare type uint32 = number;
declare let HEAP: any, 
/** @type {ArrayBuffer} */
SystemHeap: ArrayBuffer, 
/** @type {Int8Array} */
HEAP8: Int8Array, 
/** @type {Uint8Array} */
HEAPU8: Uint8Array, 
/** @type {Int16Array} */
HEAP16: Int16Array, 
/** @type {Uint16Array} */
HEAPU16: Uint16Array, 
/** @type {Int32Array} */
HEAP32: Int32Array, 
/** @type {Uint32Array} */
HEAPU32: Uint32Array, 
/** @type {Float32Array} */
HEAPF32: Float32Array, 
/** @type {Float64Array} */
HEAPF64: Float64Array;
export declare function getNativeTypeSize(type: any): number;
export declare let HeapBuffer: TBuffer;
export declare function updateGlobalBufferAndViews(buf: ArrayBuffer): void;
export declare function updateGlobalBufferAndViewsEx(buf: ArrayBuffer): void;
export declare function restoreGlobalBuffer(): void;
export declare function getValue(ptr: number, type: string, noSafe?: boolean): number | null;
export declare function setValue(ptr: number, value: number, type: string, noSafe?: boolean): void;
declare type ListNode = {
	type: string;
	offset: int32;
	size: int32;
	height: int32;
	pointers: int32[];
};
declare type InspectionResult = {
	header: ListNode;
	blocks: Array<{
		type: string;
		size: int32;
		node?: ListNode;
	}>;
};
export declare class Allocator {
	private buffer;
	private byteOffset;
	private byteLength;
	private int32Array;
	/**
	 * Initialize the allocator from the given Buffer or ArrayBuffer.
	 */
	constructor(buffer: Int32Array);
	constructor(buffer: ArrayBuffer | SharedArrayBuffer);
	constructor(buffer: ArrayBuffer | SharedArrayBuffer, byteOffset: uint32, byteLength: uint32);
	/**
	 * Allocate a given number of bytes and return the offset.
	 * If allocation fails, returns 0.
	 */
	alloc(numberOfBytes: int32): int32;
	/**
	 * Allocate and clear the given number of bytes and return the offset.
	 * If allocation fails, returns 0.
	 */
	calloc(numberOfBytes: int32): int32;
	/**
	 * Free a number of bytes from the given address.
	 */
	free(address: int32): int32;
	/**
	 * Return the size of the block at the given address.
	 */
	sizeOf(address: int32): uint32;
	/**
	 * Inspect the instance.
	 */
	inspect(): InspectionResult;
}
/**
 * Prepare the given int32Array and ensure it contains a valid header.
 */
export declare function prepare(int32Array: Int32Array): Int32Array;
/**
 * Verify that the int32Array contains a valid header.
 */
export declare function verifyHeader(int32Array: Int32Array): boolean;
/**
 * Check the integrity of the freelist in the given array.
 */
export declare function checkListIntegrity(int32Array: Int32Array): boolean;
/**
 * Inspect the freelist in the given array.
 */
export declare function inspect(int32Array: Int32Array): InspectionResult;
export declare function malloc(size: number): number;
export declare function free(pointer: number): number;
export declare function inspectHeap(): InspectionResult;
export declare class POINT extends UMP {
	X: any;
	Y: any;
}
export declare class RECT extends UMP {
	X: any;
	Y: any;
	Width: any;
	Height: any;
}
export declare class GdipEncoderParameter extends UMP {
	guid: any;
	numberOfValues: any;
	type: any;
	value: any;
}
export declare class FileNotFoundException extends Exception {
	constructor(...params: any[]);
}
export declare class DirectoryNotFoundException extends Exception {
	constructor(...params: any[]);
}
export declare class DriveNotFoundException extends Exception {
	constructor(...params: any[]);
}
export declare class EndOfStreamException extends Exception {
	constructor(...params: any[]);
}
export declare class PathTooLongException extends Exception {
	constructor(...params: any[]);
}
/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/
/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/
/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/
/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/
/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
export declare function Deflate(options: any): any;
/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
export declare function deflate(input: any, options?: any): any;
/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
export declare function deflateRaw(input: any, options: any): any;
/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
export declare function gzip(input: any, options: any): any;
/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/
/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/
/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/
/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/
/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
export declare function Inflate(options: any): any;
/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
export declare function inflate(input: any, options?: any): any;
/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
export declare function inflateRaw(input: any, options: any): any;
export declare const ungzip: typeof inflate;
export declare class TCompress {
	static CompressBytes(input: Uint8Array): Uint8Array;
	static CompressString(input: string): string;
	static DeCompressBytes(input: Uint8Array): Uint8Array;
	static DeCompressString(input: string): string;
}
declare class UnicodeEncoding extends Encoding {
	protected dispose(disposing: boolean): void;
	private static readonly _UNICODE_CODE_PAGE;
	private static readonly _BIG_UNICODE_CODE_PAGE;
	static readonly CharSize: int;
	private bigEndian;
	private byteOrderMark;
	constructor(bigEndian?: boolean, byteOrderMark?: boolean, throwOnInvalidBytes?: boolean);
	GetByteCount(chars: CharArray, index: int, count: int): int;
	GetByteCount(s: string): int;
	GetByteCount(chars: CharArray): int;
	GetByteCount(chars: CharArray, count: int): int;
	GetBytes(chars: CharArray, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int): int;
	GetBytes(s: string, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int): int;
	GetBytes(s: string): ByteArray;
	GetBytes(chars: CharArray, index: int, count: int): ByteArray;
	GetBytes(chars: CharArray): ByteArray;
	GetBytes(chars: CharArray, charCount: int, bytes: ByteArray, byteCount: int): int;
	private GetBytesInternal;
	GetCharCount(bytes: ByteArray, index: int, count: int): int;
	GetCharCount(bytes: ByteArray): int;
	GetCharCount(bytes: ByteArray, count: int): int;
	GetChars(bytes: ByteArray, byteIndex: int, byteCount: int, chars: CharArray, charIndex: int): int;
	GetChars(bytes: ByteArray, index: int, count: int): CharArray;
	GetChars(bytes: ByteArray, byteCount: int, chars: CharArray, charCount: int): int;
	GetChars(bytes: ByteArray): CharArray;
	GetString(bytes: ByteArray, index: int, count: int): string;
	GetString(bytes: ByteArray): string;
	private GetCharsInternal;
	GetEncoder(): Encoder;
	GetMaxByteCount(charCount: int): int;
	GetMaxCharCount(byteCount: int): int;
	GetDecoder(): Decoder;
	GetPreamble(): ByteArray;
	Equals<UnicodeEncoding>(value: UnicodeEncoding): boolean;
	GetHashCode(): int;
	private static CopyChars;
}
declare class UTF32Encoding extends Encoding {
	protected dispose(disposing: boolean): void;
	static readonly _UTF32_CODE_PAGE: int;
	static readonly _BIG_UTF32_CODE_PAGE: int;
	private bigEndian;
	private byteOrderMark;
	constructor(bigEndian?: boolean, byteOrderMark?: boolean, throwOnInvalidCharacters?: boolean);
	GetByteCount(chars: CharArray, index: int, count: int): int;
	GetByteCount(s: string): int;
	GetByteCount(chars: CharArray): int;
	GetByteCount(chars: CharArray, count: int): int;
	GetBytes(chars: CharArray, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int): int;
	GetBytes(s: string, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int): int;
	GetBytes(s: string): ByteArray;
	GetBytes(chars: CharArray, index: int, count: int): ByteArray;
	GetBytes(chars: CharArray): ByteArray;
	GetBytes(chars: CharArray, charCount: int, bytes: ByteArray, byteCount: int): int;
	GetCharCount(bytes: ByteArray, index: int, count: int): int;
	GetCharCount(bytes: ByteArray): int;
	GetCharCount(bytes: ByteArray, count: int): int;
	GetChars(bytes: ByteArray, byteIndex: int, byteCount: int, chars: CharArray, charIndex: int): int;
	GetChars(bytes: ByteArray, index: int, count: int): CharArray;
	GetChars(bytes: ByteArray, byteCount: int, chars: CharArray, charCount: int): int;
	GetChars(bytes: ByteArray): CharArray;
	GetMaxByteCount(charCount: int): int;
	GetMaxCharCount(byteCount: int): int;
	GetDecoder(): Decoder;
	GetPreamble(): ByteArray;
	Equals<UTF32Encoding>(value: UTF32Encoding): boolean;
	GetHashCode(): int;
}
declare class UTF8Encoding extends Encoding {
	protected dispose(disposing: boolean): void;
	private emitIdentifier;
	constructor(encoderShouldEmitUTF8Identifier?: boolean, throwOnInvalidBytes?: boolean);
	static InternalGetByteCount(chars: CharArray, index: int, count: int, fallback: EncoderFallback, leftOver: Out<char>, flush: boolean): int;
	static InternalGetByteCount(chars: CharArray, count: int, fallback: EncoderFallback, leftOver: Out<char>, flush: boolean): int;
	private static GetFallbackChars;
	GetByteCount(chars: CharArray, index: int, count: int): int;
	GetByteCount(s: string): int;
	GetByteCount(chars: CharArray): int;
	GetByteCount(chars: CharArray, count: int): int;
	static InternalGetBytes(chars: CharArray, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int, fallback: EncoderFallback, buffer: Out<EncoderFallbackBuffer>, leftOver: Out<char>, flush: boolean): int;
	static InternalGetBytes(chars: CharArray, count: int, bytes: ByteArray, bcount: int, fallback: EncoderFallback, buffer: Out<EncoderFallbackBuffer>, leftOver: Out<char>, flush: boolean): int;
	GetBytes(chars: CharArray, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int): int;
	GetBytes(s: string, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int): int;
	GetBytes(s: string): ByteArray;
	GetBytes(chars: CharArray, index: int, count: int): ByteArray;
	GetBytes(chars: CharArray): ByteArray;
	GetBytes(chars: CharArray, charCount: int, bytes: ByteArray, byteCount: int): int;
	static InternalGetCharCount(bytes: ByteArray, index: int, count: int, leftOverBits: uint, leftOverCount: uint, provider: any, fallbackBuffer: Out<DecoderFallbackBuffer>, bufferArg: Out<ByteArray>, flush: boolean): int;
	static InternalGetCharCount(bytes: ByteArray, count: int, leftOverBits: uint, leftOverCount: uint, provider: any, fallbackBuffer: Out<DecoderFallbackBuffer>, bufferArg: Out<ByteArray>, flush: boolean): int;
	private static Fallback;
	GetCharCount(bytes: ByteArray, index: int, count: int): int;
	GetCharCount(bytes: ByteArray): int;
	GetCharCount(bytes: ByteArray, count: int): int;
	static InternalGetChars(bytes: ByteArray, byteIndex: int, byteCount: int, chars: CharArray, charIndex: int, leftOverBits: Out<uint>, leftOverCount: Out<uint>, provider: any, fallbackBuffer: Out<DecoderFallbackBuffer>, bufferArg: Out<ByteArray>, flush: boolean): int;
	static InternalGetChars(bytes: ByteArray, byteCount: int, chars: CharArray, charCount: int, leftOverBits: Out<uint>, leftOverCount: Out<uint>, provider: any, fallbackBuffer: Out<DecoderFallbackBuffer>, bufferArg: Out<ByteArray>, flush: boolean): int;
	GetChars(bytes: ByteArray, byteIndex: int, byteCount: int, chars: CharArray, charIndex: int): int;
	GetChars(bytes: ByteArray, index: int, count: int): CharArray;
	GetChars(bytes: ByteArray, byteCount: int, chars: CharArray, charCount: int): int;
	GetChars(bytes: ByteArray): CharArray;
	GetMaxByteCount(charCount: int): int;
	GetMaxCharCount(byteCount: int): int;
	GetDecoder(): Decoder;
	GetEncoder(): Encoder;
	GetPreamble(): ByteArray;
	Equals<UTF8Encoding>(value: UTF8Encoding): boolean;
	GetHashCode(): int;
}
export declare class ASCIIEncoding extends Encoding {
	protected dispose(disposing: boolean): void;
	private static readonly _ASCII_CODE_PAGE;
	constructor();
	get IsSingleByte(): boolean;
	GetByteCount(chars: CharArray, index: int, count: int): int;
	GetByteCount(s: string): int;
	GetByteCount(chars: CharArray): int;
	GetByteCount(chars: CharArray, count: int): int;
	GetBytes(chars: CharArray, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int): int;
	GetBytes(s: string, charIndex: int, charCount: int, bytes: ByteArray, byteIndex: int): int;
	GetBytes(s: string): ByteArray;
	GetBytes(chars: CharArray, index: int, count: int): ByteArray;
	GetBytes(chars: CharArray): ByteArray;
	GetBytes(chars: CharArray, charCount: int, bytes: ByteArray, byteCount: int): int;
	private getBytes;
	private InternalGetBytes;
	GetCharCount(bytes: ByteArray, index: int, count: int): int;
	GetCharCount(bytes: ByteArray): int;
	GetCharCount(bytes: ByteArray, count: int): int;
	GetChars(bytes: ByteArray, byteIndex: int, byteCount: int, chars: CharArray, charIndex: int): int;
	GetChars(bytes: ByteArray, index: int, count: int): CharArray;
	GetChars(bytes: ByteArray, byteCount: int, chars: CharArray, charCount: int): int;
	GetChars(bytes: ByteArray): CharArray;
	private getChars;
	GetMaxByteCount(charCount: int): int;
	GetMaxCharCount(byteCount: int): int;
	GetString(bytes: ByteArray, index: int, count: int): string;
	GetString(bytes: ByteArray): string;
}
export declare function byteLength(b64: any): number;
export declare function toByteArray(b64: string): Uint8Array;
export declare function fromByteArray(uint8: Uint8Array): string;
export declare class Base64 {
	static ByteLength(b64: Uint8Array): number;
	static ToByteArray(text: string): Uint8Array;
	static FromByteArray(arr: Uint8Array): string;
}
export declare const EncodingModule: {
	UTF8Encoding: (string | typeof UTF8Encoding)[];
	UTF32Encoding: (string | typeof UTF32Encoding)[];
	UnicodeEncoding: (string | typeof UnicodeEncoding)[];
	ASCIIEncoding: (string | typeof ASCIIEncoding)[];
};
interface InputProcessor {
	keyDown(keycode: int): boolean;
	keyUp(keycode: int): boolean;
	keyTyped(character: char): boolean;
	touchDown(screenX: int, screenY: int, pointer: int, button: int): boolean;
	touchUp(screenX: int, screenY: int, pointer: int, button: int): boolean;
	touchDragged(screenX: int, screenY: int, pointer: int): boolean;
	mouseMoved(screenX: int, screenY: int): boolean;
	scrolled(amount: int): boolean;
}
export interface TextInputListener {
	input(text: string): void;
	canceled(): void;
}
export declare enum Orientation {
	Landscape = 0,
	Portrait = 1
}
export declare enum Peripheral {
	HardwareKeyboard = 0,
	OnscreenKeyboard = 1,
	MultitouchScreen = 2,
	Accelerometer = 3,
	Compass = 4,
	Vibrator = 5,
	Gyroscope = 6,
	RotationVector = 7,
	Pressure = 8
}
export declare abstract class Input {
	static keyNames: Dictionary<string, number>;
	static valueOf(keyname: string): number;
	static initializeKeyNames(): void;
	abstract getAccelerometerX(): float;
	abstract getAccelerometerY(): float;
	abstract getAccelerometerZ(): float;
	abstract getGyroscopeX(): float;
	abstract getGyroscopeY(): float;
	abstract getGyroscopeZ(): float;
	abstract getMaxPointers(): int;
	abstract getX(): int;
	abstract getX(pointer: int): int;
	abstract getDeltaX(): int;
	abstract getDeltaX(pointer: int): int;
	abstract getY(): int;
	abstract getY(pointer: int): int;
	abstract getDeltaY(): int;
	abstract getDeltaY(pointer: int): int;
	abstract justTouchedMethod(): boolean;
	abstract isTouched(pointer: int): boolean;
	abstract getPressure(): float;
	abstract getPressure(pointer: int): float;
	abstract isButtonPressed(button: int): boolean;
	abstract isButtonJustPressed(button: int): boolean;
	abstract isKeyPressed(key: int): boolean;
	abstract isKeyJustPressed(key: int): boolean;
	abstract getTextInput(listener: TextInputListener, title: String, text: String, hint: String): void;
	abstract setOnscreenKeyboardVisible(visible: boolean): void;
	abstract vibrate(milliseconds: int): void;
	abstract vibrate(pattern: number[], repeat: int): void;
	abstract cancelVibrate(): void;
	abstract getAzimuth(): float;
	abstract getPitch(): float;
	abstract getRoll(): float;
	abstract getRotationMatrix(matrix: float[]): void;
	abstract getCurrentEventTime(): number;
	abstract setCatchBackKey(catchBack: boolean): void;
	abstract isCatchBackKey(): boolean;
	abstract setCatchMenuKey(catchMenu: boolean): void;
	abstract isCatchMenuKey(): boolean;
	abstract setInputProcessor(processor: InputProcessor): void;
	abstract getInputProcessor(): InputProcessor;
	abstract isPeripheralAvailable(peripheral: Peripheral): boolean;
	abstract getRotation(): int;
	abstract getNativeOrientation(): Orientation;
	abstract setCursorCatched(catched: boolean): void;
	abstract isCursorCatched(): boolean;
	abstract setCursorPosition(x: int, y: int): void;
}
export declare namespace Input {
	class Buttons {
		static readonly LEFT: number;
		static readonly RIGHT: number;
		static readonly MIDDLE: number;
		static readonly BACK: number;
		static readonly FORWARD: number;
	}
	class Keys {
		static readonly ANY_KEY: number;
		static readonly NUM_0: number;
		static readonly NUM_1: number;
		static readonly NUM_2: number;
		static readonly NUM_3: number;
		static readonly NUM_4: number;
		static readonly NUM_5: number;
		static readonly NUM_6: number;
		static readonly NUM_7: number;
		static readonly NUM_8: number;
		static readonly NUM_9: number;
		static readonly A: number;
		static readonly ALT_LEFT: number;
		static readonly ALT_RIGHT: number;
		static readonly APOSTROPHE: number;
		static readonly AT: number;
		static readonly B: number;
		static readonly BACK: number;
		static readonly BACKSLASH: number;
		static readonly C: number;
		static readonly CALL: number;
		static readonly CAMERA: number;
		static readonly CLEAR: number;
		static readonly COMMA: number;
		static readonly D: number;
		static readonly DEL: number;
		static readonly BACKSPACE: number;
		static readonly FORWARD_DEL: number;
		static readonly DPAD_CENTER: number;
		static readonly DPAD_DOWN: number;
		static readonly DPAD_LEFT: number;
		static readonly DPAD_RIGHT: number;
		static readonly DPAD_UP: number;
		static readonly CENTER: number;
		static readonly DOWN: number;
		static readonly LEFT: number;
		static readonly RIGHT: number;
		static readonly UP: number;
		static readonly E: number;
		static readonly ENDCALL: number;
		static readonly ENTER: number;
		static readonly ENVELOPE: number;
		static readonly EQUALS: number;
		static readonly EXPLORER: number;
		static readonly F: number;
		static readonly FOCUS: number;
		static readonly G: number;
		static readonly GRAVE: number;
		static readonly H: number;
		static readonly HEADSETHOOK: number;
		static readonly HOME: number;
		static readonly I: number;
		static readonly J: number;
		static readonly K: number;
		static readonly L: number;
		static readonly LEFT_BRACKET: number;
		static readonly M: number;
		static readonly MEDIA_FAST_FORWARD: number;
		static readonly MEDIA_NEXT: number;
		static readonly MEDIA_PLAY_PAUSE: number;
		static readonly MEDIA_PREVIOUS: number;
		static readonly MEDIA_REWIND: number;
		static readonly MEDIA_STOP: number;
		static readonly MENU: number;
		static readonly MINUS: number;
		static readonly MUTE: number;
		static readonly N: number;
		static readonly NOTIFICATION: number;
		static readonly NUM: number;
		static readonly O: number;
		static readonly P: number;
		static readonly PERIOD: number;
		static readonly PLUS: number;
		static readonly POUND: number;
		static readonly POWER: number;
		static readonly Q: number;
		static readonly R: number;
		static readonly RIGHT_BRACKET: number;
		static readonly S: number;
		static readonly SEARCH: number;
		static readonly SEMICOLON: number;
		static readonly SHIFT_LEFT: number;
		static readonly SHIFT_RIGHT: number;
		static readonly SLASH: number;
		static readonly SOFT_LEFT: number;
		static readonly SOFT_RIGHT: number;
		static readonly SPACE: number;
		static readonly STAR: number;
		static readonly SYM: number;
		static readonly T: number;
		static readonly TAB: number;
		static readonly U: number;
		static readonly UNKNOWN: number;
		static readonly V: number;
		static readonly VOLUME_DOWN: number;
		static readonly VOLUME_UP: number;
		static readonly W: number;
		static readonly X: number;
		static readonly Y: number;
		static readonly Z: number;
		static readonly META_ALT_LEFT_ON: number;
		static readonly META_ALT_ON: number;
		static readonly META_ALT_RIGHT_ON: number;
		static readonly META_SHIFT_LEFT_ON: number;
		static readonly META_SHIFT_ON: number;
		static readonly META_SHIFT_RIGHT_ON: number;
		static readonly META_SYM_ON: number;
		static readonly CONTROL_LEFT: number;
		static readonly CONTROL_RIGHT: number;
		static readonly ESCAPE: number;
		static readonly END: number;
		static readonly INSERT: number;
		static readonly PAGE_UP: number;
		static readonly PAGE_DOWN: number;
		static readonly PICTSYMBOLS: number;
		static readonly SWITCH_CHARSET: number;
		static readonly BUTTON_CIRCLE: number;
		static readonly BUTTON_A: number;
		static readonly BUTTON_B: number;
		static readonly BUTTON_C: number;
		static readonly BUTTON_X: number;
		static readonly BUTTON_Y: number;
		static readonly BUTTON_Z: number;
		static readonly BUTTON_L1: number;
		static readonly BUTTON_R1: number;
		static readonly BUTTON_L2: number;
		static readonly BUTTON_R2: number;
		static readonly BUTTON_THUMBL: number;
		static readonly BUTTON_THUMBR: number;
		static readonly BUTTON_START: number;
		static readonly BUTTON_SELECT: number;
		static readonly BUTTON_MODE: number;
		static readonly NUMPAD_0: number;
		static readonly NUMPAD_1: number;
		static readonly NUMPAD_2: number;
		static readonly NUMPAD_3: number;
		static readonly NUMPAD_4: number;
		static readonly NUMPAD_5: number;
		static readonly NUMPAD_6: number;
		static readonly NUMPAD_7: number;
		static readonly NUMPAD_8: number;
		static readonly NUMPAD_9: number;
		static readonly COLON: number;
		static readonly F1: number;
		static readonly F2: number;
		static readonly F3: number;
		static readonly F4: number;
		static readonly F5: number;
		static readonly F6: number;
		static readonly F7: number;
		static readonly F8: number;
		static readonly F9: number;
		static readonly F10: number;
		static readonly F11: number;
		static readonly F12: number;
		static toString(keycode: number): string;
	}
}
export declare class Random {
	private static readonly MBIG;
	private static readonly MSEED;
	private static readonly MZ;
	private inext;
	private inextp;
	private SeedArray;
	constructor(Seed?: int);
	private getSampleForLargeRange;
	private internalSample;
	Next(): int;
	Next(minValue: int, maxValue: int): int;
	Next(maxValue: int): int;
	NextBytes(buffer: Uint8Array): void;
	nextDouble(): double;
	protected sample(): double;
}
export declare abstract class Console {
	static Error: {
		new (): {};
		Write(str: string, ...args: any[]): void;
		WriteLine(str: string, ...args: any[]): void;
	};
	abstract Write(value: any): any;
	abstract Write(str: string, ...args: any[]): any;
	abstract WriteLine(): any;
	abstract WriteLine(value: any): any;
	abstract WriteLine(str: string, ...args: any[]): any;
	abstract WriteHex(b: ByteArray): any;
	static Write(value: any): any;
	static Write(str: string, ...args: any[]): any;
	static WriteLine(): any;
	static WriteLine(value: any): any;
	static WriteLine(str: string, ...args: any[]): any;
	static WriteHex(b: ByteArray): void;
}
export interface IServiceProvider {
	GetService(serviceType: Type): any;
}
export declare class Locale {
	static GetText(value: any): any;
	static GetText(str: string, ...args: any[]): any;
}
export declare const Syntax: {
	AssignmentExpression: string;
	AssignmentPattern: string;
	ArrayExpression: string;
	ArrayPattern: string;
	ArrowFunctionExpression: string;
	AwaitExpression: string;
	BlockStatement: string;
	BinaryExpression: string;
	BreakStatement: string;
	CallExpression: string;
	CatchClause: string;
	ClassBody: string;
	ClassDeclaration: string;
	ClassExpression: string;
	ConditionalExpression: string;
	ContinueStatement: string;
	DoWhileStatement: string;
	DebuggerStatement: string;
	EmptyStatement: string;
	ExportAllDeclaration: string;
	ExportDefaultDeclaration: string;
	ExportNamedDeclaration: string;
	ExportSpecifier: string;
	ExpressionStatement: string;
	ForStatement: string;
	ForOfStatement: string;
	ForInStatement: string;
	FunctionDeclaration: string;
	FunctionExpression: string;
	Identifier: string;
	IfStatement: string;
	Import: string;
	ImportDeclaration: string;
	ImportDefaultSpecifier: string;
	ImportNamespaceSpecifier: string;
	ImportSpecifier: string;
	Literal: string;
	LabeledStatement: string;
	LogicalExpression: string;
	MemberExpression: string;
	MetaProperty: string;
	MethodDefinition: string;
	NewExpression: string;
	ObjectExpression: string;
	ObjectPattern: string;
	Program: string;
	Property: string;
	RestElement: string;
	ReturnStatement: string;
	ToExpression: string;
	SequenceExpression: string;
	SpreadElement: string;
	Super: string;
	SwitchCase: string;
	SwitchStatement: string;
	TaggedTemplateExpression: string;
	TemplateElement: string;
	TemplateLiteral: string;
	ThisExpression: string;
	ThrowStatement: string;
	TryStatement: string;
	UnaryExpression: string;
	UpdateExpression: string;
	VariableDeclaration: string;
	VariableDeclarator: string;
	WhileStatement: string;
	InstructionStatement: string;
	WithStatement: string;
	YieldExpression: string;
};
export declare class TuvalScript {
	static Parse(code: string, options: any, delegate: any): any;
	static ParseModule(code: string, options: any, delegate: any): any;
	static ParseScript(code: string, options: any, delegate: any): any;
	static Tokenize(code: string, options: any, delegate: any): any;
}
export declare function sprintf(key: string, ...args: any[]): string;
export declare function vsprintf(fmt: string, argv: any[]): string;
export declare class ResourceManager {
	private m_Culture;
	private m_ResourcePage;
	private m_ResourceItems;
	constructor(resourceName: string);
	GetString(name: string): string;
}
export interface IAsyncResult {
	AsyncState: any;
	AsyncWaitHandle: any;
	CompletedSynchronously: boolean;
	IsCompleted: boolean;
}
export declare class Int16 {
	static MaxValue: number;
	static MinValue: number;
}
export declare class Int32 {
	static MaxValue: number;
	static MinValue: number;
	static GetHashCode(value: int): int;
}
export declare class UInt32 {
	static MaxValue: number;
	static MinValue: number;
	static GetHashCode(value: int): int;
}
declare class ReadOnlyCollection<T> implements IList<T>, IReadOnlyList<T> {
	private list;
	constructor(list: IList<T>);
	get Count(): int;
	Get(index: int): T;
	Set(index: int, value: T): void;
	Contains(value: T): boolean;
	CopyTo(array: T[], index: int): void;
	GetEnumerator(): IEnumerator<T>;
	IndexOf(value: T): int;
	protected get Items(): IList<T>;
	get IsReadOnly(): boolean;
	Add(value: T): void;
	Clear(): void;
	Insert(index: int, value: T): void;
	Remove(value: T): boolean;
	RemoveAt(index: int): void;
}
declare type Calendar = any;
declare class DateTimeOffset implements IFormattable, IComparable<DateTimeOffset>, IEquatable<DateTimeOffset> {
	static readonly MaxOffset: long;
	static readonly MinOffset: long;
	private static readonly UnixEpochTicks;
	private static readonly UnixEpochSeconds;
	private static readonly UnixEpochMilliseconds;
	static readonly MinValue: DateTimeOffset;
	static readonly MaxValue: DateTimeOffset;
	private m_dateTime;
	private m_offsetMinutes;
	constructor(ticks: long, offset: TimeSpan);
	constructor(dateTime: DateTime, offset: TimeSpan);
	constructor(dateTime: DateTime);
	constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, offset: TimeSpan);
	constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, offset: TimeSpan);
	constructor(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: Calendar, offset: TimeSpan);
	static get Now(): DateTimeOffset;
	static get UtcNow(): DateTimeOffset;
	get DateTime(): DateTime;
	get UtcDateTime(): DateTime;
	get LocalDateTime(): DateTime;
	ToOffset(offset: TimeSpan): DateTimeOffset;
	private get ClockDateTime();
	get Date(): DateTime;
	get Day(): int;
	get DayOfWeek(): DayOfWeek;
	get DayOfYear(): int;
	get Hour(): int;
	get Millisecond(): int;
	get Minute(): int;
	get Month(): int;
	get Offset(): TimeSpan;
	get Second(): int;
	get Ticks(): long;
	get UtcTicks(): long;
	get TimeOfDay(): TimeSpan;
	get Year(): int;
	Add(timeSpan: TimeSpan): DateTimeOffset;
	AddDays(days: double): DateTimeOffset;
	AddHours(hours: double): DateTimeOffset;
	AddMilliseconds(milliseconds: double): DateTimeOffset;
	AddMinutes(minutes: double): DateTimeOffset;
	AddMonths(months: int): DateTimeOffset;
	AddSeconds(seconds: double): DateTimeOffset;
	AddTicks(ticks: long): DateTimeOffset;
	AddYears(years: int): DateTimeOffset;
	static Compare(first: DateTimeOffset, second: DateTimeOffset): int;
	CompareTo(other: DateTimeOffset): int;
	Equals(other: DateTimeOffset): boolean;
	EqualsExact(other: DateTimeOffset): boolean;
	static Equals(first: DateTimeOffset, second: DateTimeOffset): boolean;
	static FromFileTime(fileTime: long): DateTimeOffset;
	static FromUnixTimeSeconds(seconds: long): DateTimeOffset;
	static FromUnixTimeMilliseconds(milliseconds: long): DateTimeOffset;
	GetHashCode(): int;
	static Parse(input: string): DateTimeOffset;
	static Parse(input: string, formatProvider: IFormatProvider): DateTimeOffset;
	static Parse(input: string, formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset;
	static ParseExact(input: string, format: string, formatProvider: IFormatProvider): DateTimeOffset;
	static ParseExact(input: string, format: string, formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset;
	static ParseExact(input: string, formats: string[], formatProvider: IFormatProvider, styles: DateTimeStyles): DateTimeOffset;
	Subtract(value: DateTimeOffset): TimeSpan;
	Subtract(value: TimeSpan): DateTimeOffset;
	ToFileTime(): long;
	ToUnixTimeSeconds(): long;
	ToUnixTimeMilliseconds(): long;
	ToLocalTime(): DateTimeOffset;
	ToLocalTime(throwOnOverflow: boolean): DateTimeOffset;
	ToString(): string;
	ToString(format: string): string;
	ToString(formatProvider: IFormatProvider): string;
	ToString(format: string, formatProvider: IFormatProvider): string;
	ToUniversalTime(): DateTimeOffset;
	static TryParse(input: string, result: Out<DateTimeOffset>): boolean;
	static TryParse(input: string, formatProvider: IFormatProvider, styles: DateTimeStyles, result: Out<DateTimeOffset>): boolean;
	static TryParseExact(input: string, format: string, formatProvider: IFormatProvider, styles: DateTimeStyles, result: Out<DateTimeOffset>): boolean;
	static TryParseExact(input: string, formats: string[], formatProvider: IFormatProvider, styles: DateTimeStyles, result: Out<DateTimeOffset>): boolean;
	private static ValidateOffset;
	private static ValidateDate;
	private static ValidateStyles;
	static FromDateTime(dateTime: DateTime): DateTimeOffset;
	Sub(timeSpan: TimeSpan): DateTimeOffset;
}
export declare const TimeZones: {
	"Afghanistan Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Alaskan Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Aleutian Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Altai Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Arab Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Arabian Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Arabic Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2004: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Argentina Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Astrakhan Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Atlantic Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"AUS Central Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Aus Central W. Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"AUS Eastern Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Azerbaijan Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Azores Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Bahia Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Bangladesh Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Belarus Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Bougainville Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Canada Central Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Cape Verde Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Caucasus Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Cen. Australia Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Central America Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Central Asia Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Central Brazilian Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2004: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Central Europe Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Central European Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Central Pacific Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Central Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Central Standard Time (Mexico)": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Chatham Islands Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"China Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Cuba Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2003: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2004: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Dateline Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"E. Africa Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"E. Australia Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"E. Europe Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"E. South America Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2004: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Easter Island Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Eastern Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Eastern Standard Time (Mexico)": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Egypt Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Ekaterinburg Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Fiji Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2021: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2022: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2023: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2024: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2025: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2026: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2027: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2028: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2029: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"FLE Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Georgian Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"GMT Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Greenland Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2004: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2021: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Greenwich Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"GTB Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Haiti Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Hawaiian Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"India Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Iran Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2004: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2021: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2022: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2023: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2024: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Israel Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2004: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2021: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2022: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2023: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Jordan Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Kaliningrad Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Kamchatka Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Korea Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Libya Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Line Islands Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Lord Howe Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Magadan Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Magallanes Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Marquesas Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Mauritius Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Mid-Atlantic Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Middle East Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2021: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Montevideo Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Morocco Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2021: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2022: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2023: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2024: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2025: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2026: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2027: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2028: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2029: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Mountain Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Mountain Standard Time (Mexico)": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Myanmar Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"N. Central Asia Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Namibia Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Nepal Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"New Zealand Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Newfoundland Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Norfolk Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"North Asia East Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"North Asia Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"North Korea Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Omsk Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Pacific SA Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Pacific Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Pacific Standard Time (Mexico)": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Pakistan Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Paraguay Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2021: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Qyzylorda Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Romance Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Russia Time Zone 10": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Russia Time Zone 11": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Russia Time Zone 3": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Russian Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"SA Eastern Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"SA Pacific Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"SA Western Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Saint Pierre Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Sakhalin Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Samoa Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Sao Tome Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Saratov Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"SE Asia Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Singapore Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"South Africa Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Sri Lanka Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Sudan Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Syria Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2004: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Taipei Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Tasmania Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Tocantins Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Tokyo Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Tomsk Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Tonga Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Transbaikal Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Turkey Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Turks And Caicos Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Ulaanbaatar Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"US Eastern Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"US Mountain Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	UTC: {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"UTC+12": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"UTC+13": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"UTC-02": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"UTC-08": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"UTC-09": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"UTC-11": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Venezuela Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Vladivostok Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Volgograd Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"W. Australia Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2005: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"W. Central Africa Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"W. Europe Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"W. Mongolia Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"West Asia Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"West Bank Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"West Pacific Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
	};
	"Yakutsk Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
	"Yukon Standard Time": {
		DisplayName: string;
		Dlt: string;
		Std: string;
		TZI: {
			Bias: number;
			StandardBias: number;
			DaylightBias: number;
			StandardDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
			DaylightDate: {
				Year: number;
				Month: number;
				DayOfWeek: number;
				Day: number;
				Hour: number;
				Minute: number;
				Second: number;
				Milliseconds: number;
			};
		};
		"Dynamic DST": {
			FirstEntry: number;
			LastEntry: number;
			2006: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2007: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2008: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2009: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2010: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2011: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2012: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2013: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2014: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2015: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2016: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2017: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2018: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2019: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2020: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
			2021: {
				Bias: number;
				StandardBias: number;
				DaylightBias: number;
				StandardDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
				DaylightDate: {
					Year: number;
					Month: number;
					DayOfWeek: number;
					Day: number;
					Hour: number;
					Minute: number;
					Second: number;
					Milliseconds: number;
				};
			};
		};
	};
};
declare class SystemTime {
	Year: int;
	Month: int;
	DayOfWeek: int;
	Day: int;
	Hour: int;
	Minute: int;
	Second: int;
	Milliseconds: int;
}
export declare class DynamicTimeZoneInformation {
	Bias: int;
	StandardName: string;
	StandardDate: SystemTime;
	StandardBias: int;
	DaylightName: string;
	DaylightDate: SystemTime;
	DaylightBias: int;
	TimeZoneKeyName: string;
	DynamicDaylightTimeDisabled: boolean;
}
export declare class TimeZoneInformation {
	Bias: int;
	StandardName: string;
	StandardDate: SystemTime;
	StandardBias: int;
	DaylightName: string;
	DaylightDate: SystemTime;
	DaylightBias: int;
	constructor(dtzi: DynamicTimeZoneInformation);
}
export declare enum TimeZoneInfoOptions {
	None = 1,
	NoThrowOnInvalidTime = 2
}
export declare class AdjustmentRule implements IEquatable<AdjustmentRule> {
	private m_dateStart;
	private m_dateEnd;
	private m_daylightDelta;
	private m_daylightTransitionStart;
	private m_daylightTransitionEnd;
	private m_baseUtcOffsetDelta;
	get DateStart(): DateTime;
	get DateEnd(): DateTime;
	get DaylightDelta(): TimeSpan;
	get DaylightTransitionStart(): TransitionTime;
	get DaylightTransitionEnd(): TransitionTime;
	get BaseUtcOffsetDelta(): TimeSpan;
	get HasDaylightSaving(): boolean;
	Equals(other: AdjustmentRule): boolean;
	GetHashCode(): int;
	private AdjustmentRule;
	static CreateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime): AdjustmentRule;
	static CreateAdjustmentRule(dateStart: DateTime, dateEnd: DateTime, daylightDelta: TimeSpan, daylightTransitionStart: TransitionTime, daylightTransitionEnd: TransitionTime, baseUtcOffsetDelta: TimeSpan): AdjustmentRule;
	IsStartDateMarkerForBeginningOfYear(): boolean;
	IsEndDateMarkerForEndOfYear(): boolean;
	private static ValidateAdjustmentRule;
}
export declare class TransitionTime implements IEquatable<TransitionTime> {
	private m_timeOfDay;
	private m_month;
	private m_week;
	private m_day;
	private m_dayOfWeek;
	private m_isFixedDateRule;
	get TimeOfDay(): DateTime;
	get Month(): int;
	get Week(): int;
	get Day(): int;
	get DayOfWeek(): DayOfWeek;
	get IsFixedDateRule(): boolean;
	Equals(other: TransitionTime): boolean;
	NotEquals(other: TransitionTime): boolean;
	GetHashCode(): int;
	static CreateFixedDateRule(timeOfDay: DateTime, month: int, day: int): TransitionTime;
	static CreateFloatingDateRule(timeOfDay: DateTime, month: int, week: int, dayOfWeek: DayOfWeek): TransitionTime;
	private static CreateTransitionTime;
	private static ValidateTransitionTime;
}
export declare class TimeZoneInfo implements IEquatable<TimeZoneInfo> {
	private m_id;
	private m_displayName;
	private m_standardDisplayName;
	private m_daylightDisplayName;
	private m_baseUtcOffset;
	private m_supportsDaylightSavingTime;
	private m_adjustmentRules;
	private static readonly c_timeZonesRegistryHive;
	private static readonly c_timeZonesRegistryHivePermissionList;
	private static readonly c_displayValue;
	private static readonly c_daylightValue;
	private static readonly c_standardValue;
	private static readonly c_muiDisplayValue;
	private static readonly c_muiDaylightValue;
	private static readonly c_muiStandardValue;
	private static readonly c_timeZoneInfoValue;
	private static readonly c_firstEntryValue;
	private static readonly c_lastEntryValue;
	private static readonly c_utcId;
	private static readonly c_localId;
	private static readonly c_maxKeyLength;
	private static readonly c_regByteLength;
	private static readonly c_ticksPerMillisecond;
	private static readonly c_ticksPerSecond;
	private static readonly c_ticksPerMinute;
	private static readonly c_ticksPerHour;
	private static readonly c_ticksPerDay;
	private static readonly c_ticksPerDayRange;
	private static s_cachedData;
	private static s_maxDateOnly;
	private static s_minDateOnly;
	get Id(): string;
	get DisplayName(): string;
	get StandardName(): string;
	get DaylightName(): string;
	get BaseUtcOffset(): TimeSpan;
	get SupportsDaylightSavingTime(): boolean;
	GetAdjustmentRules(): AdjustmentRule[];
	GetAmbiguousTimeOffsets(dateTimeOffset: DateTimeOffset): TimeSpan[];
	GetAmbiguousTimeOffsets(dateTime: DateTime): TimeSpan[];
	GetUtcOffset(dateTimeOffset: DateTimeOffset): TimeSpan;
	GetUtcOffset(dateTime: DateTime): TimeSpan;
	GetUtcOffset(dateTime: DateTime, flags: TimeZoneInfoOptions): TimeSpan;
	private getUtcOffset;
	static GetLocalUtcOffset(dateTime: DateTime, flags: TimeZoneInfoOptions): TimeSpan;
	IsAmbiguousTime(dateTimeOffset: DateTimeOffset): boolean;
	IsAmbiguousTime(dateTime: DateTime): boolean;
	IsAmbiguousTime(dateTime: DateTime, flags: TimeZoneInfoOptions): boolean;
	IsDaylightSavingTime(dateTimeOffset: DateTimeOffset): boolean;
	IsDaylightSavingTime(dateTime: DateTime): boolean;
	IsDaylightSavingTime(dateTime: DateTime, flags: TimeZoneInfoOptions): boolean;
	private isDaylightSavingTime;
	IsInvalidTime(dateTime: DateTime): boolean;
	static ClearCachedData(): void;
	static ConvertTimeBySystemTimeZoneId(dateTimeOffset: DateTimeOffset, destinationTimeZoneId: string): DateTimeOffset;
	static ConvertTimeBySystemTimeZoneId(dateTime: DateTime, destinationTimeZoneId: string): DateTime;
	static ConvertTimeBySystemTimeZoneId(dateTime: DateTime, sourceTimeZoneId: string, destinationTimeZoneId: string): DateTime;
	static ConvertTime(dateTimeOffset: DateTimeOffset, destinationTimeZone: TimeZoneInfo): DateTimeOffset;
	static ConvertTime(dateTime: DateTime, destinationTimeZone: TimeZoneInfo): DateTime;
	static ConvertTime(dateTime: DateTime, sourceTimeZone: TimeZoneInfo, destinationTimeZone: TimeZoneInfo): DateTime;
	static ConvertTime(dateTime: DateTime, sourceTimeZone: TimeZoneInfo, destinationTimeZone: TimeZoneInfo, flags: TimeZoneInfoOptions): DateTime;
	private static convertTime;
	static ConvertTimeFromUtc(dateTime: DateTime, destinationTimeZone: TimeZoneInfo): DateTime;
	static ConvertTimeToUtc(dateTime: DateTime): DateTime;
	static ConvertTimeToUtc(dateTime: DateTime, flags: TimeZoneInfoOptions): DateTime;
	static ConvertTimeToUtc(dateTime: DateTime, sourceTimeZone: TimeZoneInfo): DateTime;
	Equals(other: TimeZoneInfo): boolean;
	GetHashCode(): int;
	static GetSystemTimeZones(): ReadOnlyCollection<TimeZoneInfo>;
	HasSameRules(other: TimeZoneInfo): boolean;
	static get Local(): TimeZoneInfo;
	ToString(): string;
	static get Utc(): TimeZoneInfo;
	constructor(zone: TimeZoneInformation, dstDisabled: boolean);
	constructor(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: AdjustmentRule[], disableDaylightSavingTime: boolean);
	static CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string): TimeZoneInfo;
	static CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: AdjustmentRule[]): TimeZoneInfo;
	static CreateCustomTimeZone(id: string, baseUtcOffset: TimeSpan, displayName: string, standardDisplayName: string, daylightDisplayName: string, adjustmentRules: AdjustmentRule[], disableDaylightSavingTime: boolean): TimeZoneInfo;
	private GetAdjustmentRuleForTime;
	private static CheckDaylightSavingTimeNotSupported;
	private static ConvertUtcToTimeZone;
	private static CreateAdjustmentRuleFromTimeZoneInformation;
	private static FindIdFromTimeZoneInformation;
	private static GetDaylightTime;
	private static GetIsDaylightSavings;
	private static GetIsDaylightSavingsFromUtc;
	private static CheckIsDst;
	private static GetIsAmbiguousTime;
	private static GetIsInvalidTime;
	private static GetLocalTimeZone;
	static GetLocalTimeZoneFromWin32Data(timeZoneInformation: TimeZoneInformation, dstDisabled: boolean): TimeZoneInfo;
	static FindSystemTimeZoneById(id: string): TimeZoneInfo;
	private static GetUtcOffset;
	static GetUtcOffsetFromUtc(time: DateTime, zone: TimeZoneInfo): TimeSpan;
	static GetUtcOffsetFromUtc(time: DateTime, zone: TimeZoneInfo, isDaylightSavings: Out<boolean>): TimeSpan;
	static GetUtcOffsetFromUtc(time: DateTime, zone: TimeZoneInfo, isDaylightSavings: Out<boolean>, isAmbiguousLocalDst: Out<boolean>): TimeSpan;
	static GetDateTimeNowUtcOffsetFromUtc(time: DateTime, isAmbiguousLocalDst: Out<boolean>): TimeSpan;
	private static TransitionTimeFromTimeZoneInformation;
	private static TransitionTimeToDateTime;
	private static TryCreateAdjustmentRules;
	private static TryCompareStandardDate;
	private static TryCompareTimeZoneInformationToRegistry;
	private static TryGetLocalizedNamesByRegistryKey;
	private static TryGetTimeZoneByRegistryKey;
	private static TryGetTimeZone;
	static UtcOffsetOutOfRange(offset: TimeSpan): boolean;
	private static ValidateTimeZoneInfo;
}
declare enum GregorianCalendarTypes {
	Localized = 1,
	USEnglish = 2,
	MiddleEastFrench = 9,
	Arabic = 10,
	TransliteratedEnglish = 11,
	TransliteratedFrench = 12
}
declare class GregorianCalendar extends Calendar {
	protected dispose(disposing: boolean): void;
	static readonly ADEra: int;
	static readonly DatePartYear: int;
	static readonly DatePartDayOfYear: int;
	static readonly DatePartMonth: int;
	static readonly DatePartDay: int;
	static readonly MaxYear: int;
	static readonly MinYear: int;
	m_type: GregorianCalendarTypes;
	static readonly DaysToMonth365: IntArray;
	static readonly DaysToMonth366: IntArray;
	private static s_defaultInstance;
	Get_MinSupportedDateTime(): DateTime;
	Get_MaxSupportedDateTime(): DateTime;
	Get_AlgorithmType(): CalendarAlgorithmType;
	static GetDefaultInstance(): Calendar;
	constructor(type?: GregorianCalendarTypes);
	protected Get_CalendarType(): GregorianCalendarTypes;
	get CalendarType(): GregorianCalendarTypes;
	protected Set_CalendarType(value: GregorianCalendarTypes): void;
	set CalendarType(value: GregorianCalendarTypes);
	Get_ID(): int;
	GetDatePart(ticks: long, part: int): int;
	static GetAbsoluteDate(year: int, month: int, day: int): long;
	DateToTicks(year: int, month: int, day: int): long;
	AddMonths(time: DateTime, months: int): DateTime;
	AddYears(time: DateTime, years: int): DateTime;
	GetDayOfMonth(time: DateTime): int;
	GetDayOfWeek(time: DateTime): DayOfWeek;
	GetDayOfYear(time: DateTime): int;
	GetDaysInMonth(year: int, month: int, era: int): int;
	GetDaysInMonth(year: int, month: int): int;
	GetDaysInYear(year: int): int;
	GetDaysInYear(year: int, era: int): int;
	GetEra(time: DateTime): int;
	protected Get_Eras(): IntArray;
	GetMonth(time: DateTime): int;
	GetMonthsInYear(year: int, era: int): int;
	GetMonthsInYear(year: int): int;
	GetYear(time: DateTime): int;
	IsLeapDay(year: int, month: int, day: int, era: int): boolean;
	IsLeapDay(year: int, month: int, day: int): boolean;
	GetLeapMonth(year: int): int;
	GetLeapMonth(year: int, era: int): int;
	IsLeapMonth(year: int, month: int, era: int): boolean;
	IsLeapMonth(year: int, month: int): boolean;
	IsLeapYear(year: int): boolean;
	IsLeapYear(year: int, era: int): boolean;
	ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
	ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
	TryToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int, result: Out<DateTime>): boolean;
	private static readonly DEFAULT_TWO_DIGIT_YEAR_MAX;
	protected Get_TwoDigitYearMax(): int;
	protected Set_TwoDigitYearMax(value: int): void;
	ToFourDigitYear(year: int): int;
}
declare class EraInfo {
	era: int;
	ticks: long;
	yearOffset: int;
	minEraYear: int;
	maxEraYear: int;
	eraName: string;
	abbrevEraName: string;
	englishEraName: string;
	constructor(era: int, startYear: int, startMonth: int, startDay: int, yearOffset: int, minEraYear: int, maxEraYear: int);
	constructor(era: int, startYear: int, startMonth: int, startDay: int, yearOffset: int, minEraYear: int, maxEraYear: int, eraName: string, abbrevEraName: string, englishEraName: string);
}
declare class GregorianCalendarHelper {
	static readonly TicksPerMillisecond: long;
	static readonly TicksPerSecond: long;
	static readonly TicksPerMinute: long;
	static readonly TicksPerHour: long;
	static readonly TicksPerDay: long;
	static readonly MillisPerSecond: int;
	static readonly MillisPerMinute: int;
	static readonly MillisPerHour: int;
	static readonly MillisPerDay: int;
	static readonly DaysPerYear: int;
	static readonly DaysPer4Years: int;
	static readonly DaysPer100Years: int;
	static readonly DaysPer400Years: int;
	static readonly DaysTo10000: int;
	static MaxMillis: long;
	static readonly DatePartYear: int;
	static readonly DatePartDayOfYear: int;
	static readonly DatePartMonth: int;
	static readonly DatePartDay: int;
	get MaxYear(): int;
	static readonly DaysToMonth365: IntArray;
	static readonly DaysToMonth366: IntArray;
	m_maxYear: int;
	m_minYear: int;
	m_Cal: Calendar;
	m_EraInfo: EraInfo[];
	m_eras: IntArray;
	m_minDate: DateTime;
	constructor(cal: Calendar, eraInfo: EraInfo[]);
	private GetYearOffset;
	GetGregorianYear(year: int, era: int): int;
	IsValidYear(year: int, era: int): boolean;
	GetDatePart(ticks: long, part: int): int;
	static GetAbsoluteDate(year: int, month: int, day: int): long;
	static DateToTicks(year: int, month: int, day: int): long;
	static TimeToTicks(hour: int, minute: int, second: int, millisecond: int): long;
	CheckTicksRange(ticks: long): void;
	AddMonths(time: DateTime, months: int): DateTime;
	AddYears(time: DateTime, years: int): DateTime;
	GetDayOfMonth(time: DateTime): int;
	GetDayOfWeek(time: DateTime): DayOfWeek;
	GetDayOfYear(time: DateTime): int;
	GetDaysInMonth(year: int, month: int, era: int): int;
	GetDaysInYear(year: int, era: int): int;
	GetEra(time: DateTime): int;
	get Eras(): IntArray;
	GetMonth(time: DateTime): int;
	GetMonthsInYear(year: int, era: int): int;
	GetYear(time: DateTime): int;
	GetYear(year: int, time: DateTime): int;
	IsLeapDay(year: int, month: int, day: int, era: int): boolean;
	GetLeapMonth(year: int, era: int): int;
	IsLeapMonth(year: int, month: int, era: int): boolean;
	IsLeapYear(year: int, era: int): boolean;
	ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
	GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
	ToFourDigitYear(year: int, twoDigitYearMax: int): int;
}
declare class TaiwanCalendar extends Calendar {
	protected dispose(disposing: boolean): void;
	static taiwanEraInfo: EraInfo[];
	static s_defaultInstance: Calendar;
	helper: GregorianCalendarHelper;
	static GetDefaultInstance(): Calendar;
	static readonly calendarMinValue: DateTime;
	Get_MinSupportedDateTime(): DateTime;
	Get_MaxSupportedDateTime(): DateTime;
	Get_AlgorithmType(): CalendarAlgorithmType;
	constructor();
	protected Get_ID(): int;
	AddMonths(time: DateTime, months: int): DateTime;
	AddYears(time: DateTime, years: int): DateTime;
	GetDaysInMonth(year: int, month: int, era: int): int;
	GetDaysInMonth(year: int, month: int): int;
	GetDaysInYear(year: int): int;
	GetDaysInYear(year: int, era: int): int;
	GetDayOfMonth(time: DateTime): int;
	GetDayOfWeek(time: DateTime): DayOfWeek;
	GetDayOfYear(time: DateTime): int;
	GetMonthsInYear(year: int, era: int): int;
	GetMonthsInYear(year: int): int;
	GetWeekOfYear(time: DateTime, rule: CalendarWeekRule, firstDayOfWeek: DayOfWeek): int;
	GetEra(time: DateTime): int;
	GetMonth(time: DateTime): int;
	GetYear(time: DateTime): int;
	IsLeapDay(year: int, month: int, day: int, era: int): boolean;
	IsLeapDay(year: int, month: int, day: int): boolean;
	IsLeapYear(year: int): boolean;
	IsLeapYear(year: int, era: int): boolean;
	GetLeapMonth(year: int): int;
	GetLeapMonth(year: int, era: int): int;
	IsLeapMonth(year: int, month: int, era: int): boolean;
	IsLeapMonth(year: int, month: int): boolean;
	ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int): DateTime;
	ToDateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, era: int): DateTime;
	protected Get_Eras(): IntArray;
	private static readonly DEFAULT_TWO_DIGIT_YEAR_MAX;
	protected Get_TwoDigitYearMax(): int;
	protected Set_TwoDigitYearMax(value: int): void;
	ToFourDigitYear(year: int): int;
}
export declare const GlobalizationModule: {
	TimeZoneInfo: (string | typeof TimeZoneInfo)[];
	TaiwanCalendar: (string | typeof TaiwanCalendar)[];
	GregorianCalendar: (string | typeof GregorianCalendar)[];
	CultureInfo: (string | typeof CultureInfo)[];
};
export declare class TNumber {
	static Precision(value: float): int;
	static ToString(format: string, value: int): string;
}
export declare class CanvasModule extends TModule {
	private m_Canvas;
	get Canvas(): HTMLCanvasElement;
	private m_Context2D;
	get Context2D(): CanvasRenderingContext2D;
	constructor(width: int, height: int, silence?: boolean, fullscreen?: boolean, parent?: any);
	private removeAllChildNodes;
}
interface ICryptoTransform extends IDisposable {
	InputBlockSize: int;
	OutputBlockSize: int;
	CanTransformMultipleBlocks: boolean;
	CanReuseTransform: boolean;
	TransformBlock(inputBuffer: ByteArray, inputOffset: int, inputCount: int, outputBuffer: ByteArray, outputOffset: int): int;
	TransformFinalBlock(inputBuffer: ByteArray, inputOffset: int, inputCount: int): ByteArray;
}
declare enum CipherMode {
	CBC = 1,
	ECB = 2,
	OFB = 3,
	CFB = 4,
	CTS = 5
}
declare enum PaddingMode {
	None = 1,
	PKCS7 = 2,
	Zeros = 3,
	ANSIX923 = 4,
	ISO10126 = 5
}
declare class KeySizes {
	private m_minSize;
	private m_maxSize;
	private m_skipSize;
	get MinSize(): int;
	get MaxSize(): int;
	get SkipSize(): int;
	constructor(minSize: int, maxSize: int, skipSize: int);
	IsLegal(keySize: int): boolean;
	static IsLegalKeySize(legalKeys: KeySizes[], size: int): boolean;
}
declare abstract class SymmetricAlgorithm extends TObject {
	protected BlockSizeValue: int;
	protected FeedbackSizeValue: int;
	protected IVValue: ByteArray;
	protected KeyValue: ByteArray;
	protected LegalBlockSizesValue: KeySizes[];
	protected LegalKeySizesValue: KeySizes[];
	protected KeySizeValue: int;
	protected ModeValue: CipherMode;
	protected PaddingValue: PaddingMode;
	protected constructor();
	Dispose(): void;
	Clear(): void;
	protected dispose(disposing: boolean): void;
	protected Get_BlockSize(): int;
	protected Set_BlockSize(value: int): void;
	get BlockSize(): int;
	set BlockSize(value: int);
	protected Get_FeedbackSize(): int;
	protected Set_FeedbackSize(value: int): void;
	get FeedbackSize(): int;
	set FeedbackSize(value: int);
	protected Get_IV(): ByteArray;
	protected Set_IV(value: ByteArray): void;
	get IV(): ByteArray;
	set IV(value: ByteArray);
	protected Get_Key(): ByteArray;
	protected Set_Key(value: ByteArray): void;
	get Key(): ByteArray;
	set Key(value: ByteArray);
	protected Get_LegalBlockSizes(): KeySizes[];
	get LegalBlockSizes(): KeySizes[];
	protected Get_LegalKeySizes(): KeySizes[];
	get LegalKeySizes(): KeySizes[];
	protected Get_KeySize(): int;
	protected Set_KeySize(value: int): void;
	get KeySize(): int;
	set KeySize(value: int);
	protected Get_Mode(): CipherMode;
	protected Set_Mode(value: CipherMode): void;
	get Mode(): CipherMode;
	set Mode(value: CipherMode);
	protected Get_Padding(): PaddingMode;
	protected Set_Padding(value: PaddingMode): void;
	get Padding(): PaddingMode;
	set Padding(value: PaddingMode);
	ValidKeySize(bitLength: int): boolean;
	static Create(): SymmetricAlgorithm;
	CreateDecryptor(): ICryptoTransform;
	CreateDecryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	CreateEncryptor(): ICryptoTransform;
	CreateEncryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	abstract GenerateKey(): void;
	abstract GenerateIV(): void;
}
export declare abstract class Aes extends SymmetricAlgorithm {
	private static s_legalBlockSizes;
	private static s_legalKeySizes;
	protected constructor();
	static Create(): Aes;
}
declare class AesManaged extends Aes {
	private m_rijndael;
	constructor();
	protected Get_FeedbackSize(): int;
	protected Set_FeedbackSize(value: int): void;
	protected Get_IV(): ByteArray;
	protected Set_IV(value: ByteArray): void;
	protected Get_Key(): ByteArray;
	protected Set_Key(value: ByteArray): void;
	protected Get_KeySize(): int;
	protected Set_KeySize(value: int): void;
	protected Get_Mode(): CipherMode;
	protected Set_Mode(value: CipherMode): void;
	protected Get_Padding(): PaddingMode;
	protected Set_Padding(value: PaddingMode): void;
	CreateDecryptor(): ICryptoTransform;
	CreateDecryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	CreateEncryptor(): ICryptoTransform;
	CreateEncryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	protected dispose(disposing: boolean): void;
	GenerateIV(): void;
	GenerateKey(): void;
}
declare class MyAesCryptoServiceProvider extends Aes {
	constructor();
	GenerateIV(): void;
	GenerateKey(): void;
	CreateDecryptor(): ICryptoTransform;
	CreateDecryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	CreateEncryptor(): ICryptoTransform;
	CreateEncryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	protected Set_Mode(value: CipherMode): void;
}
export declare abstract class DES extends SymmetricAlgorithm {
	private static readonly keySizeByte;
	protected constructor();
	static Create(): DES;
	static readonly weakKeys: ByteArray[];
	static readonly semiWeakKeys: ByteArray[];
	static IsWeakKey(rgbKey: ByteArray): boolean;
	static IsSemiWeakKey(rgbKey: ByteArray): boolean;
	protected Get_Key(): ByteArray;
	protected Set_Key(value: ByteArray): void;
}
declare class DESCryptoServiceProvider extends DES {
	constructor();
	CreateDecryptor(): ICryptoTransform;
	CreateDecryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	CreateEncryptor(): ICryptoTransform;
	CreateEncryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	GenerateIV(): void;
	GenerateKey(): void;
}
declare abstract class HashAlgorithm extends TObject implements ICryptoTransform {
	protected HashValue: ByteArray;
	protected HashSizeValue: int;
	protected State: int;
	private disposed;
	protected constructor();
	protected Get_CanTransformMultipleBlocks(): boolean;
	get CanTransformMultipleBlocks(): boolean;
	protected Get_CanReuseTransform(): boolean;
	get CanReuseTransform(): boolean;
	Clear(): void;
	ComputeHash(buffer: ByteArray): ByteArray;
	ComputeHash(buffer: ByteArray, offset: int, count: int): ByteArray;
	ComputeHash(inputStream: Stream): ByteArray;
	static Create(): HashAlgorithm;
	protected Get_Hash(): ByteArray;
	get Hash(): ByteArray;
	protected abstract HashCore(array: ByteArray, ibStart: int, cbSize: int): void;
	protected abstract HashFinal(): ByteArray;
	protected Get_HashSize(): int;
	get HashSize(): int;
	abstract Initialize(): void;
	protected dispose(disposing: boolean): void;
	protected Get_InputBlockSize(): int;
	get InputBlockSize(): int;
	protected Get_OutputBlockSize(): int;
	get OutputBlockSize(): int;
	TransformBlock(inputBuffer: ByteArray, inputOffset: int, inputCount: int, outputBuffer: ByteArray, outputOffset: int): int;
	TransformFinalBlock(inputBuffer: ByteArray, inputOffset: int, inputCount: int): ByteArray;
}
declare class BlockProcessor extends TObject {
	private transform;
	private block;
	private blockSize;
	private blockCount;
	constructor(transform: ICryptoTransform);
	constructor(transform: ICryptoTransform, blockSize: int);
	protected dispose(disposing: boolean): void;
	Initialize(): void;
	Core(rgb: ByteArray): void;
	Core(rgb: ByteArray, ib: int, cb: int): void;
	Final(): ByteArray;
}
declare abstract class KeyedHashAlgorithm extends HashAlgorithm {
	protected KeyValue: ByteArray;
	protected constructor();
	protected Get_Key(): ByteArray;
	protected Set_Key(value: ByteArray): void;
	get Key(): ByteArray;
	set Key(value: ByteArray);
	protected dispose(disposing: boolean): void;
	private ZeroizeKey;
	static Create(): KeyedHashAlgorithm;
}
export declare abstract class HMAC extends KeyedHashAlgorithm {
	private _disposed;
	private _hashName;
	private _algo;
	private _block;
	private _blockSizeValue;
	protected constructor();
	protected get BlockSizeValue(): int;
	protected set BlockSizeValue(value: int);
	get HashName(): string;
	set HashName(value: string);
	protected Set_Key(value: ByteArray): void;
	get Block(): BlockProcessor;
	private KeySetup;
	protected dispose(disposing: boolean): void;
	protected HashCore(rgb: ByteArray, ib: int, cb: int): void;
	protected HashFinal(): ByteArray;
	Initialize(): void;
	SetHash(name: string, instance: HashAlgorithm): void;
	static Create(): HMAC;
}
export declare class HMACSHA1 extends HMAC {
	constructor(key?: ByteArray);
}
export declare abstract class MD5 extends HashAlgorithm {
	protected constructor();
	static Create(): MD5;
}
declare class MD5CryptoServiceProvider extends MD5 {
	private static readonly BLOCK_SIZE_BYTES;
	private _H;
	private buff;
	private count;
	private _ProcessingBuffer;
	private _ProcessingBufferCount;
	constructor();
	protected dispose(disposing: boolean): void;
	protected HashCore(rgb: ByteArray, ibStart: int, cbSize: int): void;
	protected HashFinal(): ByteArray;
	Initialize(): void;
	private ProcessBlock;
	private ProcessFinalBlock;
	private AddLength;
	private static readonly K;
}
export declare abstract class RC2 extends SymmetricAlgorithm {
	static Create(): RC2;
	protected EffectiveKeySizeValue: int;
	protected Get_EffectiveKeySize(): int;
	protected Set_EffectiveKeySize(value: int): void;
	get EffectiveKeySize(): int;
	set EffectiveKeySize(value: int);
	protected Set_KeySize(value: int): void;
	protected constructor();
}
declare class RC2CryptoServiceProvider extends RC2 {
	private _useSalt;
	constructor();
	protected Set_EffectiveKeySize(value: int): void;
	CreateDecryptor(): ICryptoTransform;
	CreateDecryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	CreateEncryptor(): ICryptoTransform;
	CreateEncryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	GenerateIV(): void;
	GenerateKey(): void;
	get UseSalt(): boolean;
	set UseSalt(value: boolean);
}
declare abstract class Rijndael extends SymmetricAlgorithm {
	private static s_legalBlockSizes;
	private static s_legalKeySizes;
	protected constructor();
	static Create(): Rijndael;
}
declare class RijndaelManaged extends Rijndael {
	constructor();
	CreateEncryptor(): ICryptoTransform;
	CreateEncryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	CreateDecryptor(): ICryptoTransform;
	CreateDecryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	GenerateKey(): void;
	GenerateIV(): void;
	private NewEncryptor;
}
declare abstract class RandomNumberGenerator implements IDisposable {
	protected constructor();
	static Create(): RandomNumberGenerator;
	Dispose(): void;
	protected dispose(disposing: boolean): void;
	GetBytes(data: ByteArray): void;
	GetBytes(data: ByteArray, offset: int, count: int): void;
	GetNonZeroBytes(data: ByteArray): void;
}
declare class RNGCryptoServiceProvider extends RandomNumberGenerator {
	private _handle;
	constructor();
	constructor(rgb: ByteArray);
	constructor(str: string);
	private Check;
	private static RngOpen;
	private static _seedBytes;
	private static RngInitialize;
	private static RngGetBytes;
	private static RngClose;
	GetBytes(data: ByteArray): void;
	GetBytes(data: ByteArray, data_length: IntPtr): void;
	GetNonZeroBytes(data: ByteArray): void;
	protected dispose(disposing: boolean): void;
}
export declare abstract class SHA1 extends HashAlgorithm {
	protected constructor();
	static Create(): SHA1;
}
declare class SHA1CryptoServiceProvider extends SHA1 {
	private sha;
	constructor();
	protected dispose(disposing: boolean): void;
	protected HashCore(rgb: ByteArray, ibStart: int, cbSize: int): void;
	protected HashFinal(): ByteArray;
	Initialize(): void;
}
export declare abstract class SHA256 extends HashAlgorithm {
	protected constructor();
	static Create(): SHA256;
}
declare class SHA256Managed extends SHA256 {
	private static readonly BLOCK_SIZE_BYTES;
	private _H;
	private count;
	private _ProcessingBuffer;
	private _ProcessingBufferCount;
	private buff;
	constructor();
	protected HashCore(rgb: ByteArray, ibStart: int, cbSize: int): void;
	protected HashFinal(): ByteArray;
	Initialize(): void;
	private ProcessBlock;
	private ProcessFinalBlock;
	AddLength(length: BigNumber, buffer: ByteArray, position: int): void;
}
export declare abstract class SHA384 extends HashAlgorithm {
	protected constructor();
	static Create(): SHA384;
}
declare class SHA384Managed extends SHA384 {
	private xBuf;
	private xBufOff;
	private byteCount1;
	private byteCount2;
	private H1;
	private H2;
	private H3;
	private H4;
	private H5;
	private H6;
	private H7;
	private H8;
	private W;
	private wOff;
	constructor();
	private initialize;
	Initialize(): void;
	protected HashCore(rgb: ByteArray, ibStart: int, cbSize: int): void;
	protected HashFinal(): ByteArray;
	private update;
	private processWord;
	private unpackWord;
	private adjustByteCounts;
	private processLength;
	private processBlock;
}
export declare abstract class SHA512 extends HashAlgorithm {
	protected constructor();
	static Create(): SHA512;
}
declare class SHA512Managed extends SHA512 {
	private xBuf;
	private xBufOff;
	private byteCount1;
	private byteCount2;
	private H1;
	private H2;
	private H3;
	private H4;
	private H5;
	private H6;
	private H7;
	private H8;
	private W;
	private wOff;
	constructor();
	private initialize;
	Initialize(): void;
	protected HashCore(rgb: ByteArray, ibStart: int, cbSize: int): void;
	protected HashFinal(): ByteArray;
	private update;
	private processWord;
	private unpackWord;
	private adjustByteCounts;
	private processLength;
	private processBlock;
	private rotateRight;
	private Ch;
	private Maj;
	private Sum0;
	private Sum1;
	private Sigma0;
	private Sigma1;
}
export declare abstract class TripleDES extends SymmetricAlgorithm {
	protected constructor();
	Get_Key(): ByteArray;
	Set_Key(value: ByteArray): void;
	static IsWeakKey(rgbKey: ByteArray): boolean;
	static Create(): TripleDES;
}
declare class TripleDESCryptoServiceProvider extends TripleDES {
	constructor();
	GenerateIV(): void;
	GenerateKey(): void;
	CreateDecryptor(): ICryptoTransform;
	CreateDecryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
	CreateEncryptor(): ICryptoTransform;
	CreateEncryptor(rgbKey: ByteArray, rgbIV: ByteArray): ICryptoTransform;
}
declare function coerceArray(arg: any, copy?: any): any;
declare function createArray(length: any): Uint8Array;
declare function copyArray(sourceArray: any, targetArray: any, targetStart?: any, sourceStart?: any, sourceEnd?: any): void;
declare class convertUtf8 {
	static toBytes(text: any): any;
	static fromBytes(bytes: any): string;
}
declare class convertHex {
	static toBytes(text: any): any[];
	static fromBytes(bytes: any): string;
}
export declare class _AES {
	private _Ke;
	private _Kd;
	private key;
	constructor(key: any);
	private _prepare;
	encrypt(plaintext: Uint8Array): Uint8Array;
	decrypt(ciphertext: Uint8Array): Uint8Array;
}
declare class ModeOfOperationECB {
	private description;
	private name;
	private _aes;
	constructor(key: any);
	encrypt(plaintext: string): Uint8Array;
	decrypt(ciphertext: string): Uint8Array;
}
declare class ModeOfOperationCBC {
	private description;
	private name;
	private _aes;
	private _lastCipherblock;
	constructor(key: any, iv: any);
	encrypt(plaintext: string): Uint8Array;
	decrypt(ciphertext: string): Uint8Array;
}
declare class ModeOfOperationCFB {
	private description;
	private name;
	private _aes;
	private segmentSize;
	private _shiftRegister;
	constructor(key: any, iv: any, segmentSize: any);
	encrypt(plaintext: string): any;
	decrypt(ciphertext: string): any;
}
declare class ModeOfOperationOFB {
	private description;
	private name;
	private _aes;
	private _lastPrecipher;
	private _lastPrecipherIndex;
	constructor(key: any, iv: any);
	encrypt(plaintext: any): any;
	decrypt(plaintext: any): void;
}
declare class Counter {
	_counter: Uint8Array;
	constructor(initialValue: any);
	setValue(value: any): void;
	setBytes(bytes: any): void;
	increment(): void;
}
declare class ModeOfOperationCTR {
	private description;
	private name;
	private _aes;
	private _counter;
	private _remainingCounter;
	private _remainingCounterIndex;
	constructor(key: any, counter: any);
	encrypt(plaintext: string): any;
	decrypt(plaintext: string): void;
}
declare function pkcs7pad(data: any): Uint8Array;
declare function pkcs7strip(data: any): Uint8Array;
export declare const aesjs: {
	AES: typeof _AES;
	Counter: typeof Counter;
	ModeOfOperation: {
		ecb: typeof ModeOfOperationECB;
		cbc: typeof ModeOfOperationCBC;
		cfb: typeof ModeOfOperationCFB;
		ofb: typeof ModeOfOperationOFB;
		ctr: typeof ModeOfOperationCTR;
	};
	utils: {
		hex: typeof convertHex;
		utf8: typeof convertUtf8;
	};
	padding: {
		pkcs7: {
			pad: typeof pkcs7pad;
			strip: typeof pkcs7strip;
		};
	};
	_arrayTest: {
		coerceArray: typeof coerceArray;
		createArray: typeof createArray;
		copyArray: typeof copyArray;
	};
};
export declare function Generate_key(): string;
export declare class CryptographyUtils {
	static GenerateRandom(size: int): ByteArray;
	static GenerateRandomFromBytes(array: ByteArray, size: int): ByteArray;
}
export declare abstract class MyAes extends SymmetricAlgorithm {
	static Create(): MyAes;
	protected constructor();
}
export declare enum CryptoStreamMode {
	Read = 0,
	Write = 1
}
export declare class CryptoStream extends Stream implements IDisposable {
	private _stream;
	private _Transform;
	private _InputBuffer;
	private _InputBufferIndex;
	private _InputBlockSize;
	private _OutputBuffer;
	private _OutputBufferIndex;
	private _OutputBlockSize;
	private _transformMode;
	private _canRead;
	private _canWrite;
	private _finalBlockTransformed;
	private _leaveOpen;
	constructor(stream: Stream, transform: ICryptoTransform, mode: CryptoStreamMode, leaveOpen?: boolean);
	protected Get_CanRead(): boolean;
	protected Get_CanSeek(): boolean;
	protected Get_CanWrite(): boolean;
	protected Get_Length(): int;
	protected Get_Position(): int;
	protected Set_Position(value: int): void;
	get HasFlushedFinalBlock(): boolean;
	FlushFinalBlock(): void;
	Flush(): void;
	Seek(offset: int, origin: SeekOrigin): int;
	SetLength(value: int): void;
	Read(buffer: ByteArray, offset: int, count: int): int;
	Write(buffer: ByteArray, offset: int, count: int): void;
	Clear(): void;
	protected dispose(disposing: boolean): void;
	private InitializeBuffer;
}
export declare class HMACMD5 extends HMAC {
	constructor(key?: ByteArray);
}
export declare class HMACSHA256 extends HMAC {
	constructor(key?: ByteArray);
}
export declare class HMACSHA384 extends HMAC {
	private legacy;
	constructor(key?: ByteArray);
	get ProduceLegacyHmacValues(): boolean;
	set ProduceLegacyHmacValues(value: boolean);
}
export declare class HMACSHA512 extends HMAC {
	private legacy;
	constructor(key?: ByteArray);
	get ProduceLegacyHmacValues(): boolean;
	set ProduceLegacyHmacValues(value: boolean);
}
export declare const CryptographyModule: {
	AES: (string | typeof AesManaged)[];
	Rijndael: (string | typeof RijndaelManaged)[];
	RandomNumberGenerator: (string | typeof RNGCryptoServiceProvider)[];
	MD5: (string | typeof MD5CryptoServiceProvider)[];
	MYAES: (string | typeof MyAesCryptoServiceProvider)[];
	DES: (string | typeof DESCryptoServiceProvider)[];
	TripleDES: (string | typeof TripleDESCryptoServiceProvider)[];
	RC2: (string | typeof RC2CryptoServiceProvider)[];
	SHA1: (string | typeof SHA1CryptoServiceProvider)[];
	SHA256: (string | typeof SHA256Managed)[];
	SHA384: (string | typeof SHA384Managed)[];
	SHA512: (string | typeof SHA512Managed)[];
	HMACSHA1: (string | typeof HMACSHA1)[];
};
declare class TVCContext {
	tvc: TVC;
	options: any;
	domain: any;
	contexts: any;
	list: any;
	listNames: any;
	listSorted: any[];
	listSortedInContext: any;
	numberOfElements: number;
	numberOfElementsInContext: any;
	firstIndex: any;
	flatList: any;
	lastIndex: any;
	indexSorted: any;
	constructor(tvc: TVC, domain: any, options: any);
	addContext(contextName: any): void;
	reset(contextName: any): void;
	getElementInfosFromFilename(contextName: any, filename: any, type: any, index?: any, indexMap?: any): {
		name: any;
		index: any;
	};
	private getFreeIndex;
	getElement(contextName: any, index: any, errorString?: any): any;
	private getProperty;
	private setProperty;
	private setRangeProperties;
	setElement(contextName: any, element: any, index: any, replace?: boolean, errorString?: string): any;
	addElement(contextName: any, element: any, errorString?: string): any;
	deleteElement(contextName: any, index?: any, errorString?: any): void;
	deleteRange(contextName: any, first?: any, last?: any): void;
	isAny(contextName?: any): boolean;
	getNumberOfElements(contextName?: any): any;
	getHighestElementIndex(contextName: any): number | undefined;
	getLowestElementIndex(contextName: any): number | undefined;
	getFirstElement(contextName?: any): any;
	getLastElement(contextName: any): any;
	getNextElement(contextName?: any): any;
	getPreviousElement(contextName: any): any;
	sort(contextName: any, sortFunction: any): void;
	parseSorted(contextName: any, sortFunction: any, callback: any, extra?: any): void;
	parseAll(contextName: any, callback: any, extra?: any): void;
	private moveToStart;
	private moveToEnd;
	private moveAfter;
	moveBefore(contextName: any, source: any, destination: any): void;
}
declare class Utilities {
	tvc: TVC;
	uniqueIdentifiersOnce: any;
	constructor(tvc: TVC);
	get TVC_Files(): any;
	private getBrowserLanguage;
	private getUniqueIdentifier;
	private getUniqueIdentifierOnce;
	private resetUniqueIdentifierOnce;
	sendCrashMail(): void;
	private sendMail;
	private getFormattedDate;
	private rotate;
	private rotatePoint;
	private rotateCollisionRectangle;
	slice(arr: any, position: any, length: any): any[];
	private trimString;
	private static TVCTEMP_position;
	static TVCTEMPRETURN_end_position: int;
	extractFromString(text: any, start: any, type: any, throwError?: any, options?: any): any;
	private getFromString;
	skipTheSpaces(text: any, start: any): void;
	private extractCharacter;
	private extractString;
	private extractWord;
	private extractNumber;
	getFontString(name: any, height: any, weight: any, italic: any, unused?: any): string;
	getFontStringHeight(fontString: any): number;
	private getTVCRGB;
	private getRGBA;
	private getRGBAColors;
	private getRGBColors;
	getRGBAStringColors(rgbaString: any): any;
	getRGBAString(r: any, g: any, b: any, a?: any): string;
	getModernColorString(color: any, short?: boolean): string;
	private static javascriptColors;
	private getJavascriptColor;
	pokeString(str: any, replacement: any, position: any, length: any): any;
	getFilename(path: any): any;
	getFilenameExtension(path: any): any;
	getFilenameAndExtension(path: any): any;
	getDir(path: any): any;
	convertStringToArrayBuffer(str: any): ArrayBuffer;
	convertArrayBufferToString(arrayBuffer: any): string;
	private loadArraybuffer;
	replaceStringInText(text: any, mark: any, replacement: any, number?: any): any;
	loadScript(scripts: any, options: any, callback: any, extra?: any): void;
	private loadPng;
	private loadImages;
	private convertObjectToArray;
	copyArray(arr: any): any[];
	copyObject(obj: any): {};
	private mergeObjectIntoNewObject;
	getPropertyCase(obj: any, prop: any, noCase: any): any;
	private findPropertyWithProp;
	cleanObject(obj: any, exclude: any, noCase?: any): {};
	isObject(item: any): boolean;
	isArray(item: any): boolean;
	getTag(text: any, tags: any): any;
	isTag(text: any, tags: any): boolean;
	getTagParameter(text: any, tag: any): any;
	private val;
	private skipSpaces;
	flattenObject(objet: any): any[];
	private getDistance;
	private getRotatedPoint;
	private getRotatedBoxPoints;
	private getPropertyFromPath;
	private getProperty;
	private setProperty;
	private getPropertyType;
	private checkAndReturnValueOfType;
	private getCharacterType;
	getZone(rectangle: any, vars: any, scale: any): {
		x: number;
		y: number;
		width: number;
		height: number;
	};
	checkRectangle(rectangle: any, vars: any, dimension?: any): any;
	makeTransparentImage(image: any): HTMLCanvasElement;
	flipCanvas(canvas: any, horizontal: any, vertical: any): HTMLCanvasElement;
	remapBlock(context: any, rgbaSource: any, rgbaDestination: any, coordinates: any): void;
	/**
	 * Hermite resize - fast image resize/resample using Hermite filter. 1 cpu version!
	 *
	 * @param {HtmlElement} canvas
	 * @param {int} width
	 * @param {int} height
	 * @param {boolean} resize_canvas if true, canvas will be resized. Optional.
	 */
	resample_canvas(canvas: any, width: any, height: any, resize_canvas: any): void;
	loadUnlockedImages(pathArray: any, options: any, callback: any, extra?: any): void;
	loadImage(path: any, options: any, callback: any, extra?: any): void;
	loadUnlockedImage(path: any, options: any, callback: any, extra?: any): void;
	loadUnlockedSound(path: any, options: any, callback: any, extra: any): void;
	loadMultipleUnlockedSound(path: any, number: any, options: any, callback: any, extra?: any): void;
	private loadUnlockedBankElement;
	private findEndOfLine;
	private findNextLine;
	private findStartOfLine;
}
declare class TextWindow {
	tvc: TVC;
	screen: Screen;
	utilities: Utilities;
	contextName: string;
	font: any;
	fontString: string;
	fontWidth: number;
	fontHeight: number;
	width: any;
	height: any;
	x: any;
	y: any;
	border: any;
	lineWidth: any;
	lineHeight: any;
	xInside: number;
	yInside: number;
	pen: number;
	paper: number;
	writing: any;
	oldPaper: number;
	oldPen: number;
	oldWriting: number;
	xCursor: number;
	yCursor: number;
	focus: boolean;
	scrollOn: boolean;
	tab: number;
	borderPaper: number;
	borderPen: number;
	titleTop: string;
	titleBottom: string;
	memoryX: number;
	memoryY: number;
	activated: boolean;
	cursorCanvas: HTMLCanvasElement;
	cursorContext: CanvasRenderingContext2D;
	cursorActive: any;
	cursorCount: number;
	cursorFlashCount: number;
	cursorFlash: any;
	cursorImage: any;
	cursorImageCanvas: HTMLCanvasElement;
	cursorImageContext: CanvasRenderingContext2D;
	cursorHandle: any;
	lines: any[];
	linePens: any[];
	linePapers: any[];
	lineWritings: any[];
	cursorActiveSave: any;
	private _cursPen;
	cursorRed: any;
	cursorGreen: any;
	cursorBlue: any;
	yCursorAnchor: number;
	saveWidth: any;
	saveHeight: any;
	saveCanvas: HTMLCanvasElement;
	number: any;
	constructor(tvc: TVC, screen: Screen, contextName: string, definition: any);
	resize(): void;
	private static FLAG_INVERSE;
	private static FLAG_UNDER;
	private static FLAG_SHADE;
	private static FLAG_BOLD;
	private static FLAG_ITALIC;
	private static FLAG_REPLACE;
	private static FLAG_OR;
	private static FLAG_XOR;
	private static FLAG_AND;
	private static FLAG_IGNORE;
	private static FLAG_NORMAL;
	private static FLAG_ONLYPAPER;
	private static FLAG_ONLYPEN;
	private static FLAG_SHADOW;
	private static MASK_WRITING1;
	private static MASK_WRITING2;
	forceCursor(): void;
	restoreCursor(): void;
	cursorOff(): void;
	cursorOn(): void;
	private cursorDraw;
	private setCursPen;
	private setCurs;
	close(): void;
	private clw;
	private windSave;
	private restore;
	private windon;
	private windMove;
	private windSize;
	private setTitleTop;
	private setTitleBottom;
	private setBorder;
	activate(noRestore?: any): void;
	deactivate(): void;
	home(): void;
	private xText;
	private yText;
	setPen(pen: any): void;
	setPaper(paper: any): void;
	private setWriting;
	private setText;
	private getTextStyles;
	setInverse(onOff: any): void;
	private setUnder;
	private setShade;
	private setScroll;
	setCursor(onOff: any): void;
	private cursorUp;
	private cursorDown;
	private cursorLeft;
	private cursorRight;
	private cursorMove;
	private cursPen;
	private xGraphic;
	private yGraphic;
	private cLine;
	private setTab;
	locate(position: any): void;
	anchorYCursor(y?: any): void;
	cMove(displacement: any): void;
	private scroll;
	private hScroll;
	private vScroll;
	centre(text: any): void;
	private paper$;
	private pen$;
	zone$(text: any, zone: any): string;
	private border$;
	private at$;
	private move$;
	printUsing(format: any, variables: any, newLine: any): void;
	print(text: any, newLine?: any, centre?: any): void;
	private getPrintLength;
	private drawBorders;
	private restoreText;
	private createBorderCharacter;
	printLine(line: any, paper: any, pen: any, writing: any, updatePosition: any, inTitle?: any): void;
	private Borders;
}
export declare class Screen {
	tvc: any;
	renderer: any;
	contextName: string;
	utilities: Utilities;
	banks: any;
	className: any;
	dimension: any;
	vars: any;
	scale: any;
	renderScale: any;
	clip: any;
	varsUpdated: any;
	canvas: HTMLCanvasElement;
	context: CanvasRenderingContext2D;
	alphas: any;
	halfBrightMode: any;
	hamMode: boolean;
	pattern: int;
	paintBorder: boolean;
	ink: int;
	fillInk: int;
	borderInk: int;
	inverse: boolean;
	cloned: any;
	linePattern: any[];
	grPosition: any;
	dualPlayfieldFront: boolean;
	dualPlayfieldBack: boolean;
	font: any;
	imageRendering: string;
	drawingHandle: any;
	drawingCount: int;
	onlyInk: boolean;
	xor: boolean;
	reverseImages: boolean;
	bobsContext: TVCContext;
	bobsToUpdate: boolean;
	bobsUpdateOn: boolean;
	bobsPriorityOn: boolean;
	bobsPriorityReverseOn: boolean;
	windows: any;
	windowsZ: any[];
	zones: any[];
	scrolls: any[];
	transparentColors: any[];
	maxZones: int;
	fontHeight: int;
	previousFont: int;
	modified: int;
	currentTextWindow: TextWindow;
	dualPlayfield: boolean;
	pixelMode: any;
	position: any;
	isCenteredX: boolean;
	isCenteredY: boolean;
	font_loaded: boolean;
	font_error: any;
	fontWeight: any;
	fontItalic: boolean;
	fontStretch: boolean;
	formatTextZones: any[];
	previousZone: int;
	mouseZone: int;
	previousMouse: int;
	animTextState: string;
	animTextHandle: any;
	formatTextImages: any;
	formatTextZonesCount: int;
	paint: boolean;
	listCount: int;
	formatTextDone: boolean;
	formatTextResult: any;
	emptyScreen: boolean;
	displayScale: any;
	offset: any;
	numberOfColor: any;
	numberOfColors: any;
	width: any;
	height: any;
	number: number;
	index: number;
	constructor(tvc: any, args: any, tags: any);
	get_this(index: int): any;
	setTags(tags: string[]): void;
	setModified(): void;
	resize(dimension: any): void;
	startDrawing(): void;
	endDrawing(noCursor?: boolean): void;
	setClip(rectangle: any): void;
	setDualPlayfield(screen: any): void;
	setDualPriority(screen: any): void;
	setCenter(inX: any, inY: any): void;
	setHotspot(position: any, fromInstruction: any): void;
	setPosition(position: any, fromInstruction: any): void;
	setSize(dimension: any, fromInstruction: any): void;
	deactivate(): void;
	activate(): void;
	setCloned(screen: any): void;
	xScreen(x: any): any;
	yScreen(y: any): any;
	reserveZone(number: any): void;
	setZone(number: any, rectangle: any): void;
	zone(number: any, position: any): number;
	zoneEnable(number: any, value: any): void;
	isZoneEnabled(number: int): boolean;
	zonesLength(): number;
	resetZone(number: int, position: any): void;
	isIn(position: any): boolean;
	hZone2(position: any): any;
	setHalfBrightColor(p: any): void;
	getPalette(index: any, mask: any): void;
	setPalette(palette: any, tags?: any): void;
	setColour(number: any, color: any): void;
	getColour(number: any): number;
	getColorAlpha(color: any): any;
	getColorString(color: any): any;
	setTransparent(colors: any, trueFalse: any): void;
	setColorAlpha(colors: any, alphas: any): void;
	isTransparentColor(color: any): boolean;
	remap(colorsSource: any, colorsDestination: any, rectangle: any): void;
	findColorIndex(r: any, g: any, b: any): number;
	ink$(value: any): string;
	setFont$(value: any): string;
	setItalic$(value: any): string;
	setBold$(value: any): string;
	setFontSize$(value: any): string;
	setImage$(name: any, path: any): string;
	setLink$(name: any, path: any): string;
	cls(color: any, rectangle?: any): void;
	pasteImage2(bankName: any, number: any, position: any, dimension: any, angle: any, alpha: any, tags: any, contextName: any): void;
	pasteImage(bankName: any, number: any, x: any, y: any, scaleX: any, scaleY: any, angle: any, alpha?: any, tags?: any, contextName?: any): void;
	pasteCanvas(canvas: any, rectangle: any): void;
	paste(bankName: any, number: any, position: any, scale: any, angle: any, alpha: any, tags?: any, contextName?: any): void;
	screenCopy(destination: any, rectangleSource: any, rectangleDestination: any, mode: any): void;
	screenProject(destination: any, x1: any, y1: any, x2: any, y2: any, dx1: any, dy1: any, dx2: any, dy2: any, dx3: any, dy3: any, dx4: any, dy4: any): void;
	defScroll(number: any, rectangle: any, displacement: any): void;
	scroll(number: any): void;
	getImage(bankName: any, index: any, rectangle: any, tags: any, contextName: any): void;
	getImagePalette(bankName: any, mask: any, contextName: any): void;
	setLine(pattern: any): void;
	setInk(color: any, fillInk?: any, borderInk?: any): void;
	setPattern(pattern: any): void;
	setPaint(onOff: boolean): void;
	setWriting(style: any): void;
	getInk(): number;
	getFillInk(): number;
	getBorderInk(): number;
	getCompositeOperation(): "source-over" | "difference";
	plot(position: any, color: any): void;
	draw(rectangle: any): void;
	drawTo(position: any): void;
	grLocate(position: any): void;
	isPixelTransparent(position: any): boolean;
	point(position: any): string | number;
	box(rectangle: any): void;
	bar(rectangle: any): void;
	disc(rectangle: any, angle1: any, angle2: any): void;
	filledEllipse(rectangle: any, angle1: any, angle2: any, rotation?: any): void;
	circle(rectangle: any, angle1: any, angle2: any): void;
	ellipse(rectangle: any, angle1?: any, angle2?: any, rotation?: any): void;
	polyline(coords: any): void;
	polygon(coords: any): void;
	createPattern(pattern: any): CanvasPattern | null;
	Patterns: any[];
	getIconPalette(mask: any, contextName: any): void;
	getIcon(index: any, rectangle: any, tags: any, contextName: any): void;
	getBob(index: any, errorMessage: any, unused?: any): any;
	getNumberOfBobs(): any;
	getHighestBobIndex(): number | undefined;
	getLowestBobIndex(): number | undefined;
	bob(index: any, position: any, image: any, tags: any): any;
	bobDestroy(index: any, fromInstruction: any): void;
	bobsUpdate(force: any): void;
	updateBank(newBank: any, newBankIndex: any): any;
	setBobsUpdate(yes_no: any): void;
	xBob(index: int, fromInstruction: any): any;
	yBob(index: any, fromInstruction: any): any;
	iBob(index: any, fromInstruction: any): any;
	isBob(index: any, fromInstruction: any): boolean;
	limitBob(index: any, rectangle: any, fromInstruction: any): void;
	bobCamera(index: any, position: any, fromInstruction: any): void;
	bobAlpha(index: any, alpha: any, fromInstruction: any): void;
	bobScale(index: any, scale: any, fromInstruction: any): void;
	bobSkew(index: any, skew: any, fromInstruction: any): void;
	bobRotate(index: any, angle: any, fromInstruction: any): void;
	bobVisible(index: any, show_hide: any, fromInstruction: any): void;
	setBobsPriority(on_off: any, fromInstruction: any): void;
	setBobsPriorityReverse(on_off: any, fromInstruction: any): void;
	sortBobsPriority(): void;
	putBob(index: any, fromInstruction: any): void;
	setWindow(number: int): void;
	windOpen(number: any, rectangle: any, border: any, tags: any): void;
	windClose(): void;
	restoreWindows(): void;
	getBlock(number: any, rectangle: any, mask: any): void;
	getCBlock(number: any, rectangle: any, mask: any): void;
	putBlock(number: any, position: any, bitPlanes: any, bitMode: any): void;
	putCBlock(number: any, position: any, bitPlanes: any, bitMode: any): void;
	delBlock(number: any): void;
	revBlock(number: any, hRev: any, vRev: any): void;
	delCBlock(number: any): void;
	doGetBlock(rectangle: any, mask: any): any;
	doSetBlockAlpha(block: any, alpha: any): void;
	doPutBlock(block: any, position: any, bitPlanes: any, bitMode: any): void;
	doDelBlock(blocks: any, number: any): any[];
	setFont(args: any, callback?: any): void;
	setFont_wait(): boolean;
	textLength(text: any): any;
	text(position: any, text: any, align: any): void;
	animateText(onClick: any, options: any): void;
	stopAnimateText(state?: any): void;
	setAnimateTextState(state: any): void;
	formatText(args: any): number;
	formatTextWait(): boolean;
	textBase(): any;
}
export declare class ScreenEmpty {
	private emptyScreen;
	constructor(self?: any);
}
declare class MersenneTwister {
	N: number;
	M: number;
	MATRIX_A: number;
	UPPER_MASK: number;
	LOWER_MASK: number;
	mt: any[];
	mti: number;
	constructor(seed: any);
	private init_genrand;
	private genrand_int32;
	private genrand_real1;
	genrand_res53(): number;
}
declare class Banks {
	tvc: TVC;
	utilities: Utilities;
	manifest: any;
	banks: any[];
	quickBanks: any;
	numberOfSoundsToPreload: any;
	soundPoolSize: any;
	numberOfReserves: number;
	collisionPrecision: any;
	domain: any;
	constructor(tvc: TVC);
	private reserve;
	private erase;
	private eraseTemp;
	private eraseAll;
	private updateBank;
	private bankShrink;
	private bankSwap;
	getBank(bankIndex: any, contextName?: any, bankType?: any, throwError?: boolean): any;
	private getBankElement;
	getStart(bankIndex: any, contextName?: any, elementNumber?: any): number;
	getLength(bankIndex: any, contextName?: any): any;
	private listBank;
	private loadFileToBank;
	getImage(bankName: any, index: any, contextName: any, bankIndex?: any): any;
	private setImageHotSpot;
	private getImageHotSpot;
	insertImage(bankName: any, index: any, name: any, tags: any, contextName: any, bankIndex: any, canvas: any, hotSpot?: any): void;
	private insertImageRange;
	private insertImageFromArray;
	private setImageCanvas;
	private deleteImage;
	private deleteImageRange;
	private deleteImagesFromArray;
	private getImagePalette;
	private processMask;
	private getSound;
	private insertSample;
	private insertSampleRange;
	private deleteSample;
	private deleteSampleRange;
}
declare class Renderer {
	tvc: TVC;
	manifest: any;
	utilities: Utilities;
	banks: Banks;
	canvas: HTMLCanvasElement;
	context: any;
	width: number;
	height: number;
	originalWidth: number;
	originalHeight: number;
	scaleX: any;
	background: any;
	backgroundColor: any;
	redrawBars: boolean;
	xLeftDraw: number;
	yTopDraw: number;
	widthDraw: number;
	heightDraw: number;
	halted: boolean;
	blackAtFirst: boolean;
	fpsRectX: any;
	fpsRectY: any;
	fpsRectWidth: any;
	fpsRectHeight: number;
	debugX: number;
	debugY: number;
	fullScreenIcons: any;
	modified: boolean;
	doubleBuffer: boolean;
	viewOn: boolean;
	fullScreenIconRatio: number;
	resetDisplay: boolean;
	forceOnce: boolean;
	previousFps: any;
	hardLeftX: number;
	hardTopY: number;
	hardWidth: number;
	hardHeight: number;
	scaleY: number;
	platform: string;
	rendering: any;
	xRatioDisplay: number;
	yRatioDisplay: number;
	fullScreenIconOn: any;
	fullScreenIconX: any;
	fullScreenIconWidth: any;
	fullScreenIconY: any;
	fullScreenIconHeight: any;
	guruMeditation: any;
	blackAtFirstCount: number;
	constructor(tvc: TVC, canvas: string | HTMLCanvasElement);
	private init;
	private getSoftwareFromHardwareX;
	private setDoubleBuffer;
	private autoback;
	private screenSwap;
	setModified(): void;
	setBackgroundColor(color: any): void;
	private setView;
	private view;
	private setScreenDisplay;
	render(force?: any): void;
	private isFullScreen;
	isInFullScreenIcon(position: any): any;
	swapFullScreen(): void;
	captureCrash(error: any): void;
	meditate(error?: any): void;
	private drawGuruMeditation;
}
declare class Errors {
	tvc: TVC;
	language: string;
	errors: {
		en: string[];
		fr: string[];
	};
	constructor(tvc: TVC);
	getError(error: any, param?: any): {
		number: any;
		index: string;
		message: any;
	};
	getErrorFromNumber(number: int): {
		number: any;
		message: any;
		index: any;
	};
}
declare class Filesystem {
	tvc: TVC;
	currentPath: string;
	assigns: any;
	noCase: boolean;
	driveToFilesystem: any;
	fileSystems: any;
	nextDescriptor: any;
	driveList: any[];
	nextDrive: number;
	static files: any;
	constructor(tvc: TVC);
	getFile(path: any, options?: any): any;
	private getDescriptor;
	private saveFile;
	loadFile(descriptor: any, options: any, callback: any, extra: any): void;
	saveBinary(descriptor: any, options: any, callback: any, extra?: any): void;
	private saveBank;
	private loadBinary;
	private fileLength;
	private getFilter;
	private dirFirst;
	private dirNext;
	private driveFirst;
	private driveNext;
	private mkDir;
	private exist;
	private rename;
	private kill;
	private dFree;
	private stat;
	private chDir;
	private openFileRequester;
	private openFolderRequester;
	private setDir$;
	private getDir$;
	private assign;
	private parent;
}
declare class AMAL {
	tvc: TVC;
	utilities: Utilities;
	channels: any[];
	numberOfChannels: number;
	handle: boolean;
	isSynchro: boolean;
	private registers;
	callback: any;
	extra: any;
	constructor(tvc: TVC);
	private setSynchro;
	private synchro;
	setOnOff(onOff: any, channelNumber: any): void;
	private freeze;
	private getChannel;
	runChannel(channel: any, code: any, callback: any, extra?: any): void;
	doSynchro(): void;
	private setChannelPosition;
	private setRegister;
	private getRegister;
	private isChannelAnimated;
	private isChannelMoving;
}
declare class Fonts {
	tvc: TVC;
	manifest: any;
	utilities: Utilities;
	banks: Banks;
	miniCanvas: HTMLCanvasElement;
	miniContext: CanvasRenderingContext2D;
	fontInformations: any[];
	windowFonts: any;
	windowFontsInformations: any;
	firstFontHeight: number;
	firstFont: any;
	constructor(tvc: TVC);
	private static EMPTYAMIGACHAR_KERN;
	private static EMPTYAMIGACHAR_SPACE;
	private static EMPTYAMIGACHAR_WIDTH;
	private getFonts;
	private setWindowFont;
	private getFontInformation;
	private getAmigaFontDefinition;
	private getFirstFont;
	private getFont;
	loadFont(fontInformation: any, weight: any, italic: any, stretch: any, callback: any, extra?: any): void;
	private getNumberOfFonts;
	private getFont$;
	private getBaseLine;
	private getTextLength;
	drawAmigaText(context: any, scale: any, x: any, y: any, text: any, font: any, height: any, textAlign: any, textBaseLine: any, direction: any, fillStyle: any, alpha: any, fontWidth: any): void;
	private getAmigaCharacter;
	private getTextMetrics;
	private bitmapFont;
	private bitmapText;
}
export declare const TVC_Files: any;
export declare abstract class TVC<TScreen extends Screen = Screen> {
	IsAsync: boolean;
	tvc: TVC;
	atom: any;
	currentContextName: string;
	memoryHashMultiplier: int;
	loadingCount: int;
	loadingMax: int;
	finalWait: int;
	use: any;
	manifest: any;
	gotoDirectMode: any;
	sources: any;
	localTags: any;
	globalTags: any;
	developerMode: any;
	directMode: boolean;
	toDirectMode: boolean;
	directModeCommand: any;
	directModeNumber: int;
	utilities: Utilities;
	errors: Errors;
	private banks;
	filesystem: Filesystem;
	renderer: Renderer;
	amal: AMAL;
	fonts: Fonts;
	keyShift: int;
	gamepad_Threshold: float;
	gamepad_vertical_axis: int;
	gamepad_horizontal_axis: int;
	gamepad_Keyboard: boolean;
	gamepad_AutoFire: boolean;
	gamepad_AutoMove: boolean;
	gamepads: any;
	sections: any;
	returns: any[];
	section: any;
	position: int;
	parent: any;
	maxLoopTime: int;
	timeCheckCounter: int;
	refreshTrigger: int;
	refreshCounter: int;
	onError: boolean;
	resume: int;
	resumeLabel: int;
	isErrorOn: boolean;
	isErrorProc: boolean;
	lastError: int;
	displayEndAlert: boolean;
	displayErrorAlert: any;
	fix: int;
	degreeRadian: float;
	key$: any[];
	stringKey$: string;
	handleKey$: any;
	results: any[];
	inkeyShift: int;
	memoryBlocks: any[];
	memoryNumbers: int;
	everyPile: any[];
	fps: any[];
	fpsPosition: int;
	frameCounter: int;
	channelsTo: any[];
	amalErrors: any[];
	amalErrorNumberCount: int;
	amalErrorStringCount: int;
	channelBaseSprites: int;
	channelBaseBobs: int;
	updateEveryCount: int;
	isUpdate: boolean;
	blocks: any[];
	cBlocks: any[];
	setBufferSize: int;
	xMouse: int;
	yMouse: int;
	mouseVisibleCount: int;
	synchroList: any[];
	joyLock: any;
	touchEmulation: any;
	everyCount: int;
	everyOn: boolean;
	objectCount: int;
	platform: string;
	platformKeymap: any;
	machine: any;
	endian: any;
	usePalette: boolean;
	useShortColors: boolean;
	showCopperBlack: boolean;
	break: boolean;
	pause: boolean;
	currentScreen: TScreen;
	private pileScreen;
	screensContext: TVCContext;
	private screensZ;
	private degrees;
	private keymap;
	private lastKey;
	private lastKeyCode;
	private lastKeyName;
	private key;
	private keyCode;
	private keyName;
	private modifiers;
	private lastModifiers;
	private static SHIFT;
	private static CONTROL;
	private breakOn;
	private badEnd;
	private positionKey$;
	private clearKeyFlag;
	private lastKeycode;
	private lastKeyPressed;
	private static ALT;
	private static META;
	platformTrue: any;
	private waitVblCount;
	private variablesContext;
	private currentContext;
	private currentSection;
	private root;
	private inputArgs;
	private inputPosition;
	private inputString;
	private inputCursor;
	private inputXCursor;
	private input$String;
	private input$Length;
	private input$length;
	private mouseInside;
	mouseButtons: number;
	private clickMouse;
	private doubleClick;
	private wheelMouse;
	private mouseCurrent;
	private mouseShown;
	private limitMouse;
	private is_touch;
	private ongoingTouches;
	private touches;
	private is_orientable;
	private orientationX;
	private orientationY;
	private orientationZ;
	private is_accelerator;
	private accelerationX;
	private accelerationY;
	private accelerationZ;
	private latitude;
	private longitude;
	private already_fs;
	private procName;
	private orientation;
	private xMouseDebug;
	private yMouseDebug;
	private welcomeClick;
	private removeTouches;
	private stringBaseIndex;
	private waitEnd;
	private timer;
	merseneTwister: MersenneTwister;
	unlimitedScreens: boolean;
	unlimitedWindows: boolean;
	maskHardwareCoordinates: boolean;
	platformFalse: number | boolean;
	defaultPalette: any[];
	waitInstructions: any;
	useSounds: boolean;
	loadingError: any;
	previousTime: any;
	sourcePos: any;
	lastErrorPos: any;
	errorObject: any;
	memoryNumber: any;
	gamepadMaps: any;
	amalStarted: boolean;
	sprites: any;
	connectedToIDE: boolean;
	ideWebSocket: any;
	waiting: any;
	extensionsToRun: any[];
	varsUpdated: any[];
	vars: any;
	modified: any;
	varsthis: any;
	crashInfo: any;
	crash: any;
	loopCounter: number;
	unlimitedBanks: any;
	handle: any;
	moduleRainbows: any;
	pileScreens: any[];
	waitThis: any;
	error: number;
	parentElement: any;
	get Banks(): Banks;
	set Banks(value: Banks);
	constructor(canvas: string | HTMLCanvasElement, options: any);
	abstract CreateScreen(args: any, tags: any): TScreen;
	private isUnderAtom;
	private lastInputYCursor;
	SetInputStringInternal(str: string): void;
	private callWaitFunction;
	private callMethod;
	private runProcedure;
	private runBlocksAsync;
	private runBlocks;
	run(section?: any, position?: any, parent?: any): void;
	stop(): void;
	private initSection;
	private popSection;
	private handleErrors;
	printToDirectMode(text: string): void;
	private callPython;
	private addToSynchro;
	private removeRootObjectFromSynchro;
	private removeFromSynchro;
	private doSynchro;
	private openURL;
	private setUpdate;
	private setBobsUpdate;
	rendererUpdate(): void;
	private update;
	private bobsUpdate;
	private updateEvery;
	private free;
	private fastFree;
	private chipFree;
	private setTags;
	private displayWidth;
	private displayHeight;
	private ntsc;
	allowRefresh(): void;
	private every;
	private everyOnOff;
	screenOpen(args: any, tags: any): TScreen | undefined;
	screenClose(index: any, tags?: any): void;
	private screenClone;
	setScreen(number: any): void;
	getScreen(number: any, error?: any): any;
	private getScreenOrCreateOne;
	private screenIn;
	private mouseScreen;
	private screenToBack;
	screenToFront(index: any): void;
	private screenSkew;
	private screenScale;
	private dualPlayfield;
	private dualPriority;
	private setDefaultPalette;
	private colourBack;
	private swapZScreenPosition;
	private setBelowZScreenPosition;
	private default;
	private lprint;
	private doError;
	private asc;
	private repeat$;
	str$(value: any): string;
	private val;
	private checkIndex;
	private space$;
	private toRadian;
	private toDegree;
	private static keyModifiers;
	private static keyPressed;
	private lastKeyPressTime;
	private repeatTimerDic;
	setKeyboard(): void;
	private convertToPlatform;
	private startKeyboardInput;
	private debugOnKeyPress;
	private putKey;
	private clearKey;
	inkey$(): string;
	getScanCode(): int;
	getKeyState(code: int): boolean | int;
	private getScanShift;
	private getKeyName;
	getKeyShift(shift?: any): number;
	private waitKey;
	private waitKey_wait;
	private waitVbl;
	private waitVbl_wait;
	private isPromiseWaiting;
	private waitPromise;
	private waitPromise_wait;
	private setKey$;
	private getKey$;
	private scan$;
	private varPtr;
	private getVariableDefinition;
	private getVariableType;
	private getVariableName;
	private getVariableValue;
	private setVariable;
	private getVariable;
	private input;
	private input_wait;
	private input$;
	private input$_wait;
	private static buttonToMouse;
	private killEvents;
	private setMouse;
	private onMouseMove;
	private onMouseEnter;
	private onMouseLeave;
	private onMouseWheel;
	private onMouseDown;
	private onMouseUp;
	private onClick;
	private onClickDocument;
	private onDblClick;
	private onContextMenu;
	private onTouchStart;
	private onTouchMove;
	private onTouchEnd;
	private onTouchCancel;
	private onDeviceOrientation;
	private onDeviceMotion;
	private getTouchById;
	private updateTouches;
	private computeTouch;
	private touchOnChange;
	private execTouchOnChange;
	private geoLocation;
	private getTouchX;
	private getTouchY;
	private getTouchState;
	private setMouseLimits;
	private xor;
	private mouseWheel;
	private showMouse;
	private mouseClick;
	private changeMouse;
	private xHard;
	private yHard;
	private xScreen;
	private yScreen;
	private isIn;
	private hZone;
	private mouseZone;
	private setXMouse;
	private setYMouse;
	GetXMouse(x?: any): number;
	GetYMouse(y?: any): number;
	private read;
	private add;
	private getVariableFromDescription;
	private setVariableFromDescription;
	private setStringBaseIndex;
	private instr;
	private string$;
	private trim$;
	private flip$;
	private getLeft$;
	private setLeft$;
	private getMid$;
	private setMid$;
	private getRight$;
	private setRight$;
	private subtractString;
	private isDep;
	private dep;
	ReleaseDep(): void;
	private wait;
	private dep_wait;
	private wait_wait;
	private bin$;
	private hex$;
	private setTimer;
	getTimer(): any;
	rnd(value: any): number;
	private randomize;
	allocMemoryBlock(data: any, endian: any): any;
	freeMemoryBlock(block: any): void;
	getMemoryBlockFromAddress(address: any): any;
	getMemory(number: any): any;
	private poke;
	private doke;
	private loke;
	private peek;
	private deek;
	private leek;
	private poke$;
	private doke$;
	private peek$;
	private deek$;
	private fill;
	private copy;
	private hunt;
	private bSet;
	private bClr;
	private bChg;
	private rolB;
	private rolW;
	private rolL;
	private rorB;
	private rorW;
	private rorL;
	private getBrowserName;
	private browserIsWeird;
	private static GAMEPAD_FIRE;
	private static GAMEPAD_UP;
	private static GAMEPAD_DOWN;
	private static GAMEPAD_RIGHT;
	private static GAMEPAD_LEFT;
	private static GAMEPAD_A;
	private static GAMEPAD_B;
	private static GAMEPAD_X;
	private static GAMEPAD_Y;
	private static GAMEPAD_STICKLEFT;
	private static GAMEPAD_STICKRIGHT;
	private static GAMEPAD_BOTTOMLEFT;
	private static GAMEPAD_TOPLEFT;
	private static GAMEPAD_BOTTOMRIGHT;
	private static GAMEPAD_TOPRIGHT;
	private static GAMEPAD_CENTERLEFT;
	private static GAMEPAD_CENTERRIGHT;
	private static GAMEPAD_HAXELEFT;
	private static GAMEPAD_VAXELEFT;
	private static GAMEPAD_HAXERIGHT;
	private static GAMEPAD_VAXERIGHT;
	private static MAPPING_BUTTONS;
	private static MAPPING_AXES;
	private static MAPPING_TRIGGERS;
	private getGamepadAutoMove;
	private getGamepadKeyboard;
	private getGamepadTreshold;
	private setGamepads;
	private scanGamepads;
	private getMapping;
	private getKeyMapping;
	private setKeyMapping;
	private lockJoystick;
	private jUp;
	private jDown;
	private jLeft;
	private jRight;
	private jUpLeft;
	private jUpRight;
	private jDownLeft;
	private jDownRight;
	private fire;
	private joy;
	private gamepadDisconnected;
	private gamepadConnected;
	private gamepadName$;
	private gamepadVendor$;
	private gamepadProduct$;
	private gamepadNumAxes;
	private gamepadNumButtons;
	private gamepadAxis;
	private gamepadButton;
	private gamepadTrigger;
	private getAnimation;
	private callAnimations;
	private setAnimState;
	private setMoveState;
	private getObjectFromType;
	getAnimationChannel(channelNumber: any, throwError?: any): any;
	private checkAnimationChannel;
	private destroyAnimationChannel;
	private amalOnOff;
	private amalStart;
	private amalStart_wait;
	private amalError;
	private amalError$;
	fp2Int(f: any): number;
	private getBob;
	private getSprite;
	private addObject;
	private setObject;
	private delObject;
	private sendMessage;
	private waitForFinalLoad;
	private waitForGuru;
	private pushExtension;
	static HREV: int;
	static VREV: int;
	private get_fromInstruction;
	private get_x;
	private get_y;
	private get_z;
	private get_width;
	private get_height;
	private get_depth;
	private get_skewX;
	private get_skewY;
	private get_skewZ;
	private get_offsetX;
	private get_offsetY;
	private get_offsetZ;
	private get_scaleX;
	private get_scaleY;
	private get_scaleZ;
	private get_cameraX;
	private get_cameraY;
	private get_cameraZ;
	private get_hotspotX;
	private get_hotspotY;
	private get_hotspotZ;
	private get_image;
	private get_angle;
	private get_alpha;
	private get_visible;
	private set_x;
	private set_y;
	private set_z;
	private set_scaleX;
	private set_scaleY;
	private set_scaleZ;
	private set_offsetX;
	private set_offsetY;
	private set_offsetZ;
	private set_skewX;
	private set_skewY;
	private set_skewZ;
	private set_cameraX;
	private set_cameraY;
	private set_cameraZ;
	private set_hotspotX;
	private set_hotspotY;
	private set_hotspotZ;
	private set_width;
	private set_height;
	private set_depth;
	private set_image;
	private set_angle;
	private set_visible;
	private set_alpha;
	private set_fromInstruction;
	private setPosition;
	private setHotspot;
	setSize(dimension: any, fromInstruction: any): void;
	private setOffset;
	private setSkew;
	private setScale;
	private setCamera;
	private setAngle;
	private setVisible;
	private setAlpha;
	setImage(image: any, fromInstruction: any): void;
	private setGenericCoordinates;
	private setGenericProperty;
	private destroy;
	private m_position;
	private m_hotspot;
	private m_scale;
	private m_rotate;
	private m_skew;
	private m_offset;
	private m_size;
	private m_visible;
	private m_hide;
	private m_show;
	private m_destroy;
	private m_transparency;
	private m_image;
	private m_camera;
	private setModified;
	turnIntoObject(objet: any, setters: any, methods: any, replacements: any): void;
}
declare class Filesystem_Application {
	tvc: TVC;
	noCase: boolean;
	utilities: Utilities;
	data: any[];
	externalFiles: boolean;
	currentPath: any;
	fileList: any[];
	fileListPosition: number;
	constructor(tvc: TVC, noCase: boolean);
	private getFile;
	private findFileInDirectory;
	private storageAvailable;
	private filter;
	static isActive(tvc: any, callback: any, extra: any): boolean;
	private getDriveList;
	private open;
	private close;
	private exist;
	private read;
	private write;
	private mkDir;
	private rename;
	private copy;
	private kill;
	private dFree;
	private stat;
	private chMod;
	private chDir;
	private openFileRequester;
	private openFolderRequester;
	private dirFirst;
	private dirNext;
	private static Filesdata;
}
interface IConsoleCommand {
	CommandName: string;
	GetReturnObject(): any;
	Execute(console: ConsoleBase<any>): void;
	IsWaitable(): boolean;
	IsSubProcess(): boolean;
	GetSubProcessQueue(): Queue<any>;
}
declare class TextTVC extends TVC<Screen> {
	CreateScreen(args: any, tags: any): Screen;
}
export declare abstract class ConsoleCommandBase implements IConsoleCommand {
	CommandName: string;
	protected console: ConsoleBase<any>;
	constructor(console: ConsoleBase<TVC>);
	GetSubProcessQueue(): Queue<any>;
	IsWaitable(): boolean;
	IsSubProcess(): boolean;
	GetReturnObject(): any;
	abstract Execute(console: ConsoleBase<any>): void;
}
declare class PrintConsoleCommand extends ConsoleCommandBase {
	CommandName: string;
	Text: LazyValue<string>;
	Args: any[];
	IsLine: boolean;
	constructor(console: TextConsole<TextTVC>, isLine: boolean, text: LazyValue<string>, args: any[]);
	Execute(console: TextConsole<TextTVC>): void;
}
declare class ZoneConsoleCommand extends PrintConsoleCommand {
	CommandName: string;
	OnMouseMove: Function;
	private m_ZoneId;
	GetReturnObject(): any;
	constructor(console: TextConsole<TextTVC>, text: string, onMouseMove: Function);
	Execute(console: TextConsole<TextTVC>): void;
}
export declare class SubProcessCommandBase extends ConsoleCommandBase {
	Execute(console: ConsoleBase<TVC>): void;
	IsSubProcess(): boolean;
	GetSubProcessQueue(): Queue<any>;
}
declare class LoopQueue extends Queue<ConsoleCommandBase> {
	private commands;
	private pointer;
	private m_InfiniteLoop;
	constructor();
	Enqueue(item: ConsoleCommandBase): void;
	Dequeue(): ConsoleCommandBase;
	Reset(): void;
	Finite(): void;
}
interface IConsoleOptions {
	silence?: boolean;
	width?: int;
	height?: int;
	fullscreen?: boolean;
	parent?: any;
}
declare abstract class ConsoleBase<T extends TVC> extends CanvasModule {
	private root;
	private parent;
	private contextName;
	private manifest;
	tvc: T;
	private vars;
	private procParam$;
	private procParam;
	private blocks;
	m_MainQueue: Queue<IConsoleCommand>;
	m_CurrentQueue: Queue<IConsoleCommand>;
	m_LoopQueue: LoopQueue;
	m_QueueStack: Stack<any>;
	m_ReturnStack: Stack<any>;
	private m_LastCommand;
	Zones: Dictionary<int, ZoneConsoleCommand>;
	private parentElement;
	constructor(options: IConsoleOptions);
	abstract CreateTVC(canvas: HTMLCanvasElement, options: any): T;
	PreRun(): void;
	CallMain(...args: any[]): void;
	Kill(): void;
	private loadFonts;
	private getFontPromises;
	private m_MouseDown;
	private m_LastZone;
	private checkZones;
	private initBlocks;
	Task(callback: Function): void;
	StartLoop(): void;
	EndLoop(): void;
	Wait(timeout: float): void;
	WaitP(promise: Promise<any>, callback: Function): void;
	WaitNextFrame(): void;
	ExitLoop(): void;
	ResetLoop(): void;
	WaitKey(): void;
	get Inkey(): string;
	get KeyCode(): int;
	get KeyStatus(): int;
	KeyState(keyCode: int): boolean;
	get Timer(): int;
}
export declare class TextConsole<T extends TextTVC> extends ConsoleBase<T> {
	CreateTVC(canvas: HTMLCanvasElement, options: any): T;
	Write(): any;
	Write(value: any): any;
	Write(str: string, ...args: any[]): any;
	Write(str: LazyValue<string>, ...args: any[]): any;
	WriteLine(): any;
	WriteLine(value: any): any;
	WriteLine(str: string, ...args: any[]): any;
	WriteLine(str: LazyValue<string>, ...args: any[]): any;
	WriteHex(b: ByteArray): void;
	ReadLine(text: string, callback?: Function): void;
	Locate(x: int, y: int): this;
	Center(text: string): this;
	Clear(color?: int): this;
	Region(text: string, callback: Function): void;
	SetPalette(colors: Array<int>): void;
	Pen(color: int): this;
	Paper(color: int): this;
	Ink(color: int): this;
	DrawBar(x: int, y: int, width: int, height: int): void;
	Inverse(turnOn: boolean): void;
	SetCursor(on: boolean): void;
	Dep(isDep: boolean): void;
}
export declare class Umay extends ConsoleBase<TextTVC> {
	constructor();
	CreateTVC(canvas: HTMLCanvasElement, options: any): TextTVC;
	WaitServerSocketAccept(port: int): void;
}
declare class Socket {
	socketId: int;
	address: string;
	port: int;
	constructor(address: string);
}
export declare class ClientSocket extends Socket {
	private connectResolve;
	private connectReject;
	private readResolve;
	private readReject;
	constructor(address: string, port: int);
	Connect(): Promise<void>;
	Read(): Promise<ByteArray>;
	Write(data: ByteArray): void;
	private connectResponse;
	private readDataRequest;
	Pipe(data: ArrayBuffer): void;
}
export declare class ServerSocket extends Socket {
	ConnectedClients: Dictionary<int, ClientSocket>;
	private listenCallback;
	private acceptResolve;
	private readResolve;
	private readReject;
	constructor(address: string, port: int);
	Listen(): void;
	Accept(): Promise<ClientSocket>;
	Read(): Promise<ByteArray>;
	private accpetReq;
	private readDataRequest;
	Pipe(data: ArrayBuffer): void;
}
export declare class ImageBank {
	tvc: TVC;
	utilities: Utilities;
	palette: any;
	options: any;
	domain: any;
	type: any;
	path: any;
	context: TVCContext;
	collisionMaskAlphaThreshold: any;
	canvas: any;
	canvasRev: any;
	canvasHRev: any;
	canvasVRev: any;
	hotSpotX: any;
	hotSpotY: any;
	collisionMask: any;
	collisionMaskAngle: any;
	collisionMaskPrecision: number;
	width: number;
	height: number;
	collisionMaskWidth: any;
	collisionMaskHeight: any;
	constructor(tvc: TVC, imageList: string | string[], palette: string[], options: any);
	private isType;
	private loadList;
	load(path: any, options: any): Promise<boolean>;
	_load(index: any, name: any, path: any, width?: any, height?: any, tags?: any): Promise<boolean>;
	private add;
	private addRange;
	private getImageCanvas;
	private getImageHotSpot;
	private getCollisionMask;
	private getLength;
	private setLength;
	private setElement;
	private getElement;
	private getPalette;
	private setPalette;
	private reset;
	private delete;
	private deleteRange;
	private setTags;
	private getHotSpot;
	private setHotSpot;
	private erase;
}
export declare const TConsoleManifest: {
	version: number;
	infos: {
		applicationName: string;
		author: string;
		version: string;
		date: string;
		copyright: string;
		start: string;
	};
	compilation: {
		platform: string;
		keymap: string;
		machine: string;
		speed: string;
		syntax: string;
		endian: string;
		stringBaseIndex: number;
		noWarning: never[];
		displayEndAlert: boolean;
		displayErrorAlert: boolean;
		useLocalTabs: boolean;
	};
	display: {
		tvStandard: string;
		width: number;
		height: number;
		background: string;
		backgroundColor: string;
		bodyBackgroundColor: string;
		bodyBackgroundImage: string;
		smoothing: boolean;
		scaleX: number;
		scaleY: number;
		screenScale: number;
		fps: boolean;
		fpsFont: string;
		fpsColor: string;
		fpsX: number;
		fpsY: number;
		fullPage: boolean;
		fullScreen: boolean;
		keepProportions: boolean;
		fullScreenIcon: boolean;
		fullScreenIconX: number;
		fullScreenIconY: number;
		fullScreenIconImage: string;
		smallScreenIconImage: string;
	};
	bootScreen: {
		active: boolean;
		waitSounds: number;
		clickSounds: boolean;
	};
	sprites: {
		collisionBoxed: boolean;
		collisionPrecision: number;
		collisionAlphaThreshold: number;
	};
	rainbows: {
		mode: string;
	};
	fonts: {
		listFonts: string;
		amiga: never[];
		google: string[];
	};
	sounds: {
		mode: string;
		volume: number;
		preload: boolean;
		numberOfSoundsToPreload: number;
		soundPoolSize: number;
	};
	gamepad: {
		mapping: {
			up: string;
			down: string;
			left: string;
			right: string;
			fire: string;
		};
	};
	fileSystem: {
		caseSensitive: boolean;
	};
	default: {
		screen: {
			x: number;
			y: number;
			width: number;
			height: number;
			numberOfColors: number;
			pixelMode: string;
			palette: string[];
			window: {
				x: number;
				y: number;
				width: number;
				height: number;
				border: number;
				paper: number;
				pen: number;
				background: string;
				font: {
					name: string;
					type: string;
					height: number;
				};
				cursorOn: boolean;
				cursorImage: string;
				cursorColors: {
					r: number;
					g: number;
					b: number;
					a: number;
				}[];
			};
		};
	};
};
export declare const TVCModule: {
	TVC_Files: any[];
	Filesystem_Application: (string | typeof Filesystem_Application)[];
};
declare class LoadItem {
	/**
	 * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
	 * (level one) loading, as XHR (level 2) provides its own timeout event.
	 */
	private static LOAD_TIMEOUT_DEFAULT;
	/**
	  * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a
	  * string (recommended), or an HTML tag.
	  * This can also be an object, but in that case it has to include a type and be handled by a plugin.
	  */
	src: string;
	/**
	 * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also
	 * be set manually. This is helpful in cases where a file does not have an extension.
	 */
	type: string;
	/**
	 * A string identifier which can be used to reference the loaded object. If none is provided, this will be
	 * automatically set to the {{#crossLink "src:property"}}{{/crossLink}}.
	 */
	id: string;
	/**
	 * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest
	 * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has
	 * been set above 1 (using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}). Everything with this
	 * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in
	 * order when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}} is set to `true`.
	 */
	maintainOrder: boolean;
	/**
	 * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.
	 */
	callback: string;
	/**
	 * An arbitrary data object, which is included with the loaded object.
	 */
	data: Object;
	/**
	 * The request method used for HTTP calls. Both {{#crossLink "Methods/GET:property"}}{{/crossLink}} or
	 * {{#crossLink "Methods/POST:property"}}{{/crossLink}} request types are supported, and are defined as
	 * constants on {{#crossLink "AbstractLoader"}}{{/crossLink}}.
	 */
	method: string;
	/**
	 * An object hash of name/value pairs to send to the server.
	 */
	values: Object;
	/**
	 * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default
	 * headers when required, including "Origin", "Content-Type", and "X-Requested-With". You may override the
	 * default headers by including them in your headers object.
	 */
	headers: Object;
	/**
	 * Enable credentials for XHR requests.
	 */
	withCredentials: boolean;
	/**
	 * Set the mime type of XHR-based requests. This is automatically set to "text/plain; charset=utf-8" for text
	 * based files (json, xml, text, css, js).
	 */
	mimeType: string;
	/**
	 * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.
	 */
	crossOrigin: boolean;
	/**
	 * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
	 * (level one) loading, as XHR (level 2) provides its own timeout event.
	 */
	loadTimeout: number;
	/**
	 * Create a LoadItem.
	 * <ul>
	 *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink "src:property"}}{{/crossLink}}.</li>
	 *     <li>LoadItem instances are returned as-is</li>
	 *     <li>Objects are returned with any needed properties added</li>
	 * </ul>
	 */
	static Create(value: LoadItem | String | Object): LoadItem | Object;
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * <h4>Example</h4>
	 *
	 *      var loadItem = new LoadItem().set({src:"image.png", maintainOrder:true});
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the LoadItem instance.
	 * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)
	*/
	Set(props: Object): LoadItem;
}
declare class AbstractRequest extends EventDispatcher {
	protected _item: any;
	/**
		 * A base class for actual data requests, such as {{#crossLink "XHRRequest"}}{{/crossLink}}, {{#crossLink "TagRequest"}}{{/crossLink}},
		 * and {{#crossLink "MediaRequest"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the
		 * hood to get data.
		 * @class AbstractRequest
		 * @param {LoadItem} item
		 * @constructor
		 */
	constructor(item: LoadItem);
	/**
	 * Begin a load.
	 * @method load
	 */
	Load(): void;
	/**
	 * Clean up a request.
	 * @method destroy
	 */
	Destroy(): void;
	/**
	 * Cancel an in-progress request.
	 * @method cancel
	 */
	Cancel(): void;
}
declare class TagRequest extends AbstractRequest {
	/**
	 * The HTML tag instance that is used to load.
	 * @property _tag
	 * @type {HTMLElement}
	 * @protected
	 */
	protected _tag: HTMLElement;
	/**
 * The tag attribute that specifies the source, such as "src", "href", etc.
 * @property _tagSrcAttribute
 * @type {String}
 * @protected
 */
	protected _tagSrcAttribute: string;
	/**
	 * A method closure used for handling the tag load event.
	 * @property _loadedHandler
	 * @type {Function}
	 * @private
	 */
	protected _loadedHandler: Function;
	/**
	 * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.
	 * @property _addedToDOM
	 * @type {Boolean}
	 * @private
	 */
	private _addedToDOM;
	protected _loadTimeout: any;
	private _rawResult;
	private _result;
	private resultFormatter;
	/**
	 * An {{#crossLink "AbstractRequest"}}{{/crossLink}} that loads HTML tags, such as images and scripts.
	 * @class TagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
	 */
	constructor(loadItem: LoadItem, tag?: HTMLElement, srcAttribute?: string);
	Load(): void;
	Destroy(): void;
	/**
	 * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT
	 * and LINK tags), but other cases may exist.
	 * @method _handleReadyStateChange
	 * @private
	 */
	protected _handleReadyStateChange(): void;
	/**
	 * Handle any error events from the tag.
	 * @method _handleError
	 * @protected
	 */
	private _handleError;
	/**
	 * Handle the tag's onload callback.
	 * @method _handleTagComplete
	 * @private
	 */
	protected _handleTagComplete(): void;
	/**
	 * The tag request has not loaded within the time specified in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	private _handleTimeout;
	/**
	 * Remove event listeners, but don't destroy the request object
	 * @method _clean
	 * @private
	 */
	protected _clean(): void;
	/**
	 * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio
	 * that is already in a load, but not complete.
	 * @method _handleStalled
	 * @private
	 */
	protected _handleStalled(): void;
}
declare class XHRRequest extends AbstractRequest {
	/**
	 * A reference to the XHR request used to load the content.
	 * @property _request
	 * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}
	 * @private
	 */
	protected _request: XMLHttpRequest;
	/**
	   * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,
	   * typically IE9).
	   * @property _loadTimeout
	   * @type {Number}
	   * @private
	   */
	private _loadTimeout;
	/**
	  * The browser's XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect
	  * the version, so we use capabilities to make a best guess.
	  * @property _xhrLevel
	  * @type {Number}
	  * @default 1
	  * @private
	  */
	private _xhrLevel;
	/**
		* The response of a loaded file. This is set because it is expensive to look up constantly. This property will be
		* null until the file is loaded.
		* @property _response
		* @type {mixed}
		* @private
		*/
	private _response;
	/**
	 * The response of the loaded file before it is modified. In most cases, content is converted from raw text to
	 * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still
	 * want to access the raw content as it was loaded.
	 * @property _rawResponse
	 * @type {String|Object}
	 * @private
	 */
	private _rawResponse;
	private _canceled;
	private _handleLoadStartProxy;
	private _handleProgressProxy;
	private _handleAbortProxy;
	private _handleErrorProxy;
	private _handleTimeoutProxy;
	private _handleLoadProxy;
	private _handleReadyStateChangeProxy;
	private canceled;
	private _responseType;
	loaded: any;
	/**
	 * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used
	 * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.
	 * XHR requests load the content as text or binary data, provide progress and consistent completion events, and
	 * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for
	 * cross-domain loading.
	 * @class XHRRequest
	 * @constructor
	 * @param {Object} item The object that defines the file to load. Please see the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * for an overview of supported file properties.
	 * @extends AbstractLoader
	 */
	constructor(item: Object);
	/**
	 * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.
	 * @property ACTIVEX_VERSIONS
	 * @type {Array}
	 * @since 0.4.2
	 * @private
	 */
	private static ACTIVEX_VERSIONS;
	/**
	 * Look up the loaded result.
	 * @method getResult
	 * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * <ul>
	 *      <li>An image tag (&lt;image /&gt;) for images</li>
	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the
	 *      HTML head.</li>
	 *      <li>A style tag for CSS (&lt;style /&gt;)</li>
	 *      <li>Raw text for TEXT</li>
	 *      <li>A formatted JavaScript object defined by JSON</li>
	 *      <li>An XML document</li>
	 *      <li>An binary arraybuffer loaded by XHR</li>
	 * </ul>
	 * Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	GetResult(raw?: boolean): any;
	Cancel(): void;
	Load(): void;
	SetResponseType(type: string): void;
	/**
	 * Get all the response headers from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match
	 * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,
	 * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE
	 * pair.
	 * @method getAllResponseHeaders
	 * @return {String}
	 * @since 0.4.1
	 */
	GetAllResponseHeaders(): string;
	/**
	 * Get a specific response header from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches
	 * header, unless the field name is Set-Cookie or Set-Cookie2.
	 * @method getResponseHeader
	 * @param {String} header The header name to retrieve.
	 * @return {String}
	 * @since 0.4.1
	 */
	GetResponseHeader(header: string): string;
	/**
	 * The XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	private _handleProgress;
	/**
	 * The XHR request has reported a load start.
	 * @method _handleLoadStart
	 * @param {Object} event The XHR loadStart event.
	 * @private
	 */
	private _handleLoadStart;
	/**
	 * The XHR request has reported an abort event.
	 * @method handleAbort
	 * @param {Object} event The XHR abort event.
	 * @private
	 */
	private _handleAbort;
	/**
	 * The XHR request has reported an error event.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	private _handleError;
	/**
	 * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload
	 * event, so we must monitor the readyStateChange to determine if the file is loaded.
	 * @method _handleReadyStateChange
	 * @param {Object} event The XHR readyStateChange event.
	 * @private
	 */
	private _handleReadyStateChange;
	/**
	 * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has
	 * <code>request.readyState == 4</code>. Only the first call to this method will be processed.
	 *
	 * Note that This method uses {{#crossLink "_checkError"}}{{/crossLink}} to determine if the server has returned an
	 * error code.
	 * @method _handleLoad
	 * @param {Object} event The XHR load event.
	 * @private
	 */
	private _handleLoad;
	/**
	 * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>
	 * callback.
	 * @method _handleTimeout
	 * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.
	 * @private
	 */
	private _handleTimeout;
	/**
	 * Determine if there is an error in the current load.
	 * Currently this checks the status of the request for problem codes, and not actual response content:
	 * <ul>
	 *     <li>Status codes between 400 and 599 (HTTP error range)</li>
	 *     <li>A status of 0, but *only when the application is running on a server*. If the application is running
	 *     on `file:`, then it may incorrectly treat an error on local (or embedded applications) as a successful
	 *     load.</li>
	 * </ul>
	 * @method _checkError
	 * @return {Error} An error with the status code in the `message` argument.
	 * @private
	 */
	private _checkError;
	/**
	 * Validate the response. Different browsers have different approaches, some of which throw errors when accessed
	 * in other browsers. If there is no response, the <code>_response</code> property will remain null.
	 * @method _getResponse
	 * @private
	 */
	private _getResponse;
	/**
	 * Create an XHR request. Depending on a number of factors, we get totally different results.
	 * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>
	 *      <li>XMLHttpRequest are created when available.</li>
	 *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>
	 *      <li>Text requests override the mime type if possible</li>
	 *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>
	 *      <li>Binary loads set the response type to "arraybuffer"</li></ol>
	 * @method _createXHR
	 * @param {Object} item The requested item that is being loaded.
	 * @return {Boolean} If an XHR request or equivalent was successfully created.
	 * @private
	 */
	private _createXHR;
	/**
	 * A request has completed (or failed or canceled), and needs to be disposed.
	 * @method _clean
	 * @private
	 */
	private _clean;
	toString(): string;
}
declare class ErrorEvent extends _Event {
	/**
		 * The short error title, which indicates the type of error that occurred.
		 * @property title
		 * @type String
		 */
	title: string;
	/**
	 * The verbose error message, containing details about the error.
	 * @property message
	 * @type String
	 */
	message: string;
	/**
	 * Additional data attached to an error.
	 * @property data
	 * @type {Object}
	 */
	data: any;
	/**
	 * A general error {{#crossLink "Event"}}{{/crossLink}}, that describes an error that occurred, as well as any details.
	 * @class ErrorEvent
	 * @param {String} [title] The error title
	 * @param {String} [message] The error description
	 * @param {Object} [data] Additional error data
	 * @constructor
	 */
	constructor(title: string, message?: string, data?: any);
	Clone(): ErrorEvent;
}
declare class AbstractLoader extends EventDispatcher {
	/**
	 * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches
	 * used for loading do not pile up resulting in more than one `complete` {{#crossLink "Event"}}{{/crossLink}}.
	 * @property loaded
	 * @type {Boolean}
	 * @default false
	 */
	loaded: boolean;
	/**
	 * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property
	 * is readonly, so {{#crossLink "LoadQueue"}}{{/crossLink}} queues should be closed using {{#crossLink "LoadQueue/close"}}{{/crossLink}}
	 * instead.
	 * @property canceled
	 * @type {Boolean}
	 * @default false
	 * @readonly
	 */
	canceled: boolean;
	/**
	 * The current load progress (percentage) for this item. This will be a number between 0 and 1.
	 *
	 * <h4>Example</h4>
	 *
	 *     var queue = new LoadQueue();
	 *     queue.loadFile("largeImage.png");
	 *     queue.on("progress", function() {
	 *         console.log("Progress:", queue.progress, event.progress);
	 *     });
	 *
	 * @property progress
	 * @type {Number}
	 * @default 0
	 */
	progress: int;
	/**
	 * The type of item this loader will load. See {{#crossLink "AbstractLoader"}}{{/crossLink}} for a full list of
	 * supported types.
	 * @property type
	 * @type {String}
	 */
	type: string;
	/**
   * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader
   * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property
   * can be overridden to provide custom formatting.
   *
   * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be
   * asynchronous, such as creating a new image. The callback function is passed 2 parameters, which are callbacks
   * to handle success and error conditions in the resultFormatter. Note that the resultFormatter method is
   * called in the current scope, as well as the success and error callbacks.
   *
   * <h4>Example asynchronous resultFormatter</h4>
   *
   * 	function _formatResult(loader) {
   * 		return function(success, error) {
   * 			if (errorCondition) { error(errorDetailEvent); }
   * 			success(result);
   * 		}
   * 	}
   * @property resultFormatter
   * @type {Function}
   * @default null
   */
	resultFormatter: Function;
	/**
	 * The {{#crossLink "LoadItem"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink "LoadQueue"}}{{/crossLink}},
	 * but will be available on loaders such as {{#crossLink "XMLLoader"}}{{/crossLink}} and {{#crossLink "ImageLoader"}}{{/crossLink}}.
	 * @property _item
	 * @type {LoadItem|Object}
	 * @private
	 */
	protected _item: LoadItem | Object;
	/**
	  * Whether the loader will try and load content using XHR (true) or HTML tags (false).
	  * @property _preferXHR
	  * @type {Boolean}
	  * @private
	  */
	protected _preferXHR: boolean;
	/**
	  * The loaded result after it is formatted by an optional {{#crossLink "resultFormatter"}}{{/crossLink}}. For
	  * items that are not formatted, this will be the same as the {{#crossLink "_rawResult:property"}}{{/crossLink}}.
	  * The result is accessed using the {{#crossLink "getResult"}}{{/crossLink}} method.
	  * @property _result
	  * @type {Object|String}
	  * @private
	  */
	private _result;
	/**
	 * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink "getResult"}}{{/crossLink}}
	 * method, and passing `true`.
	 */
	private _rawResult;
	/**
	 * A list of items that loaders load behind the scenes. This does not include the main item the loader is
	 * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink "SpriteSheetLoader"}}{{/crossLink}} and
	 * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
	 * @property _loadItems
	 * @type {null}
	 * @protected
	 */
	private _loadedItems;
	/**
	 * The attribute the items loaded using tags use for the source.
	 * @type {string}
	 * @default null
	 * @private
	 */
	protected _tagSrcAttribute: string;
	/**
	 * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.
	 * @property _tag
	 * @type {Object}
	 * @private
	 */
	protected _tag: Object;
	protected _request: TagRequest | XHRRequest;
	private _loadItems;
	/**
	* The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,
	* including the {{#crossLink "LoadQueue"}}{{/crossLink}}.
	* @class AbstractLoader
	* @param {LoadItem|object|string} loadItem The item to be loaded.
	* @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a
	* tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the
	* other, so this is a suggested directive.
	* @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,
	* such as {{#crossLink "IMAGE:property"}}{{/crossLink}}, {{#crossLink "CSS:property"}}{{/crossLink}}, etc.
	* @extends EventDispatcher
	*/
	constructor(loadItem?: LoadItem | object | string, preferXHR?: boolean, type?: string);
	/**
	 * The {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when the overall progress changes. Prior to
	 * version 0.6.0, this was just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event progress
	 * @since 0.3.0
	 */
	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a load starts.
	 * @event loadstart
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.1
	 */
	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the entire queue has been loaded.
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.0
	 */
	/**
	 * The {{#crossLink "ErrorEvent"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was
	 * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was
	 * just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event error
	 * @since 0.3.0
	 */
	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.
	 * This enables loaders to maintain internal queues, and surface file load errors.
	 * @event fileerror
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("fileerror")
	 * @param {LoadItem|object} The item that encountered the error
	 * @since 0.6.0
	 */
	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables
	 * loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}} to maintain internal {{#crossLink "LoadQueue"}}{{/crossLink}}s
	 * and notify when they have loaded a file. The {{#crossLink "LoadQueue"}}{{/crossLink}} class dispatches a
	 * slightly different {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("fileload")
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.6.0
	 */
	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired after the internal request is created, but before a load.
	 * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.
	 * @event initialize
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("initialize")
	 * @param {AbstractLoader} loader The loader that has been initialized.
	 */
	/**
	 * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was
	 * passed into {{#crossLink "LoadQueue"}}{{/crossLink}} using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. However if only a String path was passed in, then it will
	 * be a {{#crossLink "LoadItem"}}{{/crossLink}}.
	 * @method GetItem
	 * @return {Object} The manifest item that this loader is responsible for loading.
	 * @since 0.6.0
	 */
	GetItem(): LoadItem | Object;
	/**
	 * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink "complete:event"}}{{/crossLink}}
	 * event is dispatched.
	 * @method getResult
	 * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded
	 * data (if it exists).
	 * @return {Object}
	 * @since 0.6.0
	 */
	GetResult(raw?: boolean): any;
	/**
	 * Return the `tag` this object creates or uses for loading.
	 * @method getTag
	 * @return {Object} The tag instance
	 * @since 0.6.0
	 */
	GetTag(): Object;
	/**
	 * Set the `tag` this item uses for loading.
	 * @method setTag
	 * @param {Object} tag The tag instance
	 * @since 0.6.0
	 */
	SetTag(tag: Object): void;
	/**
	 * Begin loading the item. This method is required when using a loader by itself.
	 *
	 * <h4>Example</h4>
	 *
	 *      var queue = new LoadQueue();
	 *      queue.on("complete", handleComplete);
	 *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet
	 *      queue.load();
	 *
	 * @method load
	 */
	Load(): void;
	/**
	 * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in
	 * the background), but events will not longer be dispatched.
	 * @method cancel
	 */
	Cancel(): void;
	/**
	 * Clean up the loader.
	 * @method destroy
	 */
	Destroy(): void;
	/**
	 * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}}
	 * to expose items it loads internally.
	 * @method getLoadedItems
	 * @return {Array} A list of the items loaded by the loader.
	 * @since 0.6.0
	 */
	GetLoadedItems(): Array<any>;
	/**
	 * Create an internal request used for loading. By default, an {{#crossLink "XHRRequest"}}{{/crossLink}} or
	 * {{#crossLink "TagRequest"}}{{/crossLink}} is created, depending on the value of {{#crossLink "preferXHR:property"}}{{/crossLink}}.
	 * Other loaders may override this to use different request types, such as {{#crossLink "ManifestLoader"}}{{/crossLink}},
	 * which uses {{#crossLink "JSONLoader"}}{{/crossLink}} or {{#crossLink "JSONPLoader"}}{{/crossLink}} under the hood.
	 * @method _createRequest
	 * @protected
	 */
	protected _createRequest(): void;
	/**
	 * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented
	 * by loaders that require tag loading.
	 * @method _createTag
	 * @param {String} src The tag source
	 * @return {HTMLElement} The tag that was created
	 * @protected
	 */
	protected _createTag(src?: string): HTMLElement;
	/**
	 * Dispatch a loadstart {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/loadstart:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendLoadStart
	 * @protected
	 */
	protected _sendLoadStart(): void;
	/**
	 * Dispatch a {{#crossLink "ProgressEvent"}}{{/crossLink}}.
	 * @method _sendProgress
	 * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>
	 * and <code>total</code> properties.
	 * @protected
	 */
	protected _sendProgress(value: int | Object): void;
	/**
	 * Dispatch a complete {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}} event
	 * @method _sendComplete
	 * @protected
	 */
	protected _sendComplete(): void;
	/**
	 * Dispatch an error {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendError
	 * @param {ErrorEvent} event The event object containing specific error properties.
	 * @protected
	 */
	protected _sendError(event: ErrorEvent): void;
	/**
	 * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events
	 * do not cause issues after the queue has been cleaned up.
	 * @method _isCanceled
	 * @return {Boolean} If the loader has been canceled.
	 * @protected
	 */
	protected _isCanceled: () => any;
	/**
	 * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but
	 * this method can be overridden for custom behaviours.
	 * @method handleEvent
	 * @param {Event} event The event that the internal request dispatches.
	 * @protected
	 * @since 0.6.0
	 */
	protected handleEvent(event: _Event): void;
	/**
	 * The "success" callback passed to {{#crossLink "AbstractLoader/resultFormatter"}}{{/crossLink}} asynchronous
	 * functions.
	 * @method _resultFormatSuccess
	 * @param {Object} result The formatted result
	 * @private
	 */
	private _resultFormatSuccess;
	/**
	 * The "error" callback passed to {{#crossLink "AbstractLoader/resultFormatter"}}{{/crossLink}} asynchronous
	 * functions.
	 * @method _resultFormatSuccess
	 * @param {Object} error The error event
	 * @private
	 */
	private _resultFormatFailed;
	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	toString(): string;
}
/**
 * PreloadJS provides a consistent way to preload content for use in HTML applications. Preloading can be done using
 * HTML tags, as well as XHR.
 *
 * By default, PreloadJS will try and load content using XHR, since it provides better support for progress and
 * completion events, <b>however due to cross-domain issues, it may still be preferable to use tag-based loading
 * instead</b>. Note that some content requires XHR to work (plain text, web audio), and some requires tags (HTML audio).
 * Note this is handled automatically where possible.
 *
 * PreloadJS currently supports all modern browsers, and we have done our best to include support for most older
 * browsers. If you find an issue with any specific OS/browser combination,
 *
 * <h4>Getting Started</h4>
 * To get started, check out the {{#crossLink "LoadQueue"}}{{/crossLink}} class, which includes a quick overview of how
 * to load files and process results.
 *
 * <h4>Example</h4>
 *
 *      var queue = new LoadQueue();
 *      queue.installPlugin(Sound);
 *      queue.on("complete", handleComplete, this);
 *      queue.loadFile({id:"sound", src:"http://path/to/sound.mp3"});
 *      queue.loadManifest([
 *          {id: "myImage", src:"path/to/myImage.jpg"}
 *      ]);
 *      function handleComplete() {
 *          Sound.play("sound");
 *          var image = queue.getResult("myImage");
 *          document.body.appendChild(image);
 *      }
 *
 * <b>Important note on plugins:</b> Plugins must be installed <i>before</i> items are added to the queue, otherwise
 * they will not be processed, even if the load has not actually kicked off yet. Plugin functionality is handled when
 * the items are added to the LoadQueue.
 *
 * <h4>Browser Support</h4>
 * PreloadJS is partially supported in all browsers, and fully supported in all modern browsers. Known exceptions:
 * <ul><li>XHR loading of any content will not work in many older browsers (See a matrix here: <a href="http://caniuse.com/xhr2" target="_blank">http://caniuse.com/xhr2</a>).
 *      In many cases, you can fall back on tag loading (images, audio, CSS, scripts, and SVG). Text and
 *      WebAudio will only work with XHR.</li>
 *      <li>Some formats have poor support for complete events in IE 6, 7, and 8 (SVG, tag loading of scripts, XML/JSON)</li>
 *      <li>Opera has poor support for SVG loading with XHR</li>
 *      <li>CSS loading in Android and Safari will not work with tags (currently, a workaround is in progress)</li>
 *      <li>Local loading is not permitted with XHR, which is required by some file formats. When testing local content
 *      use either a local server, or enable tag loading, which is supported for most formats. See {{#crossLink "LoadQueue/setPreferXHR"}}{{/crossLink}}
 *      for more information.</li>
 * </ul>
 *
 * <h4>Cross-domain Loading</h4>
 * Most content types can be loaded cross-domain, as long as the server supports CORS. PreloadJS also has internal
 * support for images served from a CORS-enabled server, via the `crossOrigin` argument on the {{#crossLink "LoadQueue"}}{{/crossLink}}
 * constructor. If set to a string value (such as "Anonymous"), the "crossOrigin" property of images generated by
 * PreloadJS is set to that value. Please note that setting a `crossOrigin` value on an image that is served from a
 * server without CORS will cause other errors. For more info on CORS, visit https://en.wikipedia.org/wiki/Cross-origin_resource_sharing.
 *
 * @module PreloadJS
 * @main PreloadJS
 */
export declare class LoadQueue extends AbstractLoader {
	private _plugins;
	private _typeCallbacks;
	private _extensionCallbacks;
	next: any;
	maintainScriptOrder: boolean;
	stopOnError: boolean;
	private _maxConnections;
	private _availableLoaders;
	private _defaultLoaderLength;
	preferXHR: boolean;
	private _paused;
	_basePath: any;
	_crossOrigin: any;
	_loadStartWasDispatched: boolean;
	_currentlyLoadingScript: any;
	_currentLoads: LoadQueue[];
	private _loadQueue;
	_loadQueueBackup: LoadQueue[];
	_loadItemsById: any;
	private _loadItemsBySrc;
	_loadedResults: any;
	private _loadedRawResults;
	private _numItems;
	private _numItemsLoaded;
	private _scriptOrder;
	private _loadedScripts;
	private _lastProgress;
	loadStartWasDispatched: boolean;
	_itemCount: number;
	static MANIFEST: any;
	/**
	 * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either
	 * a single file, or queue of files.
	 *
	 * <b>Creating a Queue</b><br />
	 * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR
	 * argument to false.
	 *
	 *      var queue = new LoadQueue(true);
	 *
	 * <b>Listening for Events</b><br />
	 * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink "EventDispatcher"}}{{/crossLink}}
	 * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>
	 *     <li>{{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}: fired when a queue completes loading all
	 *     files</li>
	 *     <li>{{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}: fired when the queue encounters an error with
	 *     any file.</li>
	 *     <li>{{#crossLink "AbstractLoader/progress:event"}}{{/crossLink}}: Progress for the entire queue has
	 *     changed.</li>
	 *     <li>{{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}: A single file has completed loading.</li>
	 *     <li>{{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}: Progress for a single file has changes. Note
	 *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>
	 * </ul>
	 *
	 *      queue.on("fileload", handleFileLoad, this);
	 *      queue.on("complete", handleComplete, this);
	 *
	 * <b>Adding files and manifests</b><br />
	 * Add files you want to load using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or add multiple files at a
	 * time using a list or a manifest definition using {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. Files are
	 * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you
	 * like.
	 *
	 *      queue.loadFile("filePath/file.jpg");
	 *      queue.loadFile({id:"image", src:"filePath/file.jpg"});
	 *      queue.loadManifest(["filePath/file.jpg", {id:"image", src:"filePath/file.jpg"}]);
	 *
	 *      // Use an external manifest
	 *      queue.loadManifest("path/to/manifest.json");
	 *      queue.loadManifest({src:"manifest.json", type:"manifest"});
	 *
	 * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not
	 * stop if it has already been started. Call the {{#crossLink "AbstractLoader/load"}}{{/crossLink}} method to begin
	 * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a
	 * `loadNow` argument of `true`.
	 *
	 *      queue.load();
	 *
	 * <b>File Types</b><br />
	 * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS
	 * should handle the majority of standard file and url formats, and works with common file extensions. If you have
	 * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a
	 * <code>type</code> property with any manifest item.
	 *
	 *      queue.loadFile({src:"path/to/myFile.mp3x", type:Types.SOUND});
	 *
	 *      // Note that PreloadJS will not read a file extension from the query string
	 *      queue.loadFile({src:"http://server.com/proxy?file=image.jpg", type:Types.IMAGE});
	 *
	 * Supported types are defined on the {{#crossLink "AbstractLoader"}}{{/crossLink}} class, and include:
	 * <ul>
	 *     <li>{{#crossLink "Types/BINARY:property"}}{{/crossLink}}: Raw binary data via XHR</li>
	 *     <li>{{#crossLink "Types/CSS:property"}}{{/crossLink}}: CSS files</li>
	 *     <li>{{#crossLink "Types/IMAGE:property"}}{{/crossLink}}: Common image formats</li>
	 *     <li>{{#crossLink "Types/JAVASCRIPT:property"}}{{/crossLink}}: JavaScript files</li>
	 *     <li>{{#crossLink "Types/JSON:property"}}{{/crossLink}}: JSON data</li>
	 *     <li>{{#crossLink "Types/JSONP:property"}}{{/crossLink}}: JSON files cross-domain</li>
	 *     <li>{{#crossLink "Types/MANIFEST:property"}}{{/crossLink}}: A list of files to load in JSON format, see
	 *     {{#crossLink "AbstractLoader/loadManifest"}}{{/crossLink}}</li>
	 *     <li>{{#crossLink "Types/SOUND:property"}}{{/crossLink}}: Audio file formats</li>
	 *     <li>{{#crossLink "Types/SPRITESHEET:property"}}{{/crossLink}}: JSON SpriteSheet definitions. This
	 *     will also load sub-images, and provide a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance.</li>
	 *     <li>{{#crossLink "Types/SVG:property"}}{{/crossLink}}: SVG files</li>
	 *     <li>{{#crossLink "Types/TEXT:property"}}{{/crossLink}}: Text files - XHR only</li>
	 *     <li>{{#crossLink "Types/VIDEO:property"}}{{/crossLink}}: Video objects</li>
	 *     <li>{{#crossLink "Types/XML:property"}}{{/crossLink}}: XML data</li>
	 * </ul>
	 *
	 * <em>Note: Loader types used to be defined on LoadQueue, but have been moved to the Types class</em>
	 *
	 * <b>Handling Results</b><br />
	 * When a file is finished downloading, a {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event is
	 * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a
	 * formatted object that can be used immediately, including:
	 * <ul>
	 *     <li>Binary: The binary loaded result</li>
	 *     <li>CSS: A &lt;link /&gt; tag</li>
	 *     <li>Image: An &lt;img /&gt; tag</li>
	 *     <li>JavaScript: A &lt;script /&gt; tag</li>
	 *     <li>JSON/JSONP: A formatted JavaScript Object</li>
	 *     <li>Manifest: A JavaScript object.
	 *     <li>Sound: An &lt;audio /&gt; tag</a>
	 *     <li>SpriteSheet: A {{#crossLink "SpriteSheet"}}{{/crossLink}} instance, containing loaded images.
	 *     <li>SVG: An &lt;object /&gt; tag</li>
	 *     <li>Text: Raw text</li>
	 *     <li>Video: A Video DOM node</li>
	 *     <li>XML: An XML DOM node</li>
	 * </ul>
	 *
	 *      function handleFileLoad(event) {
	 *          var item = event.item; // A reference to the item that was passed in to the LoadQueue
	 *          var type = item.type;
	 *
	 *          // Add any images to the page body.
	 *          if (type == Types.IMAGE) {
	 *              document.body.appendChild(event.result);
	 *          }
	 *      }
	 *
	 * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up
	 * via its "id" using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}. If no id was provided, then the
	 * "src" or file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong>
	 * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.
	 *
	 *      var image = queue.getResult("image");
	 *      document.body.appendChild(image);
	 *
	 * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
	 * event, or can be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}, passing `true` as the 2nd
	 * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,
	 * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.
	 *
	 *      var image = queue.getResult("image", true); // load the binary image data loaded with XHR.
	 *
	 * <b>Plugins</b><br />
	 * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,
	 * make sure to install the <a href="http://soundjs.com">SoundJS</a> Sound class, which will help load HTML audio,
	 * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.
	 *
	 *      queue.installPlugin(Sound);
	 *
	 * <h4>Known Browser Issues</h4>
	 * <ul>
	 *     <li>Browsers without audio support can not load audio files.</li>
	 *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>
	 *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other
	 *     than Chrome will continue to download in the background.</li>
	 *     <li>When loading scripts using tags, they are automatically added to the document.</li>
	 *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>
	 *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require
	 *     XHR to work.</li>
	 *     <li>Content loaded via tags will not show progress, and will continue to download in the background when
	 *     canceled, although no events will be dispatched.</li>
	 * </ul>
	 *
	 * @class LoadQueue
	 * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP
	 * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR
	 * when necessary.
	 * @param {String} [basePath=""] A path that will be prepended on to the source parameter of all items in the queue
	 * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`
	 * will not receive a base path.
	 * @param {String|Boolean} [crossOrigin=""] An optional flag to support images loaded from a CORS-enabled server. To
	 * use it, set this value to `true`, which will default the crossOrigin property on images to "Anonymous". Any
	 * string value will be passed through, but only "" and "Anonymous" are recommended. <strong>Note: The crossOrigin
	 * parameter is deprecated. Use LoadItem.crossOrigin instead</strong>
	 *
	 * @constructor
	 * @extends AbstractLoader
	 */
	constructor(preferXHR?: boolean, basePath?: string, crossOrigin?: string | boolean);
	/**
	 * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.
	 * @method init
	 * @param preferXHR
	 * @param basePath
	 * @param crossOrigin
	 * @private
	 */
	private init;
	/**
	 * This event is fired when an individual file has loaded, and been processed.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.3.0
	 */
	/**
	 * This {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when an an individual file's progress changes.
	 * @event fileprogress
	 * @since 0.3.0
	 */
	/**
	 * This event is fired when an individual file starts to load.
	 * @event filestart
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a property.
	 */
	/**
	 * Although it extends {{#crossLink "AbstractLoader"}}{{/crossLink}}, the `initialize` event is never fired from
	 * a LoadQueue instance.
	 * @event initialize
	 * @private
	 */
	/**
	 * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.
	 * It is recommended that loaders extend {{#crossLink "AbstractLoader"}}{{/crossLink}}. Loaders can only be added
	 * once, and will be prepended to the list of available loaders.
	 * @method registerLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to add.
	 * @since 0.6.0
	 */
	RegisterLoader(loader: Function | AbstractLoader): void;
	/**
	 * Remove a custom loader added using {{#crossLink "registerLoader"}}{{/crossLink}}. Only custom loaders can be
	 * unregistered, the default loaders will always be available.
	 * @method unregisterLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to remove
	 */
	UnregisterLoader(loader: Function | AbstractLoader): void;
	/**
	 * Change the {{#crossLink "preferXHR:property"}}{{/crossLink}} value. Note that if this is set to `true`, it may
	 * fail, or be ignored depending on the browser's capabilities and the load type.
	 * @method setPreferXHR
	 * @param {Boolean} value
	 * @returns {Boolean} The value of {{#crossLink "preferXHR"}}{{/crossLink}} that was successfully set.
	 * @since 0.6.0
	 */
	SetPreferXHR(value: any): boolean;
	/**
	 * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded
	 * content, and allows the queue to be used again.
	 * @method removeAll
	 * @since 0.3.0
	 */
	RemoveAll(): void;
	/**
	 * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.
	 * This also removes internal references to loaded item(s).
	 *
	 * <h4>Example</h4>
	 *
	 *      queue.loadManifest([
	 *          {src:"test.png", id:"png"},
	 *          {src:"test.jpg", id:"jpg"},
	 *          {src:"test.mp3", id:"mp3"}
	 *      ]);
	 *      queue.remove("png"); // Single item by ID
	 *      queue.remove("png", "test.jpg"); // Items as arguments. Mixed id and src.
	 *      queue.remove(["test.png", "jpg"]); // Items in an Array. Mixed id and src.
	 *
	 * @method remove
	 * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of
	 * items, or multiple items as arguments.
	 * @since 0.3.0
	 */
	Remove(idsOrUrls?: string | Array<string>): void;
	/**
	 * Stops all open loads, destroys any loaded items, and resets the queue, so all items can
	 * be reloaded again by calling {{#crossLink "AbstractLoader/load"}}{{/crossLink}}. Items are not removed from the
	 * queue. To remove items use the {{#crossLink "LoadQueue/remove"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/removeAll"}}{{/crossLink}} method.
	 * @method reset
	 * @since 0.3.0
	 */
	Reset(): void;
	/**
	 * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).
	 * Currently, only one plugin can exist per type/extension.
	 *
	 * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information
	 * on this method, check out the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method in the
	 * {{#crossLink "SamplePlugin"}}{{/crossLink}} class.
	 *
	 * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned
	 * from the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method, it will be invoked first, and its
	 * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when
	 * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these
	 * methods, check out the {{#crossLink "SamplePlugin/preloadHandler"}}{{/crossLink}} and {{#crossLink "SamplePlugin/fileLoadHandler"}}{{/crossLink}}
	 * methods on the {{#crossLink "SamplePlugin"}}{{/crossLink}}.
	 *
	 * @method installPlugin
	 * @param {Function} plugin The plugin class to install.
	 */
	InstallPlugin(plugin: Function): void;
	/**
	 * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum
	 * number of open connections, so any additional connections may remain in a pending state until the browser
	 * opens the connection. When loading scripts using tags, and when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}}
	 * is `true`, only one script is loaded at a time due to browser limitations.
	 *
	 * <h4>Example</h4>
	 *
	 *      var queue = new LoadQueue();
	 *      queue.setMaxConnections(10); // Allow 10 concurrent loads
	 *
	 * @method setMaxConnections
	 * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue
	 * is open at any time.
	 */
	SetMaxConnections(value: int): void;
	/**
	 * Load a single file. To add multiple files at once, use the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * method.
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
	 * @method loadFile
	 * @param {LoadItem|Object|String} file The file object or path to load. A file can be either
	 * <ul>
	 *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
	 *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
	 *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
	 *     in the background.</li>
	 * </ul>
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}}, and the value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "Types/MANIFEST:property"}}{{/crossLink}},
	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	LoadFile(file: LoadItem | Object, loadNow?: boolean, basePath?: string): void;
	/**
	 * Load an array of files. To load a single file, use the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} method.
	 * The files in the manifest are requested in the same order, but may complete in a different order if the max
	 * connections are set above 1 using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Scripts will load
	 * in the right order as long as {{#crossLink "LoadQueue/maintainScriptOrder"}}{{/crossLink}} is true (which is
	 * default).
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
	 * @method loadManifest
	 * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of
	 * manifests:
	 * <ol>
	 *     <li>A string path, which points to a manifest file, which is a JSON file that contains a "manifest" property,
	 *     which defines the list of files to load, and can optionally contain a "path" property, which will be
	 *     prepended to each file in the list.</li>
	 *     <li>An object which defines a "src", which is a JSON or JSONP file. A "callback" can be defined for JSONP
	 *     file. The JSON/JSONP file should contain a "manifest" property, which defines the list of files to load,
	 *     and can optionally contain a "path" property, which will be prepended to each file in the list.</li>
	 *     <li>An object which contains a "manifest" property, which defines the list of files to load, and can
	 *     optionally contain a "path" property, which will be prepended to each file in the list.</li>
	 *     <li>An Array of files to load.</li>
	 * </ol>
	 *
	 * Each "file" in a manifest can be either:
	 * <ul>
	 *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
	 *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
	 *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
	 *     in the background.</li>
	 * </ul>
	 *
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} and this value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "LoadQueue/MANIFEST:property"}}{{/crossLink}},
	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	LoadManifest(manifest: Array<string> | string | Object, loadNow: boolean, basePath?: string): void;
	/**
	 * Start a LoadQueue that was created, but not automatically started.
	 * @method load
	 */
	Load(): void;
	/**
	 * Look up a {{#crossLink "LoadItem"}}{{/crossLink}} using either the "id" or "src" that was specified when loading it. Note that if no "id" was
	 * supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method GetItem
	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
	 * @return {Object} The load item that was initially requested using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
	 * event as the `item` parameter.
	 */
	GetItem(): any;
	GetItem(value: string): any;
	/**
	 * Look up a loaded result using either the "id" or "src" that was specified when loading it. Note that if no "id"
	 * was supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method getResult
	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
	 * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * <ul>
	 *      <li>An image tag (&lt;image /&gt;) for images</li>
	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML
	 *      DOM.</li>
	 *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>
	 *      <li>Raw text for TEXT</li>
	 *      <li>A formatted JavaScript object defined by JSON</li>
	 *      <li>An XML document</li>
	 *      <li>A binary arraybuffer loaded by XHR</li>
	 *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play
	 *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method
	 *      which can not be used to play audio back.</li>
	 * </ul>
	 * This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event as the 'item`
	 * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	GetResult(rawResult: boolean): any;
	GetResult(value: string, rawResult: boolean): any;
	/**
	 * Generate an list of items loaded by this queue.
	 * @method getItems
	 * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress
	 * and failed load items will also be included.
	 * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink "LoadItem"}}{{/crossLink}},
	 * result, and rawResult.
	 * @since 0.6.0
	 */
	GetItems(loaded: boolean): Array<any>;
	/**
	 * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not
	 * be processed when active loads complete. LoadQueues are not paused by default.
	 *
	 * Note that if new items are added to the queue using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`
	 * argument is `false`.
	 * @method setPaused
	 * @param {Boolean} value Whether the queue should be paused or not.
	 */
	SetPaused(value: boolean): void;
	/**
	 * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from
	 * starting to download. Note that currently any active loads will remain open, and events may be processed.
	 *
	 * To stop and restart a queue, use the {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} method instead.
	 * @method close
	 */
	Close(): void;
	/**
	 * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to
	 * load the content. The load queue is populated with the loader instance that handles preloading, and not the load
	 * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink "LoadQueue.GetItem"}}{{/crossLink}}
	 * method.
	 * @method _addItem
	 * @param {String|Object} value The item to add to the queue.
	 * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is
	 * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was
	 * provided a {{#crossLink "_basePath"}}{{/crossLink}}, then it will optionally be prepended after.
	 * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} call. This parameter will be removed in a future tagged
	 * version.
	 * @private
	 */
	private _addItem;
	/**
	 * Create a refined {{#crossLink "LoadItem"}}{{/crossLink}}, which contains all the required properties. The type of
	 * item is determined by browser support, requirements based on the file type, and developer settings. For example,
	 * XHR is only used for file types that support it in new browsers.
	 *
	 * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may
	 * alter the load item.
	 * @method _createLoadItem
	 * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.
	 * @param {String} [path] A path to prepend to the item's source. Sources beginning with http:// or similar will
	 * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink "LoadQueue/_basePath:property"}}{{/crossLink}}
	 * when it is added.
	 * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to
	 * the path argument.
	 * @return {Object} The loader instance that will be used.
	 * @private
	 */
	private _createLoadItem;
	/**
	 * Create a loader for a load item.
	 * @method _createLoader
	 * @param {Object} item A formatted load item that can be used to generate a loader.
	 * @return {AbstractLoader} A loader that can be used to load content.
	 * @private
	 */
	private _createLoader;
	/**
	 * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event
	 * is processed. The queue will "fill up" any empty slots, up to the max connection specified using
	 * {{#crossLink "LoadQueue.setMaxConnections"}}{{/crossLink}} method. The only exception is scripts that are loaded
	 * using tags, which have to be loaded one at a time to maintain load order.
	 * @method _loadNext
	 * @private
	 */
	_loadNext(): void;
	/**
	 * Begin loading an item. Event listeners are not added to the loaders until the load starts.
	 * @method _loadItem
	 * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.
	 * @private
	 */
	private _loadItem;
	/**
	 * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink "ManifestLoader"}}{{/crossLink}}
	 * to maintain internal queues, but for this queue to dispatch the {{#crossLink "fileload:event"}}{{/crossLink}}
	 * events.
	 * @param {Event} event The {{#crossLink "AbstractLoader/fileload:event"}}{{/crossLink}} event from the loader.
	 * @private
	 * @since 0.6.0
	 */
	private _handleFileLoad;
	/**
	 * The callback that is fired when a loader encounters an error from an internal file load operation. This enables
	 * loaders like M
	 * @param event
	 * @private
	 */
	private _handleFileError;
	/**
	 * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}}
	 * is set to `true`.
	 * @method _handleError
	 * @param {ErrorEvent} event The error event, containing relevant error information.
	 * @private
	 */
	private _handleError;
	/**
	 * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and
	 * is available as the "result" property on the load item. The raw text result for a parsed item (such as JSON, XML,
	 * CSS, JavaScript, etc) is available as the "rawResult" property, and can also be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}.
	 * @method _handleFileComplete
	 * @param {Event} event The event object from the loader.
	 * @private
	 */
	private _handleFileComplete;
	/**
	 * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink "ManifestLoader"}}{{/crossLink}}).
	 * Any items exposed by the loader using {{#crossLink "AbstractLoader/getLoadItems"}}{{/crossLink}} are added to the
	 * LoadQueue's look-ups, including {{#crossLink "GetItem"}}{{/crossLink}} and {{#crossLink "getResult"}}{{/crossLink}}
	 * methods.
	 * @method _saveLoadedItems
	 * @param {AbstractLoader} loader
	 * @protected
	 * @since 0.6.0
	 */
	private _saveLoadedItems;
	/**
	 * Flag an item as finished. If the item's order is being managed, then ensure that it is allowed to finish, and if
	 * so, trigger prior items to trigger as well.
	 * @method _finishOrderedItem
	 * @param {AbstractLoader} loader
	 * @param {Boolean} loadFailed
	 * @return {Boolean} If the item's order is being managed. This allows the caller to take an alternate
	 * behaviour if it is.
	 * @private
	 */
	private _finishOrderedItem;
	/**
	 * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the
	 * order they were added, but with a "null" value. When they are completed, the value is set to the load item,
	 * and then when they are processed and dispatched, the value is set to `true`. This method simply
	 * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are
	 * dispatched.
	 * @method _checkScriptLoadOrder
	 * @private
	 */
	private _checkScriptLoadOrder;
	/**
	 * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts
	 * the next item.
	 * @method _processFinishedLoad
	 * @param {LoadItem|Object} item
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	private _processFinishedLoad;
	/**
	 * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to
	 * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed <strong>before</strong>
	 * the script can even be started, since it exist in the DOM while loading.
	 * @method _canStartLoad
	 * @param {AbstractLoader} loader The loader for the item
	 * @return {Boolean} Whether the item can start a load or not.
	 * @private
	 */
	private _canStartLoad;
	/**
	 * A load item is completed or was canceled, and needs to be removed from the LoadQueue.
	 * @method _removeLoadItem
	 * @param {AbstractLoader} loader A loader instance to remove.
	 * @private
	 */
	private _removeLoadItem;
	/**
	 * Remove unneeded references from a loader.
	 *
	 * @param loader
	 * @private
	 */
	private _cleanLoadItem;
	/**
	 * An item has dispatched progress. Propagate that progress, and update the LoadQueue's overall progress.
	 * @method _handleProgress
	 * @param {ProgressEvent} event The progress event from the item.
	 * @private
	 */
	private _handleProgress;
	/**
	 * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an
	 * item dispatches progress or completes. Note that since we don't always know the actual filesize of items before
	 * they are loaded. In this case, we define a "slot" for each item (1 item in 10 would get 10%), and then append
	 * loaded progress on top of the already-loaded items.
	 *
	 * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:
	 * <ul>
	 *      <li>5/10 of the items in the queue (50%)</li>
	 *      <li>plus 20% of item 6's slot (2%)</li>
	 *      <li>equals 52%</li>
	 * </ul>
	 * @method _updateProgress
	 * @private
	 */
	private _updateProgress;
	/**
	 * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal
	 * hashes.
	 * @method _disposeItem
	 * @param {LoadItem|Object} item The item that was passed in for preloading.
	 * @private
	 */
	private _disposeItem;
	/**
	 * Dispatch a "fileprogress" {{#crossLink "Event"}}{{/crossLink}}. Please see the LoadQueue {{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendFileProgress
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @param {Number} progress The amount the item has been loaded (between 0 and 1).
	 * @protected
	 */
	private _sendFileProgress;
	/**
	 * Dispatch a fileload {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event for
	 * details on the event payload.
	 * @method _sendFileComplete
	 * @param {LoadItemObject} item The item that is being loaded.
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	private _sendFileComplete;
	/**
	 * Dispatch a filestart {{#crossLink "Event"}}{{/crossLink}} immediately before a file starts to load. Please see
	 * the {{#crossLink "LoadQueue/filestart:event"}}{{/crossLink}} event for details on the event payload.
	 * @method _sendFileStart
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @protected
	 */
	private _sendFileStart;
	toString(): string;
}
export declare class TLoader {
	static LoadBinary(url: string): Promise<ArrayBuffer>;
	static LoadToFileSystem(url: string, path: string): Promise<boolean>;
	static LoadImage(url: string): Promise<HTMLImageElement>;
	static LoadJSON<T>(url: string): Promise<T>;
	static LoadJSON<T>(url: string, filepath: string): Promise<boolean>;
	static LoadJavaScript(url: string): Promise<HTMLScriptElement>;
	static LoadBinaryRange(url: string, start?: int, end?: null): Promise<any>;
}
export declare class BitConverter {
	static get IsLittleEndian(): boolean;
	static GetBooleanBytes(x: boolean): ByteArray;
	static GetCharBytes(c: char): ByteArray;
	static GetDoubleBytes(x: float): ByteArray;
	static GetIntBytes(x: int): ByteArray;
	static GetFloatBytes(x: float): ByteArray;
	static DoubleToInt64Bits(x: number): long;
	static ToInt32(bytes: ByteArray, index: number): number;
	static ToSingle(bytes: ByteArray, index: number): number;
	static ToInt64(value: Uint8Array, startIndex?: int): long;
}
declare type constructor<T> = {
	new (...args: any[]): T;
};
declare class DelayedConstructor<T> {
	private wrap;
	private reflectMethods;
	constructor(wrap: () => constructor<T>);
	createProxy(createObject: (ctor: constructor<T>) => T): T;
	private createHandler;
}
export declare function delay<T>(wrappedConstructor: () => constructor<T>): DelayedConstructor<T>;
export interface ClassProvider<T> {
	useClass: constructor<T> | DelayedConstructor<T>;
}
export declare function isClassProvider<T>(provider: Provider<T>): provider is ClassProvider<any>;
export interface ValueProvider<T> {
	useValue: T;
}
export declare function isValueProvider<T>(provider: Provider<T>): provider is ValueProvider<T>;
interface Transform<TIn, TOut> {
	transform: (incoming: TIn, ...args: any[]) => TOut;
}
export declare type InjectionToken<T = any> = constructor<T> | string | symbol | DelayedConstructor<T>;
export declare function isNormalToken(token?: InjectionToken<any>): token is string | symbol;
interface TokenDescriptor {
	token: InjectionToken<any>;
	multiple: boolean;
}
export interface TokenProvider<T> {
	useToken: InjectionToken<T>;
}
export declare function isTokenProvider<T>(provider: Provider<T>): provider is TokenProvider<any>;
export declare type Provider<T = any> = ClassProvider<T> | ValueProvider<T> | TokenProvider<T> | FactoryProvider<T>;
/**
 * Provide a dependency using a factory.
 * Unlike the other providers, this does not support instance caching. If
 * you need instance caching, your factory method must implement it.
 */
export interface FactoryProvider<T> {
	useFactory: (dependencyContainer: DependencyContainer) => T;
}
export declare function isFactoryProvider<T>(provider: Provider<T>): provider is FactoryProvider<any>;
export declare enum Lifecycle {
	Transient = 0,
	Singleton = 1,
	ResolutionScoped = 2,
	ContainerScoped = 3
}
export declare type RegistrationOptions = {
	lifecycle: Lifecycle;
};
export declare type Frequency = "Always" | "Once";
declare type InterceptorOptions = {
	frequency: Frequency;
};
declare type ResolutionType = "Single" | "All";
interface PreResolutionInterceptorCallback<T = any> {
	/**
	 * @param token The InjectionToken that was intercepted
	 * @param resolutionType The type of resolve that was called (i.e. All or Single)
	 */
	(token: InjectionToken<T>, resolutionType: ResolutionType): void;
}
interface PostResolutionInterceptorCallback<T = any> {
	/**
	 * @param token The InjectionToken that was intercepted
	 * @param result The object that was resolved from the container
	 * @param resolutionType The type of resolve that was called (i.e. All or Single)
	 */
	(token: InjectionToken<T>, result: T | T[], resolutionType: ResolutionType): void;
}
export interface DependencyContainer {
	register<T>(token: InjectionToken<T>, provider: ValueProvider<T>): DependencyContainer;
	register<T>(token: InjectionToken<T>, provider: FactoryProvider<T>): DependencyContainer;
	register<T>(token: InjectionToken<T>, provider: TokenProvider<T>, options?: RegistrationOptions): DependencyContainer;
	register<T>(token: InjectionToken<T>, provider: ClassProvider<T>, options?: RegistrationOptions): DependencyContainer;
	register<T>(token: InjectionToken<T>, provider: constructor<T>, options?: RegistrationOptions): DependencyContainer;
	registerSingleton<T>(from: InjectionToken<T>, to: InjectionToken<T>): DependencyContainer;
	registerSingleton<T>(token: constructor<T>): DependencyContainer;
	registerType<T>(from: InjectionToken<T>, to: InjectionToken<T>): DependencyContainer;
	registerInstance<T>(token: InjectionToken<T>, instance: T): DependencyContainer;
	/**
	 * Resolve a token into an instance
	 *
	 * @param token The dependency token
	 * @return An instance of the dependency
	 */
	resolve<T>(token: InjectionToken<T>): T;
	resolveAll<T>(token: InjectionToken<T>): T[];
	/**
	 * Check if the given dependency is registered
	 *
	 * @param token The token to check
	 * @param recursive Should parent containers be checked?
	 * @return Whether or not the token is registered
	 */
	isRegistered<T>(token: InjectionToken<T>, recursive?: boolean): boolean;
	/**
	 * Clears all registered tokens
	 */
	reset(): void;
	clearInstances(): void;
	createChildContainer(): DependencyContainer;
	/**
	 * Registers a callback that is called when a specific injection token is resolved
	 * @param token The token to intercept
	 * @param callback The callback that is called before the token is resolved
	 * @param options Options for under what circumstances the callback will be called
	 */
	beforeResolution<T>(token: InjectionToken<T>, callback: PreResolutionInterceptorCallback<T>, options?: InterceptorOptions): void;
	/**
	 * Registers a callback that is called after a successful resolution of the token
	 * @param token The token to intercept
	 * @param callback The callback that is called after the token is resolved
	 * @param options Options for under what circumstances the callback will be called
	 */
	afterResolution<T>(token: InjectionToken<T>, callback: PostResolutionInterceptorCallback<T>, options?: InterceptorOptions): void;
}
/**
 * Class decorator factory that replaces the decorated class' constructor with
 * a parameterless constructor that has dependencies auto-resolved
 *
 * Note: Resolution is performed using the global container
 *
 * @return {Function} The class decorator
 */
export declare function autoInjectable(): (target: constructor<any>) => any;
/**
 * Parameter decorator factory that allows for interface information to be stored in the constructor's metadata
 *
 * @return {Function} The parameter decorator
 */
export declare function inject(token: InjectionToken<any>): (target: any, propertyKey: string | symbol, parameterIndex: number) => any;
/**
 * Class decorator factory that allows the class' dependencies to be injected
 * at runtime.
 *
 * @return {Function} The class decorator
 */
export declare function injectable<T>(): (target: constructor<T>) => void;
/**
 * Class decorator factory that allows constructor dependencies to be registered at runtime.
 *
 * @return {Function} The class decorator
 */
export declare function registry(registrations?: ({
	token: InjectionToken;
	options?: RegistrationOptions;
} & Provider<any>)[]): (target: any) => any;
/**
 * Class decorator factory that registers the class as a singleton within
 * the global container.
 *
 * @return {Function} The class decorator
 */
export declare function singleton<T>(): (target: constructor<T>) => void;
/**
 * Parameter decorator factory that allows for interface information to be stored in the constructor's metadata
 *
 * @return {Function} The parameter decorator
 */
export declare function injectAll(token: InjectionToken<any>): (target: any, propertyKey: string | symbol, parameterIndex: number) => any;
/**
 * Parameter decorator factory that allows for interface information to be stored in the constructor's metadata
 *
 * @return {Function} The parameter decorator
 */
export declare function injectAllWithTransform(token: InjectionToken<any>, transformer: InjectionToken<Transform<[
	any
], any>>, ...args: any[]): (target: any, propertyKey: string | symbol, parameterIndex: number) => any;
/**
 * Parameter decorator factory that allows for interface information to be stored in the constructor's metadata with a transform token
 * @param token The token of the object to be resolved
 * @param transformer The token of the transform object
 * @param args Arguments to be passed to the transform method on the transformer
 * @returns The parameter decorator
 */
export declare function injectWithTransform(token: InjectionToken<any>, transformer: InjectionToken<Transform<any, any>>, ...args: any[]): (target: any, propertyKey: string | symbol, parameterIndex: number) => any;
/**
 * Class decorator factory that registers the class as a scoped dependency within
 * the global container.
 *
 * @return The class decorator
 */
export function scoped<T>(lifecycle: Lifecycle.ContainerScoped | Lifecycle.ResolutionScoped, token?: InjectionToken<T>): (target: constructor<T>) => void;
export declare type FactoryFunction<T> = (dependencyContainer: DependencyContainer) => T;
export function instanceCachingFactory<T>(factoryFunc: FactoryFunction<T>): FactoryFunction<T>;
export function instancePerContainerCachingFactory<T>(factoryFunc: FactoryFunction<T>): FactoryFunction<T>;
export function predicateAwareClassFactory<T>(predicate: (dependencyContainer: DependencyContainer) => boolean, trueConstructor: constructor<T>, falseConstructor: constructor<T>, useCaching?: boolean): FactoryFunction<T>;
declare class ResolutionContext {
	scopedResolutions: Map<Registration, any>;
}
export declare type Registration<T = any> = {
	provider: Provider<T>;
	options: RegistrationOptions;
	instance?: T;
};
export declare type ParamInfo = TokenDescriptor | InjectionToken<any>;
export declare const typeInfo: Map<constructor<any>, ParamInfo[]>;
/** Dependency Container */
export declare class InternalDependencyContainer implements DependencyContainer {
	private parent?;
	private _registry;
	private interceptors;
	constructor(parent?: InternalDependencyContainer | undefined);
	/**
	 * Register a dependency provider.
	 *
	 * @param provider {Provider} The dependency provider
	 */
	register<T>(token: InjectionToken<T>, provider: ValueProvider<T>): InternalDependencyContainer;
	register<T>(token: InjectionToken<T>, provider: FactoryProvider<T>): InternalDependencyContainer;
	register<T>(token: InjectionToken<T>, provider: TokenProvider<T>, options?: RegistrationOptions): InternalDependencyContainer;
	register<T>(token: InjectionToken<T>, provider: ClassProvider<T>, options?: RegistrationOptions): InternalDependencyContainer;
	register<T>(token: InjectionToken<T>, provider: constructor<T>, options?: RegistrationOptions): InternalDependencyContainer;
	registerType<T>(from: InjectionToken<T>, to: InjectionToken<T>): InternalDependencyContainer;
	registerInstance<T>(token: InjectionToken<T>, instance: T): InternalDependencyContainer;
	registerSingleton<T>(from: InjectionToken<T>, to: InjectionToken<T>): InternalDependencyContainer;
	registerSingleton<T>(token: constructor<T>, to?: constructor<any>): InternalDependencyContainer;
	resolve<T>(token: InjectionToken<T>, context?: ResolutionContext): T;
	private executePreResolutionInterceptor;
	private executePostResolutionInterceptor;
	private resolveRegistration;
	resolveAll<T>(token: InjectionToken<T>, context?: ResolutionContext): T[];
	isRegistered<T>(token: InjectionToken<T>, recursive?: boolean): boolean;
	reset(): void;
	clearInstances(): void;
	createChildContainer(): DependencyContainer;
	beforeResolution<T>(token: InjectionToken<T>, callback: PreResolutionInterceptorCallback<T>, options?: InterceptorOptions): void;
	afterResolution<T>(token: InjectionToken<T>, callback: PostResolutionInterceptorCallback<T>, options?: InterceptorOptions): void;
	private getRegistration;
	private getAllRegistrations;
	private construct;
	private resolveParams;
}
export declare const instance: DependencyContainer;
export declare class KeyboardDriver {
	static Start(): void;
}
export declare class MouseDriver {
	static Start(): void;
}
export declare class Runtime {
	private static KSObjects;
	static GetKernelObject(hwnd: IntPtr): any;
	static AddKernelObject(hwnd: IntPtr, obj: any): void;
	static CreateKernelHandle(): IntPtr;
}
export declare function exportToGlobal(moduleName: string, objectName: string, value: any): void;
export declare function Export(moduleName: string, objectName?: string): ClassDecorator;
export declare class Router {
	static PARAMETER_REGEXP: RegExp;
	static WILDCARD_REGEXP: RegExp;
	static REPLACE_VARIABLE_REGEXP: string;
	static REPLACE_WILDCARD: string;
	static FOLLOWED_BY_SLASH_REGEXP: string;
	static MATCH_REGEXP_FLAGS: string;
	private root;
	private _routes;
	private _useHash;
	private _hash;
	private _paused;
	private _destroyed;
	private _lastRouteResolved;
	private _notFoundHandler;
	private _defaultHandler;
	private _usePushState;
	private _genericHooks;
	private _historyAPIUpdateMethod;
	private _listeningInterval;
	constructor(r: any, useHash?: any, hash?: any);
	navigate(path: any, absolute?: any): this;
	on(...args: any[]): this;
	off(handler: any): this;
	notFound(handler: any, hooks: any): this;
	resolve(current?: any): any;
	destroy(): void;
	updatePageLinks(): void;
	generate(name: any, data?: {}): any;
	link(path: any): any;
	pause(status?: boolean): void;
	resume(): void;
	historyAPIUpdateMethod(value: any): any;
	disableIfAPINotAvailable(): void;
	lastRouteResolved(): any;
	getLinkPath(link: any): any;
	hooks(hooks: any): void;
	private _add;
	private _getRoot;
	private _listen;
	private _cLoc;
	private _findLinks;
	private _onLocationChange;
	private _callLeave;
}
export declare const moment: any;
export declare function createBios(srcFilePath: string, destBiosPath: string): void;
export declare function publish(distfolder: string, componentsFolder: string, libFolder: string): void;
export declare function appPackager(appJsFile: string, targetAppName: string, libName?: string): void;
declare class ParseNumbers {
	static readonly LeftAlign: int;
	static readonly RightAlign: int;
	static readonly PrefixSpace: int;
	static readonly PrintSign: int;
	static readonly PrintBase: int;
	static readonly PrintAsI1: int;
	static readonly PrintAsI2: int;
	static readonly PrintAsI4: int;
	static readonly TreatAsUnsigned: int;
	static readonly TreatAsI1: int;
	static readonly TreatAsI2: int;
	static readonly IsTight: int;
	static readonly NoSpace: int;
	static readonly PrintRadixBase: int;
	private static readonly MinRadix;
	private static readonly MaxRadix;
	static StringToLong(s: string, radix: int, flags: int): long;
	static StringToLong(s: CharArray, radix: int, flags: int): long;
	static StringToLong(s: CharArray, radix: int, flags: int, currPos: Out<int>): long;
	static StringToInt(s: string, radix: int, flags: int): int;
	static StringToInt(s: CharArray, radix: int, flags: int): int;
	static StringToInt(s: CharArray, radix: int, flags: int, currPos: Out<int>): int;
	static IntToString(n: int, radix: int, width: int, paddingChar: char, flags: int): string;
	static LongToString(n: long, radix: int, width: int, paddingChar: char, flags: int): string;
	private static EatWhiteSpace;
	private static GrabLongs;
	private static GrabInts;
	private static IsDigit;
}
export declare const MainCoreModule: {
	ParseNumbers: (string | typeof ParseNumbers)[];
};

export {};
