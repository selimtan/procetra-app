// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../@tuval/core
//   ../../@tuval/cg
//   ../../rxjs
//   ../../@tuval/graphics
//   ../../rxjs-compat/Observable
//   ../../@tuval/components/core

import { HttpClientResponse, HttpClientRequestConfig } from '@tuval/core';
import { ReadOnlyCollectionBase, IEnumerator } from "@tuval/core";
import { IDisposable, EventHandler } from "@tuval/core";
import { IDisposable } from "@tuval/core";
import { CGColor, CGRectangle } from '@tuval/cg';
import { int, EventArgs, List, Event, Type, Hashtable } from '@tuval/core';
import { Observable, ReplaySubject } from 'rxjs';
import { DashStyle } from "@tuval/graphics";
import { List, int, Event } from '@tuval/core';
import { List } from '@tuval/core';
import { Event, int, Delegate } from '@tuval/core';
import { ReplaySubject } from 'rxjs';
import { Event } from '@tuval/core';
import { Observable } from "rxjs-compat/Observable";
import { List, int } from '@tuval/core';
import { List, int, Router } from '@tuval/core';
import { Delegate, Event, int } from '@tuval/core';
import { TextConsole, Delegate, Event } from '@tuval/core';
import { Delegate, Event } from '@tuval/core';
import { Event, StringBuilder } from '@tuval/core';
import { Event, ByteArray } from '@tuval/core';
import { Umay, int, Delegate, Event } from '@tuval/core';
import { SketchGraphics } from '@tuval/graphics';
import { GuiConsole as GC } from '@tuval/graphics';
import { int } from '@tuval/core';
import { Delegate } from '@tuval/core';
import { ICollection, IEnumerable, IEnumerator, IList } from '@tuval/core';
import { int } from "@tuval/core";
import { int, Event, StringBuilder } from '@tuval/core';
import { Event, int, List } from '@tuval/core';
import { StringBuilder } from '@tuval/core';
import { StringBuilder } from "@tuval/core";
import { float } from '@tuval/core';
import { int, Type } from "@tuval/core";
import { float } from "@tuval/core";
import { EventArgs } from "@tuval/core";
import { Event, int } from '@tuval/core';
import { NumberFormatOptions, DateFormatOptions } from '@tuval/components/core';
import { int, List } from "@tuval/core";
import { Event, Delegate } from '@tuval/core';
import { Observable } from 'rxjs-compat/Observable';
import { EventArgs } from '@tuval/core';
import { ReplaySubject } from "rxjs";
import { int, Event } from '@tuval/core';
import { int, List } from '@tuval/core';
import { CGColor } from '@tuval/cg';
import { CGColor, CGPoint, CGRectangle, CGSize } from "@tuval/cg";
import { float, StringBuilder } from '@tuval/core';
import { Brush, GraphicsPath, Pen } from "@tuval/graphics";
import { ByteArray } from '@tuval/core';
import { Event } from "@tuval/core";

export const React: any;
import './windows/Forms/Components/fonts/loadFont';
import './exports';

export declare class BlockUI extends React.Component {
    static defaultProps: {
        id: any;
        blocked: boolean;
        fullScreen: boolean;
        baseZIndex: number;
        autoZIndex: boolean;
        style: any;
        className: any;
        template: any;
        onBlocked: any;
        onUnblocked: any;
    };
    mask: any;
    container: any;
    constructor(props: any);
    block(): void;
    unblock(): void;
    onPortalMounted(): void;
    renderMask(): any;
    componentDidMount(): void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    componentWillUnmount(): void;
    render(): any;
}

export class ProgressBar extends React.Component {
    static defaultProps: {
        id: any;
        value: any;
        showValue: boolean;
        unit: string;
        style: any;
        className: any;
        mode: string;
        displayValueTemplate: any;
        color: any;
    };
    renderLabel(): any;
    renderDeterminate(): any;
    renderIndeterminate(): any;
    render(): any;
}

export const Resources: {
    Icons: {
        Loading: string;
    };
};

export class PointTarget extends React.Component {
    static defaultProps: {
        tolerance: number;
    };
    handleClick: () => void;
    handleTouchStart: (event: any) => void;
    handleTouchMove: (event: any) => void;
    handleTouchCancel: () => void;
    handleTouchEnd: () => void;
    usingTouch: any;
    touchStarted: any;
    touchMoved: any;
    startX: number;
    startY: any;
    componentWillMount(): void;
    render(): any;
}

function createElement(el: any, props: any, ...children: any[]): {
    type: any;
    props: any;
    key: any;
    ref: any;
    _children: any;
    _parent: any;
    _depth: number;
    _dom: any;
    _nextDom: any;
    _component: any;
    _hydrating: any;
    constructor: any;
    _original: any;
};
export const Teact: {
    createElement: typeof createElement;
};
export {};

export const ControlTypes: {
    UIKit: {
        ZStack: symbol;
    };
    Panel: symbol;
    ContainerControl: symbol;
    TabControl: symbol;
    TabPage: symbol;
    ComboBoxBase: symbol;
    MultiComboBox: symbol;
    ListBoxBase: symbol;
    TextBox: symbol;
    ContextMenu: symbol;
    RibbonMenu: symbol;
    FileUpload: symbol;
    TextArea: symbol;
    ScrollPanel: symbol;
    GridView: {
        ImageColumn: symbol;
    };
    TreeView: {
        TreeNode: symbol;
    };
    Dialog: symbol;
    TreeViewEx: symbol;
    Splitter: symbol;
    MenuItem: symbol;
    ISystemMenu: symbol;
    IAppStoreService: symbol;
    IDesktopService: symbol;
    ComboBox: {
        ComboBoxItem: symbol;
    };
    IControlContainer: symbol;
    Form: symbol;
    RadioButtonGroup: {
        RadioButtonGroupItem: symbol;
    };
};

export enum PaddingApplies {
    None = 0,
    Top = 1,
    Left = 2,
    Right = 4,
    Bottom = 8,
    All = 15
}
export class Padding {
    static readonly Empty: Padding;
    Applies: PaddingApplies;
    constructor(all: number);
    constructor(left: number, top: number, right: number, bottom: number, applies?: PaddingApplies);
    get All(): number;
    set All(value: number);
    get Bottom(): number;
    set Bottom(value: number);
    get Left(): number;
    set Left(value: number);
    get Right(): number;
    set Right(value: number);
    get Top(): number;
    set Top(value: number);
    get Horizontal(): number;
    get Vertical(): number;
    get Size(): {
        width: number;
        height: number;
    };
    static Add(p1: Padding, p2: Padding): Padding;
    static Subtract(p1: Padding, p2: Padding): Padding;
    static CreateEmpty(): Padding;
}

export enum BorderApplies {
    None = 0,
    Top = 1,
    Left = 2,
    Right = 4,
    Bottom = 8,
    All = 15
}
export class Border {
    static Empty: Border;
    LeftBorderColor: string;
    TopBorderColor: string;
    RightBorderColor: string;
    BottomBorderColor: string;
    Applies: BorderApplies;
    constructor();
    AddLeftBorder(color: string): void;
    AddTopBorder(color: string): void;
    AddRightBorder(color: string): void;
    AddBottomBorder(color: string): void;
    Inpose(styleObject: any): void;
}

export class DomHandler {
        static calculatedScrollbarWidth: any;
        static browser: any;
        static style: any;
        static zIndex: any;
        static generateZIndex(): number;
        static revertZIndex(): void;
        static getCurrentZIndex(): any;
        static addCssToDocument(css: string, id?: string): string;
        static removeCssToDocument(id: string): void;
        static innerWidth(el: any): any;
        static width(el: any): any;
        static getWindowScrollTop(): number;
        static getWindowScrollLeft(): number;
        static getOuterWidth(el: any, margin?: any): any;
        static getOuterHeight(el: any, margin?: any): any;
        static getClientHeight(el: any, margin?: any): any;
        static getClientWidth(el: any, margin?: any): any;
        static getViewport(): {
                width: number;
                height: number;
        };
        static getOffset(el: any): {
                top: any;
                left: any;
        };
        static index(element: any): number;
        static addMultipleClasses(element: any, className: any): void;
        static removeMultipleClasses(element: any, className: any): void;
        static addClass(element: any, className: any): void;
        static removeClass(element: any, className: any): void;
        static hasClass(element: any, className: any): any;
        static find(element: any, selector: any): unknown[];
        static findSingle(element: any, selector: any): any;
        static getHeight(el: any): any;
        static getWidth(el: any): any;
        static alignOverlay(overlay: any, target: any, appendTo: any, calculateMinWidth?: boolean): void;
        static absolutePosition(element: any, target: any): void;
        static relativePosition(element: any, target: any): void;
        static flipfitCollision(element: any, target: any, my: string, at: string, callback: any): void;
        static findCollisionPosition(position: any): {
                axis: string;
                my: string;
                at: string;
        };
        static getParents(element: any, parents?: any[]): any;
        static getScrollableParents(element: any): any[];
        static getHiddenElementOuterHeight(element: any): any;
        static getHiddenElementOuterWidth(element: any): any;
        static getHiddenElementDimensions(element: any): any;
        static fadeIn(element: any, duration: any): void;
        static fadeOut(element: any, duration: any): void;
        static getUserAgent(): string;
        static isIOS(): boolean;
        static isAndroid(): boolean;
        static isTouchDevice(): boolean;
        static isFunction(obj: any): boolean;
        static appendChild(element: any, target: any): void;
        static removeChild(element: any, target: any): void;
        static isElement(obj: any): boolean;
        static scrollInView(container: any, item: any): void;
        static clearSelection(): void;
        static calculateScrollbarWidth(el?: any): any;
        static getBrowser(): any;
        static resolveUserAgent(): {
                browser: any;
                version: any;
        };
        static isVisible(element: any): boolean;
        static isExist(element: any): any;
        static hasDOM(): boolean;
        static getFocusableElements(element: any, selector?: string): any[];
        static getFirstFocusableElement(element: any, selector?: any): any;
        static getLastFocusableElement(element: any, selector: any): any;
        static getCursorOffset(el: any, prevText: any, nextText: any, currentText: any): {
                left: number;
                top: number;
        } | {
                top: string;
                left: string;
        };
        static invokeElementMethod(element: any, methodName: any, args: any): void;
        static isClickable(element: any): any;
        static applyStyle(element: any, style: any): void;
        static exportCSV(csv: any, filename: any): void;
        /**
            * Anytime an inline style is created check for CSP Nonce.
            * Create React App/Next look for environment variable 'process.env.REACT_APP_CSS_NONCE'.
            * Vite look for environment variable 'import.meta.env.VITE_CSS_NONCE'
            * Finally look for global variable PrimeReact.inlineCssNonce to set a CSP NONCE.
            *
            * @see https://github.com/primefaces/primereact/issues/2423
            * @return HtmlStyleElement
            */
        static createInlineStyle(): HTMLStyleElement;
        /**
            * Remove a style element from the head and attempt to prevent DOM Exception on fast refresh.
            *
            * @see https://github.com/primefaces/primereact/issues/2469
            * @param {HtmlStyleElement} styleElement the element to remove from head
            */
        static removeInlineStyle(styleElement: any): any;
}

export {};

export function UniqueComponentId(prefix?: string): string;

export enum MarginApplies {
    None = 0,
    Top = 1,
    Left = 2,
    Right = 4,
    Bottom = 8,
    All = 15
}
export class Margin {
    static readonly Empty: Margin;
    Applies: MarginApplies;
    constructor(all: number);
    constructor(left: number, top: number, right: number, bottom: number, applies?: MarginApplies);
    get All(): number;
    set All(value: number);
    get Bottom(): number;
    set Bottom(value: number);
    get Left(): number;
    set Left(value: number);
    get Right(): number;
    set Right(value: number);
    get Top(): number;
    set Top(value: number);
    get Horizontal(): number;
    get Vertical(): number;
    get Size(): {
        width: number;
        height: number;
    };
    static Add(p1: Margin, p2: Margin): Margin;
    static Subtract(p1: Margin, p2: Margin): Margin;
    static CreateEmpty(): Margin;
}

/**
    * @param {import('./index').StateUpdater<any>} [initialState]
    */
export function useState(initialState?: any): any;
export function bindState(initialState?: any): any;
/**
    * @param {import('./index').Reducer<any, any>} reducer
    * @param {import('./index').StateUpdater<any>} initialState
    * @param {(initialState: any) => void} [init]
    * @returns {[ any, (state: any) => void ]}
    */
export function useReducer(reducer: any, initialState: any, init?: any): any;
/**
    * @param {import('./internal').Effect} callback
    * @param {any[]} args
    */
export function useEffect(callback: any, args?: any): void;
/**
    * @param {import('./internal').Effect} callback
    * @param {any[]} args
    */
export function useLayoutEffect(callback: any, args: any): void;
export function useRef(initialValue?: any): any;
/**
    * @param {object} ref
    * @param {() => object} createHandle
    * @param {any[]} args
    */
export function useImperativeHandle(ref: any, createHandle: any, args?: any): void;
/**
    * @param {() => any} factory
    * @param {any[]} args
    */
export function useMemo(factory: any, args: any): any;
/**
    * @param {() => void} callback
    * @param {any[]} args
    */
export function useCallback(callback: any, args: any): any;
/**
    * @param {import('./internal').PreactContext} context
    */
export function useContext(context: any): any;
/**
    * Display a custom label for a custom hook for the devtools panel
    * @type {<T>(value: T, cb?: (value: T) => string | number) => void}
    */
export function useDebugValue(value: any, formatter: any): void;
/**
    * @param {(error: any) => void} cb
    */
export function useErrorBoundary(cb: any): any[];

export interface IStackFrame {
    isConstructor?: boolean;
    isEval?: boolean;
    isNative?: boolean;
    isToplevel?: boolean;
    columnNumber?: number;
    lineNumber?: number | string;
    fileName?: string;
    functionName?: string;
    source?: string;
    args?: any[];
    evalOrigin?: IStackFrame;
    toString(): string;
}
export class StackFrame implements IStackFrame {
    isConstructor?: boolean;
    isEval?: boolean;
    isNative?: boolean;
    isToplevel?: boolean;
    columnNumber?: number;
    lineNumber?: number | string;
    fileName?: string;
    functionName?: string;
    source?: string;
    args?: any[];
    evalOrigin?: IStackFrame;
    constructor(obj: IStackFrame);
    toString(): string;
}
export class ErrorStackParser {
    /**
      * Given an Error object, extract the most information from it.
      *
      * @param {Error} error object
      * @return {Array} of StackFrames
      */
    static parse(error: any): any;
    static extractLocation(urlLike: any): any[];
    static parseV8OrIE(error: any): any;
    static parseFFOrSafari(error: any): any;
    static parseOpera(e: any): any;
    static parseOpera9(e: any): any[];
    static parseOpera10(e: any): any[];
    static parseOpera11(error: any): any;
}
export interface IStateService {
    GetSessionId(): string;
    SetSessionId(value: string): void;
}
export class RealmHttpClient {
    static Post<D = any, T = any, R = HttpClientResponse<T>>(url: string, data?: D, config?: HttpClientRequestConfig<D>): Promise<R>;
}

/**
 * Finds first matching elements on the page that may be in a shadow root using a complex selector of n-depth
 *
 * Don't have to specify all shadow roots to button, tree is travered to find the correct element
 *
 * Example querySelectorAllDeep('downloads-item:nth-child(4) #remove');
 *
 * Example should work on chrome://downloads outputting the remove button inside of a download card component
 *
 * Example find first active download link element querySelectorDeep('#downloads-list .is-active a[href^="https://"]');
 *
 * Another example querySelectorAllDeep('#downloads-list div#title-area + a');
e.g.
 */
export function querySelectorAllDeep(selector: any, root?: Document, allElements?: any): any;
export function querySelectorDeep(selector: any, root?: Document, allElements?: any): any;
/**
    * Finds all elements on the page, inclusive of those within shadow roots.
    * @param {string=} selector Simple selector to filter the elements by. e.g. 'a', 'div.main'
    * @return {!Array<string>} List of anchor hrefs.
    * @author ebidel@ (Eric Bidelman)
    * License Apache-2.0
    */
export function collectAllElementsDeep(selector: any, root: any, cachedElements?: any): any[];

export const jss: import("jss").Jss;

/**
    * NOTE: If you refactor this to split up the modules into separate files,
    * you'll need to update the rollup config for router-dom-v5-compat.
    */
export { MemoryRouter, Navigate, Outlet, Route, Router, Routes, createRoutesFromChildren, generatePath, matchRoutes, matchPath, createPath, parsePath, renderMatches, resolvePath, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useNavigationType, useOutlet, useParams, useResolvedPath, useRoutes, useOutletContext, };
export interface BrowserRouterProps {
        basename?: string;
        children?: any;
        window?: Window;
}
/**
    * A `<Router>` for use in web browsers. Provides the cleanest URLs.
    */
export function BrowserRouter({ basename, children, window, }: BrowserRouterProps): any;
export interface HashRouterProps {
        basename?: string;
        children?: any;
        window?: Window;
}
/**
    * A `<Router>` for use in web browsers. Stores the location in the hash
    * portion of the URL so it is not sent to the server.
    */
export function HashRouter({ basename, children, window }: HashRouterProps): any;
export interface HistoryRouterProps {
        basename?: string;
        children?: any;
        history: History;
}
/**
    * A `<Router>` that accepts a pre-instantiated history object. It's important
    * to note that using your own history object is highly discouraged and may add
    * two versions of the history library to your bundles unless you use the same
    * version of the history library that React Router uses internally.
    */
function HistoryRouter({ basename, children, history }: HistoryRouterProps): any;
namespace HistoryRouter {
        var displayName: string;
}
export { HistoryRouter as unstable_HistoryRouter };
export interface LinkProps {
        reloadDocument?: boolean;
        replace?: boolean;
        state?: any;
        to: To;
}
/**
    * The public API for rendering a history-aware <a>.
    */
export const Link: {
        (props: any, ref: any): any;
        $$typeof: number | symbol;
        render: any;
        _forwarded: boolean;
        displayName: string;
};
export interface NavLinkProps extends Omit<LinkProps, "className" | "style" | "children"> {
        children?: any | ((props: {
                isActive: boolean;
        }) => any);
        caseSensitive?: boolean;
        className?: string | ((props: {
                isActive: boolean;
        }) => string | undefined);
        end?: boolean;
        style?: any | ((props: {
                isActive: boolean;
        }) => any);
}
/**
    * A <Link> wrapper that knows if it's "active" or not.
    */
export const NavLink: {
        (props: any, ref: any): any;
        $$typeof: number | symbol;
        render: any;
        _forwarded: boolean;
        displayName: string;
};
/**
    * Handles the click behavior for router `<Link>` components. This is useful if
    * you need to create custom `<Link>` components with the same click behavior we
    * use in our exported `<Link>`.
    */
export function useLinkClickHandler<E extends Element = HTMLAnchorElement>(to: To, { target, replace: replaceProp, state, }?: {
        target?: any;
        replace?: boolean;
        state?: any;
}): (event: any) => void;
/**
    * A convenient wrapper for reading and writing search parameters via the
    * URLSearchParams interface.
    */
export function useSearchParams(defaultInit?: URLSearchParamsInit): readonly [any, any];
export type ParamKeyValuePair = [string, string];
export type URLSearchParamsInit = string | ParamKeyValuePair[] | Record<string, string | string[]> | URLSearchParams;
/**
    * Creates a URLSearchParams object using the given initializer.
    *
    * This is identical to `new URLSearchParams(init)` except it also
    * supports arrays as values in the object form of the initializer
    * instead of just strings. This is convenient when you need multiple
    * values for a given key, but don't want to use an array initializer.
    *
    * For example, instead of:
    *
    *   let searchParams = new URLSearchParams([
    *     ['sort', 'name'],
    *     ['sort', 'price']
    *   ]);
    *
    * you can do:
    *
    *   let searchParams = createSearchParams({
    *     sort: ['name', 'price']
    *   });
    */
export function createSearchParams(init?: URLSearchParamsInit): URLSearchParams;

const version = "17.0.2";
/**
    * Legacy version of createElement.
    * @param {import('./internal').VNode["type"]} type The node name or Component constructor
    */
function createFactory(type: any): (props: any, children?: any) => {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
};
/**
    * Check if the passed element is a valid (p)react node.
    * @param {*} element The element to check
    * @returns {boolean}
    */
function isValidElement(element: any): boolean;
/**
    * Wrap `cloneElement` to abort if the passed element is not a valid element and apply
    * all vnode normalizations.
    * @param {import('./internal').VNode} element The vnode to clone
    * @param {object} props Props to add when cloning
    * @param {Array<import('./internal').ComponentChildren>} rest Optional component children
    */
function cloneElement(element: any, args?: any): any;
/**
    * Remove a component tree from the DOM, including state and event handlers.
    * @param {import('./internal').PreactElement} container
    * @returns {boolean}
    */
function unmountComponentAtNode(container: any): boolean;
/**
    * Get the matching DOM node for a component
    * @param {import('./internal').Component} component
    * @returns {import('./internal').PreactElement | null}
    */
function findDOMNode(component: any): any;
/**
    * Deprecated way to control batched rendering inside the reconciler, but we
    * already schedule in batches inside our rendering code
    * @template Arg
    * @param {(arg: Arg) => void} callback function that triggers the updated
    * @param {Arg} [arg] Optional argument that can be passed to the callback
    */
const unstable_batchedUpdates: (callback: any, arg: any) => any;
/**
    * In React, `flushSync` flushes the entire tree and forces a rerender. It's
    * implmented here as a no-op.
    * @template Arg
    * @template Result
    * @param {(arg: Arg) => Result} callback function that runs before the flush
    * @param {Arg} [arg] Optional arugment that can be passed to the callback
    * @returns
    */
const flushSync: (callback: any, arg: any) => any;
/**
    * Strict Mode is not implemented in Preact, so we provide a stand-in for it
    * that just renders its children without imposing any restrictions.
    */
const StrictMode: typeof Fragment;
export { version, Children, render, hydrate, unmountComponentAtNode, createPortal, Portal, createElement, createContext, createFactory, cloneElement, createRef, Fragment, isValidElement, findDOMNode, Component, PureComponent, memo, forwardRef, flushSync, unstable_batchedUpdates, StrictMode, Suspense, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED };
const _default: {
        useState: typeof useState;
        useReducer: typeof useReducer;
        useEffect: typeof useEffect;
        useLayoutEffect: typeof useLayoutEffect;
        useRef: typeof useRef;
        useImperativeHandle: typeof useImperativeHandle;
        useMemo: typeof useMemo;
        useCallback: typeof useCallback;
        useContext: typeof useContext;
        useDebugValue: typeof useDebugValue;
        version: string;
        Children: {
                map: (children: any, fn: any) => any;
                forEach: (children: any, fn: any) => any;
                count(children: any): any;
                only(children: any): any;
                toArray: typeof import("../index").toChildArray;
        };
        render: typeof render;
        hydrate: typeof hydrate;
        unmountComponentAtNode: typeof unmountComponentAtNode;
        createPortal: typeof createPortal;
        createElement: typeof createElement;
        createContext: typeof createContext;
        createFactory: typeof createFactory;
        cloneElement: typeof cloneElement;
        createRef: typeof createRef;
        Fragment: typeof Fragment;
        isValidElement: typeof isValidElement;
        findDOMNode: typeof findDOMNode;
        Component: typeof Component;
        PureComponent: typeof PureComponent;
        memo: typeof memo;
        forwardRef: typeof forwardRef;
        flushSync: (callback: any, arg: any) => any;
        unstable_batchedUpdates: (callback: any, arg: any) => any;
        StrictMode: typeof Fragment;
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                ReactCurrentDispatcher: {
                        current: {
                                readContext(context: any): any;
                        };
                };
        };
};
export default _default;

export class __ComponentCollection extends ReadOnlyCollectionBase<IComponent> {
    protected _getCount(): number;
    protected _getEnumerator(): IEnumerator<IComponent>;
    get(name: string): IComponent;
    constructor(components: IComponent[]);
}

export interface IComponent extends IDisposable {
    Site: ISite;
    disposed: EventHandler;
}

export interface IContainer extends IDisposable {
    Components: __ComponentCollection;
    add(component: IComponent): void;
    add(component: IComponent, name: string): void;
    remove(component: IComponent): void;
}

export interface ISite {
    Component: IComponent;
    Container: IContainer;
    DesignMode: boolean;
    Name: string;
}

export interface ITypeDescriptorContext {
    Container: IContainer;
    Instance: any;
    PropertyDescriptor: PropertyDescriptor;
    onComponentChanged(): void;
    onComponentChanging(): boolean;
}

type Constructor<T = any> = new (props: any) => T;
export const RendererTable: Hashtable<Type, Constructor>;
export let lastEnteredPropertyName: string;
export function ConvertToInt$(source: Observable<int>): Observable<int>;
export function ConvertToFunc$(source: Observable<any>, func: (val: any) => void): Observable<any>;
export function throttle$(source: Observable<any>, interv: int): Observable<any>;
export function Subscriber$(source: Observable<any>, func: Function): void;
export interface IControlContainer {
    GetControls(): List<Control<any>>;
}
export enum Modes {
    Component = 0,
    Control = 1
}
export abstract class TComponent extends React.Component {
    Render(): any;
    GetType(): Type;
    PropertyChanged: Event<any>;
    UpdateRequied: Event<any>;
    get Components(): ComponentCollection;
    get Owner(): TComponent;
    set Owner(value: TComponent);
    __Mode__: Modes;
    protected __m_PropertyBag__: any;
    protected __m_PipeBag__: any;
    protected __m_IsComponent__: boolean;
    protected __m_Component__: any;
    get m_PropertyBag(): any;
    set m_PropertyBag(value: any);
    get m_PipeBag(): any;
    set m_PipeBag(value: any);
    get m_IsComponent(): any;
    set m_IsComponent(value: any);
    get m_Component(): any;
    set m_Component(value: any);
    __Bounds__: CGRectangle;
    __Dash__: DashStyle;
    BeginUpdate(): void;
    EndUpdate(): void;
    UnLoad(): void;
    GetPipe<P>(propertyName: string): ReplaySubject<P>;
    protected SetPipe<P>(propertyName: any, value: Observable<P>): void;
    protected SetPropertyInSlient(name: string, value: any): void;
    protected GetPropertyInSlient(name: string): any;
    protected SetProperty(name: string, value: any): void;
    protected GetProperty(name: string): any;
    constructor();
    constructor(props: any);
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    protected InitComponents(): void;
    ForceUpdate(): void;
    protected OnComponentSet(form: any): void;
    OnFormResized(width: int, height: int): void;
    protected abstract CreateElements<T>(param?: T): any;
    protected CreateElementsInternal(): any;
    OnAdoption(parent: Control<any>): void;
    CreateMainElement(param?: any): any;
    render(): any;
    protected componentWillMount(): void;
    protected componentDidMount(): void;
    componentWillReceiveProps(): void;
    shouldComponentUpdate(nextProps: any, nextState: any): boolean;
    componentWillUpdate(): void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    protected componentWillUnmount(): void;
    protected OnComponentWillMount(): void;
    protected OnComponentDidMount(): void;
    protected OnComponentWillReceiveProps(): void;
    protected OnShouldComponentUpdate(): boolean;
    protected OnComponentWillUpdate(): boolean;
    protected OnComponentDidUpdate(): boolean;
    protected OnComponentWillUnmount(): boolean;
    protected InitializeComponent(): void;
    protected GetRenderer(): any;
}
export abstract class Control<T extends Control = any, TController = any> extends TComponent implements IControl, IRenderable {
    jssStyle: any;
    KeyFrameCollection: KeyFrameCollection[];
    Tooltip: string;
    TabIndex: int;
    protected SendMessageToController(message: string, ...args: any[]): void;
    Appearance: AppearanceObject;
    HoverAppearance: AppearanceObject;
    FocusAppearance: AppearanceObject;
    ActiveAppearance: AppearanceObject;
    DisabledAppearance: AppearanceObject;
    BeforeAppearance: AppearanceObject;
    Loaded: Event<any>;
    UnLoaded: Event<any>;
    OnLoaded(): void;
    OnUnLoaded(): void;
    MouseHover: Event<any>;
    MouseMove: Event<any>;
    Clicked: Event<any>;
    protected CreateFrameElement: boolean;
    Handle: string;
    Id: string;
    Tag: any;
    protected myParent: Control<any>;
    get Parent(): Control<any>;
    set Parent(value: Control<any>);
    get Parent$(): ReplaySubject<any>;
    set Parent$(value: ReplaySubject<any>);
    get BackgroundColor(): string;
    set BackgroundColor(value: string);
    get ForeColor(): string;
    set ForeColor(value: string);
    Visible: boolean;
    get Visible$(): ReplaySubject<boolean>;
    set Visible$(value: ReplaySubject<boolean>);
    Disabled: boolean;
    get Text(): string;
    set Text(value: string);
    Width: int;
    Height: int;
    get Height$(): ReplaySubject<int>;
    set Height$(value: ReplaySubject<int>);
    Padding: Padding;
    Border: Border;
    Margin: Margin;
    Loading: boolean;
    Left?: string;
    Top?: string;
    Bottom?: string;
    Right?: string;
    _Width?: string;
    _Height?: string;
    BackColor: CGColor;
    PaddingAll?: string;
    PaddingLeft?: string;
    PaddingRight?: string;
    PaddingTop?: string;
    PaddingBottom?: string;
    GetForm(): TForm;
    SendResizeRequest(): void;
    protected SetupControlDefaults(): void;
    OnAdoption(parent: Control<any>): void;
    protected CreateElements(param: any): any;
    protected CreateElementsInternal(): any;
    protected GetStyleObject(): any;
    OnFormResized(width: int, height: int): void;
    OnParentSet(parent: Control<any>): void;
    protected InitComponents(): void;
    WndProc(m: Message): void;
    protected wmDestroy(m: Message): void;
    protected OnMouseMove(e: MouseEventArgs): void;
    protected OnMouseHover(e: EventArgs): void;
    protected OnClick(e: EventArgs): void;
}
export {};

export class ControlCollection<TParent extends Control = any, TItem extends Control = any> extends List<any> {
    ItemAdded: Event<any>;
    get Parent(): TParent;
    constructor(parent: TParent);
    Get(index: int): TItem;
    Add(item: TItem): int;
    RemoveAt(index: int): void;
}
export class ComponentCollection<T = TComponent> extends List<T> {
    constructor(parent: TComponent);
    Add(item: T): int;
    RemoveAt(index: int): void;
}

export const ApplicationContext: {
    _id: any;
    _defaultValue: any;
    Consumer(props: any, contextValue: any): any;
    Provider(props: any): any;
};
export function useApplication(): TApplication;
export enum ApplicationModes {
    Desktop = 1,
    Portal = 2,
    Mobile = 3
}
export class TApplication extends Control<TApplication> {
    static ApplicationMode: ApplicationModes;
    static get IsDesktop(): boolean;
    static get IsPortal(): boolean;
    static get IsMobile(): boolean;
    get StartResolve(): any;
    set StartResolve(value: any);
    get Icon(): string;
    set Icon(value: string);
    get Disposed(): boolean;
    set Disposed(value: boolean);
    get Name(): string;
    set Name(value: string);
    get Forms(): List<TForm>;
    set Forms(value: List<TForm>);
    protected get Controller(): UIController;
    protected set Controller(value: UIController);
    protected get MainForm(): TForm;
    protected set MainForm(value: TForm);
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    SetMainForm(mainform: TForm): void;
    SetMainController(mainform: UIController): void;
    protected GetTheme(): any;
    CreateElements(): any;
    Dispose(): void;
    Start(): void;
}

export class TopMaximizeChangeHandler extends Delegate<(topMaximized: boolean) => void> {
}
export class TForm<TController = any> extends Control<TForm, TController> {
    static ActiveForm: TForm;
    m_Dialog: Dialog;
    get OnResizeInternal(): Function;
    set OnResizeInternal(value: Function);
    get ResizeEnd(): Event<EventHandler>;
    set ResizeEnd(value: Event<EventHandler>);
    get ZIndex(): int;
    set ZIndex(value: int);
    get Maximizable(): boolean;
    set Maximizable(value: boolean);
    get TopMaximizable(): boolean;
    set TopMaximizable(value: boolean);
    get IsActive(): boolean;
    set IsActive(value: boolean);
    get Minimizable(): boolean;
    set Minimizable(value: boolean);
    TopMaximized: boolean;
    TopMaximizeChanged: Event<TopMaximizeChangeHandler>;
    DefaultUrl: string;
    get Maximized(): boolean;
    set Maximized(value: boolean);
    get Minimized(): boolean;
    set Minimized(value: boolean);
    get Resizable(): boolean;
    set Resizable(value: boolean);
    get Name(): string;
    set Name(value: string);
    get MainMenu(): Control<MainMenu | RibbonMenu>;
    set MainMenu(value: Control<MainMenu | RibbonMenu>);
    get Application(): TApplication;
    set Application(value: TApplication);
    get Icon(): string;
    set Icon(value: string);
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    get FooterControls(): ControlCollection;
    set FooterControls(value: ControlCollection);
    get ShowHeader(): boolean;
    set ShowHeader(value: boolean);
    get HeaderTitleColor(): string;
    set HeaderTitleColor(value: string);
    get HeaderTitleAlign(): string;
    set HeaderTitleAlign(value: string);
    get HeaderTitleFontSize(): string;
    set HeaderTitleFontSize(value: string);
    get Modal(): boolean;
    set Modal(value: boolean);
    get IsMdiContainer(): boolean;
    set IsMdiContainer(value: boolean);
    get MdiParent(): TForm;
    set MdiParent(value: TForm);
    get HeaderHeight(): string;
    set HeaderHeight(value: string);
    get HeaderPadding(): string;
    set HeaderPadding(value: string);
    get HeaderSubStyle(): string;
    set HeaderSubStyle(value: string);
    get HeaderColor(): string;
    set HeaderColor(value: string);
    get ContentHeight(): int;
    set ContentHeight(value: int);
    get ContentHeight$(): ReplaySubject<int>;
    set ContentHeight$(value: ReplaySubject<int>);
    get ContentPadding(): string;
    set ContentPadding(value: string);
    HScroll: boolean;
    VScroll: boolean;
    constructor();
    constructor(props: any);
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    InitComponents(): void;
    CreateFooterControls(): any[];
    get ZOrder(): int;
    set ZOrder(value: int);
    CreateElements(): any;
    StartFormDrag(event: any): any;
    Maximize(): void;
    TopMaximize(): void;
    OnShown(): void;
    Show(): void;
    ShowDialog(): void;
    Hide(): void;
    protected OnResize(e: any): void;
}

export enum DialogResult {
    Abort = 3,
    Cancel = 2,
    Continue = 11,
    Ignore = 5,
    No = 7,
    None = 0,
    OK = 1,
    Retry = 4,
    TryAgain = 10,
    Yes = 6
}
export class Dialog<TController = any> extends Control<Dialog, TController> {
    DialogResult: DialogResult;
    Position: string;
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    get FooterControls(): ControlCollection;
    set FooterControls(value: ControlCollection);
    SetupControlDefaults(): void;
    CreateElements(): any;
    OnShown(): void;
    ShowDialog(): void;
    protected ShowDialogAsyncResolve: any;
    protected ShowDialogAsyncReject: any;
    ShowDialogAsync(): Promise<any>;
    Hide(): void;
    protected GetStyleObject(): any;
}

export class TTextBox extends Control<TTextBox> implements ITextBox {
    Label: string;
    Placeholder: string;
    Autofocus: boolean;
    LeftIcon: string;
    OnKeyDownInternal: Function;
    KeyDown: Event<any>;
    constructor();
    OnTextChange(text: string): void;
    protected OnKeyDown(e: any): void;
    protected GetRenderer(): any;
}

export class TTextArea extends Control<TTextArea> {
    get Label(): string;
    set Label(value: string);
    CreateElements(): any;
    OnTextChange(text: string): void;
}

export class TabPageCollection<T extends TTabPage> extends ControlCollection<TTabControl, T> {
    Add(item: T): int;
}
export class TTabPage extends Control<TTabPage> {
    get Closable(): boolean;
    set Closable(value: boolean);
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    protected SetupControlDefaults(): void;
    OnActivate(): void;
    AddControl(control: any): void;
    CreateControls(): any;
    CreateElements(): any;
    OnFormResized(width: int, height: int): void;
}
export class TTabControl<T extends TTabPage = TTabPage> extends Control<TTabControl<T>> implements IControlContainer {
    SelectedIndexChanged: Event<any>;
    TabPages: TabPageCollection<T>;
    ShowHeader: boolean;
    Closable: boolean;
    ActiveIndex: int;
    TabPageAdded: Event<any>;
    TabPageRemoved: Event<any>;
    get ActiveIndex$(): Observable<int>;
    set ActiveIndex$(value: Observable<int>);
    get ActiveTabPage(): TTabPage;
    set ActiveTabPage(value: TTabPage);
    constructor();
    AddTabPage(tabPage: T): void;
    protected GetRenderer(): typeof TTabControlRenderer;
    GetControls(): List<Control<any>>;
    OnFormResized(width: int, height: int): void;
    ForceUpdate(): void;
}

export class TComboBox extends Control<TComboBox> {
    get SelectedItem(): any;
    set SelectedItem(value: any);
    get Label(): string;
    set Label(value: string);
    CreateElements(): any;
}

class PageControlCollection extends List<Control<any>> {
    _: any;
    constructor(page: Page);
    Add(item: any): int;
}
export class Page extends Control<Page> {
    get SideBarControls(): PageControlCollection;
    set SideBarControls(value: PageControlCollection);
    get ContentControls(): PageControlCollection;
    set ContentControls(value: PageControlCollection);
    protected SetupControlDefaults(): void;
    InitComponents(): void;
    CreateElements(): any;
}
export {};

export class TSplitter extends Control<TSplitter> {
    get LeftControl(): Control;
    set LeftControl(value: Control);
    get RightControl(): Control;
    set RightControl(value: Control);
    CreateElements(): any;
}

export class TCanvas extends Control<TCanvas> {
    CreateElements(): any;
}

export class MainMenu extends Control<MainMenu> {
    get Model(): any[];
    set Model(value: any[]);
    CreateElements(): any;
}

class DesktopIconCollection extends List<DesktopIcon> {
    _: any;
    constructor(page: Desktop);
    Add(item: DesktopIcon): int;
}
class ModalCollection extends List<Dialog> {
    Remove(removedItem: Dialog): boolean;
}
class ModalDialogContainer extends TComponent {
    ModalDialogs: ModalCollection;
    protected SetupControlDefaults(): void;
    protected CreateElements<T>(param?: T): any;
}
export class Desktop extends Control<Desktop> {
    static TopControl: Control<any>;
    static ModalDialogContainer: ModalDialogContainer;
    static User: string;
    fileUploadRef: any;
    taskbar: Taskbar;
    get AppView(): boolean;
    set AppView(value: boolean);
    get Password(): boolean;
    set Password(value: boolean);
    get Icons(): DesktopIconCollection;
    set Icons(value: DesktopIconCollection);
    get _Router(): Router;
    set _Router(value: Router);
    get ShowAuthemticationDialog(): boolean;
    set ShowAuthemticationDialog(value: boolean);
    SiteMode: boolean;
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    protected InitComponents(): void;
    InitDesktop(): void;
    static DesktopContextMenu: any;
    get ProfilePicture(): string;
    set ProfilePicture(value: string);
    Controls: ControlCollection;
    CreateElements(): any;
    protected componentDidMount(): void;
    protected componentWillUnmount(): void;
    Start(): void;
}
export {};

class ClickEvent extends Delegate<() => void> {
}
export class DesktopIcon extends TComponent {
    m_OnClick: Event<ClickEvent>;
    Loading: boolean;
    get Text(): string;
    set Text(value: string);
    get Parent(): Desktop;
    set Parent(value: Desktop);
    get Index(): int;
    set Index(value: int);
    get AppInfo(): any;
    set AppInfo(value: any);
    get Icon(): string;
    set Icon(value: string);
    get ApplicationType(): any;
    set ApplicationType(value: any);
    get OnClick(): Event<ClickEvent>;
    set OnClick(value: Event<ClickEvent>);
    protected SetupControlDefaults(): void;
    SetManifest(appInfo: any, applicationType?: any): void;
    componentDidMount(): void;
    protected OnRequestStartApplication(): void;
    CreateElements(): any;
}
export {};

export class TaskManager {
    static Start(appType: any): Promise<TApplication>;
    static Quit(app: TApplication): void;
    static GetApplications(): TApplication[];
}

export class ConsoleReady extends Delegate<(console: TextConsole<any>) => void> {
}
export class Terminal extends Control<Terminal> {
    get OnConsoleReady(): Event<ConsoleReady>;
    set OnConsoleReady(value: Event<ConsoleReady>);
    get Console(): TextConsole<any>;
    set Console(value: TextConsole<any>);
    get Label(): string;
    set Label(value: string);
    protected SetupControlDefaults(): void;
    componentDidMount(): void;
    CreateElements(): any;
}

export class CheckedChangedEventHandler extends Delegate<(checked: boolean) => void> {
}
export class Checkbox extends Control<Checkbox> {
    get Checked(): boolean;
    set Checked(value: boolean);
    get CheckedChanged(): Event<CheckedChangedEventHandler>;
    set CheckedChanged(value: Event<CheckedChangedEventHandler>);
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    CreateElements(): any;
    OnChange(): void;
}

export enum FormLayoutModes {
    Vertical = 0,
    VerticalGrid = 1,
    HorizontalFixed = 2,
    HorizontalFluid = 3
}
export class FormLayout extends Control<FormLayout> {
    get Layout(): FormLayoutModes;
    set Layout(value: FormLayoutModes);
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    protected SetupControlDefaults(): void;
    CreateElements(): any;
}

export class Panel extends Control<Panel> {
    Controls: ControlCollection;
    constructor();
    protected OnMouseMove(e: EventArgs): void;
}
export class TControlContainer extends Control<Panel> {
    Controls: ControlCollection;
    constructor();
    protected GetRenderer(): any;
    protected OnMouseMove(e: EventArgs): void;
}
export interface IVirtualContainer extends IControl {
    Controls: ControlCollection;
    GetViews(): IRenderable[];
}
export class TVirtualContainer extends Control<Panel> implements IVirtualContainer {
    Controls: ControlCollection;
    GetViews(): IRenderable[];
    constructor();
    protected GetRenderer(): any;
    protected OnMouseMove(e: EventArgs): void;
}
export class TContainerControlRenderer extends ControlHtmlRenderer<IVirtualContainer> {
    ChildrenCreating: Event<any>;
    OnStyleCreating(obj: IVirtualContainer, sb: StringBuilder): void;
    GenerateElement(obj: IVirtualContainer): boolean;
    GenerateBody(obj: IVirtualContainer): void;
    protected CreateControls(obj: IVirtualContainer): any[];
}
export class TFlexContainer extends TVirtualContainer {
    constructor();
}
export class TFlexColumnContainer extends TVirtualContainer {
    constructor();
}
export class TFlexRowContainer extends TVirtualContainer {
    constructor();
}
export class ContainerPanel extends Control<ContainerPanel> {
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    protected SetupControlDefaults(): void;
    InitComponents(): void;
    CreateElements(): any;
}

export class FileUpload extends Control<FileUpload> {
    Url: string;
    get FileReady(): Event<EventHandler>;
    set FileReady(value: Event<EventHandler>);
    get AllowedExtensions(): string;
    set AllowedExtensions(value: string);
    SetupControlDefaults(): void;
    SetupComponentDefaults(): void;
    get Label(): string;
    set Label(value: string);
    get SelectedFileName(): string;
    get SelectedFileExt(): string;
    GetFileContentAsString(): string;
    GetFileContentAsByteArray(): ByteArray;
    SelectFile(): void;
    CreateElements(): any;
}

export class ScrollPanel extends ContainerControl<ScrollPanel> {
    CreateElements(): any;
}

export class MediaPlayer extends Control<MediaPlayer> {
    m_videoComponent: any;
    get Url(): string;
    set Url(value: string);
    get PreviewImage(): string;
    set PreviewImage(value: string);
    get Logo(): string;
    set Logo(value: string);
    get Playing(): boolean;
    set Playing(value: boolean);
    SetupControlDefaults(): void;
    CreateElements(): any;
    Play(): void;
    Stop(): void;
    OnTextChange(text: string): void;
}

export class PanelMenu extends Control<PanelMenu> {
    get Model(): any;
    set Model(value: any);
    CreateElements(): any;
}

export class PaintEventHandler extends Delegate<(g: SketchGraphics) => void> {
}
export class Canvas extends Control<Canvas> {
    get OnPaintInternal(): Function;
    set OnPaintInternal(value: Function);
    get PaintEvent(): Event<PaintEventHandler>;
    set PaintEvent(value: Event<PaintEventHandler>);
    get Graphics(): SketchGraphics;
    get Umay(): Umay;
    set Umay(value: Umay);
    get ID(): string;
    set ID(value: string);
    SetupControlDefaults(): void;
    protected OnPaint(e: SketchGraphics): void;
    componentDidMount(): void;
    ResizeCanvas(width: int, height: int): void;
    componentWillUnmount(): void;
    CreateElements(): any;
}

export class GuiConsole extends Control<GuiConsole> {
    get OnConsoleReady(): Event<ConsoleReady>;
    set OnConsoleReady(value: Event<ConsoleReady>);
    get Console(): GC<any>;
    set Console(value: GC<any>);
    get Label(): string;
    set Label(value: string);
    protected SetupControlDefaults(): void;
    componentDidMount(): void;
    CreateElements(): any;
}

export class PageFrame extends Control<PageFrame> {
    get _Loaded(): boolean;
    set _Loaded(value: boolean);
    get Src(): string;
    set Src(value: string);
    SetupComponentDefaults(): void;
    GetContentHeight(): int;
    GetFrameElement(): any;
    CreateElements(): any;
}

export class Rating extends Control<Rating> {
    get StarColor(): string;
    set StarColor(value: string);
    get Stars(): int;
    set Stars(value: int);
    get Size(): int;
    set Size(value: int);
    get Value(): int;
    set Value(value: int);
    get Cancel(): boolean;
    set Cancel(value: boolean);
    get ReadOnly(): boolean;
    set ReadOnly(value: boolean);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export let ResizeSensor: any;

export function IpcMessage(target: any, propertyKey: string, descriptor: PropertyDescriptor): void;
export function View<T extends {
    new (...args: any[]): {};
}>(Base: T): {
    new (...args: any[]): {};
} & T;
export function Controller<T extends {
    new (...args: any[]): {};
}>(Base: T): {
    new (...args: any[]): {};
} & T;
export abstract class TController {
    constructor();
    protected SendMessageToView(message: string, ...args: any[]): void;
    SetView(view: any): void;
}

export interface IView {
    Controller: TController;
    SetController(controller: TController): void;
    WndProc(msg: Message): any;
}

export class EventArgs {
    static readonly Empty: EventArgs;
    constructor();
}

export class EventHandler extends Delegate<(e: EventArgs) => void> {
}

export class UIButtonClass extends UIView implements IVirtualContainer {
    setController(controller: UIController): this;
    constructor();
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    action(actionFunc: Function): this;
}
export function UIButton(...subViews: (UIView | IControl | UIController)[]): UIButtonClass;
export class UITextFieldClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    text(value: string): this;
    GetControl(): Control;
}
export function UITextField(): UITextFieldClass;

export class UISceneClass extends UIView implements IVirtualContainer {
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    setController(controller: UIController): this;
    constructor();
}
export function UIScene(...subViews: (UIView | IControl | UIController)[]): UISceneClass;
export interface DesktopPreviewParams {
    width?: number | string;
    height?: number | string;
}
export type FunctionDesktopPreview = (...views: UIView[]) => UIView;
export function DesktopPreview(value: DesktopPreviewParams): FunctionDesktopPreview;
export function DesktopPreview(...subViews: (UIView | IControl | UIController)[]): UIView;
type ForEachIterateFunction<T> = (item: T, index?: number) => UIView;
export function ForEach<T>(enumarable: IEnumerator<T> | IEnumerable<T> | IList<T> | Array<T> | ICollection<T> | Iterator<T> | Iterable<T> | Set<T>): (value: ForEachIterateFunction<T>) => any[];
export function Filter(enumarable: any, enumFunc: Function): IRenderable[];
type TrueCaseFunction = (view: UIView) => FalseCaseFunction;
type FalseCaseFunction = {
    else: (view: UIView) => UIView;
};
export function If(condition: boolean): TrueCaseFunction;
export function Case<T extends UIView>(match: string | number, caseObject: any): T;
export {};

export let currentController: any;
export function Context(): (target: any, key: string, descriptor: PropertyDescriptor) => void;
export class UIController<T = any> extends Control implements IRenderable, IVirtualContainer {
    IsModelBind: boolean;
    Theme: any;
    setTheme(theme: any): void;
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    ParentController: UIController;
    protected SetupControlDefaults(): void;
    protected InitController(): void;
    $<T>(value: T): BindingClass<T>;
    $$<T>(value: T): BindingClass<T>;
    LoadView(): UIView;
    Bind(model: T): this;
    OnBindModel(model: T): void;
    protected BindRouterParams(params?: any): void;
    protected UseRouter(): boolean;
    _location: any;
    _params: any;
    Application: TApplication;
    navigotor: NavigateFunction;
    protected OnComponentDidMount(): void;
    protected CreateElements(param: any): any;
    Render(): any;
}

export type DividerTyype = (view: UIView) => void;
export class VStackDividerTypes {
    static Divide0: (view: UIView) => void;
    static Divide: (view: UIView) => void;
    static Divide2: (view: UIView) => void;
    static Divide4: (view: UIView) => void;
    static Divide8: (view: UIView) => void;
}
export class VStackClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    divider(value: DividerTyype): this;
    protected CreateControls(obj: VStackClass): any[];
}
interface VStackParams {
    alignment?: AlignmentType;
    spacing?: int;
}
type FunctionVStack = (...views: UIView[]) => VStackClass;
export function VStack(): VStackClass;
export function VStack(...views: (UIView | IControl | UIController)[]): VStackClass;
export function VStack(value: VStackParams): FunctionVStack;
export function Cache(useCache: boolean, builder: () => UIView): UIView;
export function AnimationStack(...subViews: (UIView | IControl | UIController)[]): VStackClass;
export class FVStackClass extends VStackClass {
    Render(): any;
}
export function FVStack(): FVStackClass;
export function FVStack(...views: (UIView | IControl | UIController)[]): FVStackClass;
export function FVStack(value: VStackParams): FunctionVStack;
export {};

export class HStackRenderer extends ControlHtmlRenderer<HStackClass> {
    ChildrenCreating: Event<any>;
    OnStyleCreating(obj: HStackClass, sb: StringBuilder): void;
    GenerateElement(obj: HStackClass): boolean;
    GenerateBody(obj: HStackClass): void;
    protected CreateControls(obj: HStackClass): any[];
}
export class HStackClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
}
interface HStackParams {
    alignment?: AlignmentType;
    spacing?: int;
}
type FunctionVStack = (...views: UIView[]) => HStackClass;
export function HStack(): HStackClass | FunctionVStack;
export function HStack(...views: (UIView | IControl | UIController)[]): HStackClass;
export function HStack(value: HStackParams): FunctionVStack;
export class FHStackClass extends UIView {
    constructor();
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    protected CreateControls(obj: FHStackClass): any[];
    Render(): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
    };
}
export function FHStack(): FHStackClass | FunctionVStack;
export function FHStack(...views: (UIView | IControl | UIController)[]): FHStackClass;
export function FHStack(value: HStackParams): FunctionVStack;
export {};

export class ZStackRenderer extends ControlHtmlRenderer<ZStackClass> {
    get UseShadowDom(): boolean;
    GenerateElement(obj: ZStackClass): boolean;
    GenerateBody(obj: ZStackClass): void;
    protected CreateControls(obj: ZStackClass): any[];
}
export class ZStackClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    setChilds(...args: (UIView | IControl | UIController)[]): this;
}
export function ZStack(...subViews: (UIView | IControl | UIController)[]): ZStackClass;

export enum RenderingTypes {
    Normal = 1,
    Markdown = 2
}
export enum TextAlignment {
    center = 0,
    leading = 1,
    trailing = 2
}
export class UITextClass extends UIView implements ILabel {
    setController(controller: UIController): this;
    constructor();
    text(buttonLabel: string): this;
    textAlign(value: string): this;
    render(type: RenderingTypes): this;
    multilineTextAlignment(value: TextAlignment): this;
    whiteSpace(value: string): this;
    textOverflow(value: string): this;
    searchWords(value: string[]): this;
}
export function Text(text: string): UITextClass;
export class UIFastTextClass extends UITextClass implements ILabel {
    Render(): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
    };
}
export function FastText(text: string): UIFastTextClass;

export class DividerClass extends UIView {
    setController(controller: UIController): this;
}
export function VDivider(): DividerClass;
export function HDivider(): DividerClass;

export function Color(value: string): ColorClass;
export namespace Color {
    let black: ColorClass;
    let navy: ColorClass;
    let darkblue: ColorClass;
    let mediumblue: ColorClass;
    let blue: ColorClass;
    let darkgreen: ColorClass;
    let green: ColorClass;
    let teal: ColorClass;
    let darkcyan: ColorClass;
    let deepskyblue: ColorClass;
    let darkturquoise: ColorClass;
    let mediumspringgreen: ColorClass;
    let lime: ColorClass;
    let springgreen: ColorClass;
    let aqua: ColorClass;
    let cyan: ColorClass;
    let midnightblue: ColorClass;
    let dodgerblue: ColorClass;
    let lightseagreen: ColorClass;
    let forestgreen: ColorClass;
    let seagreen: ColorClass;
    let darkslategray: ColorClass;
    let limegreen: ColorClass;
    let mediumseagreen: ColorClass;
    let turquoise: ColorClass;
    let royalblue: ColorClass;
    let steelblue: ColorClass;
    let darkslateblue: ColorClass;
    let mediumturquoise: ColorClass;
    let indigo: ColorClass;
    let darkolivegreen: ColorClass;
    let cadetblue: ColorClass;
    let cornflowerblue: ColorClass;
    let rebeccapurple: ColorClass;
    let mediumaquamarine: ColorClass;
    let dimgray: ColorClass;
    let slateblue: ColorClass;
    let olivedrab: ColorClass;
    let slategray: ColorClass;
    let lightslategray: ColorClass;
    let mediumslateblue: ColorClass;
    let lawngreen: ColorClass;
    let chartreuse: ColorClass;
    let aquamarine: ColorClass;
    let maroon: ColorClass;
    let purple: ColorClass;
    let olive: ColorClass;
    let gray: ColorClass;
    let skyblue: ColorClass;
    let lightskyblue: ColorClass;
    let blueviolet: ColorClass;
    let darkred: ColorClass;
    let darkmagenta: ColorClass;
    let saddlebrown: ColorClass;
    let darkseagreen: ColorClass;
    let lightgreen: ColorClass;
    let mediumpurple: ColorClass;
    let darkviolet: ColorClass;
    let palegreen: ColorClass;
    let darkorchid: ColorClass;
    let yellowgreen: ColorClass;
    let sienna: ColorClass;
    let brown: ColorClass;
    let darkgray: ColorClass;
    let lightblue: ColorClass;
    let greenyellow: ColorClass;
    let paleturquoise: ColorClass;
    let lightsteelblue: ColorClass;
    let powderblue: ColorClass;
    let firebrick: ColorClass;
    let darkgoldenrod: ColorClass;
    let mediumorchid: ColorClass;
    let rosybrown: ColorClass;
    let darkkhaki: ColorClass;
    let silver: ColorClass;
    let mediumvioletred: ColorClass;
    let indianred: ColorClass;
    let peru: ColorClass;
    let chocolate: ColorClass;
    let tan: ColorClass;
    let lightgray: ColorClass;
    let thistle: ColorClass;
    let orchid: ColorClass;
    let goldenrod: ColorClass;
    let palevioletred: ColorClass;
    let crimson: ColorClass;
    let gainsboro: ColorClass;
    let plum: ColorClass;
    let burlywood: ColorClass;
    let lightcyan: ColorClass;
    let lavender: ColorClass;
    let darksalmon: ColorClass;
    let violet: ColorClass;
    let palegoldenrod: ColorClass;
    let lightcoral: ColorClass;
    let khaki: ColorClass;
    let aliceblue: ColorClass;
    let honeydew: ColorClass;
    let azure: ColorClass;
    let sandybrown: ColorClass;
    let wheat: ColorClass;
    let beige: ColorClass;
    let whitesmoke: ColorClass;
    let mintcream: ColorClass;
    let ghostwhite: ColorClass;
    let salmon: ColorClass;
    let antiquewhite: ColorClass;
    let linen: ColorClass;
    let lightgoldenrodyellow: ColorClass;
    let oldlace: ColorClass;
    let red: ColorClass;
    let fuchsia: ColorClass;
    let magenta: ColorClass;
    let deeppink: ColorClass;
    let orangered: ColorClass;
    let tomato: ColorClass;
    let hotpink: ColorClass;
    let coral: ColorClass;
    let darkorange: ColorClass;
    let lightsalmon: ColorClass;
    let orange: ColorClass;
    let lightpink: ColorClass;
    let pink: ColorClass;
    let gold: ColorClass;
    let peachpuff: ColorClass;
    let navajowhite: ColorClass;
    let moccasin: ColorClass;
    let bisque: ColorClass;
    let mistyrose: ColorClass;
    let blanchedalmond: ColorClass;
    let papayawhip: ColorClass;
    let lavenderblush: ColorClass;
    let seashell: ColorClass;
    let cornsilk: ColorClass;
    let lemonchiffon: ColorClass;
    let floralwhite: ColorClass;
    let snow: ColorClass;
    let yellow: ColorClass;
    let lightyellow: ColorClass;
    let ivory: ColorClass;
    let white: ColorClass;
    let blue50: ColorClass;
    let blue100: ColorClass;
    let blue200: ColorClass;
    let blue300: ColorClass;
    let blue400: ColorClass;
    let blue500: ColorClass;
    let blue600: ColorClass;
    let blue700: ColorClass;
    let blue800: ColorClass;
    let blue900: ColorClass;
    let green50: ColorClass;
    let green100: ColorClass;
    let green200: ColorClass;
    let green300: ColorClass;
    let green400: ColorClass;
    let green500: ColorClass;
    let green600: ColorClass;
    let green700: ColorClass;
    let green800: ColorClass;
    let green900: ColorClass;
    let yellow50: ColorClass;
    let yellow100: ColorClass;
    let yellow200: ColorClass;
    let yellow300: ColorClass;
    let yellow400: ColorClass;
    let yellow500: ColorClass;
    let yellow600: ColorClass;
    let yellow700: ColorClass;
    let yellow800: ColorClass;
    let yellow900: ColorClass;
    let cyan50: ColorClass;
    let cyan100: ColorClass;
    let cyan200: ColorClass;
    let cyan300: ColorClass;
    let cyan400: ColorClass;
    let cyan500: ColorClass;
    let cyan600: ColorClass;
    let cyan700: ColorClass;
    let cyan800: ColorClass;
    let cyan900: ColorClass;
    let pink50: ColorClass;
    let pink100: ColorClass;
    let pink200: ColorClass;
    let pink300: ColorClass;
    let pink400: ColorClass;
    let pink500: ColorClass;
    let pink600: ColorClass;
    let pink700: ColorClass;
    let pink800: ColorClass;
    let pink900: ColorClass;
    let indigo50: ColorClass;
    let indigo100: ColorClass;
    let indigo200: ColorClass;
    let indigo300: ColorClass;
    let indigo400: ColorClass;
    let indigo500: ColorClass;
    let indigo600: ColorClass;
    let indigo700: ColorClass;
    let indigo800: ColorClass;
    let indigo900: ColorClass;
    let teal50: ColorClass;
    let teal100: ColorClass;
    let teal200: ColorClass;
    let teal300: ColorClass;
    let teal400: ColorClass;
    let teal500: ColorClass;
    let teal600: ColorClass;
    let teal700: ColorClass;
    let teal800: ColorClass;
    let teal900: ColorClass;
    let orange50: ColorClass;
    let orange100: ColorClass;
    let orange200: ColorClass;
    let orange300: ColorClass;
    let orange400: ColorClass;
    let orange500: ColorClass;
    let orange600: ColorClass;
    let orange700: ColorClass;
    let orange800: ColorClass;
    let orange900: ColorClass;
    let bluegray50: ColorClass;
    let bluegray100: ColorClass;
    let bluegray200: ColorClass;
    let bluegray300: ColorClass;
    let bluegray400: ColorClass;
    let bluegray500: ColorClass;
    let bluegray600: ColorClass;
    let bluegray700: ColorClass;
    let bluegray800: ColorClass;
    let bluegray900: ColorClass;
    let purple50: ColorClass;
    let purple100: ColorClass;
    let purple200: ColorClass;
    let purple300: ColorClass;
    let purple400: ColorClass;
    let purple500: ColorClass;
    let purple600: ColorClass;
    let purple700: ColorClass;
    let purple800: ColorClass;
    let purple900: ColorClass;
    let red50: ColorClass;
    let red100: ColorClass;
    let red200: ColorClass;
    let red300: ColorClass;
    let red400: ColorClass;
    let red500: ColorClass;
    let red600: ColorClass;
    let red700: ColorClass;
    let red800: ColorClass;
    let red900: ColorClass;
    let primary50: ColorClass;
    let primary100: ColorClass;
    let primary200: ColorClass;
    let primary300: ColorClass;
    let primary400: ColorClass;
    let primary500: ColorClass;
    let primary600: ColorClass;
    let primary700: ColorClass;
    let primary800: ColorClass;
    let primary900: ColorClass;
    let surfacea: ColorClass;
    let surfaceb: ColorClass;
    let surfacec: ColorClass;
    let surfaced: ColorClass;
    let surfacee: ColorClass;
    let surfacef: ColorClass;
    let textcolor: ColorClass;
    let textcolorsecondary: ColorClass;
    let primarycolor: ColorClass;
    let primarycolortext: ColorClass;
    let surface0: ColorClass;
    let surface50: ColorClass;
    let surface100: ColorClass;
    let surface200: ColorClass;
    let surface300: ColorClass;
    let surface400: ColorClass;
    let surface500: ColorClass;
    let surface600: ColorClass;
    let surface700: ColorClass;
    let surface800: ColorClass;
    let surface900: ColorClass;
    let gray50: ColorClass;
    let gray100: ColorClass;
    let gray200: ColorClass;
    let gray300: ColorClass;
    let gray400: ColorClass;
    let gray500: ColorClass;
    let gray600: ColorClass;
    let gray700: ColorClass;
    let gray800: ColorClass;
    let gray900: ColorClass;
    let contentpadding: ColorClass;
    let inlinespacing: ColorClass;
    let borderradius: ColorClass;
    let surfaceground: ColorClass;
    let surfacesection: ColorClass;
    let surfacecard: ColorClass;
    let surfaceoverlay: ColorClass;
    let surfaceborder: ColorClass;
    let surfacehover: ColorClass;
}
export class UITemplate {
    primary50: ColorClass;
    primary100: ColorClass;
    primary200: ColorClass;
    primary300: ColorClass;
    primary400: ColorClass;
    primary500: ColorClass;
    primary600: ColorClass;
    primary700: ColorClass;
    primary800: ColorClass;
    primary900: ColorClass;
    surfacea: ColorClass;
    surfaceb: ColorClass;
    surfacec: ColorClass;
    surfaced: ColorClass;
    surfacee: ColorClass;
    surfacef: ColorClass;
    textcolor: ColorClass;
    textcolorsecondary: ColorClass;
    primarycolor: ColorClass;
    primarycolortext: ColorClass;
    surface0: ColorClass;
    surface50: ColorClass;
    surface100: ColorClass;
    surface200: ColorClass;
    surface300: ColorClass;
    surface400: ColorClass;
    surface500: ColorClass;
    surface600: ColorClass;
    surface700: ColorClass;
    surface800: ColorClass;
    surface900: ColorClass;
    gray50: ColorClass;
    gray100: ColorClass;
    gray200: ColorClass;
    gray300: ColorClass;
    gray400: ColorClass;
    gray500: ColorClass;
    gray600: ColorClass;
    gray700: ColorClass;
    gray800: ColorClass;
    gray900: ColorClass;
    contentpadding: ColorClass;
    inlinespacing: ColorClass;
    borderradius: ColorClass;
    surfaceground: ColorClass;
    surfacesection: ColorClass;
    surfacecard: ColorClass;
    surfaceoverlay: ColorClass;
    surfaceborder: ColorClass;
    surfacehover: ColorClass;
    fontFamily: string;
    contentPadding: string;
    inlineSpacing: string;
    borderRadius: string;
    focusRing: string;
    maskbg: string;
}
export interface StyleAttribute {
    default?: string | ColorClass;
    hover?: string | ColorClass;
    active?: string | ColorClass;
    disabled?: string | ColorClass;
    focus?: string | ColorClass;
    before?: string | ColorClass;
}
export type FontWeightModifierTypes = 'normal' | 'bold' | 'lighter' | 'bolder' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900' | 'inherit' | 'initial' | 'revert' | 'unset';
export type TextAligns = 'left' | 'right' | 'center' | 'justify' | 'initial' | 'inherit';
export type VerticalAligns = 'bottom' | 'middle' | 'top';
export type TextTransforms = 'capitalize' | 'uppercase' | 'lowercase' | 'none' | 'full-width' | 'full-size-kana';
export enum ShadowTypes {
    Small = "0 1px 2px 0 rgb(0 0 0 / 0.05)",
    Shadow = "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
    Medium = "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
    Large = "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
    XLarge = "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
    XXLarge = "0 25px 50px -12px rgb(0 0 0 / 0.25)",
    Inner = "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
    None = "0 0 #0000"
}
export enum CornerRadiusTypes {
    None = "0px",
    Small = "0.125rem",
    Rounded = "0.25rem",
    Medium = "0.375rem",
    Large = "0.5rem",
    XLarge = "0.75rem",
    XXLarge = "1rem",
    XXXLarge = "1.5rem",
    Full = "9999px"
}
export class FontSizeTypes {
    static XSmall: (view: UIView) => void;
    static Small: (view: UIView) => void;
    static Base: (view: UIView) => void;
    static Large: (view: UIView) => void;
    static LargeX: (view: UIView) => void;
    static Large2X: (view: UIView) => void;
    static Large3X: (view: UIView) => void;
}
export class FontSmoothingTypes {
    static Antialiased: (view: UIView) => void;
    static Subpixel: (view: UIView) => void;
}
export interface IFont {
    family?: string;
    size?: string;
    weight?: FontWeightModifierTypes;
    leading?: string;
    spacing?: string;
}
export enum PositionTypes {
    Static = "static",
    Fixed = "fixed",
    Absolute = "absolute",
    Relative = "relative",
    Sticky = "sticky"
}
export class Fonts {
    static largeTitle: IFont;
    static title: IFont;
    static title2: IFont;
    static title3: IFont;
    static headline: IFont;
    static body: IFont;
    static callout: IFont;
    static subhead: IFont;
    static footnote: IFont;
    static caption: IFont;
    static caption2: IFont;
}
export enum Alignment {
    topLeading = 0,
    top = 1,
    topTrailing = 2,
    leading = 3,
    center = 4,
    trailing = 5,
    bottomTrailing = 6,
    bottom = 7,
    bottomLeading = 8
}
export function ViewProperty(defaultValue?: any): any;
export class UIView implements IVirtualContainer, IControl, IRenderable {
    PropertyBag(value: any): this;
    _initial: any;
    _animate: any;
    _transition: any;
    _whileHover: any;
    _whileTap: any;
    _whileDrag: any;
    _whileFocus: any;
    _whileInView: any;
    _exit: any;
    renderAsAnimated: boolean;
    protected SubViews: List<IRenderable>;
    controller: UIController;
    protected Renderer: ControlHtmlRenderer<any>;
    vp_Alias: string;
    vp_UseCache: boolean;
    Text: string;
    Tooltip: string;
    Appearance: AppearanceObject;
    HoverAppearance: AppearanceObject;
    FocusAppearance: AppearanceObject;
    ActiveAppearance: AppearanceObject;
    DisabledAppearance: AppearanceObject;
    BeforeAppearance: AppearanceObject;
    PropertyChanged: Event<any>;
    UpdateRequied: Event<any>;
    Controls: ControlCollection<any, any>;
    vp_TableHeaderWidth: string;
    vp_TableHeaderHeight: string;
    vp_Skeleton: boolean;
    vp_Disabled: boolean;
    disabled(value: boolean): this;
    GetViews(): IRenderable[];
    setController(controller: UIController): this;
    initial(value: any): this;
    animate(value: any): this;
    __transition(value: any): this;
    hover(value: any): this;
    tap(value: any): this;
    drag(value: any): this;
    focus(value: any): this;
    constructor();
    OnLoaded(): void;
    OnUnLoaded(): void;
    OnAppearanceChanged(name: string): void;
    TabIndex: int;
    BackgroundColor: string;
    Padding: Padding;
    Border: Border;
    Margin: Margin;
    Id: string;
    Visible: boolean;
    KeyFrameCollection: KeyFrameCollection[];
    vp_SetFocus: Event<any>;
    vp_KillFocus: Event<any>;
    protected WmClick(nativeEvent: any): void;
    onClick(func: Function): this;
    FireClick(nativeEvent?: any): void;
    protected WmDbClick(nativeEvent: any): void;
    onDbClick(func: Function): this;
    protected WmMouseDown(nativeEvent: any): void;
    onMouseDown(func: Function): this;
    protected WmKeyDown(nativeEvent: any): void;
    onKeyDown(func: Function): this;
    protected WmSetFocus(nativeEvent: any): void;
    onFocus(func: Function): this;
    protected WmKillFocus(nativeEvent: any): void;
    onLostFocus(func: Function): this;
    WndProc(msg: Message): void;
    AddSubView(subView: UIView | IControl | UIController): void;
    Ref(refFunc: Function): this;
    protected IsChildValid(renderable: IRenderable): boolean;
    protected DoFlatten(...args: (UIView | IControl | UIController)[]): IRenderable[];
    setChilds(...args: (UIView | IControl | UIController)[]): this;
    If(_case: boolean, func: Function): this;
    ForEach(enumarable: any, enumFunc: Function): this;
    Render(): any;
    ForceUpdate(): void;
    tabIndex(value: int): this;
    zIndex(value: int): this;
    animation(value: KeyFrameCollection, time: string): this;
    variable(name: string, value: StyleAttribute): this;
    tooltip(value: string): this;
    visible(value: boolean): this;
    position(value: PositionTypes): this;
    position(value: StyleAttribute): this;
    position(value: string): this;
    left(value: StyleAttribute): this;
    left(value: string): this;
    top(value: StyleAttribute): this;
    top(value: string): this;
    right(value: StyleAttribute): this;
    right(value: string): this;
    bottom(value: StyleAttribute): this;
    bottom(value: string): this;
    transform(value: StyleAttribute): this;
    transform(value: string): this;
    rotate(value: string): this;
    clipPath(value: string): this;
    filter(value: string): this;
    font(font: IFont): this;
    verticalAlign(value: VerticalAligns): this;
    textAlign(value: TextAligns): this;
    textTransform(value: TextTransforms): this;
    fontFamily(size: string): this;
    fontSmoothing(value: (view: UIView) => void): this;
    fontSize(value: (view: UIView) => void): this;
    fontSize(size: int): this;
    fontSize(size: string): this;
    fontWeight(weight: FontWeightModifierTypes): this;
    lineHeight(size: int): this;
    lineHeight(size: string): this;
    grow(): this;
    width(): this;
    width(value: int): this;
    width(value: string): this;
    width(value: StyleAttribute): this;
    minWidth(): this;
    minWidth(value: int): this;
    minWidth(value: string): this;
    minWidth(value: StyleAttribute): this;
    maxWidth(): this;
    maxWidth(value: int): this;
    maxWidth(value: string): this;
    maxWidth(value: StyleAttribute): this;
    allWidth(): this;
    allWidth(value: int): this;
    allWidth(value: string): this;
    height(): this;
    height(value: int): this;
    height(value: string): this;
    height(value: StyleAttribute): this;
    allHeight(): this;
    allHeight(value: int): this;
    allHeight(value: string): this;
    minHeight(): this;
    minHeight(value: int): this;
    minHeight(value: string): this;
    minHeight(value: StyleAttribute): this;
    maxHeight(): this;
    maxHeight(value: int): this;
    maxHeight(value: string): this;
    maxHeight(value: StyleAttribute): this;
    foregroundColor(value: ColorClass): this;
    foregroundColor(value: StyleAttribute): this;
    foregroundColor(color: string): this;
    foregroundColor(condition: boolean, trueValue: string, falseValue: string): this;
    backgroundImage(value: StyleAttribute): this;
    backgroundImage(value: string): this;
    backgroundColor(value: StyleAttribute): this;
    backgroundColor(value: string): this;
    background(value: ColorClass): this;
    background(value: StyleAttribute): this;
    background(zstack: ZStackClass): this;
    background(color: string): this;
    background(condition: boolean, trueValue: string, falseValue: string): this;
    content(value: StyleAttribute): this;
    content(value: string): this;
    cursor(value: StyleAttribute): this;
    cursor(value: string): this;
    alignItems(value: string): this;
    alignContent(value: string): this;
    justifyContent(value: string): this;
    cornerRadius(): this;
    cornerRadius(value: CornerRadiusTypes): this;
    cornerRadius(value: string): this;
    cornerRadius(value: int): this;
    outline(value: StyleAttribute): this;
    outline(value: string): this;
    border(value: StyleAttribute): this;
    border(value: string): this;
    borderLeft(value: StyleAttribute): this;
    borderLeft(value: string): this;
    borderRight(value: StyleAttribute): this;
    borderRight(value: string): this;
    borderTop(value: StyleAttribute): this;
    borderTop(value: string): this;
    borderBottom(value: StyleAttribute): this;
    borderBottom(value: string): this;
    wrap(value: string): this;
    basis(value: string): this;
    margin(): this;
    margin(value: string): this;
    margin(value: int): this;
    marginVertical(): this;
    marginVertical(value: string): this;
    marginVertical(value: int): this;
    marginHorizontal(): this;
    marginHorizontal(value: string): this;
    marginHorizontal(value: int): this;
    marginLeft(value: string): this;
    marginRight(value: string): this;
    marginTop(value: string): this;
    marginBottom(value: string): this;
    padding(): this;
    padding(value: string): this;
    padding(type: string, value: string): this;
    padding(value: int): this;
    padding(type: string, value: int): this;
    paddingLeft(value: string): this;
    paddingRight(value: string): this;
    paddingTop(value: string): this;
    paddingBottom(value: string): this;
    overflow(value: string): this;
    overflowX(value: string): this;
    overflowY(value: string): this;
    shadow(value: StyleAttribute): this;
    shadow(value: ShadowTypes): this;
    shadow(value: string): this;
    transition(value: string): this;
    opacity(): this;
    opacity(value: int): this;
    opacity(value: string): this;
    opacity(value: StyleAttribute): this;
    display(value: StyleAttribute): this;
    display(value: string): this;
    kerning(value: string): this;
    wordBreak(value: 'normal' | 'break-all' | 'keep-all' | 'break-word'): this;
    wordWrap(value: 'normal' | 'break-word'): this;
    alignment(value: AlignmentType): this;
    protected createStyles(): string;
    alias(value: string): this;
    useCache(value: boolean): this;
    tableHeaderWidth(value: string): this;
    tableHeaderHeight(value: string): this;
    skeleton(value: boolean): this;
    variant(value: string): this;
    jssStyle: any;
    __createStyle(): any;
}

export class SpacerClass extends UIView {
    constructor();
}
export function Spacer(): SpacerClass;

export class RoundedRectangleClass extends UIView {
    setController(controller: UIController): this;
    constructor();
}
export function RoundedRectangle(): RoundedRectangleClass;

interface IImage extends IControl {
    Src: string;
    Img?: any;
}
export class UIImageClass extends UIView implements IImage {
    vp_ImageWidth: string;
    vp_ImageHeight: string;
    setController(controller: UIController): this;
    constructor();
    src(value: string): this;
    img(value: HTMLImageElement): this;
    imageWidth(value: int | string): this;
    imageHeight(value: int | string): this;
}
export function UIImage(src: string): UIImageClass;
export {};

export class UIAnimationRenderer extends ControlHtmlRenderer<UIAnimationClass> {
    get UseShadowDom(): boolean;
    OnStyleCreating(obj: UIAnimationClass, sb: StringBuilder): void;
    GenerateElement(obj: UIAnimationClass): boolean;
    GenerateBody(obj: UIAnimationClass): void;
    protected CreateControls(obj: UIAnimationClass): any[];
}
export class UIAnimationClass extends UIView {
    ShowAnimation: boolean;
    setController(controller: UIController): this;
    constructor();
    start(show: boolean): this;
}
export function UIAnimation(...subViews: (UIView | IControl | UIController)[]): UIAnimationClass;

export class UIMotionRenderer extends ControlHtmlRenderer<UIMotionClass> {
    get UseShadowDom(): boolean;
    GenerateElement(obj: UIMotionClass): boolean;
    GenerateBody(obj: UIMotionClass): void;
    protected CreateControls(obj: UIMotionClass): any[];
}
export class UIMotionClass extends UIView {
    _animate: any;
    _whileHover: any;
    _whileTap: any;
    _whileDrag: any;
    _whileFocus: any;
    _whileInView: any;
    _exit: any;
    setController(controller: UIController): this;
    constructor();
    animate(value: any): this;
    hover(value: any): this;
    tap(value: any): this;
    drag(value: any): this;
    focus(value: any): this;
}
export function UIMotion(...subViews: (UIView | IControl | UIController)[]): UIMotionClass;

export class GaugeClass extends UIView {
    Color: string;
    MaskColor: string;
    Value: int;
    Stroke: int;
    Radius: int;
    setController(controller: UIController): this;
    constructor();
    value(value: int): this;
    radius(value: int): this;
    stroke(value: int): this;
    color(value: string): this;
    maskColor(value: string): this;
}
export class RangeClass extends UIView {
}
export function Gauge(...subViews: RangeClass[]): GaugeClass;
export function Range(): RangeClass;

export class SliderClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    onSlideEnd(): void;
    action(value: (value: int) => void): this;
    value(value: int): this;
}
export function UISlider(): SliderClass;

export class KeyFrame {
    name: string;
    style: AppearanceObject;
    constructor(name: string);
}
export class KeyFrameCollection extends List<KeyFrame> {
    Name: string;
    constructor(name: string);
    ToString(): string;
}

interface ScrollViewParams {
    axes?: 'cHorizontal' | 'cVertical';
    showsIndicators?: boolean;
    content?: any;
}
type FunctionScrollView = (...views: UIView[]) => VStackClass;
export function ScrollView(value: string): FunctionScrollView;
export function ScrollView(...views: UIView[]): VStackClass;
export function ScrollView(value: ScrollViewParams): FunctionScrollView;
export {};

export const cHorizontal = "cHorizontal";
export const cVertical = "cVertical";
export const cLeft = "cLeft";
export const cRight = "cRight";
export const cTopLeading = "cTopLeading";
export const cTop = "cTop";
export const cTopTrailing = "cTopTrailing";
export const cLeading = "cLeading";
export const cCenter = "cCenter";
export const cTrailing = "cTrailing";
export const cBottomTrailing = "cBottomTrailing";
export const cBottom = "cBottom";
export const cBottomLeading = "cBottomLeading";
export type AlignmentType = 'cTopLeading' | 'cTop' | 'cTopTrailing' | 'cLeading' | 'cCenter' | 'cTrailing' | 'cBottomTrailing' | 'cBottom' | 'cBottomLeading';

export class TextFieldRenderer extends ControlHtmlRenderer<TextFieldClass> {
    get UseShadowDom(): boolean;
    OnStyleCreating(obj: TextFieldClass, sb: StringBuilder): void;
    GenerateElement(obj: TextFieldClass): boolean;
    protected OnInputDidMount(obj: TextFieldClass, ref: HTMLElement): void;
    protected OnShadowDomDidMount(ref: any, obj: TextFieldClass): void;
    GenerateBody(obj: TextFieldClass): void;
}
export class TextFieldClass extends UIView {
    Value: string;
    Placeholder: string;
    vp_Autofocus: boolean;
    LeftIcon: string;
    InputAppearance: AppearanceObject;
    OnTextChange: Function;
    vp_Multiline: boolean;
    vp_myLostFocus: Function;
    setController(controller: UIController): this;
    constructor();
    OnAppearanceChanged(name: string): void;
    onTextChange(value: (text: string) => void): this;
    placeholder(value: string): this;
    value(value: string): this;
    autofocus(value: boolean): this;
    multiline(value: boolean): this;
    onLostFocus(func: Function): this;
}
export function TextField(): TextFieldClass;

export class SecureFieldRenderer extends ControlHtmlRenderer<SecureFieldClass> {
    get UseShadowDom(): boolean;
    OnStyleCreating(obj: SecureFieldClass, sb: StringBuilder): void;
    GenerateElement(obj: SecureFieldClass): boolean;
    protected OnInputDidMount(obj: SecureFieldClass, ref: HTMLElement): void;
    protected OnShadowDomDidMount(ref: any, obj: SecureFieldClass): void;
    GenerateBody(obj: SecureFieldClass): void;
}
export class SecureFieldClass extends UIView {
    Value: string;
    Placeholder: string;
    Autofocus: boolean;
    LeftIcon: string;
    InputAppearance: AppearanceObject;
    OnTextChange: Function;
    setController(controller: UIController): this;
    constructor();
    OnAppearanceChanged(name: string): void;
    onTextChange(value: (text: string) => void): this;
    placeholder(value: string): this;
    value(value: string): this;
}
export function SecureField(): SecureFieldClass;

export class ToggleRenderer extends ControlHtmlRenderer<ToggleClass> {
    get UseShadowDom(): boolean;
    OnStyleCreating(obj: ToggleClass, sb: StringBuilder): void;
    GenerateElement(obj: ToggleClass): boolean;
    protected OnInputDidMount(obj: ToggleClass, ref: HTMLElement): void;
    protected OnShadowDomDidMount(ref: any, obj: ToggleClass): void;
    GenerateBody(obj: ToggleClass): void;
}
export class ToggleClass extends UIView {
    vp_checked: boolean;
    vp_onChange: Function;
    setController(controller: UIController): this;
    constructor();
    OnAppearanceChanged(name: string): void;
    onToggleChange(value: (value: boolean) => void): this;
    checked(value: boolean): this;
}
export function Toggle(): ToggleClass;

export class UIContextMenuRenderer extends ControlHtmlRenderer<UIContextMenuClass> {
    shadowDom: any;
    protected menu: any;
    OnStyleCreating(obj: UIContextMenuClass, sb: StringBuilder): void;
    GenerateElement(obj: UIContextMenuClass): boolean;
    protected OnShadowDomDidMount(ref: any, obj: UIContextMenuClass): void;
    GenerateBody(obj: UIContextMenuClass): void;
    protected CreateControls(obj: UIContextMenuClass): any[];
}
export class UIContextMenuClass extends UIView {
    items: UIView[];
    setController(controller: UIController): this;
    constructor();
    setItems(...items: UIView[]): this;
}
type FunctionUIContextMenu = (...content: UIView[]) => UIContextMenuClass;
export function UIContextMenu(...items: UIView[]): FunctionUIContextMenu;
export {};

export class UILinkCLass extends UIView {
    setController(controller: UIController): this;
    constructor();
}
export function UILink(text: string): UILinkCLass;

export function $<T>(value: T): BindingClass<T>;
export class UIRoutesCLass extends UIView {
    vp_Routes: UIRouteClass[];
    vp_Theme: any;
    setController(controller: UIController): this;
    constructor();
    setRoutes(...routes: UIRouteClass[]): this;
    setTheme(theme: any): this;
}
export function UIRoutes(...routes: UIRouteClass[]): UIRoutesCLass;
export type ControllerConstructor = new () => UIController;
export class UIRouteClass extends UIView {
    vp_routePath: string;
    vp_IsIndex: boolean;
    vp_routeController: ControllerConstructor;
    vp_ChildRoutes: UIRouteClass[];
    vp_RedirectTo: string;
    setController(controller: UIController): this;
    constructor();
    setRoutePath(path: string): this;
    setRouteController(controller: ControllerConstructor): this;
    setChildRoutes(...value: UIRouteClass[]): this;
    index(value: boolean): this;
    redirectTo(value: string): this;
}
type UIRouteFunction = (path: string, routeController: ControllerConstructor) => UIRouteClass;
export function UIRoute(path: string, routeController: ControllerConstructor): UIRouteClass;
export function UIRoute(...childRoutes: UIRouteClass[]): UIRouteFunction;
export class UIRouteLinkCLass extends UIView {
    vp_link: string;
    vp_State: any;
    setController(controller: UIController): this;
    constructor();
    link(path: string): this;
    state(value: any): this;
}
type FunctionUIRouteLink = (...views: UIView[]) => UIRouteLinkCLass;
export function UIRouteLink(path: string, state?: any): FunctionUIRouteLink;
export class UIRouteOutletClass extends UIView {
    setController(controller: UIController): this;
    constructor();
}
export function UIRouteOutlet(): UIRouteOutletClass;
export class UINavigateClass extends UIView {
    vp_To: string;
    setController(controller: UIController): this;
    constructor();
    to(value: string): this;
}
export function UINavigate(): UINavigateClass;
export function getRouterParams<ParamsOrKey extends string | Record<string, string | undefined> = string>(): Readonly<[
    ParamsOrKey
] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>>;
export function bindNavigate(): NavigateFunction;
export {};

export function UIStep(): UIStepsClass;

export function UISkeleton(): UISkeletonClass;

export type DropDownItemFunction = (selectedItemTemplate: (option: any) => UIView | Function) => DropDownClass;
export function DropDown(itemTemplate: (option: any) => UIView | Function): DropDownItemFunction;

export function AutoComplete(): AutoCompleteClass;

export function OverlayPanel(headerTemplate: UIView): (...content: UIView[]) => OverlayPanelClass;

export function AvatarView(...content: UIView[]): AvatarViewClass;

export function SlideMenuView(...content: UIView[]): SlideMenuViewClass;

export class AppearanceClass {
    Appearance: AppearanceObject;
    HoverAppearance: AppearanceObject;
    FocusAppearance: AppearanceObject;
    ActiveAppearance: AppearanceObject;
    BeforeAppearance: AppearanceObject;
    KeyFrameCollection: KeyFrameCollection[];
    constructor();
    zIndex(value: int): this;
    variable(name: string, value: StyleAttribute): this;
    visible(value: boolean): this;
    position(value: PositionTypes): this;
    position(size: int): this;
    position(size: string): this;
    left(value: string): this;
    top(value: string): this;
    right(value: string): this;
    bottom(value: string): this;
    transform(value: string): this;
    rotate(value: string): this;
    clipPath(value: string): this;
    filter(value: string): this;
    font(font: IFont): this;
    textAlign(value: TextAligns): this;
    textTransform(value: TextTransforms): this;
    fontFamily(size: string): this;
    fontSmoothing(value: (view: UIView) => void): this;
    fontSize(value: (view: UIView) => void): this;
    fontSize(size: int): this;
    fontSize(size: string): this;
    fontWeight(weight: FontWeightModifierTypes): this;
    lineHeight(size: int): this;
    lineHeight(size: string): this;
    grow(): this;
    width(): this;
    width(value: int): this;
    width(value: string): this;
    minWidth(value: string): this;
    maxWidth(value: string): this;
    height(): this;
    height(value: int): this;
    height(value: string): this;
    minHeight(value: string): this;
    maxHeight(value: string): this;
    foregroundColor(value: ColorClass): this;
    foregroundColor(value: StyleAttribute): this;
    foregroundColor(color: string): this;
    foregroundColor(condition: boolean, trueValue: string, falseValue: string): this;
    backgroundImage(value: StyleAttribute): this;
    backgroundImage(value: string): this;
    backgroundColor(value: StyleAttribute): this;
    backgroundColor(value: string): this;
    background(value: ColorClass): this;
    background(value: StyleAttribute): this;
    background(color: string): this;
    background(condition: boolean, trueValue: string, falseValue: string): this;
    cursor(value: string): this;
    alignItems(value: string): this;
    alignContent(value: string): this;
    justifyContent(value: string): this;
    cornerRadius(): this;
    cornerRadius(value: CornerRadiusTypes): this;
    cornerRadius(value: string): this;
    cornerRadius(value: int): this;
    outline(value: StyleAttribute): this;
    outline(value: string): this;
    border(value: StyleAttribute): this;
    border(value: string): this;
    borderLeft(value: string): this;
    borderRight(value: string): this;
    borderTop(value: string): this;
    borderBottom(value: string): this;
    wrap(value: string): this;
    basis(value: string): this;
    margin(): this;
    margin(value: string): this;
    margin(value: int): this;
    marginVertical(): this;
    marginVertical(value: string): this;
    marginVertical(value: int): this;
    marginHorizontal(): this;
    marginHorizontal(value: string): this;
    marginHorizontal(value: int): this;
    marginLeft(value: string): this;
    marginRight(value: string): this;
    marginTop(value: string): this;
    marginBottom(value: string): this;
    padding(): this;
    padding(value: string): this;
    padding(type: string, value: string): this;
    padding(value: int): this;
    padding(type: string, value: int): this;
    paddingLeft(value: string): this;
    paddingRight(value: string): this;
    paddingTop(value: string): this;
    paddingBottom(value: string): this;
    overflow(value: string): this;
    overflowX(value: string): this;
    overflowY(value: string): this;
    shadow(value: StyleAttribute): this;
    shadow(value: ShadowTypes): this;
    shadow(value: string): this;
    transition(value: string): this;
    opacity(value: string): this;
    kerning(value: string): this;
}
export function UIAppearance(): AppearanceClass;

export class BindingClass<T> {
    constructor(controller: UIController, defaultValue: T);
    get(): T;
    set(value: T): void;
}

export function UIAccordion({ header, content }: {
    header: (item: any) => UIView | Function;
    content: (item: any) => UIView | Function;
}): AccordionClass;

export function UIMediaPlayer(): UIMediaPlayerClass;

export function getView(controller: UIController, view: any): UIView | UIController | Control;
export function viewFunc(sourceClass: any, viewCreator: Function): any;

export class ColorClass {
    color: string;
    constructor(color: string);
    opacity(value: float): this;
    lighten(volume?: float): this;
    darken(volume?: float): this;
    toString(): string;
}

/**
    * Converts a color from CSS hex format to CSS rgb format.
    * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
    * @returns {string} A CSS rgb color string
    */
export function hexToRgb(color: any): string;
/**
    * Returns an object with the type and values of a color.
    *
    * Note: Does not support rgb % values.
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @returns {object} - A MUI color object: {type: string, values: number[]}
    */
export function decomposeColor(color: any): any;
/**
    * Returns a channel created from the input color.
    *
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @returns {string} - The channel for the color, that can be used in rgba or hsla colors
    */
export const colorChannel: (color: any) => any;
/**
    * Converts a color object with type and values to a string.
    * @param {object} color - Decomposed color
    * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla', 'color'
    * @param {array} color.values - [n,n,n] or [n,n,n,n]
    * @returns {string} A CSS color string
    */
export function recomposeColor(color: any): string;
/**
    * Converts a color from CSS rgb format to CSS hex format.
    * @param {string} color - RGB color, i.e. rgb(n, n, n)
    * @returns {string} A CSS rgb color string, i.e. #nnnnnn
    */
export function rgbToHex(color: any): any;
/**
    * Converts a color from hsl format to rgb format.
    * @param {string} color - HSL color values
    * @returns {string} rgb color values
    */
export function hslToRgb(color: any): string;
/**
    * The relative brightness of any point in a color space,
    * normalized to 0 for darkest black and 1 for lightest white.
    *
    * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @returns {number} The relative brightness of the color in the range 0 - 1
    */
export function getLuminance(color: any): number;
/**
    * Calculates the contrast ratio between two colors.
    *
    * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
    * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
    * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
    * @returns {number} A contrast ratio value in the range 0 - 21.
    */
export function getContrastRatio(foreground: any, background: any): number;
/**
    * Sets the absolute transparency of a color.
    * Any existing alpha values are overwritten.
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @param {number} value - value to set the alpha channel to in the range 0 - 1
    * @returns {string} A CSS color string. Hex input values are returned as rgb
    */
export function alpha(color: any, value: any): string;
/**
    * Darkens a color.
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @param {number} coefficient - multiplier in the range 0 - 1
    * @returns {string} A CSS color string. Hex input values are returned as rgb
    */
export function darken(color: any, coefficient: any): string;
/**
    * Lightens a color.
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @param {number} coefficient - multiplier in the range 0 - 1
    * @returns {string} A CSS color string. Hex input values are returned as rgb
    */
export function lighten(color: any, coefficient: any): string;
/**
    * Darken or lighten a color, depending on its luminance.
    * Light colors are darkened, dark colors are lightened.
    * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
    * @param {number} coefficient=0.15 - multiplier in the range 0 - 1
    * @returns {string} A CSS color string. Hex input values are returned as rgb
    */
export function emphasize(color: any, coefficient?: number): string;

export function createTheme(options?: any, ...args: any[]): {
    breakpoints: any;
    direction: string;
    components: {};
    palette: any;
    spacing: import("./system/createTheme/createSpacing").Spacing;
    shape: any;
};
export function createMuiTheme(...args: any[]): {
    breakpoints: any;
    direction: string;
    components: {};
    palette: any;
    spacing: import("./system/createTheme/createSpacing").Spacing;
    shape: any;
};

export const light: {
    text: {
        primary: string;
        secondary: string;
        disabled: string;
    };
    divider: string;
    background: {
        paper: string;
        default: string;
    };
    action: {
        active: string;
        hover: string;
        hoverOpacity: number;
        selected: string;
        selectedOpacity: number;
        disabled: string;
        disabledBackground: string;
        disabledOpacity: number;
        focus: string;
        focusOpacity: number;
        activatedOpacity: number;
    };
};
export const dark: {
    text: {
        primary: string;
        secondary: string;
        disabled: string;
        icon: string;
    };
    divider: string;
    background: {
        paper: string;
        default: string;
    };
    action: {
        active: string;
        hover: string;
        hoverOpacity: number;
        selected: string;
        selectedOpacity: number;
        disabled: string;
        disabledBackground: string;
        disabledOpacity: number;
        focus: string;
        focusOpacity: number;
        activatedOpacity: number;
    };
};
export function createPalette(palette: any): any;

/**
    * Actions represent the type of change to a location value.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action
    */
export enum Action {
        /**
            * A POP indicates a change to an arbitrary index in the history stack, such
            * as a back or forward navigation. It does not describe the direction of the
            * navigation, only that the current index changed.
            *
            * Note: This is the default action for newly created history objects.
            */
        Pop = "POP",
        /**
            * A PUSH indicates a new entry being added to the history stack, such as when
            * a link is clicked and a new page loads. When this happens, all subsequent
            * entries in the stack are lost.
            */
        Push = "PUSH",
        /**
            * A REPLACE indicates the entry at the current index in the history stack
            * being replaced by a new one.
            */
        Replace = "REPLACE"
}
/**
    * A URL pathname, beginning with a /.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.pathname
    */
export type Pathname = string;
/**
    * A URL search string, beginning with a ?.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.search
    */
export type Search = string;
/**
    * A URL fragment identifier, beginning with a #.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.hash
    */
export type Hash = string;
/**
    * An object that is used to associate some arbitrary data with a location, but
    * that does not appear in the URL path.
    *
    * @deprecated
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.state
    */
export type State = unknown;
/**
    * A unique string associated with a location. May be used to safely store
    * and retrieve data in some other storage API, like `localStorage`.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.key
    */
export type Key = string;
/**
    * The pathname, search, and hash values of a URL.
    */
export interface Path {
        /**
            * A URL pathname, beginning with a /.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.pathname
            */
        pathname: Pathname;
        /**
            * A URL search string, beginning with a ?.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.search
            */
        search: Search;
        /**
            * A URL fragment identifier, beginning with a #.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.hash
            */
        hash: Hash;
}
/**
    * An entry in a history stack. A location contains information about the
    * URL path, as well as possibly some arbitrary state and a key.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location
    */
export interface Location extends Path {
        /**
            * A value of arbitrary data associated with this location.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.state
            */
        state: unknown;
        /**
            * A unique string associated with this location. May be used to safely store
            * and retrieve data in some other storage API, like `localStorage`.
            *
            * Note: This value is always "default" on the initial location.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#location.key
            */
        key: Key;
}
/**
    * A partial Path object that may be missing some properties.
    *
    * @deprecated
    */
export type PartialPath = Partial<Path>;
/**
    * A partial Location object that may be missing some properties.
    *
    * @deprecated
    */
export type PartialLocation = Partial<Location>;
/**
    * A change to the current location.
    */
export interface Update {
        /**
            * The action that triggered the change.
            */
        action: Action;
        /**
            * The new location.
            */
        location: Location;
}
/**
    * A function that receives notifications about location changes.
    */
export interface Listener {
        (update: Update): void;
}
/**
    * A change to the current location that was blocked. May be retried
    * after obtaining user confirmation.
    */
export interface Transition extends Update {
        /**
            * Retries the update to the current location.
            */
        retry(): void;
}
/**
    * A function that receives transitions when navigation is blocked.
    */
export interface Blocker {
        (tx: Transition): void;
}
/**
    * Describes a location that is the destination of some navigation, either via
    * `history.push` or `history.replace`. May be either a URL or the pieces of a
    * URL path.
    */
export type To = string | Partial<Path>;
/**
    * A history is an interface to the navigation stack. The history serves as the
    * source of truth for the current location, as well as provides a set of
    * methods that may be used to change it.
    *
    * It is similar to the DOM's `window.history` object, but with a smaller, more
    * focused API.
    */
export interface History {
        /**
            * The last action that modified the current location. This will always be
            * Action.Pop when a history instance is first created. This value is mutable.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.action
            */
        readonly action: Action;
        /**
            * The current location. This value is mutable.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.location
            */
        readonly location: Location;
        /**
            * Returns a valid href for the given `to` value that may be used as
            * the value of an <a href> attribute.
            *
            * @param to - The destination URL
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.createHref
            */
        createHref(to: To): string;
        /**
            * Pushes a new location onto the history stack, increasing its length by one.
            * If there were any entries in the stack after the current one, they are
            * lost.
            *
            * @param to - The new URL
            * @param state - Data to associate with the new location
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.push
            */
        push(to: To, state?: any): void;
        /**
            * Replaces the current location in the history stack with a new one.  The
            * location that was replaced will no longer be available.
            *
            * @param to - The new URL
            * @param state - Data to associate with the new location
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.replace
            */
        replace(to: To, state?: any): void;
        /**
            * Navigates `n` entries backward/forward in the history stack relative to the
            * current index. For example, a "back" navigation would use go(-1).
            *
            * @param delta - The delta in the stack index
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.go
            */
        go(delta: number): void;
        /**
            * Navigates to the previous entry in the stack. Identical to go(-1).
            *
            * Warning: if the current location is the first location in the stack, this
            * will unload the current document.
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.back
            */
        back(): void;
        /**
            * Navigates to the next entry in the stack. Identical to go(1).
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.forward
            */
        forward(): void;
        /**
            * Sets up a listener that will be called whenever the current location
            * changes.
            *
            * @param listener - A function that will be called when the location changes
            * @returns unlisten - A function that may be used to stop listening
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.listen
            */
        listen(listener: Listener): () => void;
        /**
            * Prevents the current location from changing and sets up a listener that
            * will be called instead.
            *
            * @param blocker - A function that will be called when a transition is blocked
            * @returns unblock - A function that may be used to stop blocking
            *
            * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#history.block
            */
        block(blocker: Blocker): () => void;
}
/**
    * A browser history stores the current location in regular URLs in a web
    * browser environment. This is the standard for most web apps and provides the
    * cleanest URLs the browser's address bar.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory
    */
export interface BrowserHistory extends History {
}
/**
    * A hash history stores the current location in the fragment identifier portion
    * of the URL in a web browser environment.
    *
    * This is ideal for apps that do not control the server for some reason
    * (because the fragment identifier is never sent to the server), including some
    * shared hosting environments that do not provide fine-grained controls over
    * which pages are served at which URLs.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory
    */
export interface HashHistory extends History {
}
/**
    * A memory history stores locations in memory. This is useful in stateful
    * environments where there is no web browser, such as node tests or React
    * Native.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#memoryhistory
    */
export interface MemoryHistory extends History {
        readonly index: number;
}
export type BrowserHistoryOptions = {
        window?: Window;
};
/**
    * Browser history stores the location in regular URLs. This is the standard for
    * most web apps, but it requires some configuration on the server to ensure you
    * serve the same app at multiple URLs.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
    */
export function createBrowserHistory(options?: BrowserHistoryOptions): BrowserHistory;
export type HashHistoryOptions = {
        window?: Window;
};
/**
    * Hash history stores the location in window.location.hash. This makes it ideal
    * for situations where you don't want to send the location to the server for
    * some reason, either because you do cannot configure it or the URL space is
    * reserved for something else.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
    */
export function createHashHistory(options?: HashHistoryOptions): HashHistory;
/**
    * A user-supplied object that describes a location. Used when providing
    * entries to `createMemoryHistory` via its `initialEntries` option.
    */
export type InitialEntry = string | Partial<Location>;
export type MemoryHistoryOptions = {
        initialEntries?: InitialEntry[];
        initialIndex?: number;
};
/**
    * Memory history stores the current location in memory. It is designed for use
    * in stateful non-browser environments like tests and React Native.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory
    */
export function createMemoryHistory(options?: MemoryHistoryOptions): MemoryHistory;
/**
    * Creates a string URL path from the given pathname, search, and hash components.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath
    */
export function createPath({ pathname, search, hash, }: Partial<Path>): string;
/**
    * Parses a string URL path into its separate pathname, search, and hash components.
    *
    * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath
    */
export function parsePath(path: string): Partial<Path>;

export type { Hash, IndexRouteProps, LayoutRouteProps, Location, MemoryRouterProps, NavigateFunction, NavigateOptions, NavigateProps, OutletProps, PathMatch, PathPattern, PathRouteProps, RouteMatch, RouteObject, RouteProps, RouterProps, RoutesProps, Navigator, Params, Path, Pathname, Search, To, };
export { MemoryRouter, Navigate, NavigationType, Outlet, Route, Router, Routes, createPath, createRoutesFromChildren, generatePath, matchPath, matchRoutes, parsePath, renderMatches, resolvePath, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRoutes, };

/**
  * Component class with a predefined `shouldComponentUpdate` implementation
  */
export class PureComponent extends Component {
    props: any;
    isPureReactComponent: boolean;
    constructor(p: any);
    shouldComponentUpdate(props: any, state: any): boolean;
}

export const REACT_MEMO_SYMBOL: number | symbol;
/**
  * Memoize a component, so that it only updates when the props actually have
  * changed. This was previously known as `React.pure`.
  * @param {import('./internal').FunctionComponent} c functional component
  * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function
  * @returns {import('./internal').FunctionComponent}
  */
export function memo(c: any, comparer?: any): {
    (props: any): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
    };
    $$typeof: number | symbol;
    displayName: string;
    _forwarded: boolean;
};

export const REACT_FORWARD_SYMBOL: number | symbol;
/**
  * Pass ref down to a child. This is mainly used in libraries with HOCs that
  * wrap components. Using `forwardRef` there is an easy way to get a reference
  * of the wrapped component instead of one of the wrapper itself.
  * @param {import('./index').ForwardFn} fn
  * @returns {import('./internal').FunctionComponent}
  */
export function forwardRef(fn: any): {
    (props: any, ref: any): any;
    $$typeof: number | symbol;
    render: any;
    _forwarded: boolean;
    displayName: string;
};

export const Children: {
    map: (children: any, fn: any) => any;
    forEach: (children: any, fn: any) => any;
    count(children: any): any;
    only(children: any): any;
    toArray: typeof toChildArray;
};

/**
    * Portal component
    * @this {import('./internal').Component}
    * @param {object | null | undefined} props
    *
    * TODO: use createRoot() instead of fake root
    */
export function Portal(props: any): void;
/**
    * Create a `Portal` to continue rendering the vnode tree at a different DOM node
    * @param {import('./internal').VNode} vnode The vnode to render
    * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.
    */
export function createPortal(vnode: any, container: any): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
};

export const REACT_ELEMENT_TYPE: number | symbol;
/**
  * Proxy render() since React returns a Component reference.
  * @param {import('./internal').VNode} vnode VNode tree to render
  * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into
  * @param {() => void} [callback] Optional callback that will be called after rendering
  * @returns {import('./internal').Component | null} The root component reference or null
  */
export function render(vnode: any, parent?: any, callback?: any): any;
export function hydrate(vnode: any, parent: any, callback: any): any;
export const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentDispatcher: {
        current: {
            readContext(context: any): any;
        };
    };
};

export function Suspense(): void;
export namespace Suspense {
    var prototype: Component;
}
/**
  * Checks and calls the parent component's _suspended method, passing in the
  * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified
  * that one of its children/descendants suspended.
  *
  * The parent MAY return a callback. The callback will get called when the
  * suspension resolves, notifying the parent of the fact.
  * Moreover, the callback gets function `unsuspend` as a parameter. The resolved
  * child descendant will not actually get unsuspended until `unsuspend` gets called.
  * This is a way for the parent to delay unsuspending.
  *
  * If the parent does not return a callback then the resolved vnode
  * gets unsuspended immediately when it resolves.
  *
  * @param {import('./internal').VNode} vnode
  * @returns {((unsuspend: () => void) => void)?}
  */
export function suspended(vnode: any): any;
export function lazy(loader: any): {
    (props: any): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
    };
    displayName: string;
    _forwarded: boolean;
};

export interface IAppStoreService {
    GetApps(env: string): Promise<IAppStoreItem[]>;
    GetApps(env: string, category: string): Promise<IAppStoreItem[]>;
}

export class BrokerAppStoreService implements IAppStoreService {
    GetApps(env: string): Promise<IAppStoreItem[]>;
}

export interface IAppStoreItem {
    id: string;
    name: string;
    service: boolean;
    application: boolean;
    category: string;
    icon: string;
}

export interface IDesktopService {
    GetUserApps(env: string, user: string): Promise<any>;
    LoadApp(appName: string): Promise<any>;
    InstallApp(env: string, user: string, app: IAppStoreItem): Promise<any>;
}

export class LocalDesktopService implements IDesktopService {
    LoadApp(appName: string): Promise<any>;
    GetUserApps(env: string, user: string): Promise<any>;
    InstallApp(env: string, user: string, app: IAppStoreItem): Promise<any>;
}

export class Message {
    get LParam(): any;
    set LParam(value: any);
    get Msg(): int;
    set Msg(value: int);
    get Result(): any;
    set Result(value: any);
    get WParam(): any;
    set WParam(value: any);
    static Create(msg: int, wparam: any, lparam: any): Message;
    static isEqual(a: Message, b: Message): boolean;
    static isNotEqual(a: Message, b: Message): boolean;
    equals(o: Message): boolean;
    getHashCode(): int;
    getLParam(cls: Type): any;
    toString(): string;
}

export class MouseEventArgs extends EventArgs {
    constructor(button: MouseButtons, clicks: number, x: float, y: float, delta: float, htmlEventObject?: MouseEvent);
    get Button(): MouseButtons;
    get Clicks(): number;
    get X(): float;
    get Y(): float;
    get Delta(): number;
    get Location(): {
        x: number;
        y: number;
    };
    get HtmlEventObject(): MouseEvent;
}

export function Skin(styleName: string): (target: any, key: string) => void;
export enum BorderAppearanceStyle {
        None = "none",
        Hidden = "hidden",
        Dotted = "dotted",
        Dashed = "dashed",
        Solid = "solid",
        Double = "double",
        Groove = "groove",
        Ridge = "ridge",
        Inset = "inset",
        Outset = "outset",
        Initial = "initial",
        Inherit = "inherit"
}
export class AppearanceObject {
        IsEmpty: boolean;
        StylePropertyBag: {};
        /**
            * Specifies the alignment of flexible container's items within the flex container.
            */
        AlignContent: string;
        /**
            * Specifies the default alignment for items within the flex container.
            */
        AlignItems: string;
        /**
            * Specifies the alignment for selected items within the flex container.
            */
        AlignSelf: string;
        /**
            * Specifies the keyframe-based animations.
            */
        Animation: string;
        /**
            * Specifies when the animation will start.
            */
        AnimationDelay: string;
        /**
            * Specifies whether the animation should play in reverse on alternate cycles or not.
            */
        AnimationDirection: string;
        /**
            * Specifies the number of seconds or milliseconds an animation should take to complete one cycle.
            */
        AnimationDuration: string;
        /**
            * Specifies how a CSS animation should apply styles to its target before and after it is executing.
            */
        AnimationFillMode: string;
        /**
            * Specifies the number of times an animation cycle should be played before stopping.
            */
        AnimationIterationCount: string;
        /**
            * Specifies the name of @keyframes defined animations that should be applied to the selected element.
            */
        AnimationName: string;
        /**
            * Specifies whether the animation is running or paused.
            */
        AnimationPlayState: string;
        /**
            * Specifies how a CSS animation should progress over the duration of each cycle.
            */
        AnimationTimingFunction: string;
        /**
            * Specifies whether or not the "back" side of a transformed element is visible when facing the user.
            */
        BackfaceVisibility: string;
        /**
            * Defines a variety of background properties within one declaration.
            */
        Background: string;
        /**
            * Specify whether the background image is fixed in the viewport or scrolls.
            */
        BackgroundAttachment: string;
        /**
            * Specifies the painting area of the background.
            */
        BackgroundClip: string;
        /**
            * Defines an element's background color.
            */
        BackgroundColor: string;
        /**
            * Defines an element's background image.
            */
        BackgroundImage: string;
        /**
            * Specifies the positioning area of the background images.
            */
        BackgroundOrigin: string;
        /**
            * Defines the origin of a background image.
            */
        BackgroundPosition: string;
        /**
            * Specify whether/how the background image is tiled.
            */
        BackgroundRepeat: string;
        /**
            * Specifies the size of the background images.
            */
        BackgroundSize: string;
        /**
            * Sets the width, style, and color for all four sides of an element's border.
            */
        Border: string;
        /**
            * Sets the width, style, and color of the bottom border of an element.
            */
        BorderBottom: string;
        /**
            * Sets the color of the bottom border of an element.
            */
        BorderBottomColor: string;
        /**
            * Defines the shape of the bottom-left border corner of an element.
            */
        BorderBottomLeftRadius: string;
        /**
            * Defines the shape of the bottom-right border corner of an element.
            */
        BorderBottomRightRadius: string;
        /**
            * Sets the style of the bottom border of an element.
            */
        BorderBottomStyle: string;
        /**
            * Sets the width of the bottom border of an element.
            */
        BorderBottomWidth: string;
        /**
            * Specifies whether table cell borders are connected or separated.
            */
        BorderCollapse: string;
        /**
            * Sets the color of the border on all the four sides of an element.
            */
        BorderColor: string;
        /**
            * Specifies how an image is to be used in place of the border styles.
            */
        BorderImage: string;
        /**
            * Specifies the amount by which the border image area extends beyond the border box.
            */
        BorderImageOutset: string;
        /**
            * Specifies whether the image-border should be repeated, rounded or stretched.
            */
        BorderImageRepeat: string;
        /**
            * Specifies the inward offsets of the image-border.
            */
        BorderImageSlice: string;
        /**
            * Specifies the location of the image to be used as a border.
            */
        BorderImageSource: string;
        /**
            * 	Specifies the width of the image-border.
            */
        BorderImageWidth: string;
        /**
            * Sets the width, style, and color of the left border of an element.
            */
        BorderLeft: string;
        /**
            * Sets the color of the left border of an element.
            */
        BorderLeftColor: string;
        /**
            * Sets the style of the left border of an element.
            */
        BorderLeftStyle: string;
        /**
            * Sets the width of the left border of an element.
            */
        BorderLeftWidth: string;
        /**
            * Defines the shape of the border corners of an element.
            */
        BorderRadius: string;
        /**
            * Sets the width, style, and color of the right border of an element.
            */
        BorderRight: string;
        /**
            * Sets the color of the right border of an element.
            */
        BorderRightColor: string;
        /**
            * Sets the style of the right border of an element.
            */
        BorderRightStyle: string;
        /**
            * Sets the width of the right border of an element.
            */
        BorderRightWidth: string;
        /**
            * Sets the spacing between the borders of adjacent table cells.
            */
        BorderSpacing: string;
        /**
            * Sets the style of the border on all the four sides of an element.
            */
        BorderStyle: string;
        /**
            * Sets the width, style, and color of the top border of an element.
            */
        BorderTop: string;
        /**
            * Sets the color of the top border of an element.
            */
        BorderTopColor: string;
        /**
            * Defines the shape of the top-left border corner of an element.
            */
        BorderTopLeftRadius: string;
        /**
            * Defines the shape of the top-right border corner of an element.
            */
        BorderTopRightRadius: string;
        /**
            * Sets the style of the top border of an element.
            */
        BorderTopStyle: string;
        /**
            * Sets the width of the top border of an element.
            */
        BorderTopWidth: string;
        /**
            * Sets the width of the border on all the four sides of an element.
            */
        BorderWidth: string;
        /**
            * Specify the location of the bottom edge of the positioned element.
            */
        Bottom: string;
        /**
            * Applies one or more drop-shadows to the element's box.
            */
        BoxShadow: string;
        /**
            * Alter the default CSS box model.
            */
        BoxSizing: string;
        /**
            * Specify the position of table's caption.
            */
        CaptionSide: string;
        /**
            * Specifies the placement of an element in relation to floating elements.
            */
        Clear: string;
        /**
            * Defines the clipping region.
            */
        Clip: string;
        /**
            * Defines the clipping region.
            */
        ClipPath: string;
        /**
        * Defines the filter.
        */
        Filter: string;
        /**
            * Specify the color of the text of an element.
            */
        Color: string;
        /**
            * Specifies the number of columns in a multi-column element.
            */
        ColumnCount: string;
        /**
            * Specifies how columns will be filled.
            */
        ColumnFill: string;
        /**
            * Specifies the gap between the columns in a multi-column element.
            */
        ColumnGap: string;
        /**
            * Specifies a straight line, or "rule", to be drawn between each column in a multi-column element.
            */
        ColumnRule: string;
        /**
            * Specifies the color of the rules drawn between columns in a multi-column layout.
            */
        ColumnRuleColor: string;
        /**
            * Specifies the style of the rule drawn between the columns in a multi-column layout.
            */
        ColumnRuleStyle: string;
        /**
            * Specifies the width of the rule drawn between the columns in a multi-column layout.
            */
        ColumnRuleWidth: string;
        /**
            * Specifies how many columns an element spans across in a multi-column layout.
            */
        ColumnSpan: string;
        /**
            * Specifies the optimal width of the columns in a multi-column element.
            */
        ColumnWidth: string;
        /**
            * A shorthand property for setting column-width and column-count properties.
            */
        Columns: string;
        /**
            * Inserts generated content.
            */
        Content: string;
        /**
            * Increments one or more counter values.
            */
        CounterIncrement: string;
        /**
            * Creates or resets one or more counters.
            */
        CounterReset: string;
        /**
            * Specify the type of cursor.
            */
        Cursor: string;
        /**
            * Define the text direction/writing direction.
            */
        Direction: string;
        /**
            * Specifies how an element is displayed onscreen.
            */
        Display: string;
        /**
            * Show or hide borders and backgrounds of empty table cells.
            */
        EmptyCells: string;
        /**
            * Specifies the components of a flexible length.
            */
        flex: string;
        /**
            * Specifies the initial main size of the flex item.
            */
        FlexBasis: string;
        /**
            * Specifies the direction of the flexible items.
            */
        FlexDirection: string;
        /**
            * A shorthand property for the flex-direction and the flex-wrap properties.
            */
        FlexFlow: string;
        /**
            * Specifies how the flex item will grow relative to the other items inside the flex container.
            */
        FlexGrow: string;
        /**
            * Specifies how the flex item will shrink relative to the other items inside the flex container.
            */
        FlexShrink: string;
        /**
            * Specifies whether the flexible items should wrap or not.
            */
        FlexWrap: string;
        /**
            * Specifies whether or not a box should float.
            */
        Float: string;
        /**
            * Defines a variety of font properties within one declaration.
            */
        Font: string;
        /**
            * Defines a list of fonts for element.
            */
        FontFamily: string;
        /**
            * Defines the font size for the text.
            */
        FontSize: string;
        /**
            * Preserves the readability of text when font fallback occurs.
            */
        FontSizeAdjust: string;
        /**
            * Selects a normal, condensed, or expanded face from a font.
            */
        FontStretch: string;
        /**
            * Defines the font style for the text.
            */
        FontStyle: string;
        /**
            * Specify the font variant.
            */
        FontVariant: string;
        /**
            * Specify the font weight of the text.
            */
        FontWeight: string;
        /**
            * Specify the height of an element.
            */
        Height: string;
        /**
            * Specifies how flex items are aligned along the main axis of the flex container after any flexible lengths and auto margins have been resolved.
            */
        JustifyContent: string;
        /**
    * Specifies how flex items are aligned along the main axis of the flex container after any flexible lengths and auto margins have been resolved.
    */
        JustifyItems: string;
        /**
            * Specify the location of the left edge of the positioned element.
            */
        Left: string;
        /**
            * Sets the extra spacing between letters.
            */
        LetterSpacing: string;
        /**
            * Sets the height between lines of text.
            */
        LineHeight: string;
        /**
            * Defines the display style for a list and list elements.
            */
        ListStyle: string;
        /**
            * Specifies the image to be used as a list-item marker.
            */
        ListStyleImage: string;
        /**
            * Specifies the position of the list-item marker.
            */
        ListStylePosition: string;
        /**
            * Specifies the marker style for a list-item.
            */
        ListStyleType: string;
        /**
            * Sets the margin on all four sides of the element.
            */
        Margin: string;
        /**
            * Sets the bottom margin of the element.
            */
        MarginBottom: string;
        /**
            * Sets the left margin of the element.
            */
        MarginLeft: string;
        /**
            * Sets the right margin of the element.
            */
        MarginRight: string;
        /**
            * Sets the top margin of the element.
            */
        MarginTop: string;
        /**
            * Specify the maximum height of an element.
            */
        MaxHeight: string;
        /**
            * Specify the maximum width of an element.
            */
        MaxWidth: string;
        /**
            * Specify the minimum height of an element.
            */
        MinHeight: string;
        /**
            * Specify the minimum width of an element.
            */
        MinWidth: string;
        /**
            * Specifies the transparency of an element.
            */
        Opacity: string;
        /**
            * Specifies the order in which a flex items are displayed and laid out within a flex container.
            */
        Order: string;
        /**
            * Sets the width, style, and color for all four sides of an element's outline.
            */
        Outline: string;
        /**
            * Sets the color of the outline.
            */
        OutlineColor: string;
        /**
            * Set the space between an outline and the border edge of an element.
            */
        OutlineOffset: string;
        /**
            * Sets a style for an outline.
            */
        OutlineStyle: string;
        /**
            * Sets the width of the outline.
            */
        OutlineWidth: string;
        /**
            * Specifies the treatment of content that overflows the element's box.
            */
        Overflow: string;
        /**
            * Specifies the treatment of content that overflows the element's box horizontally.
            */
        OverflowX: string;
        /**
            * Specifies the treatment of content that overflows the element's box vertically.
            */
        OverflowY: string;
        /**
            * Sets the padding on all four sides of the element.
            */
        Padding: string;
        /**
            * Sets the padding to the bottom side of an element.
            */
        PaddingBottom: string;
        /**
            * Sets the padding to the left side of an element.
            */
        PaddingLeft: string;
        /**
            * Sets the padding to the right side of an element.
            */
        PaddingRight: string;
        /**
            * Sets the padding to the top side of an element.
            */
        PaddingTop: string;
        /**
            * Insert a page breaks after an element.
            */
        PageBreakAfter: string;
        /**
            * Insert a page breaks before an element.
            */
        PageBreakBefore: string;
        /**
            * Insert a page breaks inside an element.
            */
        PageBreakInside: string;
        /**
            * Defines the perspective from which all child elements of the object are viewed.
            */
        Perspective: string;
        /**
            * Defines the origin (the vanishing point for the 3D space) for the perspective property.
            */
        PerspectiveOrigin: string;
        /**
            * Specifies how an element is positioned.
            */
        Position: string;
        /**
            * Specifies quotation marks for embedded quotations.
            */
        Quotes: string;
        /**
            * Specifies whether or not an element is resizable by the user.
            */
        Resize: string;
        /**
            * Specify the location of the right edge of the positioned element.
            */
        Right: string;
        /**
            * Specifies the length of the tab character.
            */
        TabSize: string;
        /**
            * Specifies a table layout algorithm.
            */
        TableLayout: string;
        /**
            * Sets the horizontal alignment of inline content.
            */
        TextAlign: string;
        /**
            * Specifies how the last line of a block or a line right before a forced line break is aligned when text-align is justify.
            */
        TextAlignLast: string;
        /**
            * Specifies the decoration added to text.
            */
        TextDecoration: string;
        /**
            * Specifies the color of the text-decoration-line.
            */
        TextDecorationColor: string;
        /**
            * Specifies what kind of line decorations are added to the element.
            */
        TextDecorationLine: string;
        /**
            * Specifies the style of the lines specified by the text-decoration-line property
            */
        TextDecorationStyle: string;
        /**
            * Indent the first line of text.
            */
        TextIndent: string;
        /**
            * Specifies the justification method to use when the text-align property is set to justify.
            */
        TextJustify: string;
        /**
            * Specifies how the text content will be displayed, when it overflows the block containers.
            */
        TextOverflow: string;
        /**
            * Applies one or more shadows to the text content of an element.
            */
        TextShadow: string;
        /**
            * Transforms the case of the text.
            */
        TextTransform: string;
        /**
            * Specify the location of the top edge of the positioned element.
            */
        Top: string;
        /**
            * Applies a 2D or 3D transformation to an element.
            */
        Transform: string;
        /**
            * Defines the origin of transformation for an element.
            */
        TransformOrigin: string;
        /**
            * Specifies how nested elements are rendered in 3D space.
            */
        TransformStyle: string;
        /**
            * Defines the transition between two states of an element.
            */
        Transition: string;
        /**
            * Specifies when the transition effect will start.
            */
        TransitionDelay: string;
        /**
            * Specifies the number of seconds or milliseconds a transition effect should take to complete.
            */
        TransitionDuration: string;
        /**
            * Specifies the names of the CSS properties to which a transition effect should be applied.
            */
        TransitionProperty: string;
        /**
            * Specifies the speed curve of the transition effect.
            */
        TransitionTimingFunction: string;
        /**
            * Sets the vertical positioning of an element relative to the current text baseline.
            */
        VerticalAlign: string;
        /**
            * Specifies whether or not an element is visible.
            */
        Visibility: string;
        /**
            * Specifies how white space inside the element is handled.
            */
        WhiteSpace: string;
        /**
            * 	Specify the width of an element.
            */
        Width: string;
        /**
            * 	Specifies how to break lines within words.
            */
        WordBreak: string;
        /**
            * Sets the spacing between words.
            */
        WordSpacing: string;
        /**
            * Specifies whether to break words when the content overflows the boundaries of its container.
            */
        WordWrap: string;
        /**
            * Specifies a layering or stacking order for positioned elements.
            */
        ZIndex: string;
        constructor(obj: IControl);
        GetStyleObject(): any;
        SetStyleObject(styleObject: any): void;
        CloneStyleObject(): {};
        Assign(other: AppearanceObject): void;
        ToString(): string;
}

export interface IControl extends IRenderable {
    Text: string;
    TabIndex: int;
    jssStyle: any;
    Appearance: AppearanceObject;
    HoverAppearance: AppearanceObject;
    ActiveAppearance: AppearanceObject;
    DisabledAppearance: AppearanceObject;
    FocusAppearance: AppearanceObject;
    BeforeAppearance: AppearanceObject;
    PropertyChanged: Event<any>;
    UpdateRequied: Event<any>;
    OnLoaded(): void;
    OnUnLoaded(): void;
    Width?: int;
    Height?: int;
    BackgroundColor: string;
    Padding: Padding;
    Border: Border;
    Margin: Margin;
    Left?: string;
    Top?: string;
    Bottom?: string;
    Right?: string;
    _Width?: string;
    _Height?: string;
    Id: string;
    WndProc(msg: Message): any;
    PaddingAll?: string;
    PaddingLeft?: string;
    PaddingRight?: string;
    PaddingTop?: string;
    PaddingBottom?: string;
    BackColor?: any;
    Visible: boolean;
    Tooltip: string;
    KeyFrameCollection: KeyFrameCollection[];
}

export interface IRenderable {
    Appearance: AppearanceObject;
    Render(): any;
}

export class Dialog extends React.Component {
    static defaultProps: {
        id: any;
        header: any;
        footer: any;
        visible: boolean;
        position: string;
        draggable: boolean;
        resizable: boolean;
        modal: boolean;
        isActive: boolean;
        onHide: any;
        onShow: any;
        contentStyle: any;
        contentClassName: any;
        closeOnEscape: boolean;
        dismissableMask: boolean;
        rtl: boolean;
        closable: boolean;
        style: any;
        maskStyle: any;
        className: any;
        maskClassName: any;
        showHeader: boolean;
        headerColor: any;
        headerPadding: any;
        headerSubStyle: any;
        headerHeight: any;
        headerTitleColor: any;
        headerTitleAlign: any;
        headerTitleFontSize: any;
        contentPadding: any;
        appendTo: any;
        baseZIndex: number;
        maximizable: boolean;
        topMaximizable: boolean;
        blockScroll: boolean;
        icons: any;
        ariaCloseIconLabel: string;
        focusOnShow: boolean;
        minX: number;
        minY: number;
        keepInViewport: boolean;
        maximized: boolean;
        topMaximized: boolean;
        breakpoints: any;
        onMaximize: any;
        onTopMaximize: any;
        onDragStart: any;
        onDrag: any;
        onDragEnd: any;
        onResizeStart: any;
        onResize: any;
        onResizeEnd: any;
        onContentResize: any;
        onClick: any;
    };
    id: any;
    attributeSelector: string;
    dialogRef: any;
    mask: any;
    dragging: boolean;
    lastPageX: any;
    lastPageY: any;
    resizing: boolean;
    documentDragListener: any;
    documentDragEndListener: any;
    documentResizeListener: any;
    documentResizeEndListener: any;
    documentKeyDownListener: any;
    styleElement: any;
    closeElement: any;
    headerEl: any;
    headerSubEl: any;
    footerElement: any;
    contentEl: HTMLElement;
    constructor(props: any);
    onClick(event: any): void;
    onClose(event: any): void;
    focus(): void;
    onMaskClick(event: any): void;
    toggleTopMaximize(event: any): void;
    toggleMaximize(event: any): void;
    toggleMinimize(event: any): void;
    onDragStart(event: any): void;
    onDrag(event: any): void;
    onDragEnd(event: any): void;
    onResizeStart(event: any): void;
    onResize(event: any): void;
    onResizeEnd(event: any): void;
    resetPosition(): void;
    getPositionClass(): string;
    get zIndex(): any;
    get topMaximized(): any;
    get maximized(): any;
    get minimized(): any;
    get dialogEl(): any;
    onEnter(): void;
    onEntered(): void;
    onExited(): void;
    enableDocumentSettings(): void;
    disableDocumentSettings(): void;
    bindGlobalListeners(): void;
    unbindGlobalListeners(): void;
    bindDocumentDragListener(): void;
    unbindDocumentDragListener(): void;
    bindDocumentResizeListeners(): void;
    unbindDocumentResizeListeners(): void;
    bindDocumentKeyDownListener(): void;
    unbindDocumentKeyDownListener(): void;
    createStyle(): void;
    componentDidMount(): void;
    componentDidUpdate(prevProps: any): void;
    changeScrollOnMaximizable(): void;
    componentWillUnmount(): void;
    renderCloseIcon(): any;
    renderTopMaximizeIcon(): any;
    renderMaximizeIcon(): any;
    renderMinimizeIcon(): any;
    renderHeader(): any;
    renderContent(): any;
    renderFooter(): any;
    renderResizer(): any;
    renderElement(): any;
    render(): any;
}

export interface ITextBox extends IControl {
    Autofocus: boolean;
    LeftIcon: string;
    Disabled: boolean;
    Placeholder: string;
    OnKeyDownInternal: Function;
}

export class TTabControlRenderer extends ControlHtmlRenderer<TTabControl> {
    GenerateBody(obj: TTabControl): void;
    protected OnComponentDidUpdate(obj: TTabControl): void;
}

export class MultiComboBox extends Control<MultiComboBox> {
    Label: string;
    Placeholder: string;
    SelectedItems: TextMultiComboBoxItem[];
    Items: MultiComboBoxItemCollection;
    protected SetupControlDefaults(): void;
    CreateElements(): any;
}

export abstract class MultiComboBoxItem {
    Parent: MultiComboBox;
    Key: string;
    Text: string;
    Tag: any;
    abstract GetItemTemplate(): any;
    abstract ToObject(): any;
}

export class MultiComboBoxItemCollection extends List<MultiComboBoxItem> {
    ComboBox: MultiComboBox;
    constructor(comboBox: MultiComboBox);
    Add(text: string): MultiComboBoxItem;
    Add(key: int, text: string): MultiComboBoxItem;
    Add(key: string, text: string): MultiComboBoxItem;
    Add(treeNode: MultiComboBoxItem): int;
    Clear(): int;
    ToObject(): any[];
}

export class ComboBox extends ComboBoxBase {
    CreateElements(): any;
}

export abstract class ComboBoxBase extends Control<ComboBoxBase> {
    get OnChanged(): any;
    set OnChanged(value: any);
    get Label(): string;
    set Label(value: string);
    get SelectedItem(): ComboBoxItem;
    set SelectedItem(value: ComboBoxItem);
    get Items(): ComboBoxItemCollection;
    set Items(value: ComboBoxItemCollection);
    get Placeholder(): string;
    set Placeholder(value: string);
    get Filter(): boolean;
    set Filter(value: boolean);
    Editable: boolean;
    protected SetupControlDefaults(): void;
    InitComponents(): void;
}

export abstract class ComboBoxItem {
    Parent: ComboBoxBase;
    Key: string;
    Text: string;
    Tag: any;
    abstract GetItemTemplate(): any;
    abstract ToObject(): any;
}

export class ComboBoxItemCollection extends List<ComboBoxItem> {
    ComboBox: ComboBoxBase;
    constructor(comboBox: ComboBoxBase);
    Add(text: string): ComboBoxItem;
    Add(key: int, text: string): ComboBoxItem;
    Add(key: string, text: string): ComboBoxItem;
    Add(treeNode: ComboBoxItem): int;
    Clear(): int;
    ToObject(): any[];
}

export class ListBox extends ListBoxBase {
    CreateElements(): any;
}

export abstract class ListBoxBase extends Control<ListBoxBase> {
    get OnChanged(): any;
    set OnChanged(value: any);
    get Label(): string;
    set Label(value: string);
    get SelectedItem(): ListBoxItem;
    set SelectedItem(value: ListBoxItem);
    get Items(): ListBoxItemCollection;
    set Items(value: ListBoxItemCollection);
    get Placeholder(): string;
    set Placeholder(value: string);
    get Filter(): boolean;
    set Filter(value: boolean);
    protected SetupControlDefaults(): void;
    InitComponents(): void;
}

export abstract class ListBoxItem {
    Parent: ListBoxBase;
    Key: string;
    Text: string;
    Tag: any;
    abstract GetItemTemplate(): any;
    abstract ToObject(): any;
}

export class ListBoxItemCollection extends List<ListBoxItem> {
    ListBox: ListBoxBase;
    constructor(ListBox: ListBoxBase);
    Add(text: string): ListBoxItem;
    Add(key: int, text: string): ListBoxItem;
    Add(key: string, text: string): ListBoxItem;
    Add(treeNode: ListBoxItem): int;
    Clear(): int;
    ToObject(): any[];
}

export class SelectionChanged extends Delegate<(key: string) => void> {
}
export class TTreeView extends Control<TTreeView> {
    get AfterSelect(): Event<TreeViewEventHandler>;
    set AfterSelect(value: Event<TreeViewEventHandler>);
    get BeforeSelect(): Event<TreeViewCancelEventHandler>;
    set BeforeSelect(value: Event<TreeViewCancelEventHandler>);
    get SelectedItem(): any;
    set SelectedItem(value: any);
    get Label(): string;
    set Label(value: string);
    get SelectedKey(): string;
    set SelectedKey(value: string);
    get SelectedKey$(): Observable<string>;
    set SelectedKey$(value: Observable<string>);
    get SelectedNode(): TreeNode;
    set SelectedNode(value: TreeNode);
    get Nodes(): TreeNodeCollection;
    set Nodes(value: TreeNodeCollection);
    NodeMouseDoubleClick: Event<any>;
    ItemDrag: Event<any>;
    protected SetupControlDefaults(): void;
    protected SetupComponentDefaults(): void;
    Expand(node: TreeNode): void;
    CreateElements(): any;
    OnSelectionChanged(): void;
    onNodeSelect(): void;
    onNodeUnselect(): void;
}

export class TreeNode {
    Key: string;
    Icon: string;
    Selectable: boolean;
    Tag: any;
    get TreeView(): TTreeView;
    set TreeView(value: TTreeView);
    Text: string;
    Nodes: TreeNodeCollection;
    constructor(text: string);
    constructor(key: string, text: string);
    ToObject(): any;
}

export class TreeViewEventArgs extends EventArgs {
    constructor(node: TreeNode, action?: TreeViewAction);
    get Action(): TreeViewAction;
    get Node(): TreeNode;
}

export class TreeViewCancelEventArgs {
    constructor(node: TreeNode, cancel: boolean, action: TreeViewAction);
    get Node(): TreeNode;
    get Action(): TreeViewAction;
    get Cancel(): boolean;
    set Cancel(value: boolean);
}

export class RowClickEvent extends Delegate<() => void> {
}
export class GridView extends Control<GridView> {
    get KeyField(): string;
    set KeyField(value: string);
    get SelectedRow(): any;
    set SelectedRow(value: any);
    get Columns(): ColumnCollection;
    set Columns(value: ColumnCollection);
    get Data(): any;
    set Data(value: any);
    get ScrollHeight(): int;
    set ScrollHeight(value: int);
    get OnRowDoubleClick(): Event<RowClickEvent>;
    set OnRowDoubleClick(value: Event<RowClickEvent>);
    SetupControlDefaults(): void;
    protected componentWillUnmount(): void;
    CreateElements(): any;
}

export abstract class GridViewBase extends Control<GridViewBase> {
    get AutoGenerateColumns(): boolean;
    set AutoGenerateColumns(value: boolean);
    get Columns(): ColumnCollection;
    set Columns(value: ColumnCollection);
    get DataSource(): any;
    set DataSource(value: any);
    get ScrollHeight(): int;
    set ScrollHeight(value: int);
    SetupControlDefaults(): void;
    protected componentWillUnmount(): void;
    RefreshColumns(): void;
    protected abstract RefreshColumnsInternal(): void;
}

export enum ColumnClipModes {
    /** Truncates the cell content when it overflows its area. */
    Clip = "Clip",
    /** Displays ellipsis when the cell content overflows its area. */
    Ellipsis = "Ellipsis",
    /** Displays ellipsis when the cell content overflows its area also it will display tooltip while hover on ellipsis applied cell. */
    EllipsisWithTooltip = "EllipsisWithTooltip"
}
export enum TextAlign {
    /**  Defines Left alignment */
    Left = "Left",
    /**  Defines Right alignment */
    Right = "Right",
    /**  Defines Center alignment */
    Center = "Center",
    /**  Defines Justify alignment */
    Justify = "Justify"
}
export class GridColumn implements IDataGridColumn {
    allowEditing: boolean;
    allowFiltering: boolean;
    allowGrouping: boolean;
    allowReordering: boolean;
    allowResizing: boolean;
    allowSearching: boolean;
    allowSorting: boolean;
    autoFit: boolean;
    clipMode: ColumnClipModes;
    columns: List<IDataGridColumn>;
    commands: any[];
    customAttributes: Object;
    dataSource: Object[];
    defaultValue: string;
    disableHtmlEncode: boolean;
    displayAsCheckBox: boolean;
    edit: any;
    editTemplate: string;
    editType: string;
    enableGroupByFormat: boolean;
    field: string;
    filter: any;
    filterBarTemplate: any;
    filterTemplate: string;
    foreignKeyField: string;
    foreignKeyValue: string;
    format: string | NumberFormatOptions | DateFormatOptions;
    formatter: Object | ICellFormatter | Function;
    headerTemplate: string;
    headerText: string;
    headerTextAlign: TextAlign;
    headerValueAccessor: string;
    hideAtMedia: string;
    index: number;
    isFrozen: boolean;
    isIdentity: boolean;
    isPrimaryKey: boolean;
    lockColumn: boolean;
    maxWidth: string | number;
    minWidth: string | number;
    showColumnMenu: boolean;
    showInColumnChooser: boolean;
    sortComparer: string;
    template: string;
    textAlign: TextAlign;
    type: string;
    uid: string;
    validationRules: Object;
    valueAccessor: string;
    visible: boolean;
    width: string | number;
    constructor(header: string);
    constructor(field: string, header: string);
    GetBodyTemplate(rowData: any): any;
}

export interface ICellFormatter {
    getValue(column: IDataGridColumn, data: Object): Object;
}
export interface IDataGridColumn {
    allowEditing: boolean;
    allowFiltering: boolean;
    allowGrouping: boolean;
    allowReordering: boolean;
    allowResizing: boolean;
    allowSearching: boolean;
    allowSorting: boolean;
    autoFit: boolean;
    clipMode: ColumnClipModes;
    columns: List<IDataGridColumn>;
    commands: any[];
    customAttributes: Object;
    dataSource: any;
    defaultValue: string;
    disableHtmlEncode: boolean;
    displayAsCheckBox: boolean;
    edit: any;
    editTemplate: string;
    editType: string;
    enableGroupByFormat: boolean;
    field: string;
    filter: any;
    filterBarTemplate: any;
    filterTemplate: string;
    foreignKeyField: string;
    foreignKeyValue: string;
    format: string | NumberFormatOptions | DateFormatOptions;
    formatter: Object | ICellFormatter | Function;
    headerTemplate: string;
    headerText: string;
    headerTextAlign: string;
    headerValueAccessor: string;
    hideAtMedia: string;
    index: int;
    isFrozen: boolean;
    isIdentity: boolean;
    isPrimaryKey: boolean;
    lockColumn: boolean;
    maxWidth: string | int;
    minWidth: string | int;
    showColumnMenu: boolean;
    showInColumnChooser: boolean;
    sortComparer: string;
    template: string;
    textAlign: string;
    type: string;
    uid: string;
    validationRules: Object;
    valueAccessor: string;
    visible: boolean;
    width: string | int;
}

export class ImageColumn extends GridColumn {
    Image: string;
    ImageSize: int;
    imageTemplate(rowData: any): any;
}

export class Toolbar extends Control<Toolbar> {
    CreateElements(): any;
}

export class DropEventArgs {
    sender: any;
    nativeEvent: DragEvent;
    constructor(sender: any, nativeEvent: DragEvent);
}
export class DragEnterEventHandler extends Delegate<(e: DragEvent) => void> {
}
export class DragLeaveEventHandler extends Delegate<(e: DragEvent) => void> {
}
export class DragOverEventHandler extends Delegate<(e: DragEvent) => void> {
}
export class DropEventHandler extends Delegate<(e: DropEventArgs) => void> {
}
export class DropArea extends Control<DropArea> {
    AllowDrop: boolean;
    Controls: ControlCollection;
    DragEnter: Event<DragEnterEventHandler>;
    DragLeave: Event<DragLeaveEventHandler>;
    DragOver: Event<DragOverEventHandler>;
    Drop: Event<DropEventHandler>;
    protected SetupControlDefaults(): void;
    CreateElements(): any;
    protected GetStyleObject(): any;
}

export class Taskbar extends Control<Taskbar> {
    get UserName(): string;
    set UserName(value: string);
    get ProfilePicture(): string;
    set ProfilePicture(value: string);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export class ContainerControl<T extends Control<any>> extends Control<ContainerControl<T>> implements IControlContainer {
    get Controls(): ControlCollection;
    set Controls(value: ControlCollection);
    protected SetupControlDefaults(): void;
    protected CreateControls(): any[];
    CreateElements(): void;
    GetControls(): List<Control<any>>;
}
export class EndLayout extends ContainerControl<EndLayout> {
    CreateElements(): any;
}

export class VerticalLayout extends ContainerControl<VerticalLayout> {
    CreateElements(): any;
}

export class HorizontalLayout extends ContainerControl<HorizontalLayout> {
    CreateElements(): any;
}

export enum SizingModes {
    LeftFixed = 0,
    RightFixed = 1,
    Left2Right10 = 2,
    Left3Right9 = 3,
    Left6Right6 = 4,
    Right2Left10 = 5
}
export class LayoutPanel extends Control<LayoutPanel> {
    RightPaneElementRef: HTMLElement;
    get SizingMode(): SizingModes;
    set SizingMode(value: SizingModes);
    get LeftSize(): int;
    set LeftSize(value: int);
    get LeftControl(): Control<any>;
    set LeftControl(value: Control<any>);
    get RightControl(): Control<any>;
    set RightControl(value: Control<any>);
    SetupControlDefaults(): void;
    componentDidMount(): void;
    CreateElements(): any;
    OnFormResized(width: int, height: int): void;
    GetLeftPanelRect(): DOMRect;
}

export class RibbonMenu extends Control<RibbonMenu> {
    get Tabs(): RibbonTabCollection;
    set Tabs(value: RibbonTabCollection);
    get ActiveTabIndex(): int;
    set ActiveTabIndex(value: int);
    SetupControlDefaults(): void;
    CreateTabs(data: any): any[];
    CreateContentPanels(data: any): any[];
    CreateElements(): any;
}

export class RibbonTab {
    Text: string;
    IsStatic: boolean;
    Groups: RibbonGroupCollection;
    ToModel(): any;
}

class ClickEvent extends Delegate<() => void> {
}
export class ListView extends Control<ListView> {
    get DbClick(): Event<ClickEvent>;
    set DbClick(value: Event<ClickEvent>);
    get SelectedItemIndex(): int;
    set SelectedItemIndex(value: int);
    get Items(): ListViewItemCollection;
    set Items(value: ListViewItemCollection);
    SetupControlDefaults(): void;
    CreateElements(): any;
}
export {};

export class ListViewItem {
    Text: string;
    Icon: string;
    Tag: any;
}

export class ContextMenu extends Control<ContextMenu> {
    get MenuItems(): MenuItemCollection;
    set MenuItems(value: MenuItemCollection);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export interface ISystemMenu {
    GetMenuItems(): MenuItem[];
}

class ClickEvent extends Delegate<() => void> {
}
export class MenuItem {
    Text: string;
    Icon: string;
    Click: Event<ClickEvent>;
    Items: MenuItemCollection;
    Serialize(): object;
}
export {};

export class MenuItemCollection extends List<MenuItem> {
    ContextMenu: ContextMenu;
    constructor(contextMenu?: ContextMenu);
    Add(text: string): MenuItem;
    Add(treeNode: MenuItem): int;
    Serialize(): any[];
}

class ClickEvent extends Delegate<() => void> {
}
export enum CardSizes {
    Small = 0,
    Medium = 1,
    Large = 2
}
export class CardView extends Control<CardView> {
    get _OnClick(): Event<ClickEvent>;
    set _OnClick(value: Event<ClickEvent>);
    get CardSize(): CardSizes;
    set CardSize(value: CardSizes);
    get Items(): CardViewItemCollection;
    set Items(value: CardViewItemCollection);
    SetupControlDefaults(): void;
    renderItem(item: CardViewItem): any;
    renderLargeItem(item: CardViewItem): any;
    CreateElements(): any;
}
export {};

export class ClickEvent extends Delegate<() => void> {
}
export class CardViewItem {
    CardView: CardView;
    get Title(): string;
    set Title(value: string);
    get TopTitle(): string;
    set TopTitle(value: string);
    get SubTitle(): string;
    set SubTitle(value: string);
    get Image(): string;
    set Image(value: string);
    get Tag(): any;
    set Tag(value: any);
    get ButtonText(): string;
    set ButtonText(value: string);
    get Description(): string;
    set Description(value: string);
    FooterControl: Control<any>;
    OnClick: Event<ClickEvent>;
}

export class DragStartEventHandler extends Delegate<(e: DragEvent) => void> {
}
export class ListMenu extends Control<ListMenu> {
    DragStart: Event<DragStartEventHandler>;
    EditMode: boolean;
    HeaderText: string;
    ItemHeight: int;
    ItemColor: string;
    SelectedItemColor: string;
    ItemBorder: Border;
    SelectedIndexChanged: Event<any>;
    get SelectedIndex(): int;
    set SelectedIndex(value: int);
    get SelectedIndex$(): Observable<int>;
    set SelectedIndex$(value: Observable<int>);
    get Items(): ListMenuItemCollection;
    set Items(value: ListMenuItemCollection);
    Controls: ControlCollection;
    constructor();
    protected GetRenderer(): typeof ListMenuRenderer;
    protected OnItemClick(item: ListMenuItem): void;
    OnSelectedIndexChanged(): void;
}

export class ListMenuItemBase extends TVirtualContainer {
    get Selectable(): boolean;
    get Parent(): ListMenu;
    set Parent(value: ListMenu);
    protected OnClick(e: EventArgs): void;
    protected OnGotSelection(): void;
    protected OnLostSelection(): void;
}
export class ListMenuItem extends ListMenuItemBase {
    get Text(): string;
    set Text(value: string);
    get BackgroundColor(): string;
    set BackgroundColor(value: string);
    Image: string;
    Icon: FontIcon;
    IconRight: FontIcon;
    Label: TLabel;
    ImageSelected: string;
    ImageRight: string;
    ImageRightSelected: string;
    Tag: any;
    constructor();
    protected OnClick(e: EventArgs): void;
    protected OnGotSelection(): void;
    protected OnLostSelection(): void;
}

export class BottomMenu extends Control<BottomMenu> {
    get Items(): BottomMenuItemCollection;
    set Items(value: BottomMenuItemCollection);
    SetupControlDefaults(): void;
    renderMenuItem(item: BottomMenuItem): any;
    CreateElements(): any;
}

export class BottomMenuItem {
    BottomMenu: BottomMenu;
    Text: string;
    Image: string;
    Icon: string;
    MenuModel: any;
    OnClick: Event<EventHandler>;
    get Disabled(): boolean;
    set Disabled(value: boolean);
    constructor(bottomMenu: BottomMenu);
}

export class BottomMenuItemCollection extends List<BottomMenuItem> {
    ListView: BottomMenu;
    constructor(listView: BottomMenu);
    Add(icon: string): BottomMenuItem;
    Add(treeNode: BottomMenuItem): int;
}

export class Tag {
    Text: any;
}

export class TagCollection extends List<Tag> {
    TagsControl: TagsControl;
    constructor(tagsControl: TagsControl);
    Add(text: string): Tag;
    Add(tag: Tag): int;
}

export class TagsControl extends Control<TagsControl> {
    get Tags(): TagCollection;
    set Tags(value: TagCollection);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export enum Orientations {
    Horizontal = "horizontal",
    Vertical = "vertical"
}
export class Slider extends Control<Slider> {
    Orientation: Orientations;
    get SlideEnd(): any;
    set SlideEnd(value: any);
    get Value(): int;
    set Value(value: int);
    get Max(): int;
    set Max(value: int);
    get Min(): int;
    set Min(value: int);
    get Value$(): ReplaySubject<int>;
    set Value$(value: ReplaySubject<int>);
    SetupControlDefaults(): void;
    GetRenderer(): any;
}

export class SelectButton extends Control<SelectButton> {
    get Value(): string;
    set Value(value: string);
    get OptionLabel(): string;
    set OptionLabel(value: string);
    get OptionValue(): any;
    set OptionValue(value: any);
    get Options(): any;
    set Options(value: any);
    get Value$(): ReplaySubject<int>;
    set Value$(value: ReplaySubject<int>);
    get Changed(): Event<any>;
    set Changed(value: Event<any>);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export class RadioButtonGroup extends Control<RadioButtonGroup> {
    get Items(): RadioGroupItemCollection;
    set Items(value: RadioGroupItemCollection);
    get Value(): RadioButtonGroupItem;
    set Value(value: RadioButtonGroupItem);
    get Value$(): ReplaySubject<RadioButtonGroupItem>;
    set Value$(value: ReplaySubject<RadioButtonGroupItem>);
    protected SetupControlDefaults(): void;
    CreateElements(): any;
}

export class RadioButtonGroupItem {
    Parent: RadioButtonGroup;
    Key: string;
    Text: string;
    Tag: any;
    constructor(text: string);
    constructor(key: string, text: string);
    ToObject(): any;
}

export class TRadioButton extends TFlexContainer {
    get Checked(): boolean;
    set Checked(value: boolean);
    get Text(): string;
    set Text(value: string);
    constructor();
}

export class TRadioButtonGroup extends TFlexColumnContainer {
    constructor();
}

export class Accordion extends Control<Accordion> {
    get ActiveIndexes(): int[];
    set ActiveIndexes(value: int[]);
    get HeaderText(): string;
    set HeaderText(value: string);
    get Tabs(): AccordionTabCollection;
    set Tabs(value: AccordionTabCollection);
    SetupControlDefaults(): void;
    CreateElements(): any;
}

export class AccordionTab extends ContainerControl<any> {
    CreateElements(): any;
}

export class AccordionTabCollection extends List<AccordionTab> {
    Accordion: Accordion;
    constructor(listView: Accordion);
    Add(text: string): AccordionTab;
    Add(treeNode: AccordionTab): int;
}

export function EventProperty(): any;
export function Property(defaultValue?: any): any;
export function State(defaultValue?: Function): any;
export function Binding<T>(defaultValue?: T): any;
export function Ref(defaultValue?: Function): any;
export function _State(target: Object, key: string): void;

export class ShadowRootPanel extends Control<ShadowRootPanel> {
    Style: string;
    Controls: ControlCollection;
    protected SetupControlDefaults(): void;
    CreateElements(): any;
}

export class FontIcon extends Control<FontIcon> implements IFontIcon {
    FontFamily: string;
    Content: string;
    Size: int;
    Color: CGColor;
    constructor();
    GetRenderer(): any;
}

export class UIIconClass extends UIView implements IFontIcon {
    setController(controller: UIController): this;
    constructor();
    size(size: int): this;
    Render(): any;
}
export function Icon(icon: IconType): UIIconClass;
export function Icon(content: string): UIIconClass;

export class IconType {
    constructor(title: string, name: string, filled: string);
    GetTitle(): string;
    GetCode(): string;
}
export const IconLibrary: {
    Search: IconType;
    Home: IconType;
    AccountCircle: IconType;
    Settings: IconType;
    Done: IconType;
    Info: IconType;
    CheckCircle: IconType;
    Delete: IconType;
    ShoppingCart: IconType;
    Visibility: IconType;
    Favorite: IconType;
    Logout: IconType;
    Description: IconType;
    FavoriteBorder: IconType;
    Lock: IconType;
    Schedule: IconType;
    Language: IconType;
    Face: IconType;
    HelpOutline: IconType;
    ManageAccounts: IconType;
    FilterAlt: IconType;
    Fingerprint: IconType;
    Event: IconType;
    Verified: IconType;
    ThumbUp: IconType;
    Dashboard: IconType;
    Login: IconType;
    CalendarToday: IconType;
    VisibilityOff: IconType;
    List: IconType;
    CheckCircleOutline: IconType;
    HighlightOff: IconType;
    Help: IconType;
    DateRange: IconType;
    QuestionAnswer: IconType;
    TaskAlt: IconType;
    Paid: IconType;
    Article: IconType;
    ShoppingBag: IconType;
    Lightbulb: IconType;
    OpenInNew: IconType;
    PermIdentity: IconType;
    TrendingUp: IconType;
    History: IconType;
    CreditCard: IconType;
    AccountBalance: IconType;
    DeleteOutline: IconType;
    ReportProblem: IconType;
    FactCheck: IconType;
    Assignment: IconType;
    VerifiedUser: IconType;
    ArrowRightAlt: IconType;
    StarRate: IconType;
    AccountBalanceWallet: IconType;
    Analytics: IconType;
    Autorenew: IconType;
    Work: IconType;
    Build: IconType;
    ViewList: IconType;
    Print: IconType;
    Store: IconType;
    Today: IconType;
    DeleteForever: IconType;
    AdminPanelSettings: IconType;
    LockOpen: IconType;
    Savings: IconType;
    Room: IconType;
    Code: IconType;
    Grade: IconType;
    Receipt: IconType;
    WatchLater: IconType;
    Update: IconType;
    AddShoppingCart: IconType;
    ContactSupport: IconType;
    PowerSettingsNew: IconType;
    Pets: IconType;
    DoneAll: IconType;
    Explore: IconType;
    Bookmark: IconType;
    BookmarkBorder: IconType;
    NoteAdd: IconType;
    Reorder: IconType;
    AccountBox: IconType;
    ShoppingBasket: IconType;
    PendingActions: IconType;
    DragIndicator: IconType;
    Payment: IconType;
    Launch: IconType;
    CalendarMonth: IconType;
    SupervisorAccount: IconType;
    Pending: IconType;
    ZoomIn: IconType;
    TouchApp: IconType;
    Assessment: IconType;
    ThumbUpOffAlt: IconType;
    OpenInFull: IconType;
    Leaderboard: IconType;
    DoneOutline: IconType;
    ExitToApp: IconType;
    Preview: IconType;
    AssignmentInd: IconType;
    CardGiftcard: IconType;
    ViewInAr: IconType;
    WorkOutline: IconType;
    PublishedWithChanges: IconType;
    Feedback: IconType;
    Timeline: IconType;
    Dns: IconType;
    SwapHoriz: IconType;
    SyncAlt: IconType;
    AssignmentTurnedIn: IconType;
    FlightTakeoff: IconType;
    Stars: IconType;
    Book: IconType;
    Label: IconType;
    PanTool: IconType;
    BugReport: IconType;
    ContactPage: IconType;
    Gavel: IconType;
    Cached: IconType;
    Alarm: IconType;
    Translate: IconType;
    SpaceDashboard: IconType;
    Android: IconType;
    SupervisedUserCircle: IconType;
    EditCalendar: IconType;
    Accessibility: IconType;
    Minimize: IconType;
    Extension: IconType;
    GetApp: IconType;
    TipsAndUpdates: IconType;
    RecordVoiceOver: IconType;
    AddTask: IconType;
    TrendingFlat: IconType;
    HourglassEmpty: IconType;
    HelpCenter: IconType;
    ThumbDown: IconType;
    AccessibilityNew: IconType;
    StickyNote2: IconType;
    Rule: IconType;
    FlutterDash: IconType;
    DashboardCustomize: IconType;
    Source: IconType;
    Support: IconType;
    FindInPage: IconType;
    CloseFullscreen: IconType;
    SettingsApplications: IconType;
    Redeem: IconType;
    ViewHeadline: IconType;
    Announcement: IconType;
    Loyalty: IconType;
    AdsClick: IconType;
    GroupWork: IconType;
    SwapVert: IconType;
    Restore: IconType;
    EuroSymbol: IconType;
    Sensors: IconType;
    Dangerous: IconType;
    CompareArrows: IconType;
    NightlightRound: IconType;
    RocketLaunch: IconType;
    PrivacyTip: IconType;
    ArrowCircleRight: IconType;
    QuestionMark: IconType;
    Subject: IconType;
    DisabledByDefault: IconType;
    TrackChanges: IconType;
    TableView: IconType;
    Https: IconType;
    Grading: IconType;
    Copyright: IconType;
    Toc: IconType;
    ArrowCircleUp: IconType;
    Bookmarks: IconType;
    Api: IconType;
    QueryBuilder: IconType;
    PermMedia: IconType;
    BuildCircle: IconType;
    Input: IconType;
    BookOnline: IconType;
    ZoomOut: IconType;
    Backup: IconType;
    PermContactCalendar: IconType;
    ViewModule: IconType;
    OpenWith: IconType;
    SettingsPhone: IconType;
    CircleNotifications: IconType;
    ThreeDRotation: IconType;
    ArrowCircleDown: IconType;
    LabelImportant: IconType;
    CardMembership: IconType;
    PermPhoneMsg: IconType;
    FilePresent: IconType;
    Wysiwyg: IconType;
    Pageview: IconType;
    Swipe: IconType;
    IntegrationInstructions: IconType;
    Upgrade: IconType;
    TrendingDown: IconType;
    ChangeHistory: IconType;
    Class: IconType;
    Accessible: IconType;
    SettingsAccessibility: IconType;
    ProductionGuantityLimits: IconType;
    OfflineBolt: IconType;
    Expand: IconType;
    ModelTraining: IconType;
    DonutLarge: IconType;
    AspectRatio: IconType;
    SettingsBackupRestore: IconType;
    CalendarViewMonth: IconType;
    Segment: IconType;
    ViewColumn: IconType;
    ScheduleSend: IconType;
    Maximize: IconType;
    BookmarkAdd: IconType;
    Percent: IconType;
    ArrowCircleLeft: IconType;
    ArrowDropDown: IconType;
    FileDownload: IconType;
    ExpandMore: IconType;
    Download: IconType;
    KeyboardArrowDown: IconType;
    ArrowDownward: IconType;
    Dashboard1: IconType;
    Error: IconType;
    Clock9: IconType;
};

export declare abstract class ControlHtmlRenderer<T extends IControl> extends HtmlRenderer<T> {
    DecideCache(obj: T): void;
    GenerateElement(obj: T): boolean;
    protected OnComponentDidMount(ref: any, obj: T): void;
    protected OnComponentWillUnmount(obj: T): void;
    GenerateAttributes(obj: T): void;
    abstract GenerateBody(obj: T): void;
    GenerateElementFinish(obj: T): void;
}

export declare abstract class HtmlRenderer<T extends IControl> extends XmlTransformer<T> {
    protected Ref: any;
    protected contextMenu: any;
    constructor(props: any);
    protected InitializeRenderer(obj: T): void;
    TranslateAlpha(c: CGColor): float;
    TranslateColor(c: CGColor): string;
    TranslateGraphicsPath(path: GraphicsPath): string;
    WriteBrushAttributes(brush: Brush): void;
    WriteEllipse(p: Pen, b: Brush, r: CGRectangle): void;
    WriteLine(p: Pen, a: CGPoint, b: CGPoint): void;
    WriteLines(p: Pen, v: CGPoint[]): void;
    WritePath(p: Pen, b: Brush, pathdesc: string): void;
    WritePenAttributes(pen: Pen): void;
    WritePolygon(p: Pen, b: Brush, poly: CGPoint[]): void;
    WriteRectangle(p: Pen, b: Brush, r: CGRectangle, corner: CGSize): void;
    protected OnShadowDomWillMount(ref: any, obj: T): void;
    protected OnShadowDomDidMount(ref: any, obj: T): void;
    protected OnShadowDomWillUnmount(ref: any, obj: T): void;
    protected OnComponentWillMount(ref: any, obj: T): void;
    protected OnComponentDidMount(ref: any, obj: T): void;
    protected OnComponentWillReceiveProps(obj: T): void;
    protected OnShouldComponentUpdate(obj: T): boolean;
    protected OnComponentWillUpdate(obj: T): void;
    protected OnComponentDidUpdate(obj: T): void;
    protected OnComponentWillUnmount(obj: T): void;
    protected GetStyleObject(): any;
    get UseShadowDom(): boolean;
    OnStyleCreating(obj: T, sb: StringBuilder): void;
    OnCustomAttributesCreating(obj: T, attributeObject: any): void;
    GetCustomJss(): Object;
    render(param?: any): any;
}

export class TLabel extends Control<TLabel> implements ILabel {
    HtmlFor: string;
    TextAlign: string;
    constructor();
    protected GetRenderer(): any;
}

export abstract class ControlHtmlRenderer<T extends IControl> extends HtmlRenderer<T> {
    DecideCache(obj: T): void;
    GenerateElement(obj: T): boolean;
    protected OnComponentDidMount(ref: any, obj: T): void;
    protected OnComponentWillUnmount(obj: T): void;
    GenerateAttributes(obj: T): void;
    abstract GenerateBody(obj: T): void;
    GenerateElementFinish(obj: T): void;
}

export interface ILabel extends IControl {
    HtmlFor: string;
    TextAlign: string;
}

export interface TwoColumnWithHeaderFooterLayoutParams {
    header: UIView[];
    left: UIView[];
    right: UIView[];
    footer: UIView[];
}
export function TwoColumnWithHeaderFooterLayout(params: TwoColumnWithHeaderFooterLayoutParams): UIView;

export interface TwoColumnWithHeaderLayoutParams {
    header: UIView[];
    left: UIView[];
    right: UIView[];
}
export function TwoColumnWithHeaderLayout(params: TwoColumnWithHeaderLayoutParams): UIView;

export interface TwoColumnLayoutParams {
    left: UIView[];
    right: UIView[];
}
export function TwoColumnLayout(params: TwoColumnLayoutParams): UIView;
export function TwoColumnLayout2(params: TwoColumnLayoutParams): UIView;

export class UISpinner extends UIView {
    setController(controller: UIController): this;
    constructor();
}
export function Spinner(): UISpinner;

export class UIStepsClass extends UIView {
    setController(controller: UIController): this;
    constructor();
}

export interface IUploadFileReady {
    GetFileContentAsString(): string;
    fileName: string;
    fileExt: string;
    fileAsByteArray: ByteArray;
    file: any;
}

export function UIFileUpload(...content: UIView[]): UIFileUploadClass;

export class UISkeletonClass extends UIView {
    setController(controller: UIController): this;
    constructor();
}

export class DropDownClass extends UIView {
    vp_model: any[];
    vp_itemTemplate: (option: any) => UIView | Function;
    vp_selectedItemTemplate: (option: any) => UIView | Function;
    vp_onSelected: Function;
    vp_value: any;
    vp_optionValue: string;
    vp_optionLabel: string;
    vp_PlaceHolder: string;
    setController(controller: UIController): this;
    constructor();
    itemTemplate(value: (option: any) => UIView | Function): this;
    selectedItemTemplate(value: (option: any) => UIView | Function): this;
    model(value: any[]): this;
    onSelected(value: Function): this;
    value(value: any): this;
    optionValue(value: string): this;
    optionLabel(value: string): this;
    placeholder(value: string): this;
}

export class AutoCompleteClass extends UIView {
    vp_model: any[];
    vp_itemTemplate: (option: any) => UIView | Function;
    vp_onSelected: Function;
    vp_items: any[];
    vp_PlaceHolder: string;
    vp_SearchMethod: Function;
    vp_Field: string;
    vp_Value: any;
    vp_OnChange: Function;
    setController(controller: UIController): this;
    constructor();
    itemTemplate(value: (option: any) => UIView | Function): this;
    model(value: any[]): this;
    onSelected(value: Function): this;
    items(value: any[]): this;
    placeholder(value: string): this;
    searchMethod(value: Function): this;
    field(value: string): this;
    value(value: any): this;
    onChange(value: Function): this;
}

export function DataTable(): DataTableClass;

export class ColumnClass {
    _field: string;
    _header: string;
    _width: string;
    _body: UIView;
    field(value: string): this;
    header(value: string): this;
    width(value: string): this;
    body(value: UIView): this;
}
export function Column(): ColumnClass;

export class OverlayPanelClass extends UIView {
    _show: boolean;
    vp_HeaderTemplate: UIView;
    setController(controller: UIController): this;
    constructor();
    show(value: boolean): this;
    headerTemplate(value: UIView): this;
}

export class AvatarViewClass extends UIView {
    setController(controller: UIController): this;
    constructor();
}

export class SlideMenuViewClass extends UIView {
    vp_ViewportHeight: int;
    viewportHeight(value: int): this;
    setController(controller: UIController): this;
    constructor();
}

export class TableColumnClass extends UIView {
    setHeaderView(value: UIView): this;
    setRowFunction(value: (dataRow: any) => UIView): this;
    headerWidth(value: string): this;
    setController(controller: UIController): this;
}
export interface HeaderParams {
}
export type FunctionHeader = (...views: UIView[]) => TableColumnClass;
export type FunctionRow = (rowFunction: (dataRow: any) => UIView) => TableColumnClass;
export function TableColumn(): TableColumnClass;
export function TableColumn(...views: (UIView | IControl | UIController)[]): FunctionRow;
export function TableColumn(value: HeaderParams): FunctionHeader;

export class BodyClass extends UIView {
    setController(controller: UIController): this;
}
export interface BodyParams {
}
export type FunctionBody = (...views: UIView[]) => BodyClass;
export function TBody(): BodyClass;
export function TBody(...views: (UIView | IControl | UIController)[]): BodyClass;
export function TBody(value: BodyParams): FunctionBody;

export class TableClass extends UIView {
    setController(controller: UIController): this;
    constructor();
    Controls: ControlCollection<any, any>;
    GetViews(): IRenderable[];
    value(value: any[]): this;
    headerAppearance(value: AppearanceClass): this;
    rowAppearance(value: AppearanceClass): this;
}
export function UITable(...columns: TableColumnClass[]): TableClass;

export class AccordionClass extends UIView {
    vp_headerTemplate: (option: any) => UIView | Function;
    vp_contentTemplate: (option: any) => UIView | Function;
    vp_items: any[];
    vp_ActiveIndex: int;
    setController(controller: UIController): this;
    constructor();
    headerTemplate(value: (option: any) => UIView | Function): this;
    contentTemplate(value: (option: any) => UIView | Function): this;
    items(value: any[]): this;
}

export class UIMediaPlayerClass extends UIView {
    url(value: string): this;
    previewImage(value: string): this;
    logo(value: string): this;
    playing(value: boolean): this;
    onProgress(value: Function): this;
    onEnded(value: Function): this;
    setController(controller: UIController): this;
    constructor();
}

export interface UIChartOptions {
        annotations?: TuvalAnnotations;
        chart?: TuvalChart;
        colors?: any[];
        dataLabels?: TuvalDataLabels;
        fill?: TuvalFill;
        forecastDataPoints?: TuvalForecastDataPoints;
        grid?: TuvalGrid;
        labels?: string[];
        legend?: TuvalLegend;
        markers?: TuvalMarkers;
        noData?: TuvalNoData;
        plotOptions?: TuvalPlotOptions;
        responsive?: TuvalResponsive[];
        series?: TuvalAxisChartSeries | TuvalNonAxisChartSeries;
        states?: TuvalStates;
        stroke?: TuvalStroke;
        subtitle?: TuvalTitleSubtitle;
        theme?: TuvalTheme;
        title?: TuvalTitleSubtitle;
        tooltip?: TuvalTooltip;
        xaxis?: TuvalXAxis;
        yaxis?: TuvalYAxis | TuvalYAxis[];
}
export type TuvalDropShadow = {
        enabled?: boolean;
        top?: number;
        left?: number;
        blur?: number;
        opacity?: number;
        color?: string;
};
export type TuvalChart = {
        width?: string | number;
        height?: string | number;
        type?: 'line' | 'area' | 'bar' | 'histogram' | 'pie' | 'donut' | 'radialBar' | 'scatter' | 'bubble' | 'heatmap' | 'candlestick' | 'boxPlot' | 'radar' | 'polarArea' | 'rangeBar' | 'treemap';
        foreColor?: string;
        fontFamily?: string;
        background?: string;
        offsetX?: number;
        offsetY?: number;
        dropShadow?: TuvalDropShadow & {
                enabledOnSeries?: undefined | number[];
                color?: string | string[];
        };
        events?: {
                animationEnd?(chart: any, options?: any): void;
                beforeMount?(chart: any, options?: any): void;
                mounted?(chart: any, options?: any): void;
                updated?(chart: any, options?: any): void;
                mouseMove?(e: any, chart?: any, options?: any): void;
                mouseLeave?(e: any, chart?: any, options?: any): void;
                click?(e: any, chart?: any, options?: any): void;
                legendClick?(chart: any, seriesIndex?: number, options?: any): void;
                markerClick?(e: any, chart?: any, options?: any): void;
                selection?(chart: any, options?: any): void;
                dataPointSelection?(e: any, chart?: any, options?: any): void;
                dataPointMouseEnter?(e: any, chart?: any, options?: any): void;
                dataPointMouseLeave?(e: any, chart?: any, options?: any): void;
                beforeZoom?(chart: any, options?: any): void;
                beforeResetZoom?(chart: any, options?: any): void;
                zoomed?(chart: any, options?: any): void;
                scrolled?(chart: any, options?: any): void;
                brushScrolled?(chart: any, options?: any): void;
        };
        brush?: {
                enabled?: boolean;
                autoScaleYaxis?: boolean;
                target?: string;
        };
        id?: string;
        group?: string;
        locales?: TuvalLocale[];
        defaultLocale?: string;
        parentHeightOffset?: number;
        redrawOnParentResize?: boolean;
        redrawOnWindowResize?: boolean | Function;
        sparkline?: {
                enabled?: boolean;
        };
        stacked?: boolean;
        stackType?: 'normal' | '100%';
        toolbar?: {
                show?: boolean;
                offsetX?: number;
                offsetY?: number;
                tools?: {
                        download?: boolean | string;
                        selection?: boolean | string;
                        zoom?: boolean | string;
                        zoomin?: boolean | string;
                        zoomout?: boolean | string;
                        pan?: boolean | string;
                        reset?: boolean | string;
                        customIcons?: {
                                icon?: string;
                                title?: string;
                                index?: number;
                                class?: string;
                                click?(chart?: any, options?: any, e?: any): any;
                        }[];
                };
                export?: {
                        csv?: {
                                filename?: undefined | string;
                                columnDelimiter?: string;
                                headerCategory?: string;
                                headerValue?: string;
                                dateFormatter?(timestamp?: number): any;
                        };
                        svg?: {
                                filename?: undefined | string;
                        };
                        png?: {
                                filename?: undefined | string;
                        };
                };
                autoSelected?: 'zoom' | 'selection' | 'pan';
        };
        zoom?: {
                enabled?: boolean;
                type?: 'x' | 'y' | 'xy';
                autoScaleYaxis?: boolean;
                zoomedArea?: {
                        fill?: {
                                color?: string;
                                opacity?: number;
                        };
                        stroke?: {
                                color?: string;
                                opacity?: number;
                                width?: number;
                        };
                };
        };
        selection?: {
                enabled?: boolean;
                type?: string;
                fill?: {
                        color?: string;
                        opacity?: number;
                };
                stroke?: {
                        width?: number;
                        color?: string;
                        opacity?: number;
                        dashArray?: number;
                };
                xaxis?: {
                        min?: number;
                        max?: number;
                };
                yaxis?: {
                        min?: number;
                        max?: number;
                };
        };
        animations?: {
                enabled?: boolean;
                easing?: 'linear' | 'easein' | 'easeout' | 'easeinout';
                speed?: number;
                animateGradually?: {
                        enabled?: boolean;
                        delay?: number;
                };
                dynamicAnimation?: {
                        enabled?: boolean;
                        speed?: number;
                };
        };
};
export type TuvalStates = {
        normal?: {
                filter?: {
                        type?: string;
                        value?: number;
                };
        };
        hover?: {
                filter?: {
                        type?: string;
                        value?: number;
                };
        };
        active?: {
                allowMultipleDataPointsSelection?: boolean;
                filter?: {
                        type?: string;
                        value?: number;
                };
        };
};
export type TuvalTitleSubtitle = {
        text?: string;
        align?: 'left' | 'center' | 'right';
        margin?: number;
        offsetX?: number;
        offsetY?: number;
        floating?: boolean;
        style?: {
                fontSize?: string;
                fontFamily?: string;
                fontWeight?: string | number;
                color?: string;
        };
};
export type TuvalAxisChartSeries = {
        name?: string;
        type?: string;
        color?: string;
        data: (number | null)[] | {
                x: any;
                y: any;
                fillColor?: string;
                strokeColor?: string;
                meta?: any;
                goals?: any;
        }[] | [number, number | null][] | [number, (number | null)[]][];
}[];
export type TuvalNonAxisChartSeries = number[];
type TuvalStroke = {
        show?: boolean;
        curve?: 'smooth' | 'straight' | 'stepline' | ('smooth' | 'straight' | 'stepline')[];
        lineCap?: 'butt' | 'square' | 'round';
        colors?: string[];
        width?: number | number[];
        dashArray?: number | number[];
        fill?: TuvalFill;
};
type TuvalAnnotations = {
        position?: string;
        yaxis?: YAxisAnnotations[];
        xaxis?: XAxisAnnotations[];
        points?: PointAnnotations[];
        texts?: TextAnnotations[];
        images?: ImageAnnotations[];
};
type AnnotationLabel = {
        borderColor?: string;
        borderWidth?: number;
        borderRadius?: number;
        text?: string;
        textAnchor?: string;
        offsetX?: number;
        offsetY?: number;
        style?: AnnotationStyle;
        position?: string;
        orientation?: string;
        mouseEnter?: Function;
        mouseLeave?: Function;
        click?: Function;
};
type AnnotationStyle = {
        background?: string;
        color?: string;
        fontFamily?: string;
        fontWeight?: string | number;
        fontSize?: string;
        cssClass?: string;
        padding?: {
                left?: number;
                right?: number;
                top?: number;
                bottom?: number;
        };
};
type XAxisAnnotations = {
        id?: number | string;
        x?: null | number | string;
        x2?: null | number | string;
        strokeDashArray?: number;
        fillColor?: string;
        borderColor?: string;
        borderWidth?: number;
        opacity?: number;
        offsetX?: number;
        offsetY?: number;
        label?: AnnotationLabel;
};
type YAxisAnnotations = {
        id?: number | string;
        y?: null | number | string;
        y2?: null | number | string;
        strokeDashArray?: number;
        fillColor?: string;
        borderColor?: string;
        borderWidth?: number;
        opacity?: number;
        offsetX?: number;
        offsetY?: number;
        width?: number | string;
        yAxisIndex?: number;
        label?: AnnotationLabel;
};
type PointAnnotations = {
        id?: number | string;
        x?: number | string;
        y?: null | number;
        yAxisIndex?: number;
        seriesIndex?: number;
        mouseEnter?: Function;
        mouseLeave?: Function;
        click?: Function;
        marker?: {
                size?: number;
                fillColor?: string;
                strokeColor?: string;
                strokeWidth?: number;
                shape?: string;
                offsetX?: number;
                offsetY?: number;
                radius?: number;
                cssClass?: string;
        };
        label?: AnnotationLabel;
        image?: {
                path?: string;
                width?: number;
                height?: number;
                offsetX?: number;
                offsetY?: number;
        };
};
type TextAnnotations = {
        x?: number;
        y?: number;
        text?: string;
        textAnchor?: string;
        foreColor?: string;
        fontSize?: string | number;
        fontFamily?: undefined | string;
        fontWeight?: string | number;
        backgroundColor?: string;
        borderColor?: string;
        borderRadius?: number;
        borderWidth?: number;
        paddingLeft?: number;
        paddingRight?: number;
        paddingTop?: number;
        paddingBottom?: number;
};
type ImageAnnotations = {
        path?: string;
        x?: number;
        y?: number;
        width?: number;
        height?: number;
};
/**
    * Options for localization.
    * See https://apexcharts.com/docs/options/chart/locales
    */
type TuvalLocale = {
        name?: string;
        options?: {
                months?: string[];
                shortMonths?: string[];
                days?: string[];
                shortDays?: string[];
                toolbar?: {
                        download?: string;
                        selection?: string;
                        selectionZoom?: string;
                        zoomIn?: string;
                        zoomOut?: string;
                        pan?: string;
                        reset?: string;
                        exportToSVG?: string;
                        exportToPNG?: string;
                        exportToCSV: string;
                };
        };
};
/**
    * PlotOptions for specifying chart-type-specific configuration.
    * See https://apexcharts.com/docs/options/plotoptions/bar/
    */
type TuvalPlotOptions = {
        area?: {
                fillTo?: 'origin' | 'end';
        };
        bar?: {
                horizontal?: boolean;
                columnWidth?: string;
                barHeight?: string;
                distributed?: boolean;
                borderRadius?: number | number[];
                rangeBarOverlap?: boolean;
                rangeBarGroupRows?: boolean;
                colors?: {
                        ranges?: {
                                from?: number;
                                to?: number;
                                color?: string;
                        }[];
                        backgroundBarColors?: string[];
                        backgroundBarOpacity?: number;
                        backgroundBarRadius?: number;
                };
                dataLabels?: {
                        maxItems?: number;
                        hideOverflowingLabels?: boolean;
                        position?: string;
                        orientation?: 'horizontal' | 'vertical';
                };
        };
        bubble?: {
                minBubbleRadius?: number;
                maxBubbleRadius?: number;
        };
        candlestick?: {
                colors?: {
                        upward?: string;
                        downward?: string;
                };
                wick?: {
                        useFillColor?: boolean;
                };
        };
        boxPlot?: {
                colors?: {
                        upper?: string;
                        lower?: string;
                };
        };
        heatmap?: {
                radius?: number;
                enableShades?: boolean;
                shadeIntensity?: number;
                reverseNegativeShade?: boolean;
                distributed?: boolean;
                useFillColorAsStroke?: boolean;
                colorScale?: {
                        ranges?: {
                                from?: number;
                                to?: number;
                                color?: string;
                                foreColor?: string;
                                name?: string;
                        }[];
                        inverse?: boolean;
                        min?: number;
                        max?: number;
                };
        };
        treemap?: {
                enableShades?: boolean;
                shadeIntensity?: number;
                distributed?: boolean;
                reverseNegativeShade?: boolean;
                useFillColorAsStroke?: boolean;
                colorScale?: {
                        inverse?: boolean;
                        ranges?: {
                                from?: number;
                                to?: number;
                                color?: string;
                                foreColor?: string;
                                name?: string;
                        }[];
                        min?: number;
                        max?: number;
                };
        };
        pie?: {
                startAngle?: number;
                endAngle?: number;
                customScale?: number;
                offsetX?: number;
                offsetY?: number;
                expandOnClick?: boolean;
                dataLabels?: {
                        offset?: number;
                        minAngleToShowLabel?: number;
                };
                donut?: {
                        size?: string;
                        background?: string;
                        labels?: {
                                show?: boolean;
                                name?: {
                                        show?: boolean;
                                        fontSize?: string;
                                        fontFamily?: string;
                                        fontWeight?: string | number;
                                        color?: string;
                                        offsetY?: number;
                                        formatter?(val: string): string;
                                };
                                value?: {
                                        show?: boolean;
                                        fontSize?: string;
                                        fontFamily?: string;
                                        fontWeight?: string | number;
                                        color?: string;
                                        offsetY?: number;
                                        formatter?(val: string): string;
                                };
                                total?: {
                                        show?: boolean;
                                        showAlways?: boolean;
                                        fontFamily?: string;
                                        fontWeight?: string | number;
                                        fontSize?: string;
                                        label?: string;
                                        color?: string;
                                        formatter?(w: any): string;
                                };
                        };
                };
        };
        polarArea?: {
                rings?: {
                        strokeWidth?: number;
                        strokeColor?: string;
                };
                spokes?: {
                        strokeWidth?: number;
                        connectorColors?: string | string[];
                };
        };
        radar?: {
                size?: number;
                offsetX?: number;
                offsetY?: number;
                polygons?: {
                        strokeColors?: string | string[];
                        strokeWidth?: string | string[];
                        connectorColors?: string | string[];
                        fill?: {
                                colors?: string[];
                        };
                };
        };
        radialBar?: {
                inverseOrder?: boolean;
                startAngle?: number;
                endAngle?: number;
                offsetX?: number;
                offsetY?: number;
                hollow?: {
                        margin?: number;
                        size?: string;
                        background?: string;
                        image?: string;
                        imageWidth?: number;
                        imageHeight?: number;
                        imageOffsetX?: number;
                        imageOffsetY?: number;
                        imageClipped?: boolean;
                        position?: 'front' | 'back';
                        dropShadow?: TuvalDropShadow;
                };
                track?: {
                        show?: boolean;
                        startAngle?: number;
                        endAngle?: number;
                        background?: string;
                        strokeWidth?: string;
                        opacity?: number;
                        margin?: number;
                        dropShadow?: TuvalDropShadow;
                };
                dataLabels?: {
                        show?: boolean;
                        name?: {
                                show?: boolean;
                                fontFamily?: string;
                                fontWeight?: string | number;
                                fontSize?: string;
                                color?: string;
                                offsetY?: number;
                        };
                        value?: {
                                show?: boolean;
                                fontFamily?: string;
                                fontSize?: string;
                                fontWeight?: string | number;
                                color?: string;
                                offsetY?: number;
                                formatter?(val: number): string;
                        };
                        total?: {
                                show?: boolean;
                                label?: string;
                                color?: string;
                                fontFamily?: string;
                                fontWeight?: string | number;
                                fontSize?: string;
                                formatter?(opts: any): string;
                        };
                };
        };
};
type TuvalFill = {
        colors?: any[];
        opacity?: number | number[];
        type?: string | string[];
        gradient?: {
                shade?: string;
                type?: string;
                shadeIntensity?: number;
                gradientToColors?: string[];
                inverseColors?: boolean;
                opacityFrom?: number | number[];
                opacityTo?: number | number[];
                stops?: number[];
                colorStops?: any[];
        };
        image?: {
                src?: string | string[];
                width?: number;
                height?: number;
        };
        pattern?: {
                style?: string | string[];
                width?: number;
                height?: number;
                strokeWidth?: number;
        };
};
/**
    * Chart Legend configuration options.
    * See https://apexcharts.com/docs/options/legend/
    */
type TuvalLegend = {
        show?: boolean;
        showForSingleSeries?: boolean;
        showForNullSeries?: boolean;
        showForZeroSeries?: boolean;
        floating?: boolean;
        inverseOrder?: boolean;
        position?: 'top' | 'right' | 'bottom' | 'left';
        horizontalAlign?: 'left' | 'center' | 'right';
        fontSize?: string;
        fontFamily?: string;
        fontWeight?: string | number;
        width?: number;
        height?: number;
        offsetX?: number;
        offsetY?: number;
        formatter?(legendName: string, opts?: any): string;
        tooltipHoverFormatter?(legendName: string, opts?: any): string;
        textAnchor?: string;
        customLegendItems?: string[];
        labels?: {
                colors?: string | string[];
                useSeriesColors?: boolean;
        };
        markers?: {
                width?: number;
                height?: number;
                strokeColor?: string;
                strokeWidth?: number;
                fillColors?: string[];
                offsetX?: number;
                offsetY?: number;
                radius?: number;
                customHTML?(): any;
                onClick?(): void;
        };
        itemMargin?: {
                horizontal?: number;
                vertical?: number;
        };
        containerMargin?: {
                left?: number;
                top?: number;
        };
        onItemClick?: {
                toggleDataSeries?: boolean;
        };
        onItemHover?: {
                highlightDataSeries?: boolean;
        };
};
type TuvalMarkerShape = "circle" | "square" | "rect" | string[];
type TuvalDiscretePoint = {
        seriesIndex?: number;
        dataPointIndex?: number;
        fillColor?: string;
        strokeColor?: string;
        size?: number;
        shape?: TuvalMarkerShape;
};
type TuvalMarkers = {
        size?: number | number[];
        colors?: string | string[];
        strokeColors?: string | string[];
        strokeWidth?: number | number[];
        strokeOpacity?: number | number[];
        strokeDashArray?: number | number[];
        fillOpacity?: number | number[];
        discrete?: TuvalDiscretePoint[];
        shape?: TuvalMarkerShape;
        width?: number | number[];
        height?: number | number[];
        radius?: number;
        offsetX?: number;
        offsetY?: number;
        showNullDataPoints?: boolean;
        onClick?(e?: any): void;
        onDblClick?(e?: any): void;
        hover?: {
                size?: number;
                sizeOffset?: number;
        };
};
type TuvalNoData = {
        text?: string;
        align?: 'left' | 'right' | 'center';
        verticalAlign?: 'top' | 'middle' | 'bottom';
        offsetX?: number;
        offsetY?: number;
        style?: {
                color?: string;
                fontSize?: string;
                fontFamily?: string;
        };
};
/**
    * Chart Datalabels options
    * See https://apexcharts.com/docs/options/datalabels/
    */
type TuvalDataLabels = {
        enabled?: boolean;
        enabledOnSeries?: undefined | number[];
        textAnchor?: 'start' | 'middle' | 'end';
        distributed?: boolean;
        offsetX?: number;
        offsetY?: number;
        style?: {
                fontSize?: string;
                fontFamily?: string;
                fontWeight?: string | number;
                colors?: any[];
        };
        background?: {
                enabled?: boolean;
                foreColor?: string;
                borderRadius?: number;
                padding?: number;
                opacity?: number;
                borderWidth?: number;
                borderColor?: string;
                dropShadow: TuvalDropShadow;
        };
        dropShadow?: TuvalDropShadow;
        formatter?(val: string | number | number[], opts?: any): string | number;
};
type TuvalResponsive = {
        breakpoint?: number;
        options?: any;
};
type TuvalTooltipY = {
        title?: {
                formatter?(seriesName: string): string;
        };
        formatter?(val: number, opts?: any): string;
};
/**
    * Chart Tooltip options
    * See https://apexcharts.com/docs/options/tooltip/
    */
type TuvalTooltip = {
        enabled?: boolean;
        enabledOnSeries?: undefined | number[];
        shared?: boolean;
        followCursor?: boolean;
        intersect?: boolean;
        inverseOrder?: boolean;
        custom?: ((options: any) => any) | ((options: any) => any)[];
        fillSeriesColor?: boolean;
        theme?: string;
        cssClass?: string;
        style?: {
                fontSize?: string;
                fontFamily?: string;
        };
        onDatasetHover?: {
                highlightDataSeries?: boolean;
        };
        x?: {
                show?: boolean;
                format?: string;
                formatter?(val: number, opts?: any): string;
        };
        y?: TuvalTooltipY | TuvalTooltipY[];
        z?: {
                title?: string;
                formatter?(val: number): string;
        };
        marker?: {
                show?: boolean;
                fillColors?: string[];
        };
        items?: {
                display?: string;
        };
        fixed?: {
                enabled?: boolean;
                position?: string;
                offsetX?: number;
                offsetY?: number;
        };
};
/**
    * X Axis options
    * See https://apexcharts.com/docs/options/xaxis/
    */
type TuvalXAxis = {
        type?: 'category' | 'datetime' | 'numeric';
        categories?: any;
        overwriteCategories?: number[] | string[] | undefined;
        offsetX?: number;
        offsetY?: number;
        sorted?: boolean;
        labels?: {
                show?: boolean;
                rotate?: number;
                rotateAlways?: boolean;
                hideOverlappingLabels?: boolean;
                showDuplicates?: boolean;
                trim?: boolean;
                minHeight?: number;
                maxHeight?: number;
                style?: {
                        colors?: string | string[];
                        fontSize?: string;
                        fontFamily?: string;
                        fontWeight?: string | number;
                        cssClass?: string;
                };
                offsetX?: number;
                offsetY?: number;
                format?: string;
                formatter?(value: string, timestamp?: number, opts?: any): string | string[];
                datetimeUTC?: boolean;
                datetimeFormatter?: {
                        year?: string;
                        month?: string;
                        day?: string;
                        hour?: string;
                        minute?: string;
                };
        };
        group?: {
                groups?: {
                        title: string;
                        cols: number;
                }[];
                style?: {
                        colors?: string | string[];
                        fontSize?: string;
                        fontFamily?: string;
                        fontWeight?: string | number;
                        cssClass?: string;
                };
        };
        axisBorder?: {
                show?: boolean;
                color?: string;
                offsetX?: number;
                offsetY?: number;
                strokeWidth?: number;
        };
        axisTicks?: {
                show?: boolean;
                borderType?: string;
                color?: string;
                height?: number;
                offsetX?: number;
                offsetY?: number;
        };
        tickPlacement?: string;
        tickAmount?: number | 'dataPoints';
        min?: number;
        max?: number;
        range?: number;
        floating?: boolean;
        decimalsInFloat?: number;
        position?: string;
        title?: {
                text?: string;
                offsetX?: number;
                offsetY?: number;
                style?: {
                        color?: string;
                        fontFamily?: string;
                        fontWeight?: string | number;
                        fontSize?: string;
                        cssClass?: string;
                };
        };
        crosshairs?: {
                show?: boolean;
                width?: number | string;
                position?: string;
                opacity?: number;
                stroke?: {
                        color?: string;
                        width?: number;
                        dashArray?: number;
                };
                fill?: {
                        type?: string;
                        color?: string;
                        gradient?: {
                                colorFrom?: string;
                                colorTo?: string;
                                stops?: number[];
                                opacityFrom?: number;
                                opacityTo?: number;
                        };
                };
                dropShadow?: TuvalDropShadow;
        };
        tooltip?: {
                enabled?: boolean;
                offsetY?: number;
                formatter?(value: string, opts?: object): string;
                style?: {
                        fontSize?: string;
                        fontFamily?: string;
                };
        };
};
/**
    * Y Axis options
    * See https://apexcharts.com/docs/options/yaxis/
    */
type TuvalYAxis = {
        show?: boolean;
        showAlways?: boolean;
        showForNullSeries?: boolean;
        seriesName?: string;
        opposite?: boolean;
        reversed?: boolean;
        logarithmic?: boolean;
        logBase?: number;
        tickAmount?: number;
        forceNiceScale?: boolean;
        min?: number | ((min: number) => number);
        max?: number | ((max: number) => number);
        floating?: boolean;
        decimalsInFloat?: number;
        labels?: {
                show?: boolean;
                minWidth?: number;
                maxWidth?: number;
                offsetX?: number;
                offsetY?: number;
                rotate?: number;
                align?: 'left' | 'center' | 'right';
                padding?: number;
                style?: {
                        colors?: string | string[];
                        fontSize?: string;
                        fontWeight?: string | number;
                        fontFamily?: string;
                        cssClass?: string;
                };
                formatter?(val: number, opts?: any): string | string[];
        };
        axisBorder?: {
                show?: boolean;
                color?: string;
                width?: number;
                offsetX?: number;
                offsetY?: number;
        };
        axisTicks?: {
                show?: boolean;
                color?: string;
                width?: number;
                offsetX?: number;
                offsetY?: number;
        };
        title?: {
                text?: string;
                rotate?: number;
                offsetX?: number;
                offsetY?: number;
                style?: {
                        color?: string;
                        fontSize?: string;
                        fontWeight?: string | number;
                        fontFamily?: string;
                        cssClass?: string;
                };
        };
        crosshairs?: {
                show?: boolean;
                position?: string;
                stroke?: {
                        color?: string;
                        width?: number;
                        dashArray?: number;
                };
        };
        tooltip?: {
                enabled?: boolean;
                offsetX?: number;
        };
};
type TuvalForecastDataPoints = {
        count?: number;
        fillOpacity?: number;
        strokeWidth?: undefined | number;
        dashArray: number;
};
/**
    * Plot X and Y grid options
    * See https://apexcharts.com/docs/options/grid/
    */
type TuvalGrid = {
        show?: boolean;
        borderColor?: string;
        strokeDashArray?: number;
        position?: 'front' | 'back';
        xaxis?: {
                lines?: {
                        show?: boolean;
                        offsetX?: number;
                        offsetY?: number;
                };
        };
        yaxis?: {
                lines?: {
                        show?: boolean;
                        offsetX?: number;
                        offsetY?: number;
                };
        };
        row?: {
                colors?: string[];
                opacity?: number;
        };
        column?: {
                colors?: string[];
                opacity?: number;
        };
        padding?: {
                top?: number;
                right?: number;
                bottom?: number;
                left?: number;
        };
};
type TuvalTheme = {
        mode?: 'light' | 'dark';
        palette?: string;
        monochrome?: {
                enabled?: boolean;
                color?: string;
                shadeTo?: 'light' | 'dark';
                shadeIntensity?: number;
        };
};
export {};

export function UIChart(): ChartClass;

export type TypographyFunc = (text: string) => TypographyClass;
export function Typography({ variant }: {
    variant: string;
}): TypographyFunc;

export type UIProgressBarTemplate = (value: int) => UIView;
export function UIProgressBar(viewTemplate: UIProgressBarTemplate): UIProgressBarClass;
export function UIProgressBar(): UIProgressBarClass;

export type ButtonTemplate = (...subViews: (UIView | IControl | UIController)[]) => ButtonView;
export function Button(props: IButtonProps): ButtonTemplate;
export function Button(...subViews: (UIView | IControl | UIController)[]): ButtonView;

export interface MemoryRouterProps {
        basename?: string;
        children?: any;
        initialEntries?: InitialEntry[];
        initialIndex?: number;
}
/**
    * A <Router> that stores all entries in memory.
    *
    * @see https://reactrouter.com/docs/en/v6/api#memoryrouter
    */
export function MemoryRouter({ basename, children, initialEntries, initialIndex, }: MemoryRouterProps): any;
export interface NavigateProps {
        to: To;
        replace?: boolean;
        state?: any;
}
/**
    * Changes the current location.
    *
    * Note: This API is mostly useful in React.Component subclasses that are not
    * able to use hooks. In functional components, we recommend you use the
    * `useNavigate` hook instead.
    *
    * @see https://reactrouter.com/docs/en/v6/api#navigate
    */
export function Navigate({ to, replace, state }: NavigateProps): null;
export interface OutletProps {
        context?: unknown;
}
/**
    * Renders the child route's element, if there is one.
    *
    * @see https://reactrouter.com/docs/en/v6/api#outlet
    */
export function Outlet(props: OutletProps): any | null;
export interface RouteProps {
        caseSensitive?: boolean;
        children?: any;
        element?: any | null;
        index?: boolean;
        path?: string;
}
export interface PathRouteProps {
        caseSensitive?: boolean;
        children?: any;
        element?: any | null;
        index?: false;
        path: string;
}
export interface LayoutRouteProps {
        children?: any;
        element?: any | null;
}
export interface IndexRouteProps {
        element?: any | null;
        index: true;
}
/**
    * Declares an element that should be rendered at a certain URL path.
    *
    * @see https://reactrouter.com/docs/en/v6/api#route
    */
export function Route(_props: PathRouteProps | LayoutRouteProps | IndexRouteProps): any | null;
export interface RouterProps {
        basename?: string;
        children?: any;
        location: Partial<Location> | string;
        navigationType?: NavigationType;
        navigator: Navigator;
        static?: boolean;
}
/**
    * Provides location context for the rest of the app.
    *
    * Note: You usually won't render a <Router> directly. Instead, you'll render a
    * router that is more specific to your environment such as a <BrowserRouter>
    * in web browsers or a <StaticRouter> for server rendering.
    *
    * @see https://reactrouter.com/docs/en/v6/api#router
    */
export function Router({ basename: basenameProp, children, location: locationProp, navigationType, navigator, static: staticProp, }: RouterProps): any | null;
export interface RoutesProps {
        children?: any;
        location?: Partial<Location> | string;
}
/**
    * A container for a nested tree of <Route> elements that renders the branch
    * that best matches the current location.
    *
    * @see https://reactrouter.com/docs/en/v6/api#routes
    */
export function Routes({ children, location, }: RoutesProps): any | null;
/**
    * Creates a route config from a React "children" object, which is usually
    * either a `<Route>` element or an array of them. Used internally by
    * `<Routes>` to create a route config from its children.
    *
    * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren
    */
export function createRoutesFromChildren(children: any): RouteObject[];
/**
    * Renders the result of `matchRoutes()` into a React element.
    */
export function renderMatches(matches: RouteMatch[] | null): null;

/**
  * A Navigator is a "location changer"; it's how you get to different locations.
  *
  * Every history instance conforms to the Navigator interface, but the
  * distinction is useful primarily when it comes to the low-level <Router> API
  * where both the location and a navigator must be provided separately in order
  * to avoid "tearing" that may occur in a suspense-enabled app if the action
  * and/or location were to be read directly from the history instance.
  */
export type Navigator = Pick<History, "go" | "push" | "replace" | "createHref">;
export const NavigationContext: {
    _id: any;
    _defaultValue: any;
    Consumer(props: any, contextValue: any): any;
    Provider(props: any): any;
};
export const LocationContext: {
    _id: any;
    _defaultValue: any;
    Consumer(props: any, contextValue: any): any;
    Provider(props: any): any;
};
export const RouteContext: {
    _id: any;
    _defaultValue: any;
    Consumer(props: any, contextValue: any): any;
    Provider(props: any): any;
};

/**
    * Returns the full href for the given "to" value. This is useful for building
    * custom links that are also accessible and preserve right-click behavior.
    *
    * @see https://reactrouter.com/docs/en/v6/api#usehref
    */
export function useHref(to: To): string;
/**
    * Returns true if this component is a descendant of a <Router>.
    *
    * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext
    */
export function useInRouterContext(): boolean;
/**
    * Returns the current location object, which represents the current URL in web
    * browsers.
    *
    * Note: If you're using this it may mean you're doing some of your own
    * "routing" in your app, and we'd like to know what your use case is. We may
    * be able to provide something higher-level to better suit your needs.
    *
    * @see https://reactrouter.com/docs/en/v6/api#uselocation
    */
export function useLocation(): Location;
/**
    * Returns the current navigation action which describes how the router came to
    * the current location, either by a pop, push, or replace on the history stack.
    *
    * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype
    */
export function useNavigationType(): NavigationType;
/**
    * Returns true if the URL for the given "to" value matches the current URL.
    * This is useful for components that need to know "active" state, e.g.
    * <NavLink>.
    *
    * @see https://reactrouter.com/docs/en/v6/api#usematch
    */
export function useMatch<ParamKey extends ParamParseKey<Path>, Path extends string>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null;
/**
    * The interface for the navigate() function returned from useNavigate().
    */
export interface NavigateFunction {
        (to: To, options?: NavigateOptions): void;
        (delta: number): void;
}
export interface NavigateOptions {
        replace?: boolean;
        state?: any;
}
/**
    * Returns an imperative method for changing the location. Used by <Link>s, but
    * may also be used by other elements to change the location.
    *
    * @see https://reactrouter.com/docs/en/v6/api#usenavigate
    */
export function useNavigate(): NavigateFunction;
/**
    * Returns the context (if provided) for the child route at this level of the route
    * hierarchy.
    * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext
    */
export function useOutletContext<Context = unknown>(): Context;
/**
    * Returns the element for the child route at this level of the route
    * hierarchy. Used internally by <Outlet> to render child routes.
    *
    * @see https://reactrouter.com/docs/en/v6/api#useoutlet
    */
export function useOutlet(context?: unknown): any;
/**
    * Returns an object of key/value pairs of the dynamic params from the current
    * URL that were matched by the route path.
    *
    * @see https://reactrouter.com/docs/en/v6/api#useparams
    */
export function useParams<ParamsOrKey extends string | Record<string, string | undefined> = string>(): Readonly<[
        ParamsOrKey
] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>>;
/**
    * Resolves the pathname of the given `to` value against the current location.
    *
    * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath
    */
export function useResolvedPath(to: To): Path;
/**
    * Returns the element of the route that matched the current location, prepared
    * with the correct context to render the remainder of the route tree. Route
    * elements in the tree must render an <Outlet> to render their child route's
    * element.
    *
    * @see https://reactrouter.com/docs/en/v6/api#useroutes
    */
export function useRoutes(routes: RouteObject[], locationArg?: Partial<Location> | string): any;
export function _renderMatches(matches: RouteMatch[] | null, parentMatches?: RouteMatch[]): any;

export function invariant(cond: any, message: string): asserts cond;
export function warning(cond: any, message: string): void;
export function warningOnce(key: string, cond: boolean, message: string): void;
type ParamParseFailed = {
        failed: true;
};
type ParamParseSegment<Segment extends string> = Segment extends `${infer LeftSegment}/${infer RightSegment}` ? ParamParseSegment<LeftSegment> extends infer LeftResult ? ParamParseSegment<RightSegment> extends infer RightResult ? LeftResult extends string ? RightResult extends string ? LeftResult | RightResult : LeftResult : RightResult extends string ? RightResult : ParamParseFailed : ParamParseFailed : ParamParseSegment<RightSegment> extends infer RightResult ? RightResult extends string ? RightResult : ParamParseFailed : ParamParseFailed : Segment extends `:${infer Remaining}` ? Remaining : ParamParseFailed;
export type ParamParseKey<Segment extends string> = ParamParseSegment<Segment> extends string ? ParamParseSegment<Segment> : string;
/**
    * The parameters that were parsed from the URL path.
    */
export type Params<Key extends string = string> = {
        readonly [key in Key]: string | undefined;
};
/**
    * A route object represents a logical route, with (optionally) its child
    * routes organized in a tree-like structure.
    */
export interface RouteObject {
        caseSensitive?: boolean;
        children?: RouteObject[];
        element?: any;
        index?: boolean;
        path?: string;
}
/**
    * Returns a path with params interpolated.
    *
    * @see https://reactrouter.com/docs/en/v6/api#generatepath
    */
export function generatePath(path: string, params?: Params): string;
/**
    * A RouteMatch contains info about how a route matched a URL.
    */
export interface RouteMatch<ParamKey extends string = string> {
        /**
            * The names and values of dynamic parameters in the URL.
            */
        params: Params<ParamKey>;
        /**
            * The portion of the URL pathname that was matched.
            */
        pathname: string;
        /**
            * The portion of the URL pathname that was matched before child routes.
            */
        pathnameBase: string;
        /**
            * The route object that was used to match.
            */
        route: RouteObject;
}
/**
    * Matches the given routes to a location and returns the match data.
    *
    * @see https://reactrouter.com/docs/en/v6/api#matchroutes
    */
export function matchRoutes(routes: RouteObject[], locationArg: Partial<Location> | string, basename?: string): RouteMatch[] | null;
/**
    * A PathPattern is used to match on some portion of a URL pathname.
    */
export interface PathPattern<Path extends string = string> {
        /**
            * A string to match against a URL pathname. May contain `:id`-style segments
            * to indicate placeholders for dynamic parameters. May also end with `/*` to
            * indicate matching the rest of the URL pathname.
            */
        path: Path;
        /**
            * Should be `true` if the static portions of the `path` should be matched in
            * the same case.
            */
        caseSensitive?: boolean;
        /**
            * Should be `true` if this pattern should match the entire URL pathname.
            */
        end?: boolean;
}
/**
    * A PathMatch contains info about how a PathPattern matched on a URL pathname.
    */
export interface PathMatch<ParamKey extends string = string> {
        /**
            * The names and values of dynamic parameters in the URL.
            */
        params: Params<ParamKey>;
        /**
            * The portion of the URL pathname that was matched.
            */
        pathname: string;
        /**
            * The portion of the URL pathname that was matched before child routes.
            */
        pathnameBase: string;
        /**
            * The pattern that was used to match.
            */
        pattern: PathPattern;
}
/**
    * Performs pattern matching on a URL pathname and returns information about
    * the match.
    *
    * @see https://reactrouter.com/docs/en/v6/api#matchpath
    */
export function matchPath<ParamKey extends ParamParseKey<Path>, Path extends string>(pattern: PathPattern<Path> | Path, pathname: string): PathMatch<ParamKey> | null;
/**
    * Returns a resolved path object relative to the given pathname.
    *
    * @see https://reactrouter.com/docs/en/v6/api#resolvepath
    */
export function resolvePath(to: To, fromPathname?: string): Path;
export function resolveTo(toArg: To, routePathnames: string[], locationPathname: string): Path;
export function getToPathname(to: To): string | undefined;
export function stripBasename(pathname: string, basename: string): string | null;
export const joinPaths: (paths: string[]) => string;
export const normalizePathname: (pathname: string) => string;
export {};

/**
    * Render a Preact virtual node into a DOM element
    * @param {import('./internal').ComponentChild} vnode The virtual node to render
    * @param {import('./internal').PreactElement} parentDom The DOM element to
    * render into
    * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an
    * existing DOM tree rooted at `replaceNode`
    */
export function render(vnode: any, parentDom: any, replaceNode?: any): void;
/**
    * Update an existing DOM element with data from a Preact virtual node
    * @param {import('./internal').ComponentChild} vnode The virtual node to render
    * @param {import('./internal').PreactElement} parentDom The DOM element to
    * update
    */
export function hydrate(vnode: any, parentDom: any): void;

/**
    * Create an virtual node (used for JSX)
    * @param {import('./internal').VNode["type"]} type The node name or Component
    * constructor for this virtual node
    * @param {object | null | undefined} [props] The properties of the virtual node
    * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node
    * @returns {import('./internal').VNode}
    */
export function createElement(type: any, props: any, children?: any): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
};
/**
    * Create a VNode (used internally by Preact)
    * @param {import('./internal').VNode["type"]} type The node name or Component
    * Constructor for this virtual node
    * @param {object | string | number | null} props The properties of this virtual node.
    * If this virtual node represents a text node, this is the text of the node (string or number).
    * @param {string | number | null} key The key for this virtual node, used when
    * diffing it against its children
    * @param {import('./internal').VNode["ref"]} ref The ref property that will
    * receive a reference to its created child
    * @returns {import('./internal').VNode}
    */
export function createVNode(type: any, props: any, key: any, ref: any, original: any): {
        type: any;
        props: any;
        key: any;
        ref: any;
        _children: any;
        _parent: any;
        _depth: number;
        _dom: any;
        _nextDom: any;
        _component: any;
        _hydrating: any;
        constructor: any;
        _original: any;
};
export function createRef(ref: any): any;
export function createRef(): any;
export function Fragment(props: any): any;
/**
    * Check if a the argument is a valid Preact VNode.
    * @param {*} vnode
    * @returns {vnode is import('./internal').VNode}
    */
export const isValidElement: (vnode: any) => boolean;

/**
    * Base Component class. Provides `setState()` and `forceUpdate()`, which
    * trigger rendering
    * @param {object} props The initial component props
    * @param {object} context The initial context from parent components'
    * getChildContext
    */
export class Component {
        props: any;
        context: any;
        state: any;
        _vnode: any;
        _force: boolean;
        _renderCallbacks: any[];
        isReactComponent: any;
        constructor(props?: any, context?: any);
        /**
    * Update component state and schedule a re-render.
    * @this {import('./internal').Component}
    * @param {object | ((s: object, p: object) => object)} update A hash of state
    * properties to update with new values or a function that given the current
    * state and props returns a new partial state
    * @param {() => void} [callback] A function to be called once component state is
    * updated
    */
        setState(update: any, callback?: any): void;
        /**
            * Immediately perform a synchronous re-render of the component
            * @this {import('./internal').Component}
            * @param {() => void} [callback] A function to be called after component is
            * re-rendered
            */
        forceUpdate(callback?: any): void;
        /**
            * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.
            * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).
            * @param {object} props Props (eg: JSX attributes) received from parent
            * element/component
            * @param {object} state The component's current state
            * @param {object} context Context object, as returned by the nearest
            * ancestor's `getChildContext()`
            * @returns {import('./index').ComponentChildren | void}
            */
        render(props: any): void;
}
/**
    * @param {import('./internal').VNode} vnode
    * @param {number | null} [childIndex]
    */
export function getDomSibling(vnode: any, childIndex?: any): any;
/**
    * Enqueue a rerender of a component
    * @param {import('./internal').Component} c The component to rerender
    */
export function enqueueRender(c: any): void;

/**
  * Clones the given VNode, optionally adding attributes/props and replacing its children.
  * @param {import('./internal').VNode} vnode The virtual DOM element to clone
  * @param {object} props Attributes/props to add when cloning
  * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.
  * @returns {import('./internal').VNode}
  */
export function cloneElement(vnode: any, props: any, children?: any): {
    type: any;
    props: any;
    key: any;
    ref: any;
    _children: any;
    _parent: any;
    _depth: number;
    _dom: any;
    _nextDom: any;
    _component: any;
    _hydrating: any;
    constructor: any;
    _original: any;
};

export let i: number;
export function createContext(defaultValue: any, contextId?: any): {
    _id: any;
    _defaultValue: any;
    /** @type {import('./internal').FunctionComponent} */
    Consumer(props: any, contextValue: any): any;
    /** @type {import('./internal').FunctionComponent} */
    Provider(props: any): any;
};

/**
    * Diff the children of a virtual node
    * @param {import('../internal').PreactElement} parentDom The DOM element whose
    * children are being diffed
    * @param {import('../internal').ComponentChildren[]} renderResult
    * @param {import('../internal').VNode} newParentVNode The new virtual
    * node whose children should be diff'ed against oldParentVNode
    * @param {import('../internal').VNode} oldParentVNode The old virtual
    * node whose children should be diff'ed against newParentVNode
    * @param {object} globalContext The current context object - modified by getChildContext
    * @param {boolean} isSvg Whether or not this DOM node is an SVG node
    * @param {Array<import('../internal').PreactElement>} excessDomChildren
    * @param {Array<import('../internal').Component>} commitQueue List of components
    * which have callbacks to invoke in commitRoot
    * @param {import('../internal').PreactElement} oldDom The current attached DOM
    * element any new dom elements should be placed around. Likely `null` on first
    * render (except when hydrating). Can be a sibling DOM element when diffing
    * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.
    * @param {boolean} isHydrating Whether or not we are in hydration
    */
export function diffChildren(parentDom: any, renderResult: any, newParentVNode: any, oldParentVNode: any, globalContext: any, isSvg: any, excessDomChildren: any, commitQueue: any, oldDom: any, isHydrating: any): void;
/**
    * Flatten and loop through the children of a virtual node
    * @param {import('../index').ComponentChildren} children The unflattened
    * children of a virtual node
    * @returns {import('../internal').VNode[]}
    */
export function toChildArray(children: any, out?: any): any;

/**
  * The `option` object can potentially contain callback functions
  * that are called during various stages of our renderer. This is the
  * foundation on which all our addons like `preact/debug`, `preact/compat`,
  * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`
  * for a full list of available option hooks (most editors/IDEs allow you to
  * ctrl+click or cmd+click on mac the type definition below).
  * @type {import('./internal').Options}
  */
const options: any;
export default options;

export enum MouseButtons {
    None = 0,
    Left = 1048576,
    Right = 2097152,
    Middle = 4194304,
    XButton1 = 8388608,
    XButton2 = 16777216
}

export class TextMultiComboBoxItem extends MultiComboBoxItem {
    constructor(text: string);
    constructor(key: string, text: string);
    GetItemTemplate(): any;
    ToObject(): any;
}

export class TreeNodeCollection extends List<TreeNode> {
    TreeView: TTreeView;
    constructor();
    Add(text: string): TreeNode;
    Add(key: int, text: string): TreeNode;
    Add(key: string, text: string): TreeNode;
    Add(treeNode: TreeNode): int;
    GetByKey(key: string): TreeNode;
    ToObject(): any[];
}

export class TreeViewCancelEventHandler extends Delegate<(sender: any, e: TreeViewCancelEventArgs) => void> {
}

export class TreeViewEventHandler extends Delegate<(sender: any, e: TreeViewEventArgs) => void> {
}

export enum TreeViewAction {
    Unknown = 0,
    ByKeyboard = 1,
    ByMouse = 2,
    Collapse = 3,
    Expand = 4
}

export class ColumnCollection extends List<GridColumn> {
    GridView: GridViewBase;
    constructor(gridview: GridViewBase);
    Add(header: string): GridColumn;
    Add(header: string, field: string): GridColumn;
    Add(treeNode: GridColumn): int;
    Clear(): int;
}

export class RibbonTabCollection extends List<RibbonTab> {
    RibbonMenu: RibbonMenu;
    constructor(ribbonMenu: RibbonMenu);
    Add(text: string): RibbonTab;
    Add(treeNode: RibbonTab): int;
    ToModel(): any[];
}

export class RibbonGroupCollection extends List<RibbonGroup> {
    constructor(ribbonMenu: RibbonMenu);
    Add(text: string): RibbonGroup;
    Add(treeNode: RibbonGroup): int;
}

export class ListViewItemCollection extends List<ListViewItem> {
    ListView: ListView;
    constructor(listView: ListView);
    Add(text: string, icon: string): ListViewItem;
    Add(treeNode: ListViewItem): int;
}

export class CardViewItemCollection extends List<CardViewItem> {
    ListView: CardView;
    constructor(listView: CardView);
    Add(text: string, icon: string): CardViewItem;
    Add(treeNode: CardViewItem): int;
    Clear(): int;
}

export class ListMenuItemCollection extends List<ListMenuItemBase> {
    ListView: ListMenu;
    constructor(listView: ListMenu);
    Add(text: string): ListMenuItem;
    Add(treeNode: ListMenuItemBase): int;
}

export class ListMenuRenderer extends ControlHtmlRenderer<ListMenu> {
    get UseShadowDom(): boolean;
    GenerateElement(obj: ListMenu): boolean;
    GenerateBody(obj: ListMenu): void;
    protected CreateItems(obj: ListMenu): any[];
    protected CreateControls(obj: ListMenu): any[];
}

export class RadioGroupItemCollection extends List<RadioButtonGroupItem> {
    RadioButtonGroup: RadioButtonGroup;
    constructor(comboBox: RadioButtonGroup);
    Add(text: string): RadioButtonGroupItem;
    Add(key: int, text: string): RadioButtonGroupItem;
    Add(key: string, text: string): RadioButtonGroupItem;
    Add(treeNode: RadioButtonGroupItem): int;
    Clear(): int;
    ToObject(): any[];
}

export interface IFontIcon extends IControl {
    FontFamily: string;
    Size: int;
    Color: CGColor;
}

export declare abstract class XmlTransformer<T extends any> extends React.Component {
    constructor(props: any);
    WriteStartElement(name: string): void;
    WriteStartFragment(): void;
    WriteEndElement(): void;
    WriteAttrVal(name: string, val: any): string;
    WriteStyleAttrVal(name: string, val: any): string;
    WriteTextBody(text: string): void;
    WriteControl(control: Control<any>): void;
    WriteComponent(text: any): void;
    InvalidateCache(): void;
    abstract DecideCache(obj: T): void;
    abstract GenerateElement(obj: T): boolean;
    abstract GenerateAttributes(obj: T): void;
    abstract GenerateBody(obj: T): void;
    abstract GenerateElementFinish(obj: T): void;
    Render(result: any[], obj: T): any;
}

export class DropdownComponent extends React.Component {
    static defaultProps: {
        id: any;
        inputRef: any;
        name: any;
        value: any;
        options: any;
        optionLabel: any;
        optionValue: any;
        optionDisabled: any;
        optionGroupLabel: any;
        optionGroupChildren: any;
        optionGroupTemplate: any;
        valueTemplate: any;
        itemTemplate: any;
        style: any;
        className: any;
        virtualScrollerOptions: any;
        scrollHeight: string;
        filter: boolean;
        filterBy: any;
        filterMatchMode: string;
        filterPlaceholder: any;
        filterLocale: any;
        emptyMessage: any;
        emptyFilterMessage: any;
        editable: boolean;
        placeholder: any;
        required: boolean;
        disabled: boolean;
        appendTo: any;
        tabIndex: any;
        autoFocus: boolean;
        filterInputAutoFocus: boolean;
        resetFilterOnHide: boolean;
        showFilterClear: boolean;
        panelClassName: any;
        panelStyle: any;
        dataKey: any;
        inputId: any;
        showClear: boolean;
        maxLength: any;
        tooltip: any;
        tooltipOptions: any;
        ariaLabel: any;
        ariaLabelledBy: any;
        transitionOptions: any;
        dropdownIcon: string;
        showOnFocus: boolean;
        onChange: any;
        onFocus: any;
        onBlur: any;
        onMouseDown: any;
        onContextMenu: any;
        onShow: any;
        onHide: any;
        onFilter: any;
    };
    overlayRef: any;
    inputRef: any;
    focusInput: any;
    container: any;
    searchTimeout: any;
    currentSearchChar: any;
    previousSearchChar: any;
    searchValue: any;
    selectedOptionUpdated: boolean;
    input: any;
    documentClickListener: any;
    scrollHandler: any;
    resizeListener: any;
    tooltip: any;
    hideTimeout: any;
    trigger: any;
    constructor(props: any);
    onClick(event: any): void;
    onInputFocus(event: any): void;
    onInputBlur(event: any): void;
    onPanelClick(event: any): void;
    onInputKeyDown(event: any): void;
    onFilterInputKeyDown(event: any): void;
    onUpKey(event: any): void;
    onDownKey(event: any): void;
    findNextOption(index: any): any;
    findNextOptionInList(list: any, index?: any): any;
    findPrevOption(index: any): any;
    findPrevOptionInList(list: any, index: any): any;
    search(event: any): void;
    searchOption(index: any): any;
    searchOptionInRange(start: any, end: any): any;
    searchOptionInGroup(index: any): any;
    matchesSearchValue(option: any): any;
    onEditableInputChange(event: any): void;
    onEditableInputFocus(event: any): void;
    onOptionClick(event: any): void;
    onFilterInputChange(event: any): void;
    onFilterClearIconClick(callback: any): void;
    resetFilter(callback?: any): void;
    clear(event: any): void;
    selectItem(event: any): void;
    getSelectedOption(): any;
    getSelectedOptionIndex(): number | {
        group: number;
        option: number;
    };
    findOptionIndexInList(value: any, list: any): number;
    isSelected(option: any): boolean;
    equalityKey(): any;
    showOverlay(): void;
    hideOverlay(): void;
    onOverlayEnter(callback: any): void;
    onOverlayEntered(callback: any): void;
    onOverlayExit(): void;
    onOverlayExited(): void;
    alignOverlay(): void;
    scrollInView(): void;
    bindDocumentClickListener(): void;
    unbindDocumentClickListener(): void;
    bindScrollListener(): void;
    unbindScrollListener(): void;
    bindResizeListener(): void;
    unbindResizeListener(): void;
    isOutsideClicked(event: any): boolean;
    isClearClicked(event: any): any;
    updateEditableLabel(option?: any): void;
    hasFilter(): boolean;
    getOptionLabel(option: any): any;
    getOptionValue(option: any): any;
    getOptionRenderKey(option: any): any;
    isOptionDisabled(option: any): any;
    getOptionGroupRenderKey(optionGroup: any): any;
    getOptionGroupLabel(optionGroup: any): any;
    getOptionGroupChildren(optionGroup: any): any;
    checkValidity(): any;
    isLazy(): any;
    getVisibleOptions(): any;
    updateInputField(): void;
    updateInputRef(): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    componentDidUpdate(prevProps: any): void;
    renderHiddenSelect(selectedOption: any): any;
    renderTooltip(): void;
    renderKeyboardHelper(): any;
    renderLabel(selectedOption: any): any;
    renderClearIcon(): any;
    renderDropdownIcon(): any;
    render(): any;
}

export const DropdownPanel: {
    (props: any, ref: any): any;
    $$typeof: number | symbol;
    render: any;
    _forwarded: boolean;
    displayName: string;
};

export class DropdownItem extends React.Component {
    static defaultProps: {
        option: any;
        label: any;
        template: any;
        selected: boolean;
        disabled: boolean;
        onClick: any;
    };
    constructor(props: any);
    onClick(event: any): void;
    render(): any;
}

export class InputText extends React.Component {
    static defaultProps: {
        keyfilter: any;
        validateOnly: boolean;
        tooltip: any;
        tooltipOptions: any;
        onInput: any;
        onKeyPress: any;
        forwardRef: any;
    };
    elementRef: any;
    tooltip: any;
    constructor(props: any);
    isFilled(): boolean;
    onKeyPress(event: any): void;
    onInput(event: any): void;
    updateForwardRef(): void;
    componentDidMount(): void;
    componentDidUpdate(prevProps: any): void;
    componentWillUnmount(): void;
    renderTooltip(): void;
    render(): any;
}
export const TuInputElement: any;

export class PanelComponent extends React.Component {
    static defaultProps: {
        id: any;
        header: any;
        headerTemplate: any;
        toggleable: any;
        style: any;
        contentStyle: any;
        className: any;
        collapsed: any;
        expandIcon: string;
        collapseIcon: string;
        icons: any;
        transitionOptions: any;
        onExpand: any;
        onCollapse: any;
        onToggle: any;
    };
    contentRef: any;
    constructor(props: any);
    toggle(event: any): void;
    expand(event: any): void;
    collapse(event: any): void;
    isCollapsed(): any;
    componentDidMount(): void;
    renderToggleIcon(collapsed: any): any;
    renderHeader(collapsed: any): any;
    renderContent(collapsed: any): any;
    render(): any;
}

export function hasClass(element: Element | SVGElement, className: string): boolean;
export function addOneClass(element: Element | SVGElement, className: string): void;
/**
  * Removes a CSS class from a given element.
  *
  * @param element the element
  * @param className the CSS class name
  */
export function removeOneClass(element: Element | SVGElement, className: string): void;
export const addClass: (node: any, classes: any) => any;
export const removeClass: (node: any, classes: any) => any;
export class CSSTransition extends React.Component {
    constructor(props: any);
    onEnter(node: any, isAppearing: any): void;
    onEntering(node: any, isAppearing: any): void;
    onEntered(node: any, isAppearing: any): void;
    onExit(node: any): void;
    onExiting(node: any): void;
    onExited(node: any): void;
    static getTeactInstance(props: any): CSSTransition;
    render(): any;
}

export class TabPanel extends React.Component {
    static defaultProps: {
        showHeader: boolean;
        header: any;
        headerTemplate: any;
        leftIcon: any;
        rightIcon: any;
        disabled: boolean;
        headerStyle: any;
        headerClassName: any;
        contentStyle: any;
        contentClassName: any;
    };
}
export class TabView extends React.Component {
    static defaultProps: {
        id: any;
        activeIndex: number;
        style: any;
        className: any;
        renderActiveOnly: boolean;
        closable: boolean;
        onTabChange: any;
    };
    inkbar: any;
    nav: any;
    constructor(props: any);
    getActiveIndex(): any;
    isSelected(index: any): boolean;
    onTabHeaderClick(event: any, tab: any, index: any): void;
    onCloseClick(event: any, index: any): void;
    updateInkBar(): void;
    componentDidMount(): void;
    componentDidUpdate(): void;
    renderTabHeader(tab: any, index: any): any;
    renderTabHeaders(): any;
    renderNavigator(): any;
    renderContent(): any;
    createContent(tab: any, index: any): any;
    render(): any;
}

export class BlockUI extends React.Component {
    static defaultProps: {
        id: any;
        blocked: boolean;
        fullScreen: boolean;
        baseZIndex: number;
        autoZIndex: boolean;
        style: any;
        className: any;
        template: any;
        onBlocked: any;
        onUnblocked: any;
    };
    mask: any;
    container: any;
    constructor(props: any);
    block(): void;
    unblock(): void;
    onPortalMounted(): void;
    renderMask(): any;
    componentDidMount(): void;
    componentDidUpdate(prevProps: any, prevState: any): void;
    componentWillUnmount(): void;
    render(): any;
}

export abstract class HtmlRenderer<T extends IControl> extends XmlTransformer<T> {
    protected Ref: any;
    protected contextMenu: any;
    constructor(props: any);
    protected InitializeRenderer(obj: T): void;
    TranslateAlpha(c: CGColor): float;
    TranslateColor(c: CGColor): string;
    TranslateGraphicsPath(path: GraphicsPath): string;
    WriteBrushAttributes(brush: Brush): void;
    WriteEllipse(p: Pen, b: Brush, r: CGRectangle): void;
    WriteLine(p: Pen, a: CGPoint, b: CGPoint): void;
    WriteLines(p: Pen, v: CGPoint[]): void;
    WritePath(p: Pen, b: Brush, pathdesc: string): void;
    WritePenAttributes(pen: Pen): void;
    WritePolygon(p: Pen, b: Brush, poly: CGPoint[]): void;
    WriteRectangle(p: Pen, b: Brush, r: CGRectangle, corner: CGSize): void;
    protected OnShadowDomWillMount(ref: any, obj: T): void;
    protected OnShadowDomDidMount(ref: any, obj: T): void;
    protected OnShadowDomWillUnmount(ref: any, obj: T): void;
    protected OnComponentWillMount(ref: any, obj: T): void;
    protected OnComponentDidMount(ref: any, obj: T): void;
    protected OnComponentWillReceiveProps(obj: T): void;
    protected OnShouldComponentUpdate(obj: T): boolean;
    protected OnComponentWillUpdate(obj: T): void;
    protected OnComponentDidUpdate(obj: T): void;
    protected OnComponentWillUnmount(obj: T): void;
    protected GetStyleObject(): any;
    get UseShadowDom(): boolean;
    OnStyleCreating(obj: T, sb: StringBuilder): void;
    OnCustomAttributesCreating(obj: T, attributeObject: any): void;
    GetCustomJss(): Object;
    render(param?: any): any;
}

export class UIFileUploadClass extends UIView {
    FileReady: (value: IUploadFileReady) => void;
    vp_AllowedExtensions: string;
    setController(controller: UIController): this;
    constructor();
    onFileReady(value: (param: IUploadFileReady) => void): this;
    allowedExtensions(value: string): this;
}

export class DataTableClass extends UIView {
    _value: any[];
    _columns: ColumnClass[];
    setController(controller: UIController): this;
    constructor();
    value(value: any): this;
    columns(...value: ColumnClass[]): this;
}

export class ChartClass extends UIView {
    vp_Series: TuvalAxisChartSeries | TuvalNonAxisChartSeries;
    series(value: TuvalAxisChartSeries | TuvalNonAxisChartSeries): this;
    vp_Options: UIChartOptions;
    options(value: UIChartOptions): this;
    setController(controller: UIController): this;
    constructor();
}

export class TypographyClass extends UIView implements ILabel {
    text(value: string): this;
    setController(controller: UIController): this;
    constructor();
}

export class UIProgressBarClass extends UIView implements ILabel {
    value(value: int): this;
    labelOffset(value: int): this;
    valueTemplate(value: (option: any) => UIView | Function): this;
    setController(controller: UIController): this;
    constructor();
}

export type VariantType = 'contained' | 'text';
export type ColorType = 'primary' | 'secondary' | 'danger';
export interface IButtonProps {
    variant?: VariantType;
    color?: ColorType;
}
export class ButtonView extends UIView implements ILabel {
    loading(value: boolean): this;
    variant(value: VariantType): this;
    color(value: ColorType): this;
    setController(controller: UIController): this;
    constructor();
}

export class RibbonGroup {
    Text: string;
    Items: RibbonItemCollection;
    ToModel(): any;
}

export abstract class XmlTransformer<T extends any> extends React.Component {
    constructor(props: any);
    WriteStartElement(name: string): void;
    WriteStartFragment(): void;
    WriteEndElement(): void;
    WriteAttrVal(name: string, val: any): string;
    WriteStyleAttrVal(name: string, val: any): string;
    WriteTextBody(text: string): void;
    WriteControl(control: Control<any>): void;
    WriteComponent(text: any): void;
    InvalidateCache(): void;
    abstract DecideCache(obj: T): void;
    abstract GenerateElement(obj: T): boolean;
    abstract GenerateAttributes(obj: T): void;
    abstract GenerateBody(obj: T): void;
    abstract GenerateElementFinish(obj: T): void;
    Render(result: any[], obj: T): any;
}

export interface ILabel {
}

export class RibbonItemCollection extends List<RibbonItem> {
    constructor(ribbonMenu: RibbonMenu);
    AddButton(text: string, icon: string): RibbonButton;
}

export abstract class RibbonItem {
    protected abstract Get_RibbonItemType(): RibbonItemTypes;
    get Type(): RibbonItemTypes;
    Text: string;
    Icon: string;
    OnClick: Event<EventHandler>;
    abstract ToModel(): any;
}
export class RibbonButton extends RibbonItem {
    protected Get_RibbonItemType(): RibbonItemTypes;
    ToModel(): {
        type: string;
        text: string;
        icon: string;
        onClick: Event<EventHandler>;
    };
}

export enum RibbonItemTypes {
    RibbonButton = 0,
    RibbonGroupDivider = 1,
    RibbonFlexLayout = 2,
    RibbonIconButton = 3,
    RibbonToolButton = 4,
    RibbonSplitButton = 5
}

