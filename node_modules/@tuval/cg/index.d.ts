// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../@tuval/core

import { int } from '@tuval/core';
import { float, byte, IEquatable } from '@tuval/core';
import { SimpleDictionary } from "@tuval/core";
import { IEquatable } from '@tuval/core';
import { float } from '@tuval/core';
import { float, IEquatable } from "@tuval/core";
import { int } from "@tuval/core";
import { float, IEquatable } from '@tuval/core';
import { float, ByteArray } from "@tuval/core";
import { DisposableBase } from '@tuval/core';
import { float } from "@tuval/core";
import { EventSimple, ByteArray } from '@tuval/core';
import { IDisposable, float } from "@tuval/core";
import { ByteArray, float } from "@tuval/core";
import { UMO } from "@tuval/core";

import './exports';

/**
  * Work around for https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8438884/
  * @ignore
  */
export function supportsSvgPathArgument(window: any): boolean;
export class CGPath {
    constructor(path: string | CGPath);
    addPath(path: CGPath): void;
    moveTo(x: int, y: int): void;
    lineTo(x: int, y: int): void;
    arc(x: int, y: int, r: int, start: int, end: int, ccw: int): void;
    arcTo(x1: int, y1: int, x2: int, y2: int, r: int): void;
    ellipse(x: int, y: int, rx: int, ry: int, angle: int, start: int, end: int, ccw: int): void;
    losePath(): void;
    bezierCurveTo(cp1x: int, cp1y: int, cp2x: int, cp2y: int, x: int, y: int): void;
    quadraticCurveTo(cpx: int, cpy: int, x: int, y: int): void;
    rect(x: int, y: int, width: int, height: int): void;
    abs(): CGPath;
    normalize(): CGPath;
    bounds(): number[];
    pilotPath(canvas: CanvasRenderingContext2D): void;
}

export class CGColor implements IEquatable<CGColor> {
    get Levels(): number[];
    constructor(gray: number, alpha?: number);
    constructor(v1: number, v2: number, v3: number, alpha?: number);
    constructor(namedColor: string);
    constructor(rgba: number[]);
    static FromSketchColor(value: byte): any;
    static FromSketchColor(value: string): any;
    static FromSketchColor(values: Array<byte>): any;
    static FromSketchColor(gray: byte, alpha: byte): any;
    static FromSketchColor(v1: byte, v2: byte, v3: byte): any;
    static FromSketchColor(v1: byte, v2: byte, v3: byte, alpha: byte): any;
    static FromRgba(color: number): CGColor;
    static FromRgba(red: number, green: number, blue: number): CGColor;
    static FromRgba(red: number, green: number, blue: number, alpha: number): CGColor;
    static FromRgba(color: CGColor, alpha: number): CGColor;
    static FromHSBA(hue: float, saturation: float, brightness: float, alpha?: float): CGColor;
    static FromHSLA(hue: float, saturation: float, lightness: float, alpha?: float): CGColor;
    toRgba(): number[];
    toInt(): number;
    clone(): CGColor;
    static FromKnownColor(color: KnownColor): CGColor;
    static FromName(name: string): CGColor;
    static get Empty(): CGColor;
    static GetRGBAString(obj: {
        red: number;
        green: number;
        blue: number;
        alpha: number;
    }): string;
    static RgbToHex(r: number, g: number, b: number): string;
    static RgbaToHex(r: number, g: number, b: number, a: number): string;
    static HexToRgb(hex: string): {
        r: number;
        g: number;
        b: number;
    };
    static GetRandomColor(): string;
    static ColorToRGBA(str: string): {
        r: number;
        g: number;
        b: number;
        a: number;
    };
    static NamedColorToRBA(str: string): {
        r: number;
        g: number;
        b: number;
        a: number;
    };
    static RgbColorToRGBA(str: string): {
        r: number;
        g: number;
        b: number;
        a: number;
    };
    static RgbaColorToRGBA(str: string): {
        r: number;
        g: number;
        b: number;
        a: number;
    };
    static Hex6ColorToRGBA(str: string): {
        r: number;
        g: number;
        b: number;
        a: number;
    };
    static Hex3ColorToRGBA(str: string): {
        r: number;
        g: number;
        b: number;
        a: number;
    };
    getBrightness(): float;
    getSaturation(): float;
    getHue(): float;
    getLightness(): number;
    ToKnownColor(): KnownColor;
    get IsEmpty(): boolean;
    get A(): byte;
    set A(value: byte);
    /**
      * Returns the alpha component value in a Color structure.
      */
    get R(): byte;
    set R(value: byte);
    get G(): byte;
    set G(value: byte);
    get B(): byte;
    set B(value: byte);
    Equals: (color: CGColor) => boolean;
    notEquals: (color: CGColor) => boolean;
    static get Transparent(): CGColor;
    static get AliceBlue(): CGColor;
    static get AntiqueWhite(): CGColor;
    static get Aqua(): CGColor;
    static get Aquamarine(): CGColor;
    static get Azure(): CGColor;
    static get Beige(): CGColor;
    static get Bisque(): CGColor;
    static get Black(): CGColor;
    static get BlanchedAlmond(): CGColor;
    static get Blue(): CGColor;
    static get BlueViolet(): CGColor;
    static get Brown(): CGColor;
    static get BurlyWood(): CGColor;
    static get CadetBlue(): CGColor;
    static get Chartreuse(): CGColor;
    static get Chocolate(): CGColor;
    static get Coral(): CGColor;
    static get CornflowerBlue(): CGColor;
    static get Cornsilk(): CGColor;
    static get Crimson(): CGColor;
    static get Cyan(): CGColor;
    static get DarkBlue(): CGColor;
    static get DarkCyan(): CGColor;
    static get DarkGoldenrod(): CGColor;
    static get DarkGray(): CGColor;
    static get DarkGreen(): CGColor;
    static get DarkKhaki(): CGColor;
    static get DarkMagenta(): CGColor;
    static get DarkOliveGreen(): CGColor;
    static get DarkOrange(): CGColor;
    static get DarkOrchid(): CGColor;
    static get DarkRed(): CGColor;
    static get DarkSalmon(): CGColor;
    static get DarkSeaGreen(): CGColor;
    static get DarkSlateBlue(): CGColor;
    static get DarkSlateGray(): CGColor;
    static get DarkTurquoise(): CGColor;
    static get DarkViolet(): CGColor;
    static get DeepPink(): CGColor;
    static get DeepSkyBlue(): CGColor;
    static get DimGray(): CGColor;
    static get DodgerBlue(): CGColor;
    static get Firebrick(): CGColor;
    static get FloralWhite(): CGColor;
    static get ForestGreen(): CGColor;
    static get Fuchsia(): CGColor;
    static get Gainsboro(): CGColor;
    static get GhostWhite(): CGColor;
    static get Gold(): CGColor;
    static get Goldenrod(): CGColor;
    static get Gray(): CGColor;
    static get Green(): CGColor;
    static get GreenYellow(): CGColor;
    static get Honeydew(): CGColor;
    static get HotPink(): CGColor;
    static get IndianRed(): CGColor;
    static get Indigo(): CGColor;
    static get Ivory(): CGColor;
    static get Khaki(): CGColor;
    static get Lavender(): CGColor;
    static get LavenderBlush(): CGColor;
    static get LawnGreen(): CGColor;
    static get LemonChiffon(): CGColor;
    static get LightBlue(): CGColor;
    static get LightCoral(): CGColor;
    static get LightCyan(): CGColor;
    static get LightGoldenrodYellow(): CGColor;
    static get LightGreen(): CGColor;
    static get LightGray(): CGColor;
    static get LightPink(): CGColor;
    static get LightSalmon(): CGColor;
    static get LightSeaGreen(): CGColor;
    static get LightSkyBlue(): CGColor;
    static get LightSlateGray(): CGColor;
    static get LightSteelBlue(): CGColor;
    static get LightYellow(): CGColor;
    static get Lime(): CGColor;
    static get LimeGreen(): CGColor;
    static get Linen(): CGColor;
    static get Magenta(): CGColor;
    static get Maroon(): CGColor;
    static get MediumAquamarine(): CGColor;
    static get MediumBlue(): CGColor;
    static get MediumOrchid(): CGColor;
    static get MediumPurple(): CGColor;
    static get MediumSeaGreen(): CGColor;
    static get MediumSlateBlue(): CGColor;
    static get MediumSpringGreen(): CGColor;
    static get MediumTurquoise(): CGColor;
    static get MediumVioletRed(): CGColor;
    static get MidnightBlue(): CGColor;
    static get MintCream(): CGColor;
    static get MistyRose(): CGColor;
    static get Moccasin(): CGColor;
    static get NavajoWhite(): CGColor;
    static get Navy(): CGColor;
    static get OldLace(): CGColor;
    static get Olive(): CGColor;
    static get OliveDrab(): CGColor;
    static get Orange(): CGColor;
    static get OrangeRed(): CGColor;
    static get Orchid(): CGColor;
    static get PaleGoldenrod(): CGColor;
    static get PaleGreen(): CGColor;
    static get PaleTurquoise(): CGColor;
    static get PaleVioletRed(): CGColor;
    static get PapayaWhip(): CGColor;
    static get PeachPuff(): CGColor;
    static get Peru(): CGColor;
    static get Pink(): CGColor;
    static get Plum(): CGColor;
    static get PowderBlue(): CGColor;
    static get Purple(): CGColor;
    static get Red(): CGColor;
    static get RosyBrown(): CGColor;
    static get RoyalBlue(): CGColor;
    static get SaddleBrown(): CGColor;
    static get Salmon(): CGColor;
    static get SandyBrown(): CGColor;
    static get SeaGreen(): CGColor;
    static get SeaShell(): CGColor;
    static get Sienna(): CGColor;
    static get Silver(): CGColor;
    static get SkyBlue(): CGColor;
    static get SlateBlue(): CGColor;
    static get SlateGray(): CGColor;
    static get Snow(): CGColor;
    static get SpringGreen(): CGColor;
    static get SteelBlue(): CGColor;
    static get Tan(): CGColor;
    static get Teal(): CGColor;
    static get Thistle(): CGColor;
    static get Tomato(): CGColor;
    static get Turquoise(): CGColor;
    static get Violet(): CGColor;
    static get Wheat(): CGColor;
    static get White(): CGColor;
    static get WhiteSmoke(): CGColor;
    static get Yellow(): CGColor;
    static get YellowGreen(): CGColor;
    getHashCode(): number;
    toString(format?: string): string;
    static Lerp(c1: CGColor, c2: CGColor, amt: float): CGColor;
}

export enum KnownColor {
    ActiveBorder = 1,
    ActiveCaption = 2,
    ActiveCaptionText = 3,
    AppWorkspace = 4,
    Control = 5,
    ControlDark = 6,
    ControlDarkDark = 7,
    ControlLight = 8,
    ControlLightLight = 9,
    ControlText = 10,
    Desktop = 11,
    GrayText = 12,
    Highlight = 13,
    HighlightText = 14,
    HotTrack = 15,
    InactiveBorder = 16,
    InactiveCaption = 17,
    InactiveCaptionText = 18,
    Info = 19,
    InfoText = 20,
    Menu = 21,
    MenuText = 22,
    ScrollBar = 23,
    Window = 24,
    WindowFrame = 25,
    WindowText = 26,
    Transparent = 27,
    AliceBlue = 28,
    AntiqueWhite = 29,
    Aqua = 30,
    Aquamarine = 31,
    Azure = 32,
    Beige = 33,
    Bisque = 34,
    Black = 35,
    BlanchedAlmond = 36,
    Blue = 37,
    BlueViolet = 38,
    Brown = 39,
    BurlyWood = 40,
    CadetBlue = 41,
    Chartreuse = 42,
    Chocolate = 43,
    Coral = 44,
    CornflowerBlue = 45,
    Cornsilk = 46,
    Crimson = 47,
    Cyan = 48,
    DarkBlue = 49,
    DarkCyan = 50,
    DarkGoldenrod = 51,
    DarkGray = 52,
    DarkGreen = 53,
    DarkKhaki = 54,
    DarkMagenta = 55,
    DarkOliveGreen = 56,
    DarkOrange = 57,
    DarkOrchid = 58,
    DarkRed = 59,
    DarkSalmon = 60,
    DarkSeaGreen = 61,
    DarkSlateBlue = 62,
    DarkSlateGray = 63,
    DarkTurquoise = 64,
    DarkViolet = 65,
    DeepPink = 66,
    DeepSkyBlue = 67,
    DimGray = 68,
    DodgerBlue = 69,
    Firebrick = 70,
    FloralWhite = 71,
    ForestGreen = 72,
    Fuchsia = 73,
    Gainsboro = 74,
    GhostWhite = 75,
    Gold = 76,
    Goldenrod = 77,
    Gray = 78,
    Green = 79,
    GreenYellow = 80,
    Honeydew = 81,
    HotPink = 82,
    IndianRed = 83,
    Indigo = 84,
    Ivory = 85,
    Khaki = 86,
    Lavender = 87,
    LavenderBlush = 88,
    LawnGreen = 89,
    LemonChiffon = 90,
    LightBlue = 91,
    LightCoral = 92,
    LightCyan = 93,
    LightGoldenrodYellow = 94,
    LightGray = 95,
    LightGreen = 96,
    LightPink = 97,
    LightSalmon = 98,
    LightSeaGreen = 99,
    LightSkyBlue = 100,
    LightSlateGray = 101,
    LightSteelBlue = 102,
    LightYellow = 103,
    Lime = 104,
    LimeGreen = 105,
    Linen = 106,
    Magenta = 107,
    Maroon = 108,
    MediumAquamarine = 109,
    MediumBlue = 110,
    MediumOrchid = 111,
    MediumPurple = 112,
    MediumSeaGreen = 113,
    MediumSlateBlue = 114,
    MediumSpringGreen = 115,
    MediumTurquoise = 116,
    MediumVioletRed = 117,
    MidnightBlue = 118,
    MintCream = 119,
    MistyRose = 120,
    Moccasin = 121,
    NavajoWhite = 122,
    Navy = 123,
    OldLace = 124,
    Olive = 125,
    OliveDrab = 126,
    Orange = 127,
    OrangeRed = 128,
    Orchid = 129,
    PaleGoldenrod = 130,
    PaleGreen = 131,
    PaleTurquoise = 132,
    PaleVioletRed = 133,
    PapayaWhip = 134,
    PeachPuff = 135,
    Peru = 136,
    Pink = 137,
    Plum = 138,
    PowderBlue = 139,
    Purple = 140,
    Red = 141,
    RosyBrown = 142,
    RoyalBlue = 143,
    SaddleBrown = 144,
    Salmon = 145,
    SandyBrown = 146,
    SeaGreen = 147,
    SeaShell = 148,
    Sienna = 149,
    Silver = 150,
    SkyBlue = 151,
    SlateBlue = 152,
    SlateGray = 153,
    Snow = 154,
    SpringGreen = 155,
    SteelBlue = 156,
    Tan = 157,
    Teal = 158,
    Thistle = 159,
    Tomato = 160,
    Turquoise = 161,
    Violet = 162,
    Wheat = 163,
    White = 164,
    WhiteSmoke = 165,
    Yellow = 166,
    YellowGreen = 167,
    ButtonFace = 168,
    ButtonHighlight = 169,
    ButtonShadow = 170,
    GradientActiveCaption = 171,
    GradientInactiveCaption = 172,
    MenuBar = 173,
    MenuHighlight = 174
}

export class KnownColors {
    static RgbaValues: number[][];
    static Names: string[];
    static argbByName: SimpleDictionary<string, number[]>;
    static nameByArgb: SimpleDictionary<number[], string>;
    static get ArgbByName(): SimpleDictionary<string, number[]>;
    static get NameByArgb(): SimpleDictionary<number[], string>;
    static FromKnownColor(kc: KnownColor): CGColor;
    static GetName(kc: number | KnownColor): string;
    static FindColorMatch(c: CGColor): CGColor;
    static Update(knownColor: number, color: number[]): void;
}

export interface IRectangleF {
        x: float;
        y: float;
        width: float;
        height: float;
}
export function Rect(X1: number, Y1: number, X2: number, Y2: number): CGRectangle;
export class CGRectangle implements IEquatable<CGRectangle> {
        x(x: any, y: any, width: any, height: any): any;
        y(x: any, y: any, width: any, height: any): any;
        width(x: any, y: any, width: any, height: any): any;
        height(x: any, y: any, width: any, height: any): any;
        static get Empty(): CGRectangle;
        get X(): float;
        set X(value: float);
        get Y(): float;
        set Y(value: float);
        get X1(): float;
        get Y1(): float;
        get X2(): float;
        get Y2(): float;
        get Width(): float;
        set Width(value: float);
        get Height(): float;
        set Height(value: float);
        get Rotation(): float;
        set Rotation(value: float);
        get Location(): CGPoint;
        set Location(value: CGPoint);
        get Size(): CGSize;
        set Size(value: CGSize);
        get Left(): float;
        get Top(): float;
        get Right(): float;
        get Bottom(): float;
        get IsEmpty(): boolean;
        constructor(rectObj?: IRectangleF);
        constructor(location?: CGPoint, size?: CGSize);
        constructor(x?: float, y?: float, width?: float, height?: float);
        static FromLTRB: (left: float, top: float, right: float, bottom: float) => CGRectangle;
        Equals: (rect: CGRectangle) => boolean;
        /**
         * Extends the rectangle's bounds to include the described point or rectangle.
         * @param {Number} x X position of the point or rectangle.
         * @param {Number} y Y position of the point or rectangle.
         * @param {Number} [width=0] The width of the rectangle.
         * @param {Number} [height=0] The height of the rectangle.
         * @return {easeljs.Rectangle} This instance. Useful for chaining method calls.
         * @chainable
        */
        extend(x: float, y: float, width?: float, height?: float): this;
        contains(point: CGPoint): boolean;
        contains(rect: CGRectangle): boolean;
        contains(x: float, y: float): boolean;
        inflate(size: CGSize): CGRectangle;
        inflate(x: float, y: float): CGRectangle;
        static Inflate(rect: CGRectangle, x: float, y: float): CGRectangle;
        intersect(rect: CGRectangle): void;
        static Intersect(a: CGRectangle, b: CGRectangle): CGRectangle;
        intersectsWith: (rect: CGRectangle) => boolean;
        static Union(a: CGRectangle, b: CGRectangle): CGRectangle;
        offset(pos: CGPoint): void;
        offset(x: float, y: float): void;
        /**
    * Sets the specified values on this instance.
    * @param {Number} [x=0] X position.
    * @param {Number} [y=0] Y position.
    * @param {Number} [width=0] The width of the Rectangle.
    * @param {Number} [height=0] The height of the Rectangle.
    * @return {easeljs.Rectangle} This instance. Useful for chaining method calls.
    * @chainable
 */
        setValues(x?: float, y?: float, width?: float, height?: float): this;
        copy(rect: CGRectangle): CGRectangle;
        toString: () => string;
        transform(matrix: Matrix): CGRectangle;
        scale(factor: float): CGRectangle;
        isEqual(rect: CGRectangle): boolean;
        clone(): CGRectangle;
        pos(): CGPoint;
        size(): CGSize;
        translate(offsetX: number, offsetY: number): CGRectangle;
        move(x: int, y: int): CGRectangle;
        shrink(value: int): CGRectangle;
        hShrink(value: int): CGRectangle;
        vShrink(value: int): CGRectangle;
        resize(width: int, height: int): CGRectangle;
        intersection(rect: CGRectangle): CGRectangle;
        intersects(rect: CGRectangle): boolean;
        intersectsNotEqual(rect: CGRectangle): boolean;
}

export interface IPointF {
    x: float;
    y: float;
}
export class CGPoint implements IEquatable<CGPoint> {
    static get Empty(): CGPoint;
    get IsEmpty(): boolean;
    get X(): float;
    set X(value: float);
    get Y(): float;
    set Y(value: float);
    constructor();
    constructor(x: IPointF);
    constructor(x: float, y: float);
    Offset(dx: int, dy: int): void;
    add: (sz: CGSize) => CGPoint;
    subtract: (sz: CGSize) => CGPoint;
    static Add(pt: CGPoint, sz: CGSize): CGPoint;
    static Subtract(pt: CGPoint, sz: CGSize): CGPoint;
    clone(): CGPoint;
    Equals: (pt: CGPoint) => boolean;
    notEquals: (pt: CGPoint) => boolean;
    sub: (p: CGPoint) => CGPoint;
    _add: (p: CGPoint) => CGPoint;
}

export interface ISizeF {
    width: float;
    height: float;
}
export class CGSize implements IEquatable<CGSize> {
    static readonly Empty: CGSize;
    get IsEmpty(): boolean;
    get Width(): float;
    set Width(value: float);
    get Height(): float;
    set Height(value: float);
    constructor(pt: CGPoint);
    constructor(size: CGSize);
    constructor(width?: float, height?: float);
    constructor(obj: ISizeF);
    Add(size: CGSize): CGSize;
    Substruct(size: CGSize): void;
    Clone(): CGSize;
    Equals: (pt: CGSize) => boolean;
    NotEquals: (pt: CGSize) => boolean;
    static Add(sz1: CGSize, sz2: CGSize): CGSize;
    static Subtract(sz1: CGSize, sz2: CGSize): CGSize;
    static Ceiling(value: CGSize): CGSize;
}

export class CGContext2D implements IContext2D {
    drawingContext: CanvasRenderingContext2D;
    constructor(context: CanvasRenderingContext2D);
    transferToImageBitmap(): ImageBitmap;
    scaleCTM(sx: float, sy: float): void;
    translateCTM(tx: float, ty: float): void;
    rotateCTM(angle: float): void;
    concatCTM(transform: CGAffineTransform): void;
    saveState(): void;
    restoreState(): void;
    setLineWidth(w: float): void;
    setLineCap(cap: CGLineCap): void;
    setLineJoin(join: CGLineJoin): void;
    setMiterLimit(limit: float): void;
    setLineDash(phase: float, lengths: float[]): void;
    setLineDash(phase: float, lengths: float[], n: number): void;
    setFlatness(flatness: float): void;
    setAlpha(alpha: float): void;
    setBlendMode(mode: CGBlendMode): void;
    getCTM(): CGAffineTransform;
    beginPath(): void;
    moveTo(x: float, y: float): void;
    addLineToPoint(x: float, y: float): void;
    addCurveToPoint(cp1x: float, cp1y: float, cp2x: float, cp2y: float, x: float, y: float): void;
    addQuadCurveToPoint(cpx: float, cpy: float, x: float, y: float): void;
    closePath(): void;
    addRect(rect: CGRectangle): void;
    addRects(rects: CGRectangle[]): void;
    addLines(points: CGPoint[]): void;
    addEllipseInRect(rect: CGRectangle): void;
    addArc(x: float, y: float, radius: float, startAngle: float, endAngle: float, clockwise: boolean): void;
    addArcToPoint(x1: float, y1: float, x2: float, y2: float, radius: float): void;
    addPath(path: CGPath): void;
    replacePathWithStrokedPath(): void;
    getPathCurrentPoint(): CGPoint;
    getPathBoundingBox(): CGRectangle;
    pathContainsPoint(point: CGPoint, mode: CGPathDrawingMode): boolean;
    drawPath(mode: CGPathDrawingMode): void;
    fillPath(): void;
    eOFillPath(): void;
    strokePath(): void;
    fillRect(rect: CGRectangle): void;
    contextFillRects(rects: CGRectangle[]): void;
    strokeRect(rect: CGRectangle): void;
    strokeRectWithWidth(rect: CGRectangle, width: float): void;
    clearRect(rect: CGRectangle): void;
    fillEllipseInRect(rect: CGRectangle): void;
    strokeEllipseInRect(rect: CGRectangle): void;
    strokeLineSegments(points: CGPoint[]): void;
    eOClip(): void;
    clipToMask(rect: CGRectangle, mask: any): void;
    getClipBoundingBox(): CGRectangle;
    clip(): void;
    clipToRect(rect: CGRectangle, debug?: boolean): void;
    clipToRects(rects: CGRectangle[]): void;
    setFillColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setFillColor(gray: float, alpha: float): void;
    setFillColor(components: float[]): void;
    setFillColor(color: CGColor): void;
    setFillColor(red: float, green: float, blue: float, alpha: float): void;
    setFillColorWithColor(color: CGColor): void;
    setStrokeColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setStrokeColor(red: float, green: float, blue: float, alpha: float): void;
    setStrokeColor(gray: float, alpha: float): void;
    setStrokeColor(components: float[]): void;
    setStrokeColor(color: CGColor): void;
    setStrokeColorWithColor(color: CGColor): void;
    setFillColorSpace(space: any): void;
    setStrokeColorSpace(space: any): void;
    setFillPattern(pattern: CGPattern, components: float[]): void;
    setStrokePattern(pattern: any, components: float[]): void;
    setPatternPhase(phase: CGSize): void;
    setGrayFillColor(gray: float, alpha: float): void;
    setGrayStrokeColor(gray: float, alpha: float): void;
    setRGBFillColor(red: float, green: float, blue: float, alpha: float): void;
    setRGBStrokeColor(red: float, green: float, blue: float, alpha: float): void;
    setCMYKFillColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setCMYKStrokeColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setRenderingIntent(intent: any): void;
    drawImage(image: any, x: number, y: number): void;
    drawImage(image: any, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
    drawTiledImage(rect: CGRectangle, image: any): void;
    InterpolationQuality: CGInterpolationQuality;
    setShadowWithColor(offset: CGSize, blur: float, color: CGColor): void;
    setShadow(offset: CGSize, blur: float): void;
    drawLinearGradient(gradient: any, startPoint: CGPoint, endPoint: CGPoint, options: any): void;
    drawRadialGradient(gradient: any, startCenter: CGPoint, startRadius: float, endCenter: CGPoint, endRadius: float, options: any): void;
    setCharacterSpacing(spacing: float): void;
    TextPosition: CGPoint;
    TextMatrix: CGAffineTransform;
    setTextDrawingMode(mode: CGTextDrawingMode): void;
    setFont(font: CGFont): void;
    measureText(text: string, font: CGFont): CGSize;
    selectFont(name: string, size: float, textEncoding: CGTextEncoding): void;
    showGlyphsAtPositions(glyphs: number[], positions: CGPoint[], size_t_count: number): void;
    setTextAlign(textAlign: string): void;
    setTextBaseline(textAlign: string): void;
    showText(str: string, x: number, y: number): void;
    showTextAtPoint(x: float, y: float, bytes: ByteArray): void;
    showTextAtPoint(x: float, y: float, bytes: ByteArray, length: number): void;
    showTextAtPoint(x: float, y: float, str: string): void;
    showTextAtPoint(x: float, y: float, str: string, length: number): void;
    showGlyphs(glyphs: ByteArray, count: number): void;
    showGlyphs(glyphs: ByteArray): void;
    showGlyphsAtPoint(x: float, y: float, glyphs: ByteArray): void;
    showGlyphsAtPoint(x: float, y: float, glyphs: ByteArray, count: number): void;
    showGlyphsWithAdvances(glyphs: ByteArray, advances: CGSize[], count: number): void;
    drawPDFPage(page: any): void;
    beginPage(rect: CGRectangle): void;
    endPage(): void;
    flush(): void;
    synchronize(): void;
    setShouldAntialias(shouldAntialias: boolean): void;
    setAllowsAntialiasing(allowsAntialiasing: boolean): void;
    setShouldSmoothFonts(shouldSmoothFonts: boolean): void;
    getUserSpaceToDeviceSpaceTransform(): CGAffineTransform;
    pointToDeviceSpace(point: CGPoint): CGPoint;
    convertPointToUserSpace(point: CGPoint): CGPoint;
    convertSizeToDeviceSpace(size: CGSize): CGSize;
    convertSizeToUserSpace(size: CGSize): CGSize;
    convertRectToDeviceSpace(rect: CGRectangle): CGRectangle;
    convertRectToUserSpace(rect: CGRectangle): CGRectangle;
    drawLayer(layer: any, rect: CGRectangle): void;
    drawLayer(layer: any, point: CGPoint): void;
    copyPath(): CGPath;
    setAllowsFontSmoothing(allows: boolean): void;
    setAllowsSubpixelPositioning(allows: boolean): void;
    setAllowsFontSubpixelQuantization(allows: boolean): void;
    setShouldSubpixelPositionFonts(shouldSubpixelPositionFonts: boolean): void;
    shouldSubpixelQuantizeFonts(shouldSubpixelQuantizeFonts: boolean): void;
    arc(x: number, y: number, w: number, h: number, start: number, stop: number, mode: string): void;
    drawImageBitmap(image: ImageBitmap, x: float, y: float): void;
}

export interface IContext2D {
    InterpolationQuality: CGInterpolationQuality;
    scaleCTM(sx: float, sy: float): void;
    translateCTM(tx: float, ty: float): void;
    rotateCTM(angle: float): void;
    concatCTM(transform: CGAffineTransform): void;
    saveState(): void;
    restoreState(): void;
    setLineWidth(w: float): void;
    setLineCap(cap: CGLineCap): any;
    setLineJoin(join: CGLineJoin): void;
    setMiterLimit(limit: float): void;
    setLineDash(phase: float, lengths: float[]): void;
    setLineDash(phase: float, lengths: float[], n: number): void;
    setFlatness(flatness: float): void;
    setAlpha(alpha: float): void;
    setBlendMode(mode: CGBlendMode): void;
    setTextAlign(textAlign: string): void;
    setTextBaseline(textAlign: string): void;
    getCTM(): CGAffineTransform;
    beginPath(): void;
    moveTo(x: float, y: float): void;
    addLineToPoint(x: float, y: float): void;
    addCurveToPoint(cp1x: float, cp1y: float, cp2x: float, cp2y: float, x: float, y: float): void;
    addQuadCurveToPoint(cpx: float, cpy: float, x: float, y: float): void;
    closePath(): void;
    addRect(rect: CGRectangle): void;
    addRects(rects: CGRectangle[]): void;
    addLines(points: CGPoint[]): void;
    addEllipseInRect(rect: CGRectangle): void;
    addArc(x: float, y: float, radius: float, startAngle: float, endAngle: float, clockwise: boolean): void;
    addArcToPoint(x1: float, y1: float, x2: float, y2: float, radius: float): void;
    addPath(path: CGPath): void;
    replacePathWithStrokedPath(): void;
    getPathCurrentPoint(): CGPoint;
    getPathBoundingBox(): CGRectangle;
    pathContainsPoint(point: CGPoint, mode: CGPathDrawingMode): boolean;
    drawPath(mode: CGPathDrawingMode): any;
    fillPath(): void;
    eOFillPath(): void;
    strokePath(): void;
    fillRect(rect: CGRectangle): void;
    contextFillRects(rects: CGRectangle[]): void;
    strokeRect(rect: CGRectangle): void;
    strokeRectWithWidth(rect: CGRectangle, width: float): void;
    clearRect(rect: CGRectangle): void;
    fillEllipseInRect(rect: CGRectangle): void;
    strokeEllipseInRect(rect: CGRectangle): void;
    strokeLineSegments(points: CGPoint[]): void;
    eOClip(): void;
    clipToMask(rect: CGRectangle, mask: any): void;
    getClipBoundingBox(): CGRectangle;
    clip(): void;
    clipToRect(rect: CGRectangle): void;
    clipToRects(rects: CGRectangle[]): void;
    setFillColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setFillColor(gray: float, alpha: float): void;
    setFillColor(components: float[]): void;
    setFillColor(color: CGColor): void;
    setFillColor(red: float, green: float, blue: float, alpha: float): void;
    setFillColorWithColor(color: CGColor): void;
    setStrokeColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setStrokeColor(red: float, green: float, blue: float, alpha: float): void;
    setStrokeColor(gray: float, alpha: float): void;
    setStrokeColor(components: float[]): void;
    setStrokeColor(color: CGColor): void;
    setStrokeColorWithColor(color: CGColor): void;
    setFillColorSpace(space: any): void;
    setStrokeColorSpace(space: any): void;
    setFillPattern(pattern: CGPattern, components: float[]): void;
    setStrokePattern(pattern: any, components: float[]): void;
    setPatternPhase(phase: CGSize): void;
    setGrayFillColor(gray: float, alpha: float): void;
    setGrayStrokeColor(gray: float, alpha: float): void;
    setRGBFillColor(red: float, green: float, blue: float, alpha: float): void;
    setRGBStrokeColor(red: float, green: float, blue: float, alpha: float): void;
    setCMYKFillColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setCMYKStrokeColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setRenderingIntent(intent: any): void;
    drawImage(image: any, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
    drawTiledImage(rect: CGRectangle, image: any): void;
    setShadowWithColor(offset: CGSize, blur: float, color: CGColor): void;
    setShadow(offset: CGSize, blur: float): void;
    drawLinearGradient(gradient: any, startPoint: CGPoint, endPoint: CGPoint, options: any): void;
    drawRadialGradient(gradient: any, startCenter: CGPoint, startRadius: float, endCenter: CGPoint, endRadius: float, options: any): void;
    setCharacterSpacing(spacing: float): void;
    setTextDrawingMode(mode: CGTextDrawingMode): void;
    setFont(font: CGFont): void;
    measureText(text: string, font: CGFont): CGSize;
    selectFont(name: string, size: float, textEncoding: CGTextEncoding): void;
    showGlyphsAtPositions(glyphs: number[], positions: CGPoint[], size_t_count: number): void;
    showText(str: string, x: number, y: number): void;
    showTextAtPoint(x: float, y: float, bytes: ByteArray): void;
    showTextAtPoint(x: float, y: float, bytes: ByteArray, length: number): void;
    showTextAtPoint(x: float, y: float, str: string): void;
    showTextAtPoint(x: float, y: float, str: string, length: number): void;
    showGlyphs(glyphs: ByteArray, count: number): void;
    showGlyphs(glyphs: ByteArray): void;
    showGlyphsWithAdvances(glyphs: ByteArray, advances: CGSize[], count: number): void;
    drawPDFPage(page: any): void;
    beginPage(rect: CGRectangle): void;
    endPage(): void;
    setShouldAntialias(shouldAntialias: boolean): void;
    synchronize(): void;
    transferToImageBitmap(): ImageBitmap;
    drawImageBitmap(image: ImageBitmap, x: float, y: float): void;
}

export abstract class CGFont extends DisposableBase {
    get Name(): string;
    set Name(value: string);
    get Size(): number;
    set Size(value: number);
    get Style(): FontStyle;
    get GdiCharSet(): number;
    get TextLeading(): float;
    get TextStyle(): FontStyle;
    get HorizAlign(): StringAlignment;
    get VertAlign(): StringAlignment;
    get FontFamily(): FontFamily;
    constructor(fontFamily: /* opentype.Font | */ FontFamily | string, size: float);
    abstract setup(graphics: IContext2D): void;
    abstract getHeight(): number;
    abstract getTextWidth(text: string): number;
    equals(font: CGFont): boolean;
}

export class CGAffineTransform {
    m: Array<number>;
    constructor(...m: number[]);
    copy(): CGAffineTransform;
    static MakeIdentity(): CGAffineTransform;
    static MakeRotation(angle: float): CGAffineTransform;
    static MakeScale(sx: float, sy: float): CGAffineTransform;
    static MakeTranslation(tx: float, ty: float): CGAffineTransform;
    static Multiply(a: CGAffineTransform, b: CGAffineTransform): CGAffineTransform;
    point(point: CGPoint): CGPoint;
    multiply(matrix: CGAffineTransform): CGAffineTransform;
    invert(): CGAffineTransform;
    scale(sx: float, sy: float): void;
    translate(x: float, y: float): void;
    rotate(rad: float): void;
    getTranslation(): {
        x: number;
        y: number;
    };
    getMatrix(): number[];
    skew(sx: any, sy: any): this;
    setAbsolutePosition(x: any, y: any): void;
    get IsIdentity(): boolean;
    clone(): CGAffineTransform;
    toString(): string;
    equals(o: CGAffineTransform): boolean;
    getHashCode(): number;
}

export type ImageLoadedEventHandler = (img: HTMLImageElement) => void;
export class CGImage {
    onLoad: EventSimple<ImageLoadedEventHandler>;
    IsImageLoaded: boolean;
    imageTransform: CGAffineTransform;
    canvas: HTMLCanvasElement;
    get Pixels(): Uint8ClampedArray;
    set Pixels(value: Uint8ClampedArray);
    get Height(): number;
    set Height(value: number);
    get Width(): number;
    set Width(value: number);
    get Size(): CGSize;
    set Size(value: CGSize);
    constructor(filename: string);
    constructor(buffer: ByteArray);
    constructor(ctx: CanvasRenderingContext2D);
    constructor(width: number, height: number);
    loadPixels(): void;
    updatePixels(x?: number, y?: number, w?: number, h?: number): void;
    get(x: number, y: number, w: number, h: number): any[] | CGImage;
    set(x: number, y: number, imgOrCol: CGColor | CGImage | number | number[]): void;
    getPixelColor(x: number, y: number): CGColor;
    resize(width: number, height: number): void;
    copy(srcImage: CGImage, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
    static _copyHelper(dstImage: any, srcImage: any, sx: any, sy: any, sw: any, sh: any, dx: any, dy: any, dw: any, dh: any): void;
    mask(cgImage: CGImage): void;
    static LoadFromUrl(path: string): Promise<CGImage>;
    filter(operation: string, value: number): void;
    static FromStream(stream: any): CGImage;
    getCanvas(): HTMLCanvasElement;
    getContext(): CanvasRenderingContext2D;
}

export const CoreGraphicTypes: {
    StartCommand: symbol;
    CGFont: symbol;
    CGPoint: symbol;
    CGRectangle: symbol;
    CGColor: symbol;
    CGImage: symbol;
    CGPath: symbol;
    CGContext2D: symbol;
    CGPattern: symbol;
    CGSize: symbol;
};

export enum CGLineCap {
    Butt = 0,
    Round = 1,
    Square = 2
}

export enum CGLineJoin {
    Miter = 0,
    Round = 1,
    Bevel = 2
}

export enum CGBlendMode {
    Normal = 0,
    Multiply = 1,
    Screen = 2,
    Overlay = 3,
    Darken = 4,
    Lighten = 5,
    ColorDodge = 6,
    ColorBurn = 7,
    SoftLight = 8,
    HardLight = 9,
    Difference = 10,
    Exclusion = 11,
    Hue = 12,
    Saturation = 13,
    Color = 14,
    Luminosity = 15,
    Clear = 16,
    Copy = 17,
    SourceIn = 18,
    SourceOut = 19,
    SourceAtop = 20,
    DestinationOver = 21,
    DestinationIn = 22,
    DestinationOut = 23,
    DestinationAtop = 24,
    XOR = 25,
    PlusDarker = 26,
    PlusLighter = 27
}

export enum CGPathDrawingMode {
    Fill = 0,
    EOFill = 1,
    Stroke = 2,
    FillStroke = 3,
    EOFillStroke = 4
}

export enum TEXT_GRADIENT {
        LINEAR_VERTICAL = 0,
        LINEAR_HORIZONTAL = 1
}
export function hex2string(hex: number): string;
export type TextStyleAlign = 'left' | 'center' | 'right';
export type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;
export type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';
export type TextStyleFontVariant = 'normal' | 'small-caps';
export type TextStyleFontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';
export type TextStyleLineJoin = 'miter' | 'round' | 'bevel';
export type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';
export type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';
export interface ICGTextStyle {
        align: TextStyleAlign;
        breakWords: boolean;
        dropShadow: boolean;
        dropShadowAlpha: number;
        dropShadowAngle: number;
        dropShadowBlur: number;
        dropShadowColor: string | number;
        dropShadowDistance: number;
        fill: TextStyleFill;
        fillGradientType: TEXT_GRADIENT;
        fillGradientStops: number[];
        fontFamily: string;
        fontSize: number;
        fontStyle: TextStyleFontStyle;
        fontVariant: TextStyleFontVariant;
        fontWeight: TextStyleFontWeight;
        letterSpacing: number;
        lineHeight: number;
        lineJoin: TextStyleLineJoin;
        miterLimit: number;
        padding: number;
        stroke: string | number;
        strokeThickness: number;
        textBaseline: TextStyleTextBaseline;
        trim: boolean;
        whiteSpace: TextStyleWhiteSpace;
        wordWrap: boolean;
        wordWrapWidth: number;
        leading: number;
}
/**
    * A TextStyle Object contains information to decorate a Text objects.
    *
    * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.
    *
    * A tool can be used to generate a text style [here](https://pixijs.io/pixi-text-style).
    *
    * @class
    * @memberof PIXI
    */
export class CGTextStyle implements ICGTextStyle {
        styleID: number;
        protected _align: TextStyleAlign;
        protected _breakWords: boolean;
        protected _dropShadow: boolean;
        protected _dropShadowAlpha: number;
        protected _dropShadowAngle: number;
        protected _dropShadowBlur: number;
        protected _dropShadowColor: string | number;
        protected _dropShadowDistance: number;
        protected _fill: TextStyleFill;
        protected _fillGradientType: TEXT_GRADIENT;
        protected _fillGradientStops: number[];
        protected _fontFamily: string;
        protected _fontSize: number;
        protected _fontStyle: TextStyleFontStyle;
        protected _fontVariant: TextStyleFontVariant;
        protected _fontWeight: TextStyleFontWeight;
        protected _letterSpacing: number;
        protected _lineHeight: number;
        protected _lineJoin: TextStyleLineJoin;
        protected _miterLimit: number;
        protected _padding: number;
        protected _stroke: string | number;
        protected _strokeThickness: number;
        protected _textBaseline: TextStyleTextBaseline;
        protected _trim: boolean;
        protected _whiteSpace: TextStyleWhiteSpace;
        protected _wordWrap: boolean;
        protected _wordWrapWidth: number;
        protected _leading: number;
        /**
            * @param {object} [style] - The style parameters
            * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'),
            *  does not affect single line text
            * @param {boolean} [style.breakWords=false] - Indicates if lines can be wrapped within words, it
            *  needs wordWrap to be set to true
            * @param {boolean} [style.dropShadow=false] - Set a drop shadow for the text
            * @param {number} [style.dropShadowAlpha=1] - Set alpha for the drop shadow
            * @param {number} [style.dropShadowAngle=Math.PI/6] - Set a angle of the drop shadow
            * @param {number} [style.dropShadowBlur=0] - Set a shadow blur radius
            * @param {string|number} [style.dropShadowColor='black'] - A fill style to be used on the dropshadow e.g 'red', '#00FF00'
            * @param {number} [style.dropShadowDistance=5] - Set a distance of the drop shadow
            * @param {string|string[]|number|number[]|CanvasGradient|CanvasPattern} [style.fill='black'] - A canvas
            *  fillstyle that will be used on the text e.g 'red', '#00FF00'. Can be an array to create a gradient
            *  eg ['#000000','#FFFFFF']
            * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
            * @param {number} [style.fillGradientType=PIXI.TEXT_GRADIENT.LINEAR_VERTICAL] - If fill is an array of colours
            *  to create a gradient, this can change the type/direction of the gradient. See {@link PIXI.TEXT_GRADIENT}
            * @param {number[]} [style.fillGradientStops] - If fill is an array of colours to create a gradient, this array can set
            * the stop points (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
            * @param {string|string[]} [style.fontFamily='Arial'] - The font family
            * @param {number|string} [style.fontSize=26] - The font size (as a number it converts to px, but as a string,
            *  equivalents are '26px','20pt','160%' or '1.6em')
            * @param {string} [style.fontStyle='normal'] - The font style ('normal', 'italic' or 'oblique')
            * @param {string} [style.fontVariant='normal'] - The font variant ('normal' or 'small-caps')
            * @param {string} [style.fontWeight='normal'] - The font weight ('normal', 'bold', 'bolder', 'lighter' and '100',
            *  '200', '300', '400', '500', '600', '700', '800' or '900')
            * @param {number} [style.leading=0] - The space between lines
            * @param {number} [style.letterSpacing=0] - The amount of spacing between letters, default is 0
            * @param {number} [style.lineHeight] - The line height, a number that represents the vertical space that a letter uses
            * @param {string} [style.lineJoin='miter'] - The lineJoin property sets the type of corner created, it can resolve
            *      spiked text issues. Possible values "miter" (creates a sharp corner), "round" (creates a round corner) or "bevel"
            *      (creates a squared corner).
            * @param {number} [style.miterLimit=10] - The miter limit to use when using the 'miter' lineJoin mode. This can reduce
            *      or increase the spikiness of rendered text.
            * @param {number} [style.padding=0] - Occasionally some fonts are cropped. Adding some padding will prevent this from
            *     happening by adding padding to all sides of the text.
            * @param {string|number} [style.stroke='black'] - A canvas fillstyle that will be used on the text stroke
            *  e.g 'blue', '#FCFF00'
            * @param {number} [style.strokeThickness=0] - A number that represents the thickness of the stroke.
            *  Default is 0 (no stroke)
            * @param {boolean} [style.trim=false] - Trim transparent borders
            * @param {string} [style.textBaseline='alphabetic'] - The baseline of the text that is rendered.
            * @param {string} [style.whiteSpace='pre'] - Determines whether newlines & spaces are collapsed or preserved "normal"
            *      (collapse, collapse), "pre" (preserve, preserve) | "pre-line" (preserve, collapse). It needs wordWrap to be set to true
            * @param {boolean} [style.wordWrap=false] - Indicates if word wrap should be used
            * @param {number} [style.wordWrapWidth=100] - The width at which text will wrap, it needs wordWrap to be set to true
            */
        constructor(style: Partial<ICGTextStyle>);
        /**
            * Creates a new TextStyle object with the same values as this one.
            * Note that the only the properties of the object are cloned.
            *
            * @return {PIXI.TextStyle} New cloned TextStyle object
            */
        clone(): CGTextStyle;
        /**
            * Resets all properties to the defaults specified in TextStyle.prototype._default
            */
        reset(): void;
        /**
            * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
            *
            * @member {string}
            */
        get align(): TextStyleAlign;
        set align(align: TextStyleAlign);
        /**
            * Indicates if lines can be wrapped within words, it needs wordWrap to be set to true
            *
            * @member {boolean}
            */
        get breakWords(): boolean;
        set breakWords(breakWords: boolean);
        /**
            * Set a drop shadow for the text
            *
            * @member {boolean}
            */
        get dropShadow(): boolean;
        set dropShadow(dropShadow: boolean);
        /**
            * Set alpha for the drop shadow
            *
            * @member {number}
            */
        get dropShadowAlpha(): number;
        set dropShadowAlpha(dropShadowAlpha: number);
        /**
            * Set a angle of the drop shadow
            *
            * @member {number}
            */
        get dropShadowAngle(): number;
        set dropShadowAngle(dropShadowAngle: number);
        /**
            * Set a shadow blur radius
            *
            * @member {number}
            */
        get dropShadowBlur(): number;
        set dropShadowBlur(dropShadowBlur: number);
        /**
            * A fill style to be used on the dropshadow e.g 'red', '#00FF00'
            *
            * @member {string|number}
            */
        get dropShadowColor(): string | number;
        set dropShadowColor(dropShadowColor: string | number);
        /**
            * Set a distance of the drop shadow
            *
            * @member {number}
            */
        get dropShadowDistance(): number;
        set dropShadowDistance(dropShadowDistance: number);
        /**
            * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
            * Can be an array to create a gradient eg ['#000000','#FFFFFF']
            * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
            *
            * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
            */
        get fill(): TextStyleFill;
        set fill(fill: TextStyleFill);
        /**
            * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
            * See {@link PIXI.TEXT_GRADIENT}
            *
            * @member {number}
            */
        get fillGradientType(): TEXT_GRADIENT;
        set fillGradientType(fillGradientType: TEXT_GRADIENT);
        /**
            * If fill is an array of colours to create a gradient, this array can set the stop points
            * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
            *
            * @member {number[]}
            */
        get fillGradientStops(): number[];
        set fillGradientStops(fillGradientStops: number[]);
        /**
            * The font family
            *
            * @member {string|string[]}
            */
        get fontFamily(): string;
        set fontFamily(fontFamily: string);
        /**
            * The font size
            * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
            *
            * @member {number|string}
            */
        get fontSize(): number;
        set fontSize(fontSize: number);
        /**
            * The font style
            * ('normal', 'italic' or 'oblique')
            *
            * @member {string}
            */
        get fontStyle(): TextStyleFontStyle;
        set fontStyle(fontStyle: TextStyleFontStyle);
        /**
            * The font variant
            * ('normal' or 'small-caps')
            *
            * @member {string}
            */
        get fontVariant(): TextStyleFontVariant;
        set fontVariant(fontVariant: TextStyleFontVariant);
        /**
            * The font weight
            * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
            *
            * @member {string}
            */
        get fontWeight(): TextStyleFontWeight;
        set fontWeight(fontWeight: TextStyleFontWeight);
        /**
            * The amount of spacing between letters, default is 0
            *
            * @member {number}
            */
        get letterSpacing(): number;
        set letterSpacing(letterSpacing: number);
        /**
            * The line height, a number that represents the vertical space that a letter uses
            *
            * @member {number}
            */
        get lineHeight(): number;
        set lineHeight(lineHeight: number);
        /**
            * The space between lines
            *
            * @member {number}
            */
        get leading(): number;
        set leading(leading: number);
        /**
            * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
            * Default is 'miter' (creates a sharp corner).
            *
            * @member {string}
            */
        get lineJoin(): TextStyleLineJoin;
        set lineJoin(lineJoin: TextStyleLineJoin);
        /**
            * The miter limit to use when using the 'miter' lineJoin mode
            * This can reduce or increase the spikiness of rendered text.
            *
            * @member {number}
            */
        get miterLimit(): number;
        set miterLimit(miterLimit: number);
        /**
            * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
            * by adding padding to all sides of the text.
            *
            * @member {number}
            */
        get padding(): number;
        set padding(padding: number);
        /**
            * A canvas fillstyle that will be used on the text stroke
            * e.g 'blue', '#FCFF00'
            *
            * @member {string|number}
            */
        get stroke(): string | number;
        set stroke(stroke: string | number);
        /**
            * A number that represents the thickness of the stroke.
            * Default is 0 (no stroke)
            *
            * @member {number}
            */
        get strokeThickness(): number;
        set strokeThickness(strokeThickness: number);
        /**
            * The baseline of the text that is rendered.
            *
            * @member {string}
            */
        get textBaseline(): TextStyleTextBaseline;
        set textBaseline(textBaseline: TextStyleTextBaseline);
        /**
            * Trim transparent borders
            *
            * @member {boolean}
            */
        get trim(): boolean;
        set trim(trim: boolean);
        /**
            * How newlines and spaces should be handled.
            * Default is 'pre' (preserve, preserve).
            *
            *  value       | New lines     |   Spaces
            *  ---         | ---           |   ---
            * 'normal'     | Collapse      |   Collapse
            * 'pre'        | Preserve      |   Preserve
            * 'pre-line'   | Preserve      |   Collapse
            *
            * @member {string}
            */
        get whiteSpace(): TextStyleWhiteSpace;
        set whiteSpace(whiteSpace: TextStyleWhiteSpace);
        /**
            * Indicates if word wrap should be used
            *
            * @member {boolean}
            */
        get wordWrap(): boolean;
        set wordWrap(wordWrap: boolean);
        /**
            * The width at which text will wrap, it needs wordWrap to be set to true
            *
            * @member {number}
            */
        get wordWrapWidth(): number;
        set wordWrapWidth(wordWrapWidth: number);
        /**
            * Generates a font style string to use for `TextMetrics.measureFont()`.
            *
            * @return {string} Font style string, for passing to `TextMetrics.measureFont()`
            */
        toFontString(): string;
}

interface IFontMetrics {
        ascent: number;
        descent: number;
        fontSize: number;
}
/**
    * The TextMetrics object represents the measurement of a block of text with a specified style.
    *
    * ```js
    * let style = new PIXI.TextStyle({fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'})
    * let textMetrics = PIXI.TextMetrics.measureText('Your text', style)
    * ```
    *
    * @class
    * @memberof PIXI
    */
export class CGTextMetrics {
        text: string;
        style: CGTextStyle;
        width: number;
        height: number;
        lines: string[];
        lineWidths: number[];
        lineHeight: number;
        maxLineWidth: number;
        fontProperties: IFontMetrics;
        static METRICS_STRING: string;
        static BASELINE_SYMBOL: string;
        static BASELINE_MULTIPLIER: number;
        static _canvas: HTMLCanvasElement;
        static _context: CanvasRenderingContext2D;
        static _fonts: {
                [font: string]: IFontMetrics;
        };
        static _newlines: number[];
        static _breakingSpaces: number[];
        /**
            * @param {string} text - the text that was measured
            * @param {PIXI.TextStyle} style - the style that was measured
            * @param {number} width - the measured width of the text
            * @param {number} height - the measured height of the text
            * @param {string[]} lines - an array of the lines of text broken by new lines and wrapping if specified in style
            * @param {number[]} lineWidths - an array of the line widths for each line matched to `lines`
            * @param {number} lineHeight - the measured line height for this style
            * @param {number} maxLineWidth - the maximum line width for all measured lines
            * @param {Object} fontProperties - the font properties object from TextMetrics.measureFont
            */
        constructor(text: string, style: CGTextStyle, width: number, height: number, lines: string[], lineWidths: number[], lineHeight: number, maxLineWidth: number, fontProperties: IFontMetrics);
        /**
            * Measures the supplied string of text and returns a Rectangle.
            *
            * @param {string} text - the text to measure.
            * @param {PIXI.TextStyle} style - the text style to use for measuring
            * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.
            * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
            * @return {PIXI.TextMetrics} measured width and height of the text.
            */
        static measureText(text: string, style: CGTextStyle, wordWrap: boolean, canvas?: HTMLCanvasElement): CGTextMetrics;
        /**
            * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
            *
            * It allows one to customise which words should break
            * Examples are if the token is CJK or numbers.
            * It must return a boolean.
            *
            * @param  {string}  token       The token
            * @param  {boolean}  breakWords  The style attr break words
            * @return {boolean} whether to break word or not
            */
        static canBreakWords(_token: string, breakWords: boolean): boolean;
        /**
            * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
            *
            * It allows one to determine whether a pair of characters
            * should be broken by newlines
            * For example certain characters in CJK langs or numbers.
            * It must return a boolean.
            *
            * @param  {string}  char      The character
            * @param  {string}  nextChar  The next character
            * @param  {string}  token     The token/word the characters are from
            * @param  {number}  index     The index in the token of the char
            * @param  {boolean}  breakWords  The style attr break words
            * @return {boolean} whether to break word or not
            */
        static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number, _breakWords: boolean): boolean;
        /**
            * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
            *
            * It is called when a token (usually a word) has to be split into separate pieces
            * in order to determine the point to break a word.
            * It must return an array of characters.
            *
            * @example
            * // Correctly splits emojis, eg "" will result in two element array, each with one emoji.
            * TextMetrics.wordWrapSplit = (token) => [...token];
            *
            * @param  {string}  token The token to split
            * @return {string[]} The characters of the token
            */
        static wordWrapSplit(token: string): string[];
        /**
            * Calculates the ascent, descent and fontSize of a given font-style
            *
            * @static
            * @param {string} font - String representing the style of the font
            * @return {PIXI.IFontMetrics} Font properties object
            */
        static measureFont(font: string): IFontMetrics;
        /**
            * Clear font metrics in metrics cache.
            *
            * @static
            * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
            */
        static clearMetrics(font?: string): void;
}
export {};

export enum CGInterpolationQuality {
    Default = 0,
    None = 1,
    Low = 2,
    High = 3,
    Medium = 4
}

export enum MatrixOrder {
    Prepend = 0,
    Append = 1
}
export class Matrix implements IDisposable {
    transform: CGAffineTransform;
    constructor();
    constructor(transform: CGAffineTransform);
    constructor(rect: CGRectangle, plgpts: CGPoint[]);
    constructor(m11: float, m12: float, m21: float, m22: float, dx: float, dy: float);
    get Elements(): float[];
    get IsIdentity(): boolean;
    get IsInvertible(): boolean;
    get OffsetX(): float;
    get OffsetY(): float;
    get IsScaled(): boolean;
    clone(): Matrix;
    Dispose(): void;
    equals(m: Matrix): boolean;
    getHashCode(): number;
    invert(): void;
    multiply(matrix: Matrix): void;
    multiply(matrix: Matrix, order: MatrixOrder): void;
    reset(): void;
    rotate(angle: float): void;
    rotate(angle: float, order: MatrixOrder): void;
    rotateAt(angle: float, point: CGPoint): void;
    rotateAt(angle: float, point: CGPoint, order: MatrixOrder): void;
    scale(scaleX: float, scaleY: float): void;
    scale(scaleX: float, scaleY: float, order: MatrixOrder): void;
    shear(shearX: float, shearY: float): void;
    shear(shearX: float, shearY: float, order: MatrixOrder): void;
    transformPoints(pts: CGPoint[]): void;
    transformVectors(pts: CGPoint[]): void;
    translate(offsetX: float, offsetY: float): void;
    translate(offsetX: float, offsetY: float, order: MatrixOrder): void;
    vectorTransformPoints(pts: CGPoint[]): void;
}

export type DrawPattern = (ctx: IContext2D) => void;
export type ProcessImageFunc = (ctx: IContext2D) => IContext2D;
export enum CGPatternTiling {
    NoDistortion = 0,
    ConstantSpacingMinimalDistortion = 1,
    ConstantSpacing = 2
}
export class CGPattern {
    bounds: CGRectangle;
    matrix: CGAffineTransform;
    xStep: float;
    yStep: float;
    tiling: CGPatternTiling;
    isColored: boolean;
    drawPattern: DrawPattern;
    wrapMode: WrapMode;
    processImageFunc?: ProcessImageFunc | undefined;
    constructor(bounds: CGRectangle, matrix: CGAffineTransform, xStep: float, yStep: float, tiling: CGPatternTiling, isColored: boolean, drawPattern: DrawPattern, wrapMode?: WrapMode, processImageFunc?: ProcessImageFunc | undefined);
}

export enum CGTextDrawingMode {
    Fill = 0,
    Stroke = 1,
    FillStroke = 2,
    Invisible = 3,
    FillClip = 4,
    StrokeClip = 5,
    FillStrokeClip = 6,
    Clip = 7
}

export enum CGTextEncoding {
    FontSpecific = 0,
    MacRoman = 1
}

export class FontFamily {
    get Name(): string;
    getLineSpacing(style: FontStyle): number;
    getEmHeight(style: FontStyle): number;
    constructor(name: string);
    toString(): string;
}

export enum FontStyle {
    Regular = 0,
    Bold = 1,
    Italic = 2,
    Underline = 4,
    Strikeout = 8
}

export enum StringAlignment {
    Near = 0,
    Center = 1,
    Far = 2
}

export class CGCommandContext2D implements IContext2D {
    drawingContext: CanvasRenderingContext2D;
    IsOpened: boolean;
    IsClosed: boolean;
    constructor(context: CanvasRenderingContext2D);
    Begin(): void;
    End(): void;
    GetStartPointer(): number;
    transferToImageBitmap(): ImageBitmap;
    scaleCTM(sx: float, sy: float): void;
    translateCTM(tx: float, ty: float): void;
    rotateCTM(angle: float): void;
    concatCTM(transform: CGAffineTransform): void;
    saveState(): void;
    restoreState(): void;
    setLineWidth(w: float): void;
    setLineCap(cap: CGLineCap): void;
    setLineJoin(join: CGLineJoin): void;
    setMiterLimit(limit: float): void;
    setLineDash(phase: float, lengths: float[]): void;
    setLineDash(phase: float, lengths: float[], n: number): void;
    setFlatness(flatness: float): void;
    setAlpha(alpha: float): void;
    setBlendMode(mode: CGBlendMode): void;
    getCTM(): CGAffineTransform;
    beginPath(): void;
    moveTo(x: float, y: float): void;
    addLineToPoint(x: float, y: float): void;
    addCurveToPoint(cp1x: float, cp1y: float, cp2x: float, cp2y: float, x: float, y: float): void;
    addQuadCurveToPoint(cpx: float, cpy: float, x: float, y: float): void;
    closePath(): void;
    addRect(rect: CGRectangle): void;
    addRects(rects: CGRectangle[]): void;
    addLines(points: CGPoint[]): void;
    addEllipseInRect(rect: CGRectangle): void;
    addArc(x: float, y: float, radius: float, startAngle: float, endAngle: float, clockwise: boolean): void;
    addArcToPoint(x1: float, y1: float, x2: float, y2: float, radius: float): void;
    addPath(path: CGPath): void;
    replacePathWithStrokedPath(): void;
    getPathCurrentPoint(): CGPoint;
    getPathBoundingBox(): CGRectangle;
    pathContainsPoint(point: CGPoint, mode: CGPathDrawingMode): boolean;
    drawPath(mode: CGPathDrawingMode): void;
    fillPath(): void;
    eOFillPath(): void;
    strokePath(): void;
    fillRect(rect: CGRectangle): void;
    contextFillRects(rects: CGRectangle[]): void;
    strokeRect(rect: CGRectangle): void;
    strokeRectWithWidth(rect: CGRectangle, width: float): void;
    clearRect(rect: CGRectangle): void;
    fillEllipseInRect(rect: CGRectangle): void;
    strokeEllipseInRect(rect: CGRectangle): void;
    strokeLineSegments(points: CGPoint[]): void;
    eOClip(): void;
    clipToMask(rect: CGRectangle, mask: any): void;
    getClipBoundingBox(): CGRectangle;
    clip(): void;
    clipToRect(rect: CGRectangle, debug?: boolean): void;
    clipToRects(rects: CGRectangle[]): void;
    setFillColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setFillColor(gray: float, alpha: float): void;
    setFillColor(components: float[]): void;
    setFillColor(color: CGColor): void;
    setFillColor(red: float, green: float, blue: float, alpha: float): void;
    setFillColorWithColor(color: CGColor): void;
    setStrokeColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setStrokeColor(red: float, green: float, blue: float, alpha: float): void;
    setStrokeColor(gray: float, alpha: float): void;
    setStrokeColor(components: float[]): void;
    setStrokeColor(color: CGColor): void;
    setStrokeColorWithColor(color: CGColor): void;
    setFillColorSpace(space: any): void;
    setStrokeColorSpace(space: any): void;
    setFillPattern(pattern: CGPattern, components: float[]): void;
    setStrokePattern(pattern: any, components: float[]): void;
    setPatternPhase(phase: CGSize): void;
    setGrayFillColor(gray: float, alpha: float): void;
    setGrayStrokeColor(gray: float, alpha: float): void;
    setRGBFillColor(red: float, green: float, blue: float, alpha: float): void;
    setRGBStrokeColor(red: float, green: float, blue: float, alpha: float): void;
    setCMYKFillColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setCMYKStrokeColor(cyan: float, magenta: float, yellow: float, black: float, alpha: float): void;
    setRenderingIntent(intent: any): void;
    drawImage(image: any, x: number, y: number): void;
    drawImage(image: any, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number): void;
    drawTiledImage(rect: CGRectangle, image: any): void;
    InterpolationQuality: CGInterpolationQuality;
    setShadowWithColor(offset: CGSize, blur: float, color: CGColor): void;
    setShadow(offset: CGSize, blur: float): void;
    drawLinearGradient(gradient: any, startPoint: CGPoint, endPoint: CGPoint, options: any): void;
    drawRadialGradient(gradient: any, startCenter: CGPoint, startRadius: float, endCenter: CGPoint, endRadius: float, options: any): void;
    setCharacterSpacing(spacing: float): void;
    TextPosition: CGPoint;
    TextMatrix: CGAffineTransform;
    setTextDrawingMode(mode: CGTextDrawingMode): void;
    setFont(font: CGFont): void;
    measureText(text: string, font: CGFont): CGSize;
    selectFont(name: string, size: float, textEncoding: CGTextEncoding): void;
    showGlyphsAtPositions(glyphs: number[], positions: CGPoint[], size_t_count: number): void;
    setTextAlign(textAlign: string): void;
    setTextBaseline(textAlign: string): void;
    showText(str: string, x: number, y: number): void;
    showTextAtPoint(x: float, y: float, bytes: ByteArray): void;
    showTextAtPoint(x: float, y: float, bytes: ByteArray, length: number): void;
    showTextAtPoint(x: float, y: float, str: string): void;
    showTextAtPoint(x: float, y: float, str: string, length: number): void;
    showGlyphs(glyphs: ByteArray, count: number): void;
    showGlyphs(glyphs: ByteArray): void;
    showGlyphsAtPoint(x: float, y: float, glyphs: ByteArray): void;
    showGlyphsAtPoint(x: float, y: float, glyphs: ByteArray, count: number): void;
    showGlyphsWithAdvances(glyphs: ByteArray, advances: CGSize[], count: number): void;
    drawPDFPage(page: any): void;
    beginPage(rect: CGRectangle): void;
    endPage(): void;
    flush(): void;
    synchronize(): void;
    setShouldAntialias(shouldAntialias: boolean): void;
    setAllowsAntialiasing(allowsAntialiasing: boolean): void;
    setShouldSmoothFonts(shouldSmoothFonts: boolean): void;
    getUserSpaceToDeviceSpaceTransform(): CGAffineTransform;
    pointToDeviceSpace(point: CGPoint): CGPoint;
    convertPointToUserSpace(point: CGPoint): CGPoint;
    convertSizeToDeviceSpace(size: CGSize): CGSize;
    convertSizeToUserSpace(size: CGSize): CGSize;
    convertRectToDeviceSpace(rect: CGRectangle): CGRectangle;
    convertRectToUserSpace(rect: CGRectangle): CGRectangle;
    drawLayer(layer: any, rect: CGRectangle): void;
    drawLayer(layer: any, point: CGPoint): void;
    copyPath(): CGPath;
    setAllowsFontSmoothing(allows: boolean): void;
    setAllowsSubpixelPositioning(allows: boolean): void;
    setAllowsFontSubpixelQuantization(allows: boolean): void;
    setShouldSubpixelPositionFonts(shouldSubpixelPositionFonts: boolean): void;
    shouldSubpixelQuantizeFonts(shouldSubpixelQuantizeFonts: boolean): void;
    arc(x: number, y: number, w: number, h: number, start: number, stop: number, mode: string): void;
    drawImageBitmap(image: ImageBitmap, x: float, y: float): void;
    Reset(): void;
}

export class CommandContextPilot {
    constructor(context: CGCommandContext2D);
    Reset(canvasContext: CanvasRenderingContext2D): void;
    Drive(canvasContext: CanvasRenderingContext2D): void;
}

export class CommandContextPilotWithPointer {
    constructor(pointer: number);
    Drive(canvasContext: CanvasRenderingContext2D): void;
}

export enum WrapMode {
    Tile = 0,
    TileFlipX = 1,
    TileFlipY = 2,
    TileFlipXY = 3,
    Clamp = 4
}

export class ClearRectCommand extends UMO implements ICommand {
    CommandType: number;
    X: any;
    Y: any;
    Width: any;
    Height: any;
    NextCommandType: any;
    NextCommandPointer: any;
    ExecuteCommand(drawingContext: CanvasRenderingContext2D): void;
}

export const Commands: any[];

export class EndCommand extends UMO implements ICommand {
    CommandType: number;
    NextCommandType: any;
    NextCommandPointer: any;
    ExecuteCommand(drawingContext: CanvasRenderingContext2D): void;
}

export interface ICommand {
    CommandType: any;
    NextCommandType: any;
    NextCommandPointer: any;
    ExecuteCommand(drawingContext: CanvasRenderingContext2D): any;
}
export const IsDebug = false;

export class RotateCommand extends UMO implements ICommand {
    CommandType: number;
    Angle: any;
    NextCommandType: any;
    NextCommandPointer: any;
    ExecuteCommand(drawingContext: CanvasRenderingContext2D): void;
}

export class ScaleCommand extends UMO implements ICommand {
    CommandType: number;
    SX: any;
    SY: any;
    NextCommandType: any;
    NextCommandPointer: any;
    ExecuteCommand(drawingContext: CanvasRenderingContext2D): void;
}

export class StartCommand extends UMO implements ICommand {
    CommandType: number;
    NextCommandType: any;
    NextCommandPointer: any;
    ExecuteCommand(drawingContext: CanvasRenderingContext2D): void;
}

export class TransformCommand extends UMO implements ICommand {
    CommandType: number;
    A: any;
    B: any;
    C: any;
    D: any;
    E: any;
    F: any;
    NextCommandType: any;
    NextCommandPointer: any;
    ExecuteCommand(drawingContext: CanvasRenderingContext2D): void;
}

export class TranslateCommand extends UMO implements ICommand {
    CommandType: number;
    TX: any;
    TY: any;
    NextCommandType: any;
    NextCommandPointer: any;
    ExecuteCommand(drawingContext: CanvasRenderingContext2D): void;
}

